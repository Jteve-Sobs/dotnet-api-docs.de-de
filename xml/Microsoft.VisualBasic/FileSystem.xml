<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76423e19c418e3145c1946201eeb07bad53c0200" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39908793" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1523f-101">Das <see langword="FileSystem" />-Modul enthält Prozeduren, mit denen Datei-, Verzeichnis- oder Ordner- und Systemoperationen ausgeführt werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1523f-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span>
      </span>
      <span data-ttu-id="1523f-102">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als bei Verwendung des <see langword="FileSystem" />-Moduls.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1523f-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span>
      </span>
      <span data-ttu-id="1523f-103">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1523f-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-104">Dieses Modul unterstützt die Schlüsselwörter von Visual Basic und die Laufzeitbibliothek-Member, die auf Dateien und Ordner zugreifen.</span><span class="sxs-lookup"><span data-stu-id="1523f-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-105">Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und Verzeichnis oder Ordner zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="1523f-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="1523f-106">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-106">Required.</span>
          </span>
          <span data-ttu-id="1523f-107">Ein <see langword="String" />-Ausdruck, der das Verzeichnis oder den Ordner bezeichnet, der zum neuen Verzeichnis oder Ordner wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span>
          </span>
          <span data-ttu-id="1523f-108">
            <c>Path</c> enthält möglicherweise das Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-108">
              <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="1523f-109">Wenn kein Laufwerk angegeben wird, ändert <see langword="ChDir" /> das Standardverzeichnis oder den Ordner in das aktuelle Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-110">Ändert das aktuelle Verzeichnis oder den aktuellen Ordner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-110">Changes the current directory or folder.</span>
          </span>
          <span data-ttu-id="1523f-111">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung als die <see langword="ChDir" />-Funktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span>
          </span>
          <span data-ttu-id="1523f-112">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-113">Die `ChDir` -Funktion ändert das Standardverzeichnis, aber nicht das Standardlaufwerk.</span><span class="sxs-lookup"><span data-stu-id="1523f-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="1523f-114">Z. B. wenn das Standard-Laufwerk C ist, die folgende Anweisung ändert sich das Standardverzeichnis auf Laufwerk D, C, bleibt das Standardlaufwerk jedoch:</span><span class="sxs-lookup"><span data-stu-id="1523f-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="1523f-115">Sie können relative machen verzeichnisänderungen wird durch zwei Punkte wie folgt eingeben:</span><span class="sxs-lookup"><span data-stu-id="1523f-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-116">Die `ChDir` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="1523f-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="1523f-117">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und.</span><span class="sxs-lookup"><span data-stu-id="1523f-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-118">Dieses Beispiel verwendet die `ChDir` Funktion, um das aktuelle Verzeichnis oder Ordner zu ändern.</span><span class="sxs-lookup"><span data-stu-id="1523f-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-119">
            <paramref name="Path" /> ist leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-119">
              <paramref name="Path" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-120">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-120">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-121">Ändert das aktuelle Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-121">Changes the current drive.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="1523f-122">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-122">Required.</span>
          </span>
          <span data-ttu-id="1523f-123">Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-123">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="1523f-124">Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-124">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="1523f-125">Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-126">Ändert das aktuelle Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-126">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-127">Die `ChDrive` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="1523f-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="1523f-128">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="1523f-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-129">Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern.</span><span class="sxs-lookup"><span data-stu-id="1523f-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="1523f-130">Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-131">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-131">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="1523f-132">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-132">Required.</span>
          </span>
          <span data-ttu-id="1523f-133">Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-133">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="1523f-134">Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-134">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="1523f-135">Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-136">Ändert das aktuelle Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-136">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-137">Die `ChDrive` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="1523f-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="1523f-138">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="1523f-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-139">Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern.</span><span class="sxs-lookup"><span data-stu-id="1523f-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="1523f-140">Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-141">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-141">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-142">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-142">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="1523f-143">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="1523f-144">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1523f-145">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-145">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="1523f-146">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="1523f-147">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-148">Eine Zeichenfolge mit dem aktuellen Pfad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-148">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1523f-149">Dieses Beispiel verwendet die `CurDir` Funktion den aktuellen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="1523f-150">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-150">Optional.</span>
          </span>
          <span data-ttu-id="1523f-151">Ein <see langword="Char" />-Ausdruck, der ein vorhandenes Laufwerk angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-151">
              <see langword="Char" /> expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="1523f-152">Wenn kein Laufwerk angegeben wird oder <c>Drive</c> eine Zeichenfolgen der Länge 0 (null) ("") ist, gibt <see langword="CurDir" /> den Pfad für das aktuelle Laufwerk zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-153">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-153">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="1523f-154">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="1523f-155">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-156">Eine Zeichenfolge mit dem aktuellen Pfad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-156">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1523f-157">Dieses Beispiel verwendet die `CurDir` Funktion den aktuellen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-158">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="1523f-159">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="1523f-160">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1523f-161">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="1523f-162">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="1523f-163">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-164">Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-165">Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="1523f-166">`VbVolume` Gibt die Volumebezeichnung des Laufwerks anstelle von einem bestimmten Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="1523f-167">Geben Sie an einer `PathName` beim ersten, die Sie Aufrufen der `Dir` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="1523f-168">Um das nächste Element abzurufen, können Sie, aufeinander folgende Aufrufe der `Dir` Funktion ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="1523f-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-169">Zur fehlerfreien Ausführung der `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="1523f-170">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="1523f-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="1523f-171">Die `Attributes` Argument Enumerationswerte lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="1523f-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="1523f-172">Wert</span><span class="sxs-lookup"><span data-stu-id="1523f-172">Value</span></span>|<span data-ttu-id="1523f-173">Konstante</span><span class="sxs-lookup"><span data-stu-id="1523f-173">Constant</span></span>|<span data-ttu-id="1523f-174">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="1523f-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="1523f-175">Standard</span><span class="sxs-lookup"><span data-stu-id="1523f-175">Default.</span></span> <span data-ttu-id="1523f-176">Gibt die Dateien ohne Attribute an.</span><span class="sxs-lookup"><span data-stu-id="1523f-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="1523f-177">Gibt an, schreibgeschützte Dateien sowie Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="1523f-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="1523f-178">Gibt an, alle Dateien, und auch Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="1523f-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="1523f-179">Gibt an, das Systemdateien und auch Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="1523f-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="1523f-180">Gibt die Volumebezeichnung an. Wenn alle anderen Attribute angegeben wird, `vbVolume` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1523f-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="1523f-181">Gibt an, Verzeichnissen oder Ordnern und auch Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="1523f-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="1523f-182">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="1523f-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="1523f-183">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="1523f-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="1523f-184">Diese Enumerationen werden von Visual Basic-Sprache angegeben und können überall in Ihrem Code anstelle der tatsächlichen Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-185">Dieses Beispiel verwendet die `Dir` Funktion zu überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="1523f-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-186">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-186">Optional.</span>
          </span>
          <span data-ttu-id="1523f-187">
            <see langword="String" />-Ausdruck, der einen Dateinamen, ein Verzeichnis, einen Ordnernamen oder eine Volumebezeichnung des Laufwerks angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-187">
              <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span>
          </span>
          <span data-ttu-id="1523f-188">Eine Zeichenfolge der Länge 0 (null) (<see langword="&quot;&quot;" />) wird zurückgegeben, wenn <c>PathName</c> nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span>
          </span>
        </param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">
          <span data-ttu-id="1523f-189">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-189">Optional.</span>
          </span>
          <span data-ttu-id="1523f-190">Enumeration oder numerischer Ausdruck, dessen Wert Dateiattribute angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-190">Enumeration or numeric expression whose value specifies file attributes.</span>
          </span>
          <span data-ttu-id="1523f-191">Wenn der Wert nicht angegeben wird, gibt <see langword="Dir" /> Dateien zurück, die mit <c>PathName</c> übereinstimmen, aber keine Attribute besitzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-192">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="1523f-193">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="1523f-194">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-195">Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-196">Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="1523f-197">`VbVolume` Gibt die Volumebezeichnung des Laufwerks anstelle von einem bestimmten Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="1523f-198">Geben Sie an einer `PathName` beim ersten, die Sie Aufrufen der `Dir` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="1523f-199">Um das nächste Element abzurufen, können Sie, aufeinander folgende Aufrufe der `Dir` Funktion ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="1523f-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-200">Zur fehlerfreien Ausführung der `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="1523f-201">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="1523f-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="1523f-202">Die `Attributes` Argument Enumerationswerte lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="1523f-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="1523f-203">Wert</span><span class="sxs-lookup"><span data-stu-id="1523f-203">Value</span></span>|<span data-ttu-id="1523f-204">Konstante</span><span class="sxs-lookup"><span data-stu-id="1523f-204">Constant</span></span>|<span data-ttu-id="1523f-205">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="1523f-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="1523f-206">Standard</span><span class="sxs-lookup"><span data-stu-id="1523f-206">Default.</span></span> <span data-ttu-id="1523f-207">Gibt Dateien an, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="1523f-208">Gibt an, nur-Lese Dateien zusätzlich zu den Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="1523f-209">Gibt die versteckte Dateien zusätzlich zu den Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="1523f-210">Gibt an, der Systemdateien, zusätzlich zu den Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="1523f-211">Gibt die Volumebezeichnung an. Wenn alle anderen Attribute angegeben wird, `vbVolume` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1523f-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="1523f-212">Gibt an, Verzeichnissen oder Ordnern, zusätzlich zu den Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="1523f-213">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="1523f-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="1523f-214">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="1523f-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="1523f-215">Diese Enumerationen werden von Visual Basic-Sprache angegeben und können überall in Ihrem Code anstelle von tatsächlichen Werten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-216">Dieses Beispiel verwendet die `Dir` Funktion zu überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="1523f-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-217">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-217">Required.</span>
          </span>
          <span data-ttu-id="1523f-218">Ein <see langword="Integer" /> mit einer beliebigen gültigen Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-218">An <see langword="Integer" /> that contains any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-219">Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-220">Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-221">Verwendung `EOF` zur Vermeidung des Fehlers, bei dem Versuch, nach dem Ende einer Datei abrufen von Eingabe-generiert werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="1523f-222">Die `EOF` -Funktion zurückgegeben `False` bis Ende der Datei erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="1523f-223">Dateien für geöffnet `Random` oder `Binary` Zugriff `EOF` gibt `False` bis zur letzten Ausführung `FileGet` Funktion kann nicht zum Lesen der vollständigen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="1523f-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="1523f-224">Dateien für geöffnet `Binary` für den Zugriff auf einen Versuch, lesen Sie die Datei mit der `Input` Funktion bis `EOF` gibt `True` wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="1523f-225">Verwenden Sie die `LOF` und `Loc` Funktionen anstelle von `EOF` beim Lesen von Binärdateien mit `Input`, oder verwenden Sie `Get` bei Verwendung der `EOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="1523f-226">Dateien für geöffnet `Output`, `EOF` gibt immer `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-227">Dieses Beispiel verwendet die `EOF` Funktion, um das Ende einer Datei zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="1523f-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="1523f-228">In diesem Beispiel wird vorausgesetzt, dass `Testfile` ist eine Textdatei, die mehrere Zeilen Text enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-229">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-229">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-230">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-230">Required.</span>
          </span>
          <span data-ttu-id="1523f-231">
            <see langword="Integer" />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-231">
              <see langword="Integer" />.</span>
          </span>
          <span data-ttu-id="1523f-232">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-232">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-233">Gibt eine Enumeration zurück, die den Dateimodus für Dateien darstellt, die mit der <see langword="FileOpen" />-Funktion geöffnet wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-234">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="FileAttr" />-Funktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span>
          </span>
          <span data-ttu-id="1523f-235">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-236">Die folgenden Enumerationswerte geben den Dateizugriffsmodus an:</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-236">The following enumeration values indicate the file access mode:</span>
          </span>
          <span data-ttu-id="1523f-237">
            <list type="table">
              <item>
                <term> Wert  </term>
                <description> Modus  </description>
              </item>
              <item>
                <term> 1  </term>
                <description>
                  <see langword="OpenMode.Input" />
                </description>
              </item>
              <item>
                <term> 2  </term>
                <description>
                  <see langword="OpenMode.Output" />
                </description>
              </item>
              <item>
                <term> 4  </term>
                <description>
                  <see langword="OpenMode.Random" />
                </description>
              </item>
              <item>
                <term> 8  </term>
                <description>
                  <see langword="OpenMode.Append" />
                </description>
              </item>
              <item>
                <term> 32  </term>
                <description>
                  <see langword="OpenMode.Binary" />
                </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-237">
              <list type="table">
                <item>
                  <term> Value  </term>
                  <description> Mode  </description>
                </item>
                <item>
                  <term> 1  </term>
                  <description>
                    <see langword="OpenMode.Input" />
                  </description>
                </item>
                <item>
                  <term> 2  </term>
                  <description>
                    <see langword="OpenMode.Output" />
                  </description>
                </item>
                <item>
                  <term> 4  </term>
                  <description>
                    <see langword="OpenMode.Random" />
                  </description>
                </item>
                <item>
                  <term> 8  </term>
                  <description>
                    <see langword="OpenMode.Append" />
                  </description>
                </item>
                <item>
                  <term> 32  </term>
                  <description>
                    <see langword="OpenMode.Binary" />
                  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-238">Diese Funktion gibt eine Enumeration, die den Dateimodus mit geöffneten Dateien darstellt. die `FileOpen` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-238">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-239">Dieses Beispiel verwendet die `FileAttr` Funktion, die den Dateimodus, einer geöffneten Datei zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-239">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">
          <span data-ttu-id="1523f-240">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-240">Optional.</span>
          </span>
          <span data-ttu-id="1523f-241">Parameterarray von 0 oder mehr zu schließenden Channels.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-241">Parameter array of 0 or more channels to be closed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-242">Schließt die Eingabe/Ausgabe (E/A) für eine Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-242">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-243">
            <see langword="My" /> ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-243">
              <see langword="My" /> gives you better productivity and performance in file I/O operations.</span>
          </span>
          <span data-ttu-id="1523f-244">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-244">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-245">Die `FileClose` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-245">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-246">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-246">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-247">Weitere Informationen finden Sie unter [wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[Vorgehensweise: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), und [Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-247">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="1523f-248">Wenn Sie weglassen `FileNumbers`, alle aktive Dateien geöffnet werden, indem die `FileOpen` Funktion geschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-248">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="1523f-249">Beim Schließen von Dateien, die für geöffnet wurden `Output` oder `Append`, wird der endgültige Puffer der Ausgabe in die Betriebssystempuffer für diese Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-249">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="1523f-250">Alle geschlossenen zugeordnete Pufferspeicher Datei wird veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-250">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="1523f-251">Wenn die `FileClose` Funktion ausgeführt wird, wird die Zuordnung einer Datei mit der Datei Zahl enden.</span><span class="sxs-lookup"><span data-stu-id="1523f-251">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-252">Dieses Beispiel verwendet die `FileClose` Funktion, um eine Datei zu schließen, die für geöffnet `Input`.</span><span class="sxs-lookup"><span data-stu-id="1523f-252">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-253">
            <paramref name="FileNumber" /> ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-253">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">
          <span data-ttu-id="1523f-254">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-254">Required.</span>
          </span>
          <span data-ttu-id="1523f-255">Ein <see langword="String" />-Ausdruck, der den Namen der zu kopierenden Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-255">
              <see langword="String" /> expression that specifies the name of the file to be copied.</span>
          </span>
          <span data-ttu-id="1523f-256">
            <c>Source</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Quelldatei beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-256">
              <c>Source</c> may include the directory or folder, and drive, of the source file.</span>
          </span>
        </param>
        <param name="Destination">
          <span data-ttu-id="1523f-257">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-257">Required.</span>
          </span>
          <span data-ttu-id="1523f-258">Ein <see langword="String" />-Ausdruck, der den Zieldateinamen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-258">
              <see langword="String" /> expression that specifies the destination file name.</span>
          </span>
          <span data-ttu-id="1523f-259">
            <c>Destination</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Zieldatei beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-259">
              <c>Destination</c> may include the directory or folder, and drive, of the destination file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-260">Kopiert eine Datei</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-260">Copies a file.</span>
          </span>
          <span data-ttu-id="1523f-261">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="FileCopy" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-261">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span>
          </span>
          <span data-ttu-id="1523f-262">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-262">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-263">Wenn Sie versuchen, Sie verwenden die `FileCopy` funktionieren für eine aktuell geöffneten Datei ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-263">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="1523f-264">`FileCopy` erfordert volle Vertrauenswürdigkeit auf dem lokalen Laufwerk funktioniert.</span><span class="sxs-lookup"><span data-stu-id="1523f-264">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-265">Dieses Beispiel verwendet die `FileCopy` Funktion, um eine Datei in ein anderes kopieren.</span><span class="sxs-lookup"><span data-stu-id="1523f-265">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="1523f-266">Für dieses Beispiel wird angenommen, dass `SrcFile` ist eine Datei, die Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-266">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-267">
            <paramref name="Source" /> oder <paramref name="Destination" /> ist ungültig oder nicht angegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-267">
              <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-268">Datei ist bereits geöffnet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-268">File is already open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-269">Die Datei ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-269">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-270">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-270">Required.</span>
          </span>
          <span data-ttu-id="1523f-271">Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-271">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="1523f-272">
            <c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-272">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-273">Gibt einen <see langword="Date" />-Wert zurück, der Datum und Uhrzeit des Schreibvorgangs in einer Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-273">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span>
          </span>
          <span data-ttu-id="1523f-274">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileDateTime" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-274">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span>
          </span>
          <span data-ttu-id="1523f-275">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-275">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-276">Ein <see langword="Date" />-Wert, der Datum und Uhrzeit der Erstellung oder letzten Änderung der Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-276">
              <see langword="Date" /> value that indicates the date and time a file was created or last modified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1523f-277">Dieses Beispiel verwendet die `FileDateTime` Funktion, um das Datum zu bestimmen und die Uhrzeit einer Datei erstellt oder zuletzt geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-277">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="1523f-278">Das Format des Datums und der angezeigte Uhrzeit basiert auf den gebietsschemaeinstellungen des Systems.</span><span class="sxs-lookup"><span data-stu-id="1523f-278">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-279">
            <paramref name="PathName" /> ist ungültig oder enthält Platzhalterzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-279">
              <paramref name="PathName" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-280">Zieldatei ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-280">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-281">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-281">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-282">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-282">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-283">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-283">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-284">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-284">Required.</span>
          </span>
          <span data-ttu-id="1523f-285">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-285">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-286">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-286">Required.</span>
          </span>
          <span data-ttu-id="1523f-287">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-287">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-288">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-288">Optional.</span>
          </span>
          <span data-ttu-id="1523f-289">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-289">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-290">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-290">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-291">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-291">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-292">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-292">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-293">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-293">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-294">Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-294">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-295">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-295">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-296">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-296">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-297">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-297">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-298">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-298">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-299">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-299">Random Mode</span></span>  
 <span data-ttu-id="1523f-300">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-300">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-301">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-301">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-302">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-302">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-303">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-303">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-304">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-304">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-305">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-305">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-306">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-306">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-307">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-307">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-308">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-308">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-309">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-309">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-310">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-310">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-311">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-311">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-312">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-312">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-313">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-313">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-314">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-314">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-315">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-315">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-316">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-316">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-317">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-317">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-318">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-318">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-319">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-319">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-320">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-320">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-321">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-321">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-322">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-322">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-323">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-323">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-324">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-324">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-325">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-325">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-326">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-326">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-327">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-327">Binary Mode</span></span>  
 <span data-ttu-id="1523f-328">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-328">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-329">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-329">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-330">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-330">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-331">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-331">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-332">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-332">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-333">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-333">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-334">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-334">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-335">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-335">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-336">Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-336">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-337">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-337">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-338">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-338">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-339">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-339">Required.</span>
          </span>
          <span data-ttu-id="1523f-340">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-340">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-341">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-341">Required.</span>
          </span>
          <span data-ttu-id="1523f-342">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-342">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-343">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-343">Optional.</span>
          </span>
          <span data-ttu-id="1523f-344">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-344">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-345">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-345">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-346">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-346">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-347">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-347">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-348">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-348">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-349">Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-349">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-350">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-350">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-351">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-351">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-352">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-352">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-353">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-353">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-354">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-354">Random Mode</span></span>  
 <span data-ttu-id="1523f-355">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-355">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-356">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-356">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-357">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-357">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-358">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-358">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-359">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-359">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-360">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-360">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-361">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-361">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-362">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-362">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-363">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-363">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-364">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-364">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-365">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-365">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-366">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-366">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-367">Wenn der Deskriptor nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-367">If the descriptor is not used.</span></span> <span data-ttu-id="1523f-368">Übergeben Sie die Größe und die Grenzen des Arrays in `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-368">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-369">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-369">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-370">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-370">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-371">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-371">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-372">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-372">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-373">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-373">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-374">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-374">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-375">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-375">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-376">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-376">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-377">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-377">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-378">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-378">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-379">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-379">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-380">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-380">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-381">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-381">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-382">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-382">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-383">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-383">Binary Mode</span></span>  
 <span data-ttu-id="1523f-384">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-384">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-385">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-385">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-386">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-386">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-387">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-387">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-388">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-388">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-389">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-389">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-390">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-390">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-391">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-391">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-392">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-392">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-393">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-393">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-394">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-394">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-395">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-395">Required.</span>
          </span>
          <span data-ttu-id="1523f-396">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-396">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-397">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-397">Required.</span>
          </span>
          <span data-ttu-id="1523f-398">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-398">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-399">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-399">Optional.</span>
          </span>
          <span data-ttu-id="1523f-400">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-400">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-401">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-401">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-402">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-402">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-403">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-403">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-404">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-404">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-405">Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-405">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-406">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-406">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-407">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-407">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-408">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-408">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-409">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-409">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-410">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-410">Random Mode</span></span>  
 <span data-ttu-id="1523f-411">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-411">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-412">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-412">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-413">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-413">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-414">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-414">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-415">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-415">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-416">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-416">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-417">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-417">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-418">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-418">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-419">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-419">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-420">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-420">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-421">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-421">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-422">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-422">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-423">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-423">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-424">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-424">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-425">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-425">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-426">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-426">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-427">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-427">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-428">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-428">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-429">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-429">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-430">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-430">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-431">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-431">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-432">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-432">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-433">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-433">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-434">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-434">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-435">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-435">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-436">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-436">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-437">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-437">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-438">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-438">Binary Mode</span></span>  
 <span data-ttu-id="1523f-439">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-439">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-440">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-440">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-441">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-441">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-442">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-442">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-443">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-443">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-444">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-444">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-445">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-445">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-446">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-446">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-447">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-447">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-448">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-448">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-449">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-449">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-450">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-450">Required.</span>
          </span>
          <span data-ttu-id="1523f-451">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-451">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-452">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-452">Required.</span>
          </span>
          <span data-ttu-id="1523f-453">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-453">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-454">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-454">Optional.</span>
          </span>
          <span data-ttu-id="1523f-455">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-455">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-456">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-456">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-457">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-457">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-458">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-458">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-459">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-459">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-460">Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-460">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-461">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-461">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-462">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-462">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-463">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-463">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-464">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-464">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-465">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-465">Random Mode</span></span>  
 <span data-ttu-id="1523f-466">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-466">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-467">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion`FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-467">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-468">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-468">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-469">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-469">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-470">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-470">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-471">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-471">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-472">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-472">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-473">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-473">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-474">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-474">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-475">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-475">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-476">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-476">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-477">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-477">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-478">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-478">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-479">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-479">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-480">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-480">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-481">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-481">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-482">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-482">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-483">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-483">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-484">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-484">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-485">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-485">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-486">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-486">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-487">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-487">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-488">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-488">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-489">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-489">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-490">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-490">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-491">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-491">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-492">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-492">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-493">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-493">Binary Mode</span></span>  
 <span data-ttu-id="1523f-494">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-494">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-495">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-495">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-496">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-496">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-497">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-497">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-498">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-498">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-499">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-499">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-500">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-500">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-501">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-501">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-502">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-502">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-503">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-503">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-504">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-504">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-505">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-505">Required.</span>
          </span>
          <span data-ttu-id="1523f-506">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-506">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-507">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-507">Required.</span>
          </span>
          <span data-ttu-id="1523f-508">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-508">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-509">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-509">Optional.</span>
          </span>
          <span data-ttu-id="1523f-510">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-510">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-511">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-511">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-512">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-512">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-513">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-513">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-514">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-514">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-515">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-515">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-516">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-516">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-517">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-517">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-518">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-518">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-519">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-519">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-520">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-520">Random Mode</span></span>  
 <span data-ttu-id="1523f-521">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-521">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-522">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-522">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-523">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-523">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-524">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-524">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-525">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-525">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-526">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-526">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-527">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-527">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-528">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-528">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-529">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-529">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-530">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-530">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-531">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-531">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-532">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-532">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-533">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-533">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-534">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-534">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-535">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-535">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-536">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-536">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-537">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-537">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-538">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-538">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-539">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-539">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-540">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-540">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-541">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-541">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-542">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-542">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-543">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-543">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-544">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-544">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-545">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-545">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-546">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-546">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-547">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-547">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-548">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-548">Binary Mode</span></span>  
 <span data-ttu-id="1523f-549">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-549">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-550">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-550">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-551">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-551">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-552">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-552">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-553">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-553">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-554">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-554">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-555">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-555">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-556">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-556">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-557">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-557">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-558">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-558">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-559">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-559">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-560">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-560">Required.</span>
          </span>
          <span data-ttu-id="1523f-561">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-561">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-562">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-562">Required.</span>
          </span>
          <span data-ttu-id="1523f-563">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-563">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-564">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-564">Optional.</span>
          </span>
          <span data-ttu-id="1523f-565">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-565">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-566">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-566">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-567">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-567">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-568">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-568">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-569">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-569">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-570">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-570">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-571">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-571">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-572">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-572">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-573">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-573">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-574">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-574">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-575">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-575">Random Mode</span></span>  
 <span data-ttu-id="1523f-576">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-576">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-577">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-577">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-578">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-578">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-579">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-579">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-580">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-580">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-581">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-581">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-582">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-582">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-583">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-583">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-584">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-584">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-585">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-585">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-586">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-586">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-587">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-587">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-588">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-588">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-589">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-589">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-590">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-590">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-591">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-591">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-592">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-592">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-593">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-593">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-594">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-594">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-595">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-595">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-596">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-596">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-597">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-597">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-598">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-598">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-599">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-599">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-600">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-600">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-601">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-601">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-602">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-602">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-603">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-603">Binary Mode</span></span>  
 <span data-ttu-id="1523f-604">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-604">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-605">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-605">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-606">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-606">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-607">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-607">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-608">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-608">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-609">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-609">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-610">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-610">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-611">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-611">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-612">Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-612">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-613">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-613">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-614">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-614">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-615">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-615">Required.</span>
          </span>
          <span data-ttu-id="1523f-616">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-616">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-617">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-617">Required.</span>
          </span>
          <span data-ttu-id="1523f-618">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-618">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-619">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-619">Optional.</span>
          </span>
          <span data-ttu-id="1523f-620">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-620">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-621">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-621">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-622">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-622">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-623">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-623">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-624">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-624">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-625">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-625">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-626">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-626">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-627">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-627">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-628">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-628">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-629">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-629">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-630">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-630">Random Mode</span></span>  
 <span data-ttu-id="1523f-631">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-631">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-632">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-632">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-633">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-633">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-634">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-634">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-635">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-635">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-636">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-636">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-637">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-637">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-638">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-638">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-639">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-639">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-640">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-640">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-641">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-641">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-642">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-642">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-643">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-643">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-644">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-644">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-645">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-645">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-646">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-646">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-647">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-647">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-648">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-648">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-649">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-649">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-650">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-650">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-651">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-651">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-652">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-652">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-653">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-653">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-654">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-654">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-655">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-655">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-656">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-656">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-657">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-657">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-658">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-658">Binary Mode</span></span>  
 <span data-ttu-id="1523f-659">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-659">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-660">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-660">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-661">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-661">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-662">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-662">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-663">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-663">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-664">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-664">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-665">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-665">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-666">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-666">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-667">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-667">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-668">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-668">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-669">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-669">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-670">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-670">Required.</span>
          </span>
          <span data-ttu-id="1523f-671">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-671">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-672">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-672">Required.</span>
          </span>
          <span data-ttu-id="1523f-673">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-673">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-674">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-674">Optional.</span>
          </span>
          <span data-ttu-id="1523f-675">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-675">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-676">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-676">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-677">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-677">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-678">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-678">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-679">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-679">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-680">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-680">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-681">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-681">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-682">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-682">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-683">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-683">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-684">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-684">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-685">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-685">Random Mode</span></span>  
 <span data-ttu-id="1523f-686">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-686">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-687">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-687">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-688">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-688">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-689">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-689">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-690">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-690">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-691">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-691">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-692">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-692">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-693">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-693">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-694">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-694">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-695">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-695">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-696">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-696">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-697">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-697">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-698">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-698">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-699">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-699">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-700">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-700">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-701">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-701">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-702">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-702">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-703">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-703">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-704">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-704">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-705">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-705">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-706">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-706">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-707">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-707">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-708">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-708">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-709">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-709">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-710">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-710">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-711">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-711">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-712">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-712">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-713">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-713">Binary Mode</span></span>  
 <span data-ttu-id="1523f-714">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-714">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-715">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-715">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-716">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-716">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-717">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-717">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-718">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-718">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-719">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-719">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-720">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-720">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-721">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-721">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-722">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-722">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-723">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-723">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-724">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-724">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-725">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-725">Required.</span>
          </span>
          <span data-ttu-id="1523f-726">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-726">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-727">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-727">Required.</span>
          </span>
          <span data-ttu-id="1523f-728">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-728">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-729">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-729">Optional.</span>
          </span>
          <span data-ttu-id="1523f-730">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-730">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-731">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-731">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-732">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-732">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-733">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-733">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-734">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-734">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-735">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-735">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-736">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-736">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-737">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-737">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-738">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-738">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-739">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-739">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-740">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-740">Random Mode</span></span>  
 <span data-ttu-id="1523f-741">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-741">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-742">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-742">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-743">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-743">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-744">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-744">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-745">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-745">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-746">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-746">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-747">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-747">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-748">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-748">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-749">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-749">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-750">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-750">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-751">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-751">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-752">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-752">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-753">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-753">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-754">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-754">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-755">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-755">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-756">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-756">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-757">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-757">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-758">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-758">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-759">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-759">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-760">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-760">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-761">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-761">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-762">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-762">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-763">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-763">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-764">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-764">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-765">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-765">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-766">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-766">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-767">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-767">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-768">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-768">Binary Mode</span></span>  
 <span data-ttu-id="1523f-769">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-769">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-770">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-770">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-771">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-771">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-772">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-772">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-773">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-773">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-774">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-774">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-775">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-775">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-776">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-776">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-777">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-777">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-778">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-778">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-779">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-779">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-780">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-780">Required.</span>
          </span>
          <span data-ttu-id="1523f-781">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-781">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-782">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-782">Required.</span>
          </span>
          <span data-ttu-id="1523f-783">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-783">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-784">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-784">Optional.</span>
          </span>
          <span data-ttu-id="1523f-785">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-785">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-786">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-786">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-787">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-787">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-788">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-788">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-789">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-789">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-790">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-790">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-791">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-791">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-792">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-792">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-793">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-793">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-794">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-794">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-795">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-795">Random Mode</span></span>  
 <span data-ttu-id="1523f-796">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-796">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-797">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-797">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-798">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-798">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-799">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-799">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-800">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-800">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-801">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-801">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-802">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-802">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-803">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-803">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-804">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-804">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-805">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-805">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-806">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-806">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-807">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-807">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-808">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-808">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-809">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-809">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-810">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-810">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-811">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-811">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-812">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-812">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-813">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-813">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-814">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-814">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-815">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-815">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-816">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-816">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-817">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-817">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-818">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-818">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-819">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-819">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-820">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-820">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-821">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-821">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-822">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-822">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-823">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-823">Binary Mode</span></span>  
 <span data-ttu-id="1523f-824">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-824">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-825">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-825">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-826">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-826">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-827">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-827">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-828">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-828">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-829">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-829">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-830">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-830">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-831">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-831">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-832">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-832">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-833">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-833">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-834">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-834">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-835">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-835">Required.</span>
          </span>
          <span data-ttu-id="1523f-836">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-836">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-837">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-837">Required.</span>
          </span>
          <span data-ttu-id="1523f-838">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-838">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-839">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-839">Optional.</span>
          </span>
          <span data-ttu-id="1523f-840">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-840">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-841">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-841">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-842">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-842">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-843">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-843">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-844">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-844">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-845">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-845">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-846">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-846">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-847">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-847">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-848">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-848">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-849">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-849">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-850">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-850">Random Mode</span></span>  
 <span data-ttu-id="1523f-851">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-851">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-852">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-852">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-853">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-853">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-854">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-854">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-855">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-855">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-856">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-856">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-857">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-857">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-858">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-858">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-859">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-859">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-860">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-860">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-861">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-861">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-862">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-862">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-863">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-863">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-864">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-864">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-865">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-865">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-866">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-866">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-867">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-867">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-868">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-868">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-869">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-869">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-870">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-870">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-871">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-871">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-872">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-872">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-873">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-873">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-874">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-874">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-875">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-875">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-876">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-876">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-877">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-877">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-878">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-878">Binary Mode</span></span>  
 <span data-ttu-id="1523f-879">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-879">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-880">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-880">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-881">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-881">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-882">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-882">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-883">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-883">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-884">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-884">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-885">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-885">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-886">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-886">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-887">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-887">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-888">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-888">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-889">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-889">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-890">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-890">Required.</span>
          </span>
          <span data-ttu-id="1523f-891">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-891">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-892">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-892">Required.</span>
          </span>
          <span data-ttu-id="1523f-893">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-893">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-894">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-894">Optional.</span>
          </span>
          <span data-ttu-id="1523f-895">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-895">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="1523f-896">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-896">Optional.</span>
          </span>
          <span data-ttu-id="1523f-897">Betrifft nur das Schreiben einer Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-897">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="1523f-898">Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-898">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="1523f-899">Der Standardwert ist <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-899">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-900">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-900">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-901">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-901">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-902">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-902">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-903">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-903">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-904">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-904">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-905">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-905">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-906">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-906">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-907">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-907">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-908">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-908">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-909">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-909">Random Mode</span></span>  
 <span data-ttu-id="1523f-910">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-910">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-911">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-911">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-912">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-912">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-913">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-913">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-914">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-914">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-915">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-915">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-916">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-916">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-917">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-917">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-918">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-918">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-919">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-919">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-920">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-920">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-921">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-921">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-922">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-922">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-923">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-923">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-924">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-924">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-925">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-925">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-926">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-926">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-927">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-927">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-928">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-928">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-929">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-929">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-930">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-930">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-931">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-931">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-932">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-932">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-933">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-933">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-934">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-934">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-935">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-935">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-936">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-936">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-937">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-937">Binary Mode</span></span>  
 <span data-ttu-id="1523f-938">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-938">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-939">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-939">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-940">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-940">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-941">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-941">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-942">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-942">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-943">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-943">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-944">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-944">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-945">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-945">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-946">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-946">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-947">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-947">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-948">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-948">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-949">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-949">Required.</span>
          </span>
          <span data-ttu-id="1523f-950">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-950">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-951">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-951">Required.</span>
          </span>
          <span data-ttu-id="1523f-952">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-952">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-953">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-953">Optional.</span>
          </span>
          <span data-ttu-id="1523f-954">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-954">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="1523f-955">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-955">Optional.</span>
          </span>
          <span data-ttu-id="1523f-956">Betrifft nur das Schreiben eines Arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-956">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="1523f-957">Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor erforderlich ist, der die Größe und die Begrenzungen des Arrays beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-957">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="1523f-958">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-958">Optional.</span>
          </span>
          <span data-ttu-id="1523f-959">Betrifft nur das Schreiben einer Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-959">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="1523f-960">Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-960">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="1523f-961">Der Standardwert ist <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-961">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-962">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-962">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-963">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-963">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="1523f-964">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-964">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-965">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-965">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-966">Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-966">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="1523f-967">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-967">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-968">Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-968">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-969">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-969">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-970">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-970">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-971">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-971">Random Mode</span></span>  
 <span data-ttu-id="1523f-972">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-972">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-973">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-973">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-974">Der Abstand zwischen dem Ende eines Datensatzes und das Starten des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-974">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-975">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-975">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-976">Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-976">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-977">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-977">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-978">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-978">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-979">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-979">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-980">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-980">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="1523f-981">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-981">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-982">Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-982">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="1523f-983">Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-983">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="1523f-984">Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-984">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="1523f-985">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-985">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-986">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-986">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-987">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-987">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-988">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-988">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="1523f-989">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="1523f-989">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="1523f-990">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="1523f-990">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="1523f-991">200 Byte für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-991">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="1523f-992">Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-992">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="1523f-993">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="1523f-993">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-994">`FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-994">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-995">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-995">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-996">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-996">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="1523f-997">Dies schließt alle Arrays und ihren Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="1523f-997">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-998">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-998">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-999">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-999">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1000">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1000">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1001">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1001">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1002">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1002">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1003">`FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1003">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1004">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1004">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="1523f-1005">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1005">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="1523f-1006">`FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1006">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1007">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1007">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="1523f-1008">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1008">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1009">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1009">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1010">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1010">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1011">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1011">Required.</span>
          </span>
          <span data-ttu-id="1523f-1012">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1012">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1013">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1013">Required.</span>
          </span>
          <span data-ttu-id="1523f-1014">Der gültige Name einer Variablen, in die Daten gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1014">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1015">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1015">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1016">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1016">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1017">Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1017">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="1523f-1018">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGetObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1018">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span>
          </span>
          <span data-ttu-id="1523f-1019">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1019">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1020">Die `FileGetObject` Funktion dient anstelle von `FileGet` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird zurückgegeben, anstelle eines anderen Typs, z. B. `Integer`, `Long`, `Short`und so weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1020">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="1523f-1021">Wenn Sie beabsichtigen, schreibt die `Variant` Typ `FileGetObject` ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="1523f-1021">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="1523f-1022">Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, ist immer empfehlenswert, die Sie verwenden `FilePutObject` und `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1022">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="1523f-1023">`FileGetObject` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1023">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1024">Mit gelesene Daten `FileGetObject` richtet sich in der Regel mit `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1024">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="1523f-1025">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1025">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1026">Wenn Sie weglassen `RecordNumber`, `FileGetObject` liest den Datensatz bzw. das Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion).</span><span class="sxs-lookup"><span data-stu-id="1523f-1026">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1027">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1027">Random Mode</span></span>  
 <span data-ttu-id="1523f-1028">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1028">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1029">Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGetObject` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1029">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1030">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1030">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1031">Da die Menge der Daten der Auffüllung nicht genau bestimmt werden kann, ist es eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1031">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="1523f-1032">Wenn die Zielvariable eine Zeichenfolge, in der Standardeinstellung ist `FileGetObject` liest einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1032">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1033">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1033">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1034">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge und in eine Datei beim Lesen der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1034">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="1523f-1035">Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1035">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1036">Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1036">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1037">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1037">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1038">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="1523f-1038">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="1523f-1039">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf den Datenträger:</span><span class="sxs-lookup"><span data-stu-id="1523f-1039">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="1523f-1040">Die 218 Bytes werden wie folgt verteilt: 18 Bytes für den Deskriptor (2 + 8 \* 2), und 100 Bytes für die Daten (10 \* 5 \* 4).</span><span class="sxs-lookup"><span data-stu-id="1523f-1040">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="1523f-1041">`FileGetObject` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1041">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="1523f-1042">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePutObject`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="1523f-1042">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="1523f-1043">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente, einschließlich aller Arrays und ihren Deskriptoren erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1043">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="1523f-1044">Die <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasse angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1044">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1045">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1045">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1046">Für Dateien in geöffnet `Binary` aller-Modus die `Random` Regeln anwenden, mit den folgenden Ausnahmen:</span><span class="sxs-lookup"><span data-stu-id="1523f-1046">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="1523f-1047">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1047">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1048">`FileGetObject` Liest alle Variablen aus dem Datenträger zusammenhängend, also ohne Abstand zwischen den Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1048">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1049">Für ein beliebiges Array als ein Array in einer Struktur `FileGetObject` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1049">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="1523f-1050">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1050">No descriptor is read.</span></span>  
  
 <span data-ttu-id="1523f-1051">`FileGetObject` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1051">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1052">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1052">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-1053">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-1053">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-1054">Z. B. möglicherweise eine Datei namens "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-1054">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1055">Das folgende Beispiel liest einen Datensatz in eine Datei, und klicken Sie dann abgerufen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1055">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-1056">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1056">Required.</span>
          </span>
          <span data-ttu-id="1523f-1057">Ein <see langword="String" />-Ausdruck, der eine Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1057">
              <see langword="String" /> expression that specifies a file.</span>
          </span>
          <span data-ttu-id="1523f-1058">
            <c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1058">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1059">Gibt einen <see langword="Long" />-Wert zurück, der die Länge einer Datei in Bytes angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1059">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
          <span data-ttu-id="1523f-1060">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileLen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1060">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span>
          </span>
          <span data-ttu-id="1523f-1061">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1061">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-1062">Ein <see langword="Long" />-Wert, der die Länge einer Datei in Bytes angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1062">
              <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1063">Wenn die angegebene Datei geöffnet, wenn ist die `FileLen` Funktion aufgerufen wird, wird der zurückgegebene Wert stellt die Größe der Datei, die zum Zeitpunkt der sie geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="1523f-1063">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-1064">Um die aktuelle Länge einer geöffneten Datei zu erhalten, verwenden die `LOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-1064">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1065">Dieses Beispiel verwendet die `FileLen` Funktion, um die Länge einer Datei in Byte zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-1065">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="1523f-1066">Für dieses Beispiel wird angenommen, dass `TestFile` ist eine Datei, die Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-1066">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-1067">Die Datei ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1067">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1068">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1068">Required.</span>
          </span>
          <span data-ttu-id="1523f-1069">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1069">Any valid file number.</span>
          </span>
          <span data-ttu-id="1523f-1070">Verwenden Sie die <see langword="FreeFile" />-Funktion, um die nächste verfügbare Dateinummer zu erhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1070">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span>
          </span>
        </param>
        <param name="FileName">
          <span data-ttu-id="1523f-1071">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1071">Required.</span>
          </span>
          <span data-ttu-id="1523f-1072">
            <see langword="String" />-Ausdruck, der einen Dateinamen angibt. Kann das Verzeichnis oder den Ordner und das Laufwerk enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1072">
              <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Mode">
          <span data-ttu-id="1523f-1073">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1073">Required.</span>
          </span>
          <span data-ttu-id="1523f-1074">Eine Enumeration, die den Dateimodus angibt: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> oder <see langword="Random" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1074">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span>
          </span>
          <span data-ttu-id="1523f-1075">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1075">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span>
          </span>
        </param>
        <param name="Access">
          <span data-ttu-id="1523f-1076">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1076">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1077">Eine Enumeration, die die für eine offene Datei erlaubten Operationen angibt: <see langword="Read" />, <see langword="Write" /> oder <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1077">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="1523f-1078">Wird standardmäßig auf <see langword="ReadWrite" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1078">Defaults to <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="1523f-1079">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1079">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span>
          </span>
        </param>
        <param name="Share">
          <span data-ttu-id="1523f-1080">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1080">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1081">Eine Enumeration, die für eine offene Datei aus anderen Prozessen nicht erlaubten Operationen angibt: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> und <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1081">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="1523f-1082">Wird standardmäßig auf <see langword="Lock Read Write" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1082">Defaults to <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="1523f-1083">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1083">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span>
          </span>
        </param>
        <param name="RecordLength">
          <span data-ttu-id="1523f-1084">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1084">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1085">Eine Zahl kleiner oder gleich 32.767 (Bytes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1085">Number less than or equal to 32,767 (bytes).</span>
          </span>
          <span data-ttu-id="1523f-1086">Bei Dateien, die mit Random-Zugriff geöffnet wurden, ist dieser Wert die Datensatzlänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1086">For files opened for random access, this value is the record length.</span>
          </span>
          <span data-ttu-id="1523f-1087">Bei sequenziellen Dateien ist dieser Wert die Anzahl von gepufferten Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1087">For sequential files, this value is the number of characters buffered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1088">Öffnet eine Datei für Eingabe oder Ausgabe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1088">Opens a file for input or output.</span>
          </span>
          <span data-ttu-id="1523f-1089">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1089">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span>
          </span>
          <span data-ttu-id="1523f-1090">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1090">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1091">Die `FileOpen` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1091">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-1092">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-1092">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-1093">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-1093">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-1094">Sie müssen eine Datei öffnen, bevor alle e/a-Vorgänge ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="1523f-1094">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="1523f-1095">`FileOpen` weist einen Puffer für e/a in die Datei, und bestimmt den Zugriffsmodus für die Verwendung mit dem Puffer.</span><span class="sxs-lookup"><span data-stu-id="1523f-1095">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-1096">Beim Schreiben in eine Datei eine Anwendung möglicherweise eine Datei erstellen, wenn die Datei, auf die sie schreiben nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1096">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="1523f-1097">Zu diesem Zweck benötigt diese Berechtigung für das Verzeichnis, in dem die Datei ist, erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1097">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="1523f-1098">Aber wenn die Datei durch angegeben `FileName` vorhanden ist, muss die Anwendung `Write` Berechtigung nur für die Datei selbst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1098">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="1523f-1099">Ganz egal, wo möglich, zur Verbesserung der Sicherheit, erstellen Sie die Datei während der Bereitstellung und Grant `Write` Berechtigung für diese Datei nur, statt das gesamte Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="1523f-1099">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="1523f-1100">Schreiben Sie Daten in Verzeichnissen nach Benutzer statt auf das Root-Verzeichnis oder das Verzeichnis Programme, um Sicherheit zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="1523f-1100">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="1523f-1101">Der Kanal zum Öffnen finden Sie unter Verwendung der `FreeFile()` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-1101">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-1102">Die `FileOpen` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` -Enumeration, die die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirkt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1102">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="1523f-1103">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1103">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1104">Dieses Beispiel veranschaulicht verschiedene Verwendungen der der `FileOpen` Funktion, um die Eingabe und Ausgabe in eine Datei zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="1523f-1104">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="1523f-1105">Der folgende Code öffnet die Datei `TestFile` in `Input` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1105">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="1523f-1106">In diesem Beispiel öffnet die Datei im `Binary` Modus ausschließlich für Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1106">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="1523f-1107">Das folgende Beispiel öffnet die Datei im `Random` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1107">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="1523f-1108">Die Datei enthält die Datensätze der Struktur `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1108">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="1523f-1109">Dieses Codebeispiel öffnet die Datei im `Output` Modus: jeder Prozess kann lesen oder Schreiben in die Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-1109">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="1523f-1110">Dieses Codebeispiel öffnet die Datei im `Binary` Modus zum Lesen; andere Prozesse die Datei können nicht gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1110">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1111">Datensatzlänge ist negativ (und nicht gleich -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1111">Record length is negative (and not equal to -1).</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1112">
            <paramref name="FileName" /> ist bereits geöffnet, oder <paramref name="FileName" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1112">
              <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-1113">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1113">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1114">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1114">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1115">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1115">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1116">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1116">Required.</span>
          </span>
          <span data-ttu-id="1523f-1117">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1117">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1118">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1118">Required.</span>
          </span>
          <span data-ttu-id="1523f-1119">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1119">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1120">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1120">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1121">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1121">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1122">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1122">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1123">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1123">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1124">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1124">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1125">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1125">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1126">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1126">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1127">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1127">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1128">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1128">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1129">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1129">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1130">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1130">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1131">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1131">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1132">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1132">Random Mode</span></span>  
 <span data-ttu-id="1523f-1133">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1133">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1134">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1134">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1135">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1135">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1136">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1136">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1137">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1137">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1138">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1138">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1139">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1139">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1140">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1140">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1141">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1141">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1142">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1142">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1143">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1143">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1144">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1144">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1145">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1145">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1146">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1146">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1147">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1147">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1148">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1148">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1149">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1149">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1150">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1150">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1151">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1151">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1152">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1152">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1153">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1153">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1154">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1154">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1155">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1155">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1156">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1156">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1157">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1157">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1158">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1158">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1159">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1159">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1160">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1160">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1161">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1161">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1162">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1162">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1163">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1163">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1164">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1164">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1165">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1165">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1166">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1166">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1167">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1167">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1168">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1168">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1169">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1169">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1170">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1170">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1171">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1171">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1172">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1172">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1173">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1173">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1174">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1174">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1175">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1175">Required.</span>
          </span>
          <span data-ttu-id="1523f-1176">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1176">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1177">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1177">Required.</span>
          </span>
          <span data-ttu-id="1523f-1178">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1178">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1179">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1179">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1180">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1180">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1181">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1181">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1182">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1182">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1183">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1183">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1184">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1184">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1185">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1185">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1186">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1186">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1187">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1187">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1188">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1188">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1189">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1189">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1190">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1190">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1191">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1191">Random Mode</span></span>  
 <span data-ttu-id="1523f-1192">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1192">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1193">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1193">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1194">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1194">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1195">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1195">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1196">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1196">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1197">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1197">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1198">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1198">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1199">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1199">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1200">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1200">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1201">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1201">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1202">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1202">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1203">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1203">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1204">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1204">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1205">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1205">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1206">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1206">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1207">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1207">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1208">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1208">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1209">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1209">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1210">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1210">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1211">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1211">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1212">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1212">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1213">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1213">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1214">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1214">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1215">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1215">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1216">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1216">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1217">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1217">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1218">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1218">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1219">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1219">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1220">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1220">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1221">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1221">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1222">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1222">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1223">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1223">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1224">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1224">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1225">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1225">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1226">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1226">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1227">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1227">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1228">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1228">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1229">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1229">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1230">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1230">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1231">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1231">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1232">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1232">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1233">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1233">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1234">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1234">Required.</span>
          </span>
          <span data-ttu-id="1523f-1235">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1235">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1236">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1236">Required.</span>
          </span>
          <span data-ttu-id="1523f-1237">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1237">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1238">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1238">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1239">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1239">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1240">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1240">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1241">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1241">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1242">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1242">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1243">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1243">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1244">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1244">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1245">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1245">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1246">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1246">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1247">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1247">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1248">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1248">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1249">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1249">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1250">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1250">Random Mode</span></span>  
 <span data-ttu-id="1523f-1251">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1251">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1252">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1252">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1253">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1253">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1254">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1254">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1255">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1255">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1256">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1256">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1257">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1257">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1258">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1258">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1259">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1259">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1260">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1260">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1261">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1261">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1262">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1262">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1263">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1263">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1264">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1264">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1265">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1265">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1266">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1266">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1267">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1267">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1268">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1268">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1269">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1269">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1270">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1270">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1271">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1271">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1272">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1272">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1273">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1273">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1274">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1274">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1275">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1275">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1276">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1276">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1277">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1277">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1278">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1278">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1279">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1279">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1280">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1280">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1281">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1281">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1282">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1282">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1283">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1283">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1284">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1284">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1285">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1285">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1286">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1286">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1287">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1287">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1288">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1288">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1289">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1289">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1290">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1290">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1291">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1291">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1292">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1292">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1293">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1293">Required.</span>
          </span>
          <span data-ttu-id="1523f-1294">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1294">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1295">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1295">Required.</span>
          </span>
          <span data-ttu-id="1523f-1296">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1296">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1297">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1297">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1298">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1298">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1299">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1299">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1300">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1300">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1301">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1301">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1302">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1302">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1303">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1303">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1304">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1304">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1305">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1305">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1306">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1306">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1307">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1307">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1308">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1308">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1309">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1309">Random Mode</span></span>  
 <span data-ttu-id="1523f-1310">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1310">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1311">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1311">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1312">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1312">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1313">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1313">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1314">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1314">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1315">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1315">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1316">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1316">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1317">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1317">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1318">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1318">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1319">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1319">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1320">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1320">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1321">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1321">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1322">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1322">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1323">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1323">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1324">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1324">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1325">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1325">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1326">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1326">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1327">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1327">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1328">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1328">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1329">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1329">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1330">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1330">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1331">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1331">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1332">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1332">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1333">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1333">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1334">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1334">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1335">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1335">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1336">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1336">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1337">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1337">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1338">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1338">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1339">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1339">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1340">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1340">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1341">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1341">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1342">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1342">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1343">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1343">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1344">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1344">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1345">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1345">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1346">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1346">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1347">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1347">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1348">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1348">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1349">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1349">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1350">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1350">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1351">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1351">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1352">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1352">Required.</span>
          </span>
          <span data-ttu-id="1523f-1353">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1353">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1354">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1354">Required.</span>
          </span>
          <span data-ttu-id="1523f-1355">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1355">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1356">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1356">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1357">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1357">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1358">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1358">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1359">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1359">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1360">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1360">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1361">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1361">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1362">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1362">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1363">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1363">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1364">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1364">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1365">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1365">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1366">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1366">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1367">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1367">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1368">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1368">Random Mode</span></span>  
 <span data-ttu-id="1523f-1369">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1369">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1370">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1370">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1371">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1371">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1372">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1372">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1373">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1373">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1374">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1374">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1375">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1375">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1376">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1376">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1377">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1377">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1378">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1378">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1379">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1379">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1380">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1380">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1381">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1381">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1382">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1382">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1383">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1383">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1384">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1384">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1385">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1385">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1386">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1386">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1387">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1387">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1388">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1388">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1389">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1389">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1390">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1390">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1391">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1391">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1392">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1392">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1393">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1393">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1394">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1394">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1395">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1395">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1396">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1396">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1397">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1397">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1398">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1398">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1399">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1399">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1400">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1400">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1401">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1401">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1402">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1402">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1403">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1403">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1404">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1404">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1405">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1405">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1406">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1406">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1407">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1407">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1408">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1408">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1409">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1409">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1410">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1410">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1411">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1411">Required.</span>
          </span>
          <span data-ttu-id="1523f-1412">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1412">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1413">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1413">Required.</span>
          </span>
          <span data-ttu-id="1523f-1414">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1414">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1415">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1415">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1416">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1416">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1417">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1417">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1418">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1418">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1419">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1419">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1420">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1420">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1421">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1421">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1422">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1422">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1423">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1423">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1424">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1424">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1425">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1425">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1426">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1426">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1427">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1427">Random Mode</span></span>  
 <span data-ttu-id="1523f-1428">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1428">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1429">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1429">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1430">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1430">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1431">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1431">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1432">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1432">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1433">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1433">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1434">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1434">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1435">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1435">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1436">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1436">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1437">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1437">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1438">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1438">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1439">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1439">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1440">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1440">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1441">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1441">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1442">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1442">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1443">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1443">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1444">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1444">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1445">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1445">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1446">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1446">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1447">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1447">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1448">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1448">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1449">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1449">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1450">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1450">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1451">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1451">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1452">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1452">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1453">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1453">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1454">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1454">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1455">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1455">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1456">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1456">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1457">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1457">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1458">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1458">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1459">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1459">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1460">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1460">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1461">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1461">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1462">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1462">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1463">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1463">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1464">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1464">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1465">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1465">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1466">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1466">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1467">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1467">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1468">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1468">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1469">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1469">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1470">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1470">Required.</span>
          </span>
          <span data-ttu-id="1523f-1471">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1471">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1472">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1472">Required.</span>
          </span>
          <span data-ttu-id="1523f-1473">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1473">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1474">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1474">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1475">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1475">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1476">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1476">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1477">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1477">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1478">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1478">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1479">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1479">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1480">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1480">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1481">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1481">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1482">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1482">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1483">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1483">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1484">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1484">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1485">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1485">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1486">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1486">Random Mode</span></span>  
 <span data-ttu-id="1523f-1487">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1487">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1488">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1488">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1489">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1489">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1490">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1490">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1491">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1491">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1492">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1492">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1493">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1493">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1494">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1494">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1495">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1495">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1496">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1496">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1497">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die`VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1497">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1498">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1498">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1499">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1499">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1500">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1500">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1501">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1501">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1502">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1502">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1503">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1503">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1504">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1504">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1505">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1505">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1506">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1506">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1507">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1507">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1508">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1508">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1509">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1509">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1510">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1510">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1511">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1511">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1512">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1512">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1513">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1513">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1514">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1514">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1515">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1515">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1516">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1516">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1517">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1517">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1518">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1518">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1519">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1519">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1520">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1520">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1521">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1521">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1522">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1522">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1523">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1523">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1524">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1524">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1525">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1525">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1526">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1526">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1527">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1527">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1528">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1528">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1529">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1529">Required.</span>
          </span>
          <span data-ttu-id="1523f-1530">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1530">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1531">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1531">Required.</span>
          </span>
          <span data-ttu-id="1523f-1532">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1532">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1533">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1533">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1534">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1534">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1535">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1535">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1536">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1536">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1537">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1537">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1538">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1538">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1539">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1539">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1540">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1540">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1541">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1541">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1542">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1542">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1543">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1543">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1544">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1544">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1545">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1545">Random Mode</span></span>  
 <span data-ttu-id="1523f-1546">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1546">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1547">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1547">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1548">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1548">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1549">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1549">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1550">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1550">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1551">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1551">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1552">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1552">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1553">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1553">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1554">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1554">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1555">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1555">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1556">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1556">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1557">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1557">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1558">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1558">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1559">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1559">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1560">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1560">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1561">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1561">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1562">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1562">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1563">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1563">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1564">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1564">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1565">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1565">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1566">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1566">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1567">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1567">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1568">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1568">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1569">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1569">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1570">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1570">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1571">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1571">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1572">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1572">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1573">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1573">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1574">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1574">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1575">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1575">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1576">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1576">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1577">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1577">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1578">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1578">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1579">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1579">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1580">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1580">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1581">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1581">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1582">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1582">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1583">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1583">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1584">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1584">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1585">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1585">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1586">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1586">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1587">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1587">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1588">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1588">Required.</span>
          </span>
          <span data-ttu-id="1523f-1589">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1589">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1590">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1590">Required.</span>
          </span>
          <span data-ttu-id="1523f-1591">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1591">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1592">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1592">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1593">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1593">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1594">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1594">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1595">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1595">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1596">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1596">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1597">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1597">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1598">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1598">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1599">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1599">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1600">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1600">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1601">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1601">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1602">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1602">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1603">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1603">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1604">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1604">Random Mode</span></span>  
 <span data-ttu-id="1523f-1605">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1605">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1606">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1606">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1607">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1607">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1608">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1608">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1609">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1609">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1610">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1610">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1611">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1611">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1612">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1612">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1613">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1613">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1614">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1614">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1615">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1615">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1616">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1616">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1617">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1617">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1618">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1618">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1619">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1619">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1620">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1620">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1621">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1621">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1622">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1622">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1623">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1623">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1624">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1624">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1625">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1625">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1626">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1626">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1627">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1627">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1628">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1628">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1629">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1629">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1630">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1630">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1631">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1631">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1632">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1632">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1633">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1633">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1634">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1634">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1635">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1635">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1636">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1636">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1637">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1637">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1638">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1638">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1639">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1639">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1640">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1640">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1641">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1641">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1642">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1642">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1643">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1643">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1644">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1644">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1645">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1645">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1646">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1646">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1647">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1647">Required.</span>
          </span>
          <span data-ttu-id="1523f-1648">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1648">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1649">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1649">Required.</span>
          </span>
          <span data-ttu-id="1523f-1650">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1650">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1651">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1651">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1652">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1652">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1653">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1653">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1654">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1654">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1655">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1655">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1656">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1656">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1657">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1657">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1658">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1658">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1659">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1659">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1660">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1660">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1661">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1661">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1662">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1662">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1663">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1663">Random Mode</span></span>  
 <span data-ttu-id="1523f-1664">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1664">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1665">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1665">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1666">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1666">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1667">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1667">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1668">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1668">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1669">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1669">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1670">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1670">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1671">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1671">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1672">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1672">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1673">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1673">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1674">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1674">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1675">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1675">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1676">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1676">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1677">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1677">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1678">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1678">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1679">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1679">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1680">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1680">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1681">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1681">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1682">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1682">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1683">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1683">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1684">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1684">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1685">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1685">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1686">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1686">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1687">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1687">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1688">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1688">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1689">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1689">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1690">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1690">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1691">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1691">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1692">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1692">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1693">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1693">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1694">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1694">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1695">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1695">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1696">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1696">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1697">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1697">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1698">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1698">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1699">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1699">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1700">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1700">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1701">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1701">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1702">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1702">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1703">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1703">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1704">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1704">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1705">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1705">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1706">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1706">Required.</span>
          </span>
          <span data-ttu-id="1523f-1707">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1707">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1708">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1708">Required.</span>
          </span>
          <span data-ttu-id="1523f-1709">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1709">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1710">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1710">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1711">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1711">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1712">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1712">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1713">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1713">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1714">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1714">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1715">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1715">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1716">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1716">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1717">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1717">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1718">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1718">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1719">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1719">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1720">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1720">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1721">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1721">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1722">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1722">Random Mode</span></span>  
 <span data-ttu-id="1523f-1723">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1723">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1724">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die`RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1724">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1725">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1725">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1726">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1726">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1727">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1727">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1728">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1728">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1729">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1729">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1730">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1730">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1731">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1731">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1732">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1732">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1733">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1733">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1734">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1734">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1735">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1735">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1736">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1736">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1737">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1737">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1738">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1738">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1739">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1739">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1740">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1740">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1741">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1741">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1742">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1742">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1743">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1743">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1744">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1744">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1745">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1745">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1746">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1747">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1747">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1748">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1748">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1749">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1749">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1750">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1750">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1751">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1751">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1752">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1752">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1753">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1753">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1754">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1754">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1755">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1755">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1756">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1756">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1757">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1757">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1758">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1758">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1759">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1759">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1760">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1760">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1761">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1761">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1762">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1762">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1763">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1763">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1764">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1764">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1765">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1765">Required.</span>
          </span>
          <span data-ttu-id="1523f-1766">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1766">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1767">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1767">Required.</span>
          </span>
          <span data-ttu-id="1523f-1768">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1768">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1769">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1769">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1770">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1770">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1771">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1771">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1772">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1772">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1773">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1773">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1774">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1774">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1775">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1775">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1776">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1776">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1777">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1777">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1778">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1778">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1779">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1779">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1780">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1780">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1781">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1781">Random Mode</span></span>  
 <span data-ttu-id="1523f-1782">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1782">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1783">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1783">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1784">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1784">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1785">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1785">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1786">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1786">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1787">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1787">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1788">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1788">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1789">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1789">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1790">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1790">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1791">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1791">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1792">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1792">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1793">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1793">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1794">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1794">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1795">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1795">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1796">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1796">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1797">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1797">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1798">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1798">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1799">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1799">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1800">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1800">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1801">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1801">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1802">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1802">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1803">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1803">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1804">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1804">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1805">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1805">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1806">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1806">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1807">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1807">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1808">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1808">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1809">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1809">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1810">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1810">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1811">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1811">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1812">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1812">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1813">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1813">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1814">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1814">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1815">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1815">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1816">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1816">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1817">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1817">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1818">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1818">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1819">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1819">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1820">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1820">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1821">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1821">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1822">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1822">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1823">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1823">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1824">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1824">Required.</span>
          </span>
          <span data-ttu-id="1523f-1825">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1825">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1826">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1826">Required.</span>
          </span>
          <span data-ttu-id="1523f-1827">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1827">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1828">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1828">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1829">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1829">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="1523f-1830">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1830">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1831">Betrifft nur das Schreiben einer Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1831">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="1523f-1832">Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1832">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="1523f-1833">Der Standardwert ist <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1833">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1834">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1834">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1835">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1835">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1836">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1836">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1837">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1837">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1838">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1838">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1839">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1839">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1840">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1840">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1841">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1841">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1842">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1842">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1843">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1843">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1844">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1844">Random Mode</span></span>  
 <span data-ttu-id="1523f-1845">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1845">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1846">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1846">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1847">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1847">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1848">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1848">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1849">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1849">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1850">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1850">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1851">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1851">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1852">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1852">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1853">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1853">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1854">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1854">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1855">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1855">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1856">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1856">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1857">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1857">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1858">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1858">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1859">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1859">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1860">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1860">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1861">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1861">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1862">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1862">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1863">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1863">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1864">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1864">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1865">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1865">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1866">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1866">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1867">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1867">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1868">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1868">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1869">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1869">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1870">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1870">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1871">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1871">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1872">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1872">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1873">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1873">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1874">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1874">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1875">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1875">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1876">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1876">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1877">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1877">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1878">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1878">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1879">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1879">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1880">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1880">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1881">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1881">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1882">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1882">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1883">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1883">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1884">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1884">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1885">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1885">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1886">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1886">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1887">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1887">Required.</span>
          </span>
          <span data-ttu-id="1523f-1888">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1888">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1889">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1889">Required.</span>
          </span>
          <span data-ttu-id="1523f-1890">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1890">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1891">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1891">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1892">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1892">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="1523f-1893">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1893">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1894">Betrifft nur das Schreiben eines Arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1894">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="1523f-1895">Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor für die Zeichenfolge erforderlich ist, der die Länge beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1895">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="1523f-1896">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1896">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1897">Betrifft nur das Schreiben einer Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1897">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="1523f-1898">Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1898">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="1523f-1899">Der Standardwert ist <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1899">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1900">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1900">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1901">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1901">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="1523f-1902">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1902">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1903">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1903">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1904">Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1904">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="1523f-1905">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1905">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1906">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-1906">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="1523f-1907">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1907">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1908">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1908">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1909">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1909">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1910">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1910">Random Mode</span></span>  
 <span data-ttu-id="1523f-1911">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1911">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1912">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1912">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1913">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1913">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1914">Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1914">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1915">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1915">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1916">Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1916">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="1523f-1917">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1917">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="1523f-1918">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1918">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1919">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1919">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1920">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1920">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1921">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1921">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1922">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1922">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1923">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1923">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1924">Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1924">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="1523f-1925">Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1925">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="1523f-1926">Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors.</span><span class="sxs-lookup"><span data-stu-id="1523f-1926">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="1523f-1927">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1927">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="1523f-1928">Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1928">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="1523f-1929">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1929">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1930">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1930">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="1523f-1931">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1931">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1932">Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1932">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="1523f-1933">Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1933">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="1523f-1934">Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1934">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="1523f-1935">`FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1935">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="1523f-1936">Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1936">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="1523f-1937">Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="1523f-1937">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1938">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1938">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1939">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1939">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="1523f-1940">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="1523f-1940">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="1523f-1941">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1941">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1942">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1942">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="1523f-1943">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1943">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="1523f-1944">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1944">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="1523f-1945">`FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor.</span><span class="sxs-lookup"><span data-stu-id="1523f-1945">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="1523f-1946">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1946">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="1523f-1947">Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:</span><span class="sxs-lookup"><span data-stu-id="1523f-1947">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="1523f-1948">Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-1948">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1949">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1949">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="1523f-1950">Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-1950">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-1951">
            <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1951">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-1952">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1952">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1953">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1953">Required.</span>
          </span>
          <span data-ttu-id="1523f-1954">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1954">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-1955">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1955">Required.</span>
          </span>
          <span data-ttu-id="1523f-1956">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1956">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="1523f-1957">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1957">Optional.</span>
          </span>
          <span data-ttu-id="1523f-1958">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1958">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1959">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1959">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="1523f-1960">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePutObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1960">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span>
          </span>
          <span data-ttu-id="1523f-1961">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1961">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-1962">Die `FilePutObject` Funktion dient anstelle von `FilePut` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs übergeben `Integer`, `Long`, `Short`usw.</span><span class="sxs-lookup"><span data-stu-id="1523f-1962">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="1523f-1963">`FilePutObject` schreibt, und liest Deskriptoren, die das Objekt zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1963">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="1523f-1964">Wenn Sie beabsichtigen, schreibt die `Variant` Typ `FilePutObject` ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="1523f-1964">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="1523f-1965">Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird empfohlen, dass Sie immer verwenden `FilePutObject` und `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1965">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="1523f-1966">`FilePutObject` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-1966">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-1967">Mit `FilePutObject` geschriebene Daten werden normalerweise mit `FileGetObject` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1967">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="1523f-1968">Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-1968">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="1523f-1969">Wenn Sie weglassen `RecordNumber`, `FilePutObject` schreibt den Datensatz bzw. das Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder den Datensatz bzw. das Byte zeigt den letzten `Seek` Funktion).</span><span class="sxs-lookup"><span data-stu-id="1523f-1969">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="1523f-1970">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-1970">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="1523f-1971">`FilePutObject` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="1523f-1971">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="1523f-1972">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePutObject`, müssen Sie das gleiche mit `FileGetObject`, und Sie müssen auch sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-1972">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="1523f-1973">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-1973">Random Mode</span></span>  
 <span data-ttu-id="1523f-1974">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="1523f-1974">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="1523f-1975">Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePutObject` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1975">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="1523f-1976">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="1523f-1976">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="1523f-1977">Da die Menge der Daten der Auffüllung nicht genau bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1977">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="1523f-1978">Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1523f-1978">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="1523f-1979">Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePutObject` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="1523f-1979">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="1523f-1980">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePutObject` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1980">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="1523f-1981">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1981">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="1523f-1982">Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePutObject` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-1982">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="1523f-1983">Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-1983">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="1523f-1984">Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="1523f-1984">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="1523f-1985">Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1985">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="1523f-1986">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="1523f-1986">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="1523f-1987">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="1523f-1987">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="1523f-1988">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="1523f-1988">Binary Mode</span></span>  
 <span data-ttu-id="1523f-1989">Für Dateien in geöffnet `Binary` Modus alle die `Random` Modus Regeln anwenden, mit Ausnahme von:</span><span class="sxs-lookup"><span data-stu-id="1523f-1989">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="1523f-1990">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="1523f-1990">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="1523f-1991">`FilePutObject` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.</span><span class="sxs-lookup"><span data-stu-id="1523f-1991">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-1992">Dieses Beispiel verwendet die `FilePutObject` Funktion, um eine Zeichenfolge in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-1992">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-1993">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1993">Required.</span>
          </span>
          <span data-ttu-id="1523f-1994">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1994">Any valid file number.</span>
          </span>
        </param>
        <param name="RecordWidth">
          <span data-ttu-id="1523f-1995">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1995">Required.</span>
          </span>
          <span data-ttu-id="1523f-1996">Ein numerischer Ausdruck im Bereich 0-255 einschließlich, der angibt, wie viele Zeichen auf einer Zeile stehen, bevor eine neue Zeile beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1996">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span>
          </span>
          <span data-ttu-id="1523f-1997">Wenn <c>RecordWidth</c> gleich 0 ist, ist die Länge einer Zeile unbegrenzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1997">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span>
          </span>
          <span data-ttu-id="1523f-1998">Der Standardwert für <c>RecordWidth</c> ist 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1998">The default value for <c>RecordWidth</c> is 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-1999">Weist einer Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wurde, eine Ausgabezeilenbreite zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-1999">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1523f-2000">Dieses Beispiel verwendet die `FileWidth` Funktion, um die Breite einer Zeile für eine Datei festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2000">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2001">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2001">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2002">Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2002">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2003">Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2003">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2004">Verwendung `FreeFile` zahlreiche Datei angeben, die nicht bereits verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2004">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2005">Dieses Beispiel verwendet die `FreeFile` Funktion, um die nächste verfügbare Dateinummer zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2005">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="1523f-2006">Für die Ausgabe innerhalb der Schleife werden fünf Dateien geöffnet, und einige Beispieldaten in jeder geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2006">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2007">Mehr als 255 Dateien verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2007">More than 255 files are in use.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-2008">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2008">Required.</span>
          </span>
          <span data-ttu-id="1523f-2009">Ein <see langword="String" />-Ausdruck, der einen Datei-, Verzeichnis- oder Ordnernamen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2009">
              <see langword="String" /> expression that specifies a file, directory, or folder name.</span>
          </span>
          <span data-ttu-id="1523f-2010">
            <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2010">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2011">Gibt einen <see langword="FileAttribute" />-Wert zurück, der die Attribute einer Datei, eines Verzeichnisses oder eines Ordners darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2011">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span>
          </span>
          <span data-ttu-id="1523f-2012">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2012">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span>
          </span>
          <span data-ttu-id="1523f-2013">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2013">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2014">Der von <see langword="GetAttr" /> zurückgegebene Wert ist die Summe aus folgenden Enumerationswerten:</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2014">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span>
          </span>
          <span data-ttu-id="1523f-2015">
            <list type="table">
              <item>
                <term> Wert  </term>
                <description> Kontante </description>
                <description> Beschreibung  </description>
              </item>
              <item>
                <term>
                  <see langword="Normal" />
                </term>
                <description>
                  <see langword="vbNormal" />
                </description>
                <description> Normal.  </description>
              </item>
              <item>
                <term>
                  <see langword="ReadOnly" />
                </term>
                <description>
                  <see langword="vbReadOnly" />
                </description>
                <description> Schreibgeschützt.  </description>
              </item>
              <item>
                <term>
                  <see langword="Hidden" />
                </term>
                <description>
                  <see langword="vbHidden" />
                </description>
                <description> Ausgeblendet.  </description>
              </item>
              <item>
                <term>
                  <see langword="System" />
                </term>
                <description>
                  <see langword="vbSystem" />
                </description>
                <description> Systemdatei.  </description>
              </item>
              <item>
                <term>
                  <see langword="Directory" />
                </term>
                <description>
                  <see langword="vbDirectory" />
                </description>
                <description> Verzeichnis oder Ordner.  </description>
              </item>
              <item>
                <term>
                  <see langword="Archive" />
                </term>
                <description>
                  <see langword="vbArchive" />
                </description>
                <description> Die Datei wurde nach der letzten Sicherung geändert.  </description>
              </item>
              <item>
                <term>
                  <see langword="Alias" />
                </term>
                <description>
                  <see langword="vbAlias" />
                </description>
                <description> Die Datei hat einen anderen Namen.  </description>
              </item>
            </list>
            <block subset="none" type="note">
              <para> Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben. Die Namen können überall im Code anstelle von tatsächlichen Werten verwendet werden.  </para>
            </block>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2015">
              <list type="table">
                <item>
                  <term> Value  </term>
                  <description> Constant  </description>
                  <description> Description  </description>
                </item>
                <item>
                  <term>
                    <see langword="Normal" />
                  </term>
                  <description>
                    <see langword="vbNormal" />
                  </description>
                  <description> Normal.  </description>
                </item>
                <item>
                  <term>
                    <see langword="ReadOnly" />
                  </term>
                  <description>
                    <see langword="vbReadOnly" />
                  </description>
                  <description> Read-only.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Hidden" />
                  </term>
                  <description>
                    <see langword="vbHidden" />
                  </description>
                  <description> Hidden.  </description>
                </item>
                <item>
                  <term>
                    <see langword="System" />
                  </term>
                  <description>
                    <see langword="vbSystem" />
                  </description>
                  <description> System file.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Directory" />
                  </term>
                  <description>
                    <see langword="vbDirectory" />
                  </description>
                  <description> Directory or folder.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Archive" />
                  </term>
                  <description>
                    <see langword="vbArchive" />
                  </description>
                  <description> File has changed since last backup.  </description>
                </item>
                <item>
                  <term>
                    <see langword="Alias" />
                  </term>
                  <description>
                    <see langword="vbAlias" />
                  </description>
                  <description> File has a different name.  </description>
                </item>
              </list>
              <block subset="none" type="note">
                <para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para>
              </block>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2016">Verwenden, um zu bestimmen, welche Attribute festgelegt sind, die `And` Operator, um einen bitweisen Vergleich, der den Rückgabewert von führen die `GetAttr` -Funktion und der Wert des Dateiattributs werden sollen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2016">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="1523f-2017">Wenn das Ergebnis nicht 0 (null) ist, wird dieses Attribut für die angegebene Datei festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2017">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="1523f-2018">Beispielsweise ist der Rückgabewert der folgenden `And` Ausdruck ist NULL, wenn die `Archive` Attribut nicht festgelegt ist:</span><span class="sxs-lookup"><span data-stu-id="1523f-2018">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="1523f-2019">Ein Wert ungleich NULL wird zurückgegeben, wenn die `Archive` -Attribut festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2019">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2020">Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und Verzeichnis oder Ordner zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="1523f-2020">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2021">
            <paramref name="Pathname" /> ist ungültig oder enthält Platzhalterzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2021">
              <paramref name="Pathname" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-2022">Zieldatei ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2022">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2023">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2023">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2024">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2024">Required.</span>
          </span>
          <span data-ttu-id="1523f-2025">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2025">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2026">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2026">Required.</span>
          </span>
          <span data-ttu-id="1523f-2027">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2027">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2028">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2028">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2029">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2029">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2030">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2030">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2031">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2031">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2032">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2032">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2033">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2033">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2034">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2034">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2035">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2035">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2036">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2036">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2037">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2037">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2038">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2038">Data</span></span>|<span data-ttu-id="1523f-2039">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2039">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2040">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2040">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2041">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2041">Empty</span></span>|  
|<span data-ttu-id="1523f-2042">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2042">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2043">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2043">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2044">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2044">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2045">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2045">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2046">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2046">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2047">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2047">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2048">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2048">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2049">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2049">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2050">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2050">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2051">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2051">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2052">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2052">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2053">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2053">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2054">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2054">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2055">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2055">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2056">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2056">Required.</span>
          </span>
          <span data-ttu-id="1523f-2057">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2057">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2058">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2058">Required.</span>
          </span>
          <span data-ttu-id="1523f-2059">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2059">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2060">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2060">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2061">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2061">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2062">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2062">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2063">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2063">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2064">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2064">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2065">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2065">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2066">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2066">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2067">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2067">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2068">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2068">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2069">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2069">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2070">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2070">Data</span></span>|<span data-ttu-id="1523f-2071">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2071">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2072">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2072">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2073">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2073">Empty</span></span>|  
|<span data-ttu-id="1523f-2074">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2074">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2075">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2075">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2076">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2076">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2077">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2077">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2078">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2078">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2079">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2079">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2080">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2080">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2081">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2081">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2082">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2082">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2083">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2083">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2084">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2084">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2085">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2085">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2086">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2086">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2087">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2087">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2088">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2088">Required.</span>
          </span>
          <span data-ttu-id="1523f-2089">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2089">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2090">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2090">Required.</span>
          </span>
          <span data-ttu-id="1523f-2091">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2091">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2092">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2092">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2093">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2093">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2094">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2094">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2095">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2095">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2096">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2096">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2097">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2097">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2098">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2098">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2099">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2099">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2100">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2100">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2101">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2101">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2102">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2102">Data</span></span>|<span data-ttu-id="1523f-2103">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2103">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2104">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2104">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2105">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2105">Empty</span></span>|  
|<span data-ttu-id="1523f-2106">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2106">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2107">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2107">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2108">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2108">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2109">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2109">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2110">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2110">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2111">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2111">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2112">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2112">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2113">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2113">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2114">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2114">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2115">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2115">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2116">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2116">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2117">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2117">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2118">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2118">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2119">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2119">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2120">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2120">Required.</span>
          </span>
          <span data-ttu-id="1523f-2121">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2121">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2122">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2122">Required.</span>
          </span>
          <span data-ttu-id="1523f-2123">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2123">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2124">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2124">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2125">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2125">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2126">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2126">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2127">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2127">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2128">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2128">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2129">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2129">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2130">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2130">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2131">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2131">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2132">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2132">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2133">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2133">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2134">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2134">Data</span></span>|<span data-ttu-id="1523f-2135">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2135">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2136">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2136">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2137">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2137">Empty</span></span>|  
|<span data-ttu-id="1523f-2138">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2138">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2139">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2139">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2140">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2140">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2141">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2141">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2142">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2142">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2143">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2143">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2144">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2144">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2145">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2145">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2146">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2146">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2147">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2147">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2148">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2148">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2149">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2149">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2150">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2150">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2151">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2151">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2152">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2152">Required.</span>
          </span>
          <span data-ttu-id="1523f-2153">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2153">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2154">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2154">Required.</span>
          </span>
          <span data-ttu-id="1523f-2155">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2155">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2156">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2156">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2157">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2157">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2158">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2158">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2159">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2159">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2160">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2160">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2161">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2161">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2162">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2162">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2163">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2163">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2164">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2164">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2165">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2165">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2166">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2166">Data</span></span>|<span data-ttu-id="1523f-2167">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2167">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2168">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2168">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2169">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2169">Empty</span></span>|  
|<span data-ttu-id="1523f-2170">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2170">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2171">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2171">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2172">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2172">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2173">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2173">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2174">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2174">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2175">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2175">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2176">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2176">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2177">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2177">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2178">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2178">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2179">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2179">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2180">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2180">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2181">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2181">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2182">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2182">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2183">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2183">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2184">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2184">Required.</span>
          </span>
          <span data-ttu-id="1523f-2185">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2185">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2186">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2186">Required.</span>
          </span>
          <span data-ttu-id="1523f-2187">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2187">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2188">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2188">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2189">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2189">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2190">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2190">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2191">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2191">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2192">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2192">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2193">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2193">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2194">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2194">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2195">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2195">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2196">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2196">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2197">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2197">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2198">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2198">Data</span></span>|<span data-ttu-id="1523f-2199">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2199">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2200">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2200">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2201">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2201">Empty</span></span>|  
|<span data-ttu-id="1523f-2202">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2202">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2203">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2203">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2204">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2204">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2205">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2205">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2206">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2206">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2207">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2207">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2208">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2208">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2209">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2209">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2210">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2210">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2211">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2211">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2212">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2212">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2213">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2213">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2214">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2214">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2215">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2215">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2216">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2216">Required.</span>
          </span>
          <span data-ttu-id="1523f-2217">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2217">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2218">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2218">Required.</span>
          </span>
          <span data-ttu-id="1523f-2219">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2219">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2220">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2220">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2221">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2221">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2222">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2222">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2223">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2223">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2224">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2224">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2225">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2225">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2226">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2226">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2227">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2227">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2228">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2228">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2229">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2229">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2230">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2230">Data</span></span>|<span data-ttu-id="1523f-2231">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2231">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2232">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2232">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2233">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2233">Empty</span></span>|  
|<span data-ttu-id="1523f-2234">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2234">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2235">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2235">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2236">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2236">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2237">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2237">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2238">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2238">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2239">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2239">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2240">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2240">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2241">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2241">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2242">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2242">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2243">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2243">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2244">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2244">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2245">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2245">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2246">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2246">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2247">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2247">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2248">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2248">Required.</span>
          </span>
          <span data-ttu-id="1523f-2249">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2249">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2250">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2250">Required.</span>
          </span>
          <span data-ttu-id="1523f-2251">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2251">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2252">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2252">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2253">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2253">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2254">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2254">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2255">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2255">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2256">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2256">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2257">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2257">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2258">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2258">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2259">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2259">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2260">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2260">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2261">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2261">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2262">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2262">Data</span></span>|<span data-ttu-id="1523f-2263">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2263">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2264">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2264">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2265">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2265">Empty</span></span>|  
|<span data-ttu-id="1523f-2266">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2266">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2267">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2267">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2268">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2268">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2269">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2269">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2270">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2270">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2271">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2271">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2272">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2272">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2273">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2273">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2274">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2274">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2275">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2275">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2276">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2276">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2277">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2277">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2278">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2278">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2279">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2279">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2280">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2280">Required.</span>
          </span>
          <span data-ttu-id="1523f-2281">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2281">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2282">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2282">Required.</span>
          </span>
          <span data-ttu-id="1523f-2283">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2283">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2284">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2284">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2285">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2285">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2286">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2286">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2287">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2287">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2288">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2288">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2289">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2289">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2290">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2290">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2291">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2291">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2292">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2292">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2293">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2293">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2294">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2294">Data</span></span>|<span data-ttu-id="1523f-2295">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2295">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2296">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2296">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2297">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2297">Empty</span></span>|  
|<span data-ttu-id="1523f-2298">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2298">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2299">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2299">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2300">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2300">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2301">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2301">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2302">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2302">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2303">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2303">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2304">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2304">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2305">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2305">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2306">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2306">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2307">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2307">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2308">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2308">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2309">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2309">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2310">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2310">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2311">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2311">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2312">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2312">Required.</span>
          </span>
          <span data-ttu-id="1523f-2313">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2313">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2314">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2314">Required.</span>
          </span>
          <span data-ttu-id="1523f-2315">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2315">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2316">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2316">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2317">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2317">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2318">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2318">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2319">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2319">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2320">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2320">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2321">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2321">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2322">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2322">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2323">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2323">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2324">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2324">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2325">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2325">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2326">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2326">Data</span></span>|<span data-ttu-id="1523f-2327">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2327">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2328">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2328">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2329">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2329">Empty</span></span>|  
|<span data-ttu-id="1523f-2330">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2330">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2331">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2331">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2332">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2332">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2333">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2333">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2334">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2334">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2335">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2335">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2336">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2336">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2337">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2337">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2338">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2338">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2339">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2339">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2340">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2340">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2341">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2341">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2342">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2342">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2343">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2343">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2344">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2344">Required.</span>
          </span>
          <span data-ttu-id="1523f-2345">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2345">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2346">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2346">Required.</span>
          </span>
          <span data-ttu-id="1523f-2347">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2347">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2348">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2348">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2349">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2349">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2350">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2350">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2351">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2351">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2352">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2352">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2353">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2353">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2354">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2354">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2355">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2355">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2356">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2356">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2357">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2357">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2358">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2358">Data</span></span>|<span data-ttu-id="1523f-2359">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2359">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2360">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2360">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2361">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2361">Empty</span></span>|  
|<span data-ttu-id="1523f-2362">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2362">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2363">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2363">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2364">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2364">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2365">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2365">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2366">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2366">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2367">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2367">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2368">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2368">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2369">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2369">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2370">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2370">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2371">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2371">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2372">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2372">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2373">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2373">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2374">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2374">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2375">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2375">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2376">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2376">Required.</span>
          </span>
          <span data-ttu-id="1523f-2377">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2377">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="1523f-2378">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2378">Required.</span>
          </span>
          <span data-ttu-id="1523f-2379">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2379">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2380">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2380">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2381">Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2381">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2382">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2382">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2383">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2383">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2384">Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2384">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="1523f-2385">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2385">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2386">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2386">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2387">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2387">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="1523f-2388">Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2388">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="1523f-2389">Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2389">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="1523f-2390">Daten</span><span class="sxs-lookup"><span data-stu-id="1523f-2390">Data</span></span>|<span data-ttu-id="1523f-2391">Wert, der Variablen zugewiesen</span><span class="sxs-lookup"><span data-stu-id="1523f-2391">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="1523f-2392">Als Trennzeichen Komma oder die leere Zeile</span><span class="sxs-lookup"><span data-stu-id="1523f-2392">Delimiting comma or blank line</span></span>|<span data-ttu-id="1523f-2393">Empty</span><span class="sxs-lookup"><span data-stu-id="1523f-2393">Empty</span></span>|  
|<span data-ttu-id="1523f-2394">#NULL #</span><span class="sxs-lookup"><span data-stu-id="1523f-2394">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="1523f-2395">#TRUE # oder #FALSE</span><span class="sxs-lookup"><span data-stu-id="1523f-2395">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="1523f-2396">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="1523f-2396">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="1523f-2397">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2397">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="1523f-2398">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="1523f-2398">#ERROR `errornumber`#</span></span>|<span data-ttu-id="1523f-2399">`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="1523f-2399">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="1523f-2400">Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2400">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2401">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2401">The `Input` function is not localized.</span></span> <span data-ttu-id="1523f-2402">Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2402">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2403">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2403">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2404">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2404">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2405">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2405">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="1523f-2406">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="1523f-2406">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2407">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2407">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2408">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2408">Required.</span>
          </span>
          <span data-ttu-id="1523f-2409">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2409">Any valid file number.</span>
          </span>
        </param>
        <param name="CharCount">
          <span data-ttu-id="1523f-2410">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2410">Required.</span>
          </span>
          <span data-ttu-id="1523f-2411">Ein beliebiger gültiger numerischer Ausdruck, der die Anzahl der zu lesenden Zeichen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2411">Any valid numeric expression specifying the number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2412">Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2412">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="1523f-2413">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2413">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
          <span data-ttu-id="1523f-2414">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2414">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2415">Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2415">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="1523f-2416">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2416">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2417">Die `InputString` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2417">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2418">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2418">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2419">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2419">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2420">Mit gelesene Daten der `InputString` Funktion ist in der Regel in eine Datei geschrieben, mit `Print` oder `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2420">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="1523f-2421">Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="1523f-2421">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="1523f-2422">Im Gegensatz zu den `Input` -Funktion, die `InputString` Funktionsergebnis ist die gelesenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2422">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="1523f-2423">Dies schließt Kommas, Wagenrücklaufzeichen, Zeilenvorschübe, Anführungszeichen und Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2423">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="1523f-2424">Dateien für geöffnet `Binary` für den Zugriff auf einem Versuch, lesen in der Datei mit der `InputString` Funktion bis `EOF` gibt `True` wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2424">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="1523f-2425">Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `InputString`, oder verwenden Sie `FileGet` bei Verwendung der `EOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-2425">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2426">Beim Lesen aus Dateien, nehmen Sie keine Sicherheitsfragen die richtigen Entscheidungen über den Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2426">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="1523f-2427">Z. B. möglicherweise eine Datei namens "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2427">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2428">Dieses Beispiel verwendet die `InputString` Funktion, um Zeichen aus einer Datei gelesen und zum Drucken der `Output` Fenster.</span><span class="sxs-lookup"><span data-stu-id="1523f-2428">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="1523f-2429">In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2429">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2430">
            <paramref name="FileNumber" /> ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2430">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-2431">
            <paramref name="CharCount" /> &lt; 0 oder &gt; 214.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2431">
              <paramref name="CharCount" /> &lt; 0 or &gt; 214.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-2432">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2432">Required.</span>
          </span>
          <span data-ttu-id="1523f-2433">Ein <see langword="String" />-Ausdruck, der einen oder mehrere Namen von zu löschenden Dateien angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2433">
              <see langword="String" /> expression that specifies one or more file names to be deleted.</span>
          </span>
          <span data-ttu-id="1523f-2434">
            <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2434">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2435">Löscht Dateien von einem Datenträger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2435">Deletes files from a disk.</span>
          </span>
          <span data-ttu-id="1523f-2436">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Kill" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2436">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span>
          </span>
          <span data-ttu-id="1523f-2437">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2437">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2438">`Kill` unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2438">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="1523f-2439">**Sicherheitshinweis** zum Ausführen der `Kill` -Funktion erfordert `Read` und `PathDiscovery` flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2439">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="1523f-2440">Weitere Informationen finden Sie unter <xref:System.Security.SecurityException> [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="1523f-2440">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2441">Dieses Beispiel verwendet die `Kill` Funktion, um eine Datei von einem Datenträger zu löschen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2441">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2442">Zieldatei(en) geöffnet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2442">Target file(s) open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-2443">Zieldatei(en) nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2443">Target file(s) not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="1523f-2444">Berechtigung verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2444">Permission denied.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2445">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2445">Required.</span>
          </span>
          <span data-ttu-id="1523f-2446">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2446">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2447">Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2447">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2448">Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2448">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2449">Die `LineInput` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2449">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2450">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2450">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2451">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2451">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2452">Mit gelesene Daten `LineInput` in der Regel in eine Datei geschrieben wird, mithilfe von `Print`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2452">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2453">Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2453">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="1523f-2454">Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.</span><span class="sxs-lookup"><span data-stu-id="1523f-2454">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="1523f-2455">Die `LineInput` Funktion liest Zeichen aus einer Datei ein, zu einem Zeitpunkt, bis er feststellt, dass einen Wagenrücklauf (`Chr(13)`) oder Wagenrücklauf/Zeilenvorschub (`Chr(13) + Chr(10)`) Sequenz.</span><span class="sxs-lookup"><span data-stu-id="1523f-2455">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="1523f-2456">Carriage Return/Line feed Sequenzen werden übersprungen und nicht auf die Zeichenfolge angefügt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2456">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2457">Lesen aus einer Datei mithilfe der `LineInput` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2457">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2458">Dieses Beispiel verwendet die `LineInput` -Funktion zum Lesen einer Zeile aus einer sequenziellen Datei und einer Variablen zuweisen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2458">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="1523f-2459">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2459">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="1523f-2460">Dateiende erreicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2460">End of file reached.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2461">
            <paramref name="FileNumber" /> ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2461">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2462">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2462">Required.</span>
          </span>
          <span data-ttu-id="1523f-2463">Eine beliebige gültige <see langword="Integer" />-Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2463">Any valid <see langword="Integer" /> file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2464">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2464">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2465">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2465">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2466">Die `Loc` Funktion ist nullbasiert, verwenden, um das erste Byte in einer Datei abrufen gibt 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-2466">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="1523f-2467">Die `Loc` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2467">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2468">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2468">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2469">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2469">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2470">Im folgenden wird den Rückgabewert für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="1523f-2470">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="1523f-2471">Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-2471">Mode</span></span>|<span data-ttu-id="1523f-2472">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="1523f-2472">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="1523f-2473">Anzahl der dem letzten Datensatz gelesen oder geschrieben werden, auf die Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2473">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="1523f-2474">Aktuelle Byte-Position in der Datei geteilt durch 128.</span><span class="sxs-lookup"><span data-stu-id="1523f-2474">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="1523f-2475">Zurückgegebene Informationen werden jedoch von `Loc` für sequenzielle Dateien ist weder verwendet noch benötigt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2475">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="1523f-2476">Die Position des letzten Bytes gelesen bzw. geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2476">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2477">Dieses Beispiel verwendet die `Loc` Funktion, um die aktuelle Lese-/Schreibposition in einer offenen Datei zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2477">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="1523f-2478">In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2478">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2479">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2479">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2480">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2480">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2481">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2481">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2482">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2482">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2483">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2483">Required.</span>
          </span>
          <span data-ttu-id="1523f-2484">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2484">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2485">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2485">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2486">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2486">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2487">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2487">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2488">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2488">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2489">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2489">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2490">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2490">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2491">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2491">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2492">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2492">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2493">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2493">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2494">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2494">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2495">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2495">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2496">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2496">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2497">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2497">Required.</span>
          </span>
          <span data-ttu-id="1523f-2498">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2498">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="1523f-2499">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2499">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2500">Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2500">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2501">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2501">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2502">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2502">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2503">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2503">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2504">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2504">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2505">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2505">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2506">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2506">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2507">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2507">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2508">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2508">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2509">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2509">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2510">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2510">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2511">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2511">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2512">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2512">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2513">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2513">Required.</span>
          </span>
          <span data-ttu-id="1523f-2514">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2514">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="1523f-2515">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2515">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2516">Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2516">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="1523f-2517">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2517">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2518">Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2518">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2519">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2519">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2520">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2520">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2521">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2521">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2522">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2522">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2523">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2523">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2524">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2524">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2525">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2525">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2526">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2526">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2527">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2527">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2528">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2528">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2529">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2529">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2530">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2530">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2531">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2531">Required.</span>
          </span>
          <span data-ttu-id="1523f-2532">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2532">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2533">Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2533">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2534">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2534">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
          <span data-ttu-id="1523f-2535">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2535">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2536">Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2536">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2537">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2537">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2538">Verwenden der `FileLen` Funktion, um die Länge einer Datei zu erhalten, die nicht geöffnet ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2538">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2539">Dieses Beispiel verwendet die `LOF` Funktion, um die Größe einer geöffneten Datei zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2539">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="1523f-2540">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die Beispieldaten enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2540">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2541">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2541">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="1523f-2542">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2542">Required.</span>
          </span>
          <span data-ttu-id="1523f-2543">
            <see langword="String" />-Ausdruck, der das zu erstellende Verzeichnis identifiziert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2543">
              <see langword="String" /> expression that identifies the directory to be created.</span>
          </span>
          <span data-ttu-id="1523f-2544">
            <c>Path</c> enthält möglicherweise das Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2544">The <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="1523f-2545">Wenn kein Laufwerk angegeben wird, erstellt <see langword="MkDir" /> das neue Verzeichnis auf dem aktuellen Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2545">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2546">Erstellt ein neues Verzeichnis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2546">Creates a new directory.</span>
          </span>
          <span data-ttu-id="1523f-2547">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="MkDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2547">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span>
          </span>
          <span data-ttu-id="1523f-2548">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2548">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2549">Diese Funktion erstellt ein neues Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="1523f-2549">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2550">Dieses Beispiel verwendet die `MkDir` Funktion, um ein Verzeichnis zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2550">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="1523f-2551">Wenn das Laufwerk nicht angegeben ist, wird das neue Verzeichnis auf dem aktuellen Laufwerk erstellt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2551">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-2552">
            <paramref name="Path" /> ist nicht angegeben oder leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2552">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="1523f-2553">Berechtigung verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2553">Permission denied.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2554">Verzeichnis ist bereits vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2554">Directory already exists.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2555">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2555">Required.</span>
          </span>
          <span data-ttu-id="1523f-2556">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2556">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="1523f-2557">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2557">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2558">0 (null) oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2558">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="1523f-2559">Die <c>Output</c>-Argumenteinstellungen lauten:</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2559">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="1523f-2560">
            <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2560">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="1523f-2561">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2561">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2562">Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2562">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2563">Die `Print` und `PrintLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="1523f-2563">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2564">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2564">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2565">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2565">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2566">`Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings `PrintLine` umfasst einen Zeilenvorschub.</span><span class="sxs-lookup"><span data-stu-id="1523f-2566">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="1523f-2567">Mit geschriebene Daten `Print` wird in der Regel aus einer Datei gelesen, mithilfe von `LineInput` oder `Input`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2567">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="1523f-2568">Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; `Print`, nichts wird ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2568">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="1523f-2569">Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden an den Begrenzungen der Registerkarte ", aber Mischen von Kommas ausgerichtet und `TAB` kann zu inkonsistente Ergebnissen führen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2569">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="1523f-2570">Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2570">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="1523f-2571">Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.</span><span class="sxs-lookup"><span data-stu-id="1523f-2571">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="1523f-2572">Daten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2572">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="1523f-2573">Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2573">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="1523f-2574">"Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="1523f-2574">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="1523f-2575">Aber wenn `Output` Daten aus der Liste ist `DBNull`, `Null` in die Datei geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2575">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="1523f-2576">Für `Error` Daten, die Ausgabe angezeigt, als `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2576">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="1523f-2577">Die `Error` Schlüsselwort wird nicht unabhängig vom Gebietsschema übersetzt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2577">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="1523f-2578">Alle Daten, die in die Datei geschrieben werden, mithilfe von `Print` Dezimaltrennzeichen; ist, also die Daten ordnungsgemäß formatiert mit entsprechenden Dezimaltrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2578">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="1523f-2579">Wenn der Benutzer zur Ausgabe von Daten für die Verwendung durch mehrere Sprachversionen möchte `Write` verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1523f-2579">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="1523f-2580">Schreiben in eine Datei mit den `Print` oder `PrintLine` Functions erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2580">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2581">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2581">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2582">Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen zum Schreiben von Daten in eine Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2582">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2583">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2583">Required.</span>
          </span>
          <span data-ttu-id="1523f-2584">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2584">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="1523f-2585">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2585">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2586">0 (null) oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2586">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="1523f-2587">Die <c>Output</c>-Argumenteinstellungen lauten:</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2587">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="1523f-2588">
            <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2588">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="1523f-2589">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2589">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2590">Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2590">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2591">Die `Print` und `PrintLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="1523f-2591">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2592">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2592">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2593">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2593">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2594">`Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings`PrintLine` umfasst einen Zeilenvorschub.</span><span class="sxs-lookup"><span data-stu-id="1523f-2594">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="1523f-2595">Mit geschriebene Daten `Print` wird in der Regel aus einer Datei gelesen, mithilfe von `LineInput` oder `Input`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2595">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="1523f-2596">Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; `Print`, nichts wird ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2596">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="1523f-2597">Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden an den Begrenzungen der Registerkarte ", aber Mischen von Kommas ausgerichtet und `TAB` kann zu inkonsistente Ergebnissen führen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2597">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="1523f-2598">Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2598">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="1523f-2599">Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.</span><span class="sxs-lookup"><span data-stu-id="1523f-2599">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="1523f-2600">Daten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2600">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="1523f-2601">Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2601">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="1523f-2602">"Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="1523f-2602">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="1523f-2603">Aber wenn `Output` Daten aus der Liste ist `DBNull`, `Null` in die Datei geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2603">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="1523f-2604">Für `Error` Daten, die Ausgabe angezeigt, als `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2604">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="1523f-2605">Die `Error` Schlüsselwort wird nicht unabhängig vom Gebietsschema übersetzt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2605">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="1523f-2606">Alle Daten, die in die Datei geschrieben werden, mithilfe von `Print` Dezimaltrennzeichen; ist, also die Daten ordnungsgemäß formatiert mit entsprechenden Dezimaltrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2606">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="1523f-2607">Wenn der Benutzer zur Ausgabe von Daten für die Verwendung durch mehrere Sprachversionen möchte `Write` verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1523f-2607">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="1523f-2608">Schreiben in eine Datei mit den `Print` oder `PrintLine` Functions erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2608">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2609">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2609">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2610">Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen zum Schreiben von Daten in eine Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2610">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">
          <span data-ttu-id="1523f-2611">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2611">Required.</span>
          </span>
          <span data-ttu-id="1523f-2612">Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der vorhandenen Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2612">
              <see langword="String" /> expression that specifies the existing file name and location.</span>
          </span>
          <span data-ttu-id="1523f-2613">
            <c>OldPath</c> kann das Verzeichnis und das Laufwerk der Datei beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2613">
              <c>OldPath</c> may include the directory, and drive, of the file.</span>
          </span>
        </param>
        <param name="NewPath">
          <span data-ttu-id="1523f-2614">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2614">Required.</span>
          </span>
          <span data-ttu-id="1523f-2615">Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der neuen Datei angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2615">
              <see langword="String" /> expression that specifies the new file name and location.</span>
          </span>
          <span data-ttu-id="1523f-2616">
            <c>NewPath</c> kann das Verzeichnis und das Laufwerk des Zielspeicherorts beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2616">
              <c>NewPath</c> may include directory and drive of the destination location.</span>
          </span>
          <span data-ttu-id="1523f-2617">Der durch <c>NewPath</c> angegebene Dateiname darf noch nicht vorhanden sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2617">The file name specified by <c>NewPath</c> cannot already exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2618">Benennt eine Datenträgerdatei oder ein Verzeichnis um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2618">Renames a disk file or directory.</span>
          </span>
          <span data-ttu-id="1523f-2619">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Rename" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2619">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span>
          </span>
          <span data-ttu-id="1523f-2620">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2620">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2621">Die`Rename` Funktion benennt eine Datei und verschiebt ihn in ein anderes Verzeichnis aus, wenn dies erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="1523f-2621">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="1523f-2622">Die `Rename` Funktion kann eine Datei auf Laufwerken verschoben, aber es kann nur ein vorhandenes Verzeichnis umbenennen Wenn beide `NewPath` und `OldPath` auf dem gleichen Laufwerk befinden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2622">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="1523f-2623">`Rename` eine neue Datei oder ein Verzeichnis kann nicht erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2623">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="1523f-2624">Mithilfe der `Rename` erzeugt einen Fehler, Funktion, die auf eine geöffnete Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2624">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="1523f-2625">Sie müssen eine geöffnete Datei schließen, bevor Sie es umbenennen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2625">You must close an open file before renaming it.</span></span> <span data-ttu-id="1523f-2626">`Rename` Argumente können nicht mehrere Zeichen (\*) und Platzhalter für einzelne Zeichen (?) enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2626">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1523f-2627">Bei Verwendung `Rename` um eine Datei von einem nicht geschützten Speicherort auf einem geschützten Speicherort zu kopieren, behält die Datei weniger eingeschränkte Rechte.</span><span class="sxs-lookup"><span data-stu-id="1523f-2627">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="1523f-2628">Stellen Sie sicher, dass kein potenzielles Sicherheitsrisiko entstehen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2628">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2629">Dieses Beispiel verwendet die `Rename` Funktion, um eine Datei umzubenennen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2629">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="1523f-2630">Für die Zwecke dieses Beispiels wird davon ausgegangen Sie, dass die Verzeichnisse, die bereits angegeben sind vorhanden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2630">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-2631">Pfad ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2631">Path is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-2632">Die <paramref name="OldPath" />-Datei ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2632">
              <paramref name="OldPath" /> file does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2633">Kann nicht auf anderes Gerät umbenannt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2633">Cannot rename to different device.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2634">Schließt alle mit der <see langword="FileOpen" />-Funktion geöffneten Datenträgerdateien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2634">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2635">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Reset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2635">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span>
          </span>
          <span data-ttu-id="1523f-2636">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2636">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2637">Die `Reset` -Funktion schließt alle aktive Dateien geöffnet, indem die `FileOpen` Funktion, und hat die gleiche Funktion wie `FileClose()` ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="1523f-2637">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2638">Dieses Beispiel verwendet die `Reset` Funktion, um alle geöffneten Dateien geschlossen und der Inhalt der alle Puffer auf Datenträger geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2638">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="1523f-2639">Beachten Sie die Verwendung der `Object` Variable `FileNumber` als eine Zeichenfolge und eine Zahl.</span><span class="sxs-lookup"><span data-stu-id="1523f-2639">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="1523f-2640">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2640">Required.</span>
          </span>
          <span data-ttu-id="1523f-2641">
            <see langword="String" />-Ausdruck, der das zu entfernende Verzeichnis oder den zu entfernenden Ordner identifiziert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2641">
              <see langword="String" /> expression that identifies the directory or folder to be removed.</span>
          </span>
          <span data-ttu-id="1523f-2642">
            <c>Path</c> kann das Laufwerk enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2642">
              <c>Path</c> can include the drive.</span>
          </span>
          <span data-ttu-id="1523f-2643">Wenn kein Laufwerk angegeben wird, entfernt <see langword="RmDir" /> das Verzeichnis vom aktuellen Laufwerk.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2643">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2644">Entfernt ein vorhandenes Verzeichnis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2644">Removes an existing directory.</span>
          </span>
          <span data-ttu-id="1523f-2645">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="RmDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2645">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span>
          </span>
          <span data-ttu-id="1523f-2646">Weitere Informationen finden Sie unter <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2646">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2647">Ein Fehler auftritt, wenn Sie versuchen, `RmDir` in einem Verzeichnis, das Dateien enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2647">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="1523f-2648">Verwenden der `Kill` Funktion, um alle Dateien zu löschen, bevor Sie versuchen, ein Verzeichnis zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2648">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2649">Dieses Beispiel verwendet die `RmDir` Funktion, um ein vorhandenes Verzeichnis zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2649">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-2650">
            <paramref name="Path" /> ist nicht angegeben oder leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2650">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2651">Zielverzeichnis enthält Dateien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2651">Target directory contains files.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="1523f-2652">Verzeichnis ist nicht vorhanden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2652">Directory does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2653">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2653">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2654">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2654">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="1523f-2655">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2655">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2656">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2656">Required.</span>
          </span>
          <span data-ttu-id="1523f-2657">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2657">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2658">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2658">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2659">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="1523f-2660">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2661">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2661">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2662">`Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 zurück (entspricht 2 ^ 31-1), inklusive.</span><span class="sxs-lookup"><span data-stu-id="1523f-2662">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="1523f-2663">Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="1523f-2663">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="1523f-2664">Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-2664">Mode</span></span>|<span data-ttu-id="1523f-2665">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="1523f-2665">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="1523f-2666">Anzahl des nächsten Datensatzes gelesen bzw. geschrieben werden</span><span class="sxs-lookup"><span data-stu-id="1523f-2666">Number of the next record read or written</span></span>|  
|<span data-ttu-id="1523f-2667">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="1523f-2667">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="1523f-2668">Byte-Position, an dem der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2668">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2669">Das erste Byte in einer Datei ist an Position 1, das zweite Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-2669">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2670">Dieses Beispiel verwendet die `Seek` Funktion die aktuelle Dateiposition zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-2670">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="1523f-2671">Im Beispiel wird vorausgesetzt `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2671">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="1523f-2672">Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-2672">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="1523f-2673">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt zurück, die mit der der nächste Vorgang stattfindet, Byte-Position.</span><span class="sxs-lookup"><span data-stu-id="1523f-2673">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2674">Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2674">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="1523f-2675">Dieses Beispiel verwendet die `Seek` Funktion zum Festlegen der Position für den nächsten Lesevorgang oder in einer Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2675">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="1523f-2676">Anders als in den Modi geöffneten Dateien `Random` Modus `Seek` die Byte-Position, an dem der nächste Vorgang tritt auf, legt sie fest.</span><span class="sxs-lookup"><span data-stu-id="1523f-2676">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2677">Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2677">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2678">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2678">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2679">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2679">Required.</span>
          </span>
          <span data-ttu-id="1523f-2680">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2680">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <param name="Position">
          <span data-ttu-id="1523f-2681">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2681">Required.</span>
          </span>
          <span data-ttu-id="1523f-2682">Eine Zahl im Bereich 1-2.147.483.647 einschließlich, die angibt, wo die nächste Lese-/Schreiboperation erfolgen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2682">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2683">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2683">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2684">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2684">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="1523f-2685">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2685">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2686">`Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 zurück (entspricht 2 ^ 31-1), inklusive.</span><span class="sxs-lookup"><span data-stu-id="1523f-2686">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="1523f-2687">Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="1523f-2687">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="1523f-2688">Modus</span><span class="sxs-lookup"><span data-stu-id="1523f-2688">Mode</span></span>|<span data-ttu-id="1523f-2689">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="1523f-2689">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="1523f-2690">Anzahl des nächsten Datensatzes gelesen bzw. geschrieben werden</span><span class="sxs-lookup"><span data-stu-id="1523f-2690">Number of the next record read or written</span></span>|  
|<span data-ttu-id="1523f-2691">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="1523f-2691">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="1523f-2692">Byte-Position, an dem der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2692">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2693">Das erste Byte in einer Datei ist an Position 1, das zweite Byte an Position 2 und So weiter.</span><span class="sxs-lookup"><span data-stu-id="1523f-2693">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2694">Dieses Beispiel verwendet die `Seek` Funktion die aktuelle Dateiposition zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-2694">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="1523f-2695">Im Beispiel wird vorausgesetzt `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2695">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="1523f-2696">Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.</span><span class="sxs-lookup"><span data-stu-id="1523f-2696">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="1523f-2697">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt zurück, die mit der der nächste Vorgang stattfindet, Byte-Position.</span><span class="sxs-lookup"><span data-stu-id="1523f-2697">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2698">Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2698">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="1523f-2699">Dieses Beispiel verwendet die `Seek` Funktion zum Festlegen der Position für den nächsten Lesevorgang oder in einer Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2699">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="1523f-2700">Anders als in den Modi geöffneten Dateien `Random` Modus `Seek` die Byte-Position, an dem der nächste Vorgang tritt auf, legt sie fest.</span><span class="sxs-lookup"><span data-stu-id="1523f-2700">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="1523f-2701">Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.</span><span class="sxs-lookup"><span data-stu-id="1523f-2701">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2702">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2702">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="1523f-2703">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2703">Required.</span>
          </span>
          <span data-ttu-id="1523f-2704">Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2704">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="1523f-2705">
            <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2705">
              <c>PathName</c> can include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Attributes">
          <span data-ttu-id="1523f-2706">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2706">Required.</span>
          </span>
          <span data-ttu-id="1523f-2707">Konstanter oder numerischer Ausdruck, dessen Summe Dateiattribute angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2707">Constant or numeric expression, whose sum specifies file attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2708">Legt Attributinformationen für eine Datei fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2708">Sets attribute information for a file.</span>
          </span>
          <span data-ttu-id="1523f-2709">Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="SetAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2709">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span>
          </span>
          <span data-ttu-id="1523f-2710">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2710">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2711">Ein Laufzeitfehler tritt auf, wenn Sie versuchen, die die Attribute einer geöffneten Datei festzulegen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2711">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="1523f-2712">Die `Attributes` Argument Enumerationswerte lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="1523f-2712">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="1523f-2713">Wert</span><span class="sxs-lookup"><span data-stu-id="1523f-2713">Value</span></span>|<span data-ttu-id="1523f-2714">Konstante</span><span class="sxs-lookup"><span data-stu-id="1523f-2714">Constant</span></span>|<span data-ttu-id="1523f-2715">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="1523f-2715">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="1523f-2716">Normal (Standard).</span><span class="sxs-lookup"><span data-stu-id="1523f-2716">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="1523f-2717">Schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2717">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="1523f-2718">Ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2718">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="1523f-2719">Systemdatei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2719">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="1523f-2720">Volumebezeichnung</span><span class="sxs-lookup"><span data-stu-id="1523f-2720">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="1523f-2721">Verzeichnis oder Ordner.</span><span class="sxs-lookup"><span data-stu-id="1523f-2721">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="1523f-2722">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="1523f-2722">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="1523f-2723">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2723">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2724">Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2724">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="1523f-2725">Die Namen können eine beliebige Stelle im Code anstelle der tatsächlichen Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2725">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2726">Dieses Beispiel verwendet die `SetAttr` -Funktion zum Festlegen der Attribute einer Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2726">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1523f-2727">
            <paramref name="Attribute" />-Typ ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2727">
              <paramref name="Attribute" /> type is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">
          <span data-ttu-id="1523f-2728">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2728">Required.</span>
          </span>
          <span data-ttu-id="1523f-2729">Die Anzahl von Leerzeichen, die vor dem Anzeigen oder Ausgeben des nächsten Ausdrucks in einer Liste eingefügt werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2729">The number of spaces to insert before displaying or printing the next expression in a list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2730">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2730">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2731">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2731">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2732">Wenn `Count` ist kleiner als die Zeilenbreite der Ausgabe, die nächste Ausgabeposition sofort die Anzahl der ausgegebenen Leerzeichen folgt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2732">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="1523f-2733">Wenn`Count` ist größer als die Breite der Ausgabe, `SPC` die nächste Ausgabeposition unter Verwendung der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="1523f-2733">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="1523f-2734">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="1523f-2734">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="1523f-2735">Beispielsweise ist die aktuelle Ausgabeposition 24, Breite der Ausgabe ist 80, und geben Sie `SPC(90)`, die nächste Ausgabe beginnt an Position 34 (aktuelle Ausgabeposition + die restlichen 90/80).</span><span class="sxs-lookup"><span data-stu-id="1523f-2735">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="1523f-2736">Ist der Unterschied zwischen der aktuellen Ausgabeposition und der Breite der Ausgabe weniger als `Count` (oder `Count` `Mod` *Breite*), wird die `SPC` Funktion springt an den Anfang der nächsten Zeile und generiert Leerzeichen gleich `Count` – (*Breite* – *aktuelleAusgabeposition*).</span><span class="sxs-lookup"><span data-stu-id="1523f-2736">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2737">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2737">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2738">Dieses Beispiel verwendet die `SPC` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="1523f-2738">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2739">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2739">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2740">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2740">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2741">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2741">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2742">Wenn die aktuelle Ausgabeposition in der aktuellen Zeile größer als `Column`, `TAB` der Spaltenwert gleich ans `Column` in der nächsten Ausgabezeile.</span><span class="sxs-lookup"><span data-stu-id="1523f-2742">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="1523f-2743">Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Ausgabeposition in Spalte 1.</span><span class="sxs-lookup"><span data-stu-id="1523f-2743">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="1523f-2744">Wenn `Column` ist größer als die Breite der Ausgabe, `TAB` die nächste Ausgabeposition unter Verwendung der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="1523f-2744">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="1523f-2745">Mod Spaltenbreite</span><span class="sxs-lookup"><span data-stu-id="1523f-2745">Column Mod width</span></span>  
  
 <span data-ttu-id="1523f-2746">Z. B. wenn *Breite* ist 80, und geben Sie Sie `TAB(90)`, beginnt die nächste Ausgabe in der Spalte 10 (der Rest von 90/80).</span><span class="sxs-lookup"><span data-stu-id="1523f-2746">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="1523f-2747">Wenn `Column` ist kleiner als die aktuelle Ausgabeposition, beginnt die Ausgabe in der nächsten Zeile an die berechneten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2747">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="1523f-2748">Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an die berechnete Position in der gleichen Zeile an.</span><span class="sxs-lookup"><span data-stu-id="1523f-2748">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="1523f-2749">Die am weitesten links stehende Ausgabeposition in eine Ausgabezeile ist immer 1.</span><span class="sxs-lookup"><span data-stu-id="1523f-2749">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="1523f-2750">Bei Verwendung der `Print` oder `PrintLine` Funktionen in Dateien, die Ausgabeposition ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-2750">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="1523f-2751">Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-2751">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="1523f-2752">Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2752">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2753">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite der Buchstaben enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2753">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2754">Dieses Beispiel verwendet die `TAB` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="1523f-2754">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">
          <span data-ttu-id="1523f-2755">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2755">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2756">Die Spaltennummer, zu der vor dem Anzeigen oder Drucken des nächsten Ausdrucks in einer Liste gewechselt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2756">The column number moved to before displaying or printing the next expression in a list.</span>
          </span>
          <span data-ttu-id="1523f-2757">Wenn der Wert nicht angegeben wird, verschiebt <see langword="TAB" /> die Einfügemarke an den Anfang der nächsten Ausgabezone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2757">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2758">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2758">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1523f-2759">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2759">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2760">Wenn die aktuelle Ausgabeposition in der aktuellen Zeile überschreitet `Column`, `TAB` der Spaltenwert gleich ans `Column` in der nächsten Ausgabezeile.</span><span class="sxs-lookup"><span data-stu-id="1523f-2760">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="1523f-2761">Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Ausgabeposition in Spalte 1.</span><span class="sxs-lookup"><span data-stu-id="1523f-2761">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="1523f-2762">Wenn `Column` ist größer als die Breite der Ausgabe, `TAB` die nächste Ausgabeposition unter Verwendung der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="1523f-2762">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="1523f-2763">Mod Spaltenbreite</span><span class="sxs-lookup"><span data-stu-id="1523f-2763">Column Mod width</span></span>  
  
 <span data-ttu-id="1523f-2764">Z. B. wenn *Breite* ist 80, und geben Sie Sie `TAB(90)`, beginnt die nächste Ausgabe in der Spalte 10 (der Rest von 90/80).</span><span class="sxs-lookup"><span data-stu-id="1523f-2764">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="1523f-2765">Wenn `Column` ist kleiner als die aktuelle Ausgabeposition, beginnt die Ausgabe in der nächsten Zeile an die berechneten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2765">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="1523f-2766">Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an die berechnete Position in der gleichen Zeile.</span><span class="sxs-lookup"><span data-stu-id="1523f-2766">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="1523f-2767">Die am weitesten links stehende Ausgabeposition in eine Ausgabezeile ist immer 1.</span><span class="sxs-lookup"><span data-stu-id="1523f-2767">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="1523f-2768">Bei Verwendung der `Print` oder `PrintLine` Funktionen in Dateien, die Ausgabeposition ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-2768">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="1523f-2769">Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion.</span><span class="sxs-lookup"><span data-stu-id="1523f-2769">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="1523f-2770">Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2770">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1523f-2771">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite der Buchstaben enthalten.</span><span class="sxs-lookup"><span data-stu-id="1523f-2771">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2772">Dieses Beispiel verwendet die `TAB` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="1523f-2772">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1523f-2773">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2773">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2774">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2774">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2775">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2775">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2776">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2776">Required.</span>
          </span>
          <span data-ttu-id="1523f-2777">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2777">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2778">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2778">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2779">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2779">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2780">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2780">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2781">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2781">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2782">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2782">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2783">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2783">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2784">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2784">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2785">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2785">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2786">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2786">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2787">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2787">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2788">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2788">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2789">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2789">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2790">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2790">Required.</span>
          </span>
          <span data-ttu-id="1523f-2791">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2791">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="1523f-2792">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2792">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2793">Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2793">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2794">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2794">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2795">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2795">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2796">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2796">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2797">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2797">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2798">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2798">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2799">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2799">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2800">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2800">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2801">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2801">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2802">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2802">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2803">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2803">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2804">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2804">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2805">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2805">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2806">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2806">Required.</span>
          </span>
          <span data-ttu-id="1523f-2807">Eine beliebige gültige Dateinummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2807">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="1523f-2808">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2808">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2809">Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2809">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="1523f-2810">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2810">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2811">Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2811">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2812">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2812">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="1523f-2813">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2813">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="1523f-2814">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2814">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2815">Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2815">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="1523f-2816">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2816">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="1523f-2817">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2817">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="1523f-2818">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="1523f-2818">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="1523f-2819">Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2819">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="1523f-2820">Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2820">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2821">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="1523f-2821">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="1523f-2822">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2822">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2823">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2823">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2824">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2824">Required.</span>
          </span>
          <span data-ttu-id="1523f-2825">Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2825">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="1523f-2826">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2826">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2827">Ein oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2827">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2828">Schreibt Daten in eine sequenzielle Datei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2828">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="1523f-2829">Mit <see langword="Write" /> geschriebene Daten werden normalerweise mit <see langword="Input" /> aus einer Datei gelesen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2829">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2830">Die `Write` und `WriteLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="1523f-2830">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2831">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2831">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2832">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2832">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2833">Wenn Sie weglassen `Output`, eine leere Zeile wird in der Datei ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2833">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="1523f-2834">Mehrere Ausdrücke können durch ein Komma getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2834">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="1523f-2835">Im Gegensatz zu den `Print` -Funktion, die `Write` Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen an, wie sie in der Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2835">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="1523f-2836">Sie müssen keinen explizite Trennzeichen in der Liste anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2836">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="1523f-2837">Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Datum, Null, und `Error` Datenformate unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2837">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="1523f-2838">Die folgenden Annahmen für die universelle gefolgt sind, damit die Daten immer gelesen werden können und unter Verwendung ordnungsgemäß interpretiert `Input`, unabhängig vom Gebietsschema:</span><span class="sxs-lookup"><span data-stu-id="1523f-2838">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="1523f-2839">Numerische Daten werden immer geschrieben mit einem Punkt als Dezimaltrennzeichen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2839">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="1523f-2840">Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2840">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="1523f-2841">Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.</span><span class="sxs-lookup"><span data-stu-id="1523f-2841">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="1523f-2842">Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2842">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="1523f-2843">Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2843">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="1523f-2844">"Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="1523f-2844">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="1523f-2845">Allerdings für null-Daten `#NULL#` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2845">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="1523f-2846">Für `Error` Daten, die Ausgabe angezeigt, als `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2846">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="1523f-2847">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2847">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="1523f-2848">`WriteLine` Fügt ein Zeilenumbruchzeichen (d. h. ein Wagenrücklauf-/Zeilenvorschubzeichen, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2848">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="1523f-2849">Sie können Anführungszeichen in einer Zeichenfolge mit doppelten Anführungszeichen einbetten oder "".</span><span class="sxs-lookup"><span data-stu-id="1523f-2849">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="1523f-2850">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="1523f-2850">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="1523f-2851">Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2851">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="1523f-2852">Schreiben in eine Datei mit den `Write` oder `WriteLine` Functions erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2852">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2853">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2853">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2854">Dieses Beispiel verwendet die `Write` Funktion zum Schreiben von Rohdaten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2854">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="1523f-2855">Dateimodus ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2855">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="1523f-2856">Erforderlich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2856">Required.</span>
          </span>
          <span data-ttu-id="1523f-2857">Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2857">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="1523f-2858">Dies ist optional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2858">Optional.</span>
          </span>
          <span data-ttu-id="1523f-2859">Ein oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2859">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1523f-2860">Schreibt Daten in eine sequenzielle Datei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2860">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="1523f-2861">Mit <see langword="Write" /> geschriebene Daten werden normalerweise mit <see langword="Input" /> aus einer Datei gelesen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1523f-2861">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1523f-2862">Die `Write` und `WriteLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="1523f-2862">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="1523f-2863">Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="1523f-2863">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="1523f-2864">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="1523f-2864">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="1523f-2865">Wenn Sie weglassen `Output`, eine leere Zeile wird in der Datei ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2865">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="1523f-2866">Mehrere Ausdrücke können durch ein Komma getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2866">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="1523f-2867">Im Gegensatz zu den `Print` -Funktion, die `Write` Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen an, wie sie in der Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2867">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="1523f-2868">Sie müssen keinen explizite Trennzeichen in der Liste anzugeben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2868">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="1523f-2869">Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Datum, Null, und `Error` Datenformate unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1523f-2869">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="1523f-2870">Die folgenden Annahmen für die universelle gefolgt sind, damit die Daten immer gelesen werden können und unter Verwendung ordnungsgemäß interpretiert `Input`, unabhängig vom Gebietsschema:</span><span class="sxs-lookup"><span data-stu-id="1523f-2870">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="1523f-2871">Numerische Daten werden immer geschrieben mit einem Punkt als Dezimaltrennzeichen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1523f-2871">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="1523f-2872">Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2872">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="1523f-2873">Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.</span><span class="sxs-lookup"><span data-stu-id="1523f-2873">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="1523f-2874">Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2874">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="1523f-2875">Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="1523f-2875">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="1523f-2876">"Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="1523f-2876">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="1523f-2877">Allerdings für null-Daten `#NULL#` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1523f-2877">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="1523f-2878">Für `Error` Daten, die Ausgabe angezeigt, als `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2878">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="1523f-2879">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="1523f-2879">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="1523f-2880">`WriteLine` Fügt ein Zeilenumbruchzeichen (d. h. ein Wagenrücklauf-/Zeilenvorschubzeichen, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2880">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="1523f-2881">Sie können Anführungszeichen in einer Zeichenfolge mit doppelten Anführungszeichen einbetten oder "".</span><span class="sxs-lookup"><span data-stu-id="1523f-2881">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="1523f-2882">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="1523f-2882">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="1523f-2883">Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="1523f-2883">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="1523f-2884">Schreiben in eine Datei mit den `Write` oder `WriteLine` Functions erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="1523f-2884">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="1523f-2885">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="1523f-2885">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1523f-2886">Dieses Beispiel verwendet die `Write` Funktion zum Schreiben von Rohdaten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="1523f-2886">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>