<Type Name="Strings" FullName="Microsoft.VisualBasic.Strings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6361446cafc845128ade79a48c96b5dd23d7ad38" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48620404" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Strings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Strings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Strings" />
  <TypeSignature Language="VB.NET" Value="Public Module Strings" />
  <TypeSignature Language="C++ CLI" Value="public ref class Strings sealed" />
  <TypeSignature Language="F#" Value="type Strings = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Das <see langword="Strings" />-Modul enthält Prozeduren, mit denen Zeichenfolgenoperationen ausgeführt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Schlüsselwörter von Visual Basic und die Laufzeitbibliothek-Member, die Zeichenfolgen bearbeiten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zum Aufteilen einer Zeichenfolge an ihren Leerzeichen wird.  
  
 [!code-vb[VbVbalrStrings#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#13)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Schlüsselwörter (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Asc">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Asc">
      <MemberSignature Language="C#" Value="public static int Asc (char String);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Asc(char String) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Asc(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asc (String As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Asc(char String);" />
      <MemberSignature Language="F#" Value="static member Asc : char -&gt; int" Usage="Microsoft.VisualBasic.Strings.Asc String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="String">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke oder <see langword="String" />-Ausdrücke. Wenn <c>String</c> ein <see langword="String" />-Ausdruck ist, wird nur das erste Zeichen der Zeichenfolge als Eingabe verwendet. Wenn <c>String</c><see langword="Nothing" /> ist oder keine Zeichen enthält, tritt ein <see cref="T:System.ArgumentException" />-Fehler auf.</param>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
        <returns>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Asc` Gibt die *Codepunkt*, oder Zeichencode für das eingegebene Zeichen. Dies kann auf 0 und 255 für Einzelbyte-Satz (SBCS) Werte und zwischen-32768 und 32767 für Doppelbyte-Zeichensatz (DBCS)-Satz Werte sein.  
  
 `AscW` Gibt den Unicode-Codepunkt für das eingegebene Zeichen zurück. Dies kann 0 bis 65535 sein. Der zurückgegebene Wert ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread.  
  
> [!NOTE]
>  Die `AscB` Funktion früherer Versionen von Visual Basic einen Code für ein Byte, anstatt ein Zeichen zurückgegeben. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `AscB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Asc` Funktion zurückzugebende `Integer` Zeichen des Codes, den ersten Buchstaben in jeder Zeichenfolge entspricht.  
  
 [!code-vb[VbVbalrFunctions#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="N:System.Globalization" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.TextInfo.ANSICodePage" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/index.md">Funktionen (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Asc">
      <MemberSignature Language="C#" Value="public static int Asc (string String);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Asc(string String) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Asc(System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Asc(System::String ^ String);" />
      <MemberSignature Language="F#" Value="static member Asc : string -&gt; int" Usage="Microsoft.VisualBasic.Strings.Asc String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="String">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke oder <see langword="String" />-Ausdrücke. Wenn <c>String</c> ein <see langword="String" />-Ausdruck ist, wird nur das erste Zeichen der Zeichenfolge als Eingabe verwendet. Wenn <c>String</c><see langword="Nothing" /> ist oder keine Zeichen enthält, tritt ein <see cref="T:System.ArgumentException" />-Fehler auf.</param>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
        <returns>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Asc` Gibt die *Codepunkt*, oder Zeichencode für das eingegebene Zeichen. Dies kann auf 0 und 255 für Einzelbyte-Satz (SBCS) Werte und zwischen-32768 und 32767 für Doppelbyte-Zeichensatz (DBCS)-Satz Werte sein.  
  
 `AscW` Gibt den Unicode-Codepunkt für das eingegebene Zeichen zurück. Dies kann 0 bis 65535 sein. Der zurückgegebene Wert ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread.  
  
> [!NOTE]
>  Die `AscB` Funktion früherer Versionen von Visual Basic einen Code für ein Byte, anstatt ein Zeichen zurückgegeben. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `AscB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Asc` Funktion zurückzugebende `Integer` Zeichen des Codes, den ersten Buchstaben in jeder Zeichenfolge entspricht.  
  
 [!code-vb[VbVbalrFunctions#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="N:System.Globalization" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.TextInfo.ANSICodePage" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/index.md">Funktionen (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AscW">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AscW">
      <MemberSignature Language="C#" Value="public static int AscW (char String);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 AscW(char String) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.AscW(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function AscW (String As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AscW(char String);" />
      <MemberSignature Language="F#" Value="static member AscW : char -&gt; int" Usage="Microsoft.VisualBasic.Strings.AscW String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="String">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke oder <see langword="String" />-Ausdrücke. Wenn <c>String</c> ein <see langword="String" />-Ausdruck ist, wird nur das erste Zeichen der Zeichenfolge als Eingabe verwendet. Wenn <c>String</c><see langword="Nothing" /> ist oder keine Zeichen enthält, tritt ein <see cref="T:System.ArgumentException" />-Fehler auf.</param>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
        <returns>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Asc` Gibt die *Codepunkt*, oder Zeichencode für das eingegebene Zeichen. Dies kann auf 0 und 255 für Einzelbyte-Satz (SBCS) Werte und zwischen-32768 und 32767 für Doppelbyte-Zeichensatz (DBCS)-Satz Werte sein.  
  
 `AscW` Gibt den Unicode-Codepunkt für das eingegebene Zeichen zurück. Dies kann 0 bis 65535 sein. Der zurückgegebene Wert ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread.  
  
> [!NOTE]
>  Die `AscB` Funktion früherer Versionen von Visual Basic einen Code für ein Byte, anstatt ein Zeichen zurückgegeben. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `AscB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Asc` Funktion zurückzugebende `Integer` Zeichen des Codes, den ersten Buchstaben in jeder Zeichenfolge entspricht.  
  
 [!code-vb[VbVbalrFunctions#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="N:System.Globalization" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.TextInfo.ANSICodePage" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/index.md">Funktionen (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="AscW">
      <MemberSignature Language="C#" Value="public static int AscW (string String);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 AscW(string String) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.AscW(System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AscW(System::String ^ String);" />
      <MemberSignature Language="F#" Value="static member AscW : string -&gt; int" Usage="Microsoft.VisualBasic.Strings.AscW String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="String">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke oder <see langword="String" />-Ausdrücke. Wenn <c>String</c> ein <see langword="String" />-Ausdruck ist, wird nur das erste Zeichen der Zeichenfolge als Eingabe verwendet. Wenn <c>String</c><see langword="Nothing" /> ist oder keine Zeichen enthält, tritt ein <see cref="T:System.ArgumentException" />-Fehler auf.</param>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</summary>
        <returns>Gibt einen <see langword="Integer" />-Wert zurück, der den Zeichencode darstellt, der einem Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Asc` Gibt die *Codepunkt*, oder Zeichencode für das eingegebene Zeichen. Dies kann auf 0 und 255 für Einzelbyte-Satz (SBCS) Werte und zwischen-32768 und 32767 für Doppelbyte-Zeichensatz (DBCS)-Satz Werte sein.  
  
 `AscW` Gibt den Unicode-Codepunkt für das eingegebene Zeichen zurück. Dies kann 0 bis 65535 sein. Der zurückgegebene Wert ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread.  
  
> [!NOTE]
>  Die `AscB` Funktion früherer Versionen von Visual Basic einen Code für ein Byte, anstatt ein Zeichen zurückgegeben. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `AscB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Asc` Funktion zurückzugebende `Integer` Zeichen des Codes, den ersten Buchstaben in jeder Zeichenfolge entspricht.  
  
 [!code-vb[VbVbalrFunctions#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="N:System.Globalization" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.TextInfo.ANSICodePage" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/index.md">Funktionen (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Chr">
      <MemberSignature Language="C#" Value="public static char Chr (int CharCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static char Chr(int32 CharCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Chr (CharCode As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Chr(int CharCode);" />
      <MemberSignature Language="F#" Value="static member Chr : int -&gt; char" Usage="Microsoft.VisualBasic.Strings.Chr CharCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CharCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="CharCode">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der den <c>Codepunkt</c> oder Zeichencode für das Zeichen darstellt.</param>
        <summary>Gibt das dem angegebenen Zeichencode zugeordnete Zeichen zurück.</summary>
        <returns>Gibt das dem angegebenen Zeichencode zugeordnete Zeichen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Akzeptierte asymmetrische Bereich für `CharCode` führt einen Ausgleich für die Speicherunterschiede zwischen der `Short` und `Integer`. Z. B.-29183 eine `Short` 36353 ist jedoch ein `Integer`. Dies erleichtert auch die Kompatibilität mit Visual Basic 6.0.  
  
 `Chr` verwendet die <xref:System.Text.Encoding> -Klasse in der <xref:System.Text?displayProperty=nameWithType> Namespace, um zu bestimmen, ob der aktuelle Thread eine Einzelbyte-Zeichensatz (SBCS) oder Double-Byte-Zeichen festgelegt (DBCS). Klicken Sie dann dauert `CharCode` als Code zu zeigen, in dem entsprechenden Satz. Der Bereich kann zwischen 0 und 255 für SBCS-Zeichen und zwischen-32768 und 65535 für DBCS-Zeichen sein.  
  
 Der zurückgegebene Wert hängt von der Codepage für den aktuellen Thread, der in enthalten ist das <xref:System.Globalization.TextInfo.ANSICodePage%2A> Eigenschaft der <xref:System.Globalization.TextInfo> -Klasse in der <xref:System.Globalization> Namespace. Sie erhalten <xref:System.Globalization.TextInfo.ANSICodePage%2A> durch Angabe `System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage`.  
  
 `ChrW` nimmt `CharCode` als Unicode-Codepunkt. Der Bereich ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread. Werte zwischen-32768 und-1 werden behandelt als Werte in den Bereich + 32768 und + 65535.  
  
 Zahlen von 0 bis 31 entsprechen den standardmäßigen druckbaren ASCII-Codes. Z. B. `Chr(10)` gibt ein Zeilenvorschubzeichen.  
  
> [!NOTE]
>  Die `ChrB` -Funktion in früheren Versionen von Visual Basic gibt ein einzelnes Byte zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Zeichenfolgen in Visual Basic und .NET Framework werden in Unicode und `ChrB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Chr` Funktion, um das dem angegebenen Zeichencode zugeordnete Zeichen zurück.  
  
 [!code-vb[VbVbalrStrings#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCode" /> &lt; 0 oder &gt; 255 für <see langword="Chr" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Asc" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.AscW" />
        <altmember cref="M:Microsoft.VisualBasic.Conversion.Str(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="ChrW">
      <MemberSignature Language="C#" Value="public static char ChrW (int CharCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static char ChrW(int32 CharCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ChrW (CharCode As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ChrW(int CharCode);" />
      <MemberSignature Language="F#" Value="static member ChrW : int -&gt; char" Usage="Microsoft.VisualBasic.Strings.ChrW CharCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CharCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="CharCode">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der den <c>Codepunkt</c> oder Zeichencode für das Zeichen darstellt.</param>
        <summary>Gibt das dem angegebenen Zeichencode zugeordnete Zeichen zurück.</summary>
        <returns>Gibt das dem angegebenen Zeichencode zugeordnete Zeichen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Akzeptierte asymmetrische Bereich für `CharCode` führt einen Ausgleich für die Speicherunterschiede zwischen der `Short` und `Integer`. Z. B.-29183 eine `Short` 36353 ist jedoch ein `Integer`. Dies erleichtert auch die Kompatibilität mit Visual Basic 6.0.  
  
 `Chr` verwendet die <xref:System.Text.Encoding> -Klasse in der <xref:System.Text?displayProperty=nameWithType> Namespace, um zu bestimmen, ob der aktuelle Thread eine Einzelbyte-Zeichensatz (SBCS) oder Double-Byte-Zeichen festgelegt (DBCS). Klicken Sie dann dauert `CharCode` als Code zu zeigen, in dem entsprechenden Satz. Der Bereich kann zwischen 0 und 255 für SBCS-Zeichen und zwischen-32768 und 65535 für DBCS-Zeichen sein.  
  
 Der zurückgegebene Wert hängt von der Codepage für den aktuellen Thread, der in enthalten ist das <xref:System.Globalization.TextInfo.ANSICodePage%2A> Eigenschaft der <xref:System.Globalization.TextInfo> -Klasse in der <xref:System.Globalization> Namespace. Sie erhalten <xref:System.Globalization.TextInfo.ANSICodePage%2A> durch Angabe `System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage`.  
  
 `ChrW` nimmt `CharCode` als Unicode-Codepunkt. Der Bereich ist unabhängig von der Kultur und der Code die seiteneinstellungen für den aktuellen Thread. Werte zwischen-32768 und-1 werden behandelt als Werte in den Bereich + 32768 und + 65535.  
  
 Zahlen von 0 bis 31 entsprechen den standardmäßigen druckbaren ASCII-Codes. Z. B. `Chr(10)` gibt ein Zeilenvorschubzeichen.  
  
> [!NOTE]
>  Die `ChrB` -Funktion in früheren Versionen von Visual Basic gibt ein einzelnes Byte zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Zeichenfolgen in Visual Basic und .NET Framework werden in Unicode und `ChrB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Chr` Funktion, um das dem angegebenen Zeichencode zugeordnete Zeichen zurück.  
  
 [!code-vb[VbVbalrStrings#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCode" /> &lt; – 32768 oder &gt; 65535 für <see langword="ChrW" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Asc" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.AscW" />
        <altmember cref="M:Microsoft.VisualBasic.Conversion.Str(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Filter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein nullbasiertes Array zurück, das einen Teilbereich eines <see langword="String" />-Arrays auf der Basis angegebener Filterkriterien enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static string[] Filter (object[] Source, string Match, bool Include = true, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[] Filter(object[] Source, string Match, bool Include, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Filter(System.Object[],System.String,System.Boolean,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function Filter (Source As Object(), Match As String, Optional Include As Boolean = true, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As String()" />
      <MemberSignature Language="F#" Value="static member Filter : obj[] * string * bool * Microsoft.VisualBasic.CompareMethod -&gt; string[]" Usage="Microsoft.VisualBasic.Strings.Filter (Source, Match, Include, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.Object[]" />
        <Parameter Name="Match" Type="System.String" />
        <Parameter Name="Include" Type="System.Boolean" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. Eindimensionales Zeichenfolgenarray, das durchsucht werden soll.</param>
        <param name="Match">Erforderlich. Die zu suchende Zeichenfolge.</param>
        <param name="Include">Dies ist optional. Ein <see langword="Boolean" />-Wert, der angibt, ob untergeordnete Zeichenfolgen zurückgegeben werden sollen, die <c>Match</c> einschließen oder ausschließen. Wenn <c>Include</c><see langword="True" />ist, gibt die <see langword="Filter" />-Funktion die Teilmenge des Arrays zurück, die <c>Match</c> als eine untergeordnete Zeichenfolge enthält. Wenn <c>Include</c><see langword="False" />ist, gibt die <see langword="Filter" />-Funktion die Teilmenge des Arrays zurück, die <c>Match</c> nicht als untergeordnete Zeichenfolge enthält.</param>
        <param name="Compare">Dies ist optional. Numerischer Wert, der die Art des zu verwendenden Zeichenfolgenvergleichs angibt. Die Werte finden Sie unter „Einstellungen“.</param>
        <summary>Gibt ein nullbasiertes Array zurück, das einen Teilbereich eines <see langword="String" />-Arrays auf der Basis angegebener Filterkriterien enthält.</summary>
        <returns>Gibt ein nullbasiertes Array zurück, das einen Teilbereich eines <see langword="String" />-Arrays auf der Basis angegebener Filterkriterien enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Übereinstimmungen von `Match` befinden `Source`, `Filter` Funktion ein leeres Array zurück. Ein Fehler tritt auf, wenn `Source` nastaven NA hodnotu `Nothing` oder ist kein eindimensionales Array.  
  
 Das zurückgegebene Array die `Filter` -Funktion enthält nur genügend Elemente, um die Anzahl der übereinstimmenden Elemente enthalten.  
  
 Die `Compare` Argument kann die folgenden Werte haben.  
  
|Konstante|Beschreibung |  
|-|-|  
|Konstante|Beschreibung |  
|`CompareMethod.Binary`|Führt einen binären Vergleich|  
|`CompareMethod.Text`|Führt einen Textvergleich|  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `Filter` Funktion.  
  
 [!code-vb[VbVbalrStrings#24](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> ist <see langword="Nothing" /> oder kein eindimensionales Array.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Replace(System.String,System.String,System.String,System.Int32,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static string[] Filter (string[] Source, string Match, bool Include = true, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[] Filter(string[] Source, string Match, bool Include, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Filter(System.String[],System.String,System.Boolean,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function Filter (Source As String(), Match As String, Optional Include As Boolean = true, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As String()" />
      <MemberSignature Language="F#" Value="static member Filter : string[] * string * bool * Microsoft.VisualBasic.CompareMethod -&gt; string[]" Usage="Microsoft.VisualBasic.Strings.Filter (Source, Match, Include, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String[]" />
        <Parameter Name="Match" Type="System.String" />
        <Parameter Name="Include" Type="System.Boolean" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. Eindimensionales Zeichenfolgenarray, das durchsucht werden soll.</param>
        <param name="Match">Erforderlich. Die zu suchende Zeichenfolge.</param>
        <param name="Include">Dies ist optional. Ein <see langword="Boolean" />-Wert, der angibt, ob untergeordnete Zeichenfolgen zurückgegeben werden sollen, die <c>Match</c> einschließen oder ausschließen. Wenn <c>Include</c><see langword="True" />ist, gibt die <see langword="Filter" />-Funktion die Teilmenge des Arrays zurück, die <c>Match</c> als eine untergeordnete Zeichenfolge enthält. Wenn <c>Include</c><see langword="False" />ist, gibt die <see langword="Filter" />-Funktion die Teilmenge des Arrays zurück, die <c>Match</c> nicht als untergeordnete Zeichenfolge enthält.</param>
        <param name="Compare">Dies ist optional. Numerischer Wert, der die Art des zu verwendenden Zeichenfolgenvergleichs angibt. Die Werte finden Sie unter „Einstellungen“.</param>
        <summary>Gibt ein nullbasiertes Array zurück, das einen Teilbereich eines <see langword="String" />-Arrays auf der Basis angegebener Filterkriterien enthält.</summary>
        <returns>Gibt ein nullbasiertes Array zurück, das einen Teilbereich eines <see langword="String" />-Arrays auf der Basis angegebener Filterkriterien enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Übereinstimmungen von `Match` befinden `Source`, `Filter` Funktion ein leeres Array zurück. Ein Fehler tritt auf, wenn `Source` nastaven NA hodnotu `Nothing` oder ist kein eindimensionales Array.  
  
 Das zurückgegebene Array die `Filter` -Funktion enthält nur genügend Elemente, um die Anzahl der übereinstimmenden Elemente enthalten.  
  
 Die `Compare` Argument kann die folgenden Werte haben.  
  
|Konstante|Beschreibung |  
|-|-|  
|`CompareMethod.Binary`|Führt einen binären Vergleich|  
|`CompareMethod.Text`|Führt einen Textvergleich|  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `Filter` Funktion.  
  
 [!code-vb[VbVbalrStrings#24](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> ist <see langword="Nothing" /> oder kein eindimensionales Array.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Replace(System.String,System.String,System.String,System.Int32,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (object Expression, string Style = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Format(object Expression, string Style) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Format(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Format (Expression As Object, Optional Style As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member Format : obj * string -&gt; string" Usage="Microsoft.VisualBasic.Strings.Format (Expression, Style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Object" />
        <Parameter Name="Style" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Jeder gültige Ausdruck.</param>
        <param name="Style">Dies ist optional. Ein gültiger benannter oder benutzerdefinierter Format-<see langword="String" />-Ausdruck.</param>
        <summary>Gibt eine Zeichenfolge zurück, die entsprechend den Anweisungen in einem <see langword="String" />-Formatausdruck formatiert ist.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die entsprechend den Anweisungen in einem <see langword="String" />-Formatausdruck formatiert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Format%2A?displayProperty=nameWithType> Methode verfügt auch über ähnliche Funktionen.  
  
 Wenn Sie eine nicht lokalisierte numerische Zeichenfolge formatieren, sollten Sie ein benutzerdefiniertes numerisches Format verwenden, um sicherzustellen, dass Sie das Ergebnis erhalten Sie die gewünschten.  
  
 Wenn Sie versuchen, formatieren Sie eine Zahl ohne `Style`, `Format` -Funktion bietet ähnliche Funktionen wie die `Str` -Funktion an, obwohl es das Gebietsschema berücksichtigt wird. Positive Zahlen jedoch formatiert, als Zeichenfolgen, die mit der `Format` Funktion nicht mit ein führendes Leerzeichen zur Angabe des Vorzeichens des Werts einschließen, die mit konvertiert die `Str` Funktion behalten das führende Leerzeichen.  
  
## <a name="different-formats-for-different-numeric-values"></a>Verschiedene Formate für verschiedene numerische Werte  
 Ein benutzerdefinierte Formatausdruck für Zahlen kann ein bis drei durch Semikolons getrennte Abschnitte haben. Wenn die `Style` Argument der `Format` Funktion enthält mindestens einen der vordefinierten numerischen Formate, die nur ein Abschnitt zulässig ist.  
  
|Bei Verwendung von|Dies ist das Ergebnis|  
|-|-|  
|Nur ein Abschnitt|Der Formatausdruck gilt für alle Werte.|  
|Zwei Abschnitte|Der erste Abschnitt gilt für positive Werte und Nullen; die zweite gilt für negative Werte.|  
|Drei Abschnitte|Der erste Abschnitt gilt für positive Werte, die zweite gilt für negative Werte und die dritte gilt für Nullen.|  
  
 Im folgende Beispiel besteht aus zwei Abschnitten: der erste definiert das Format für positive Werte und Nullen; der zweite Abschnitt definiert das Format für negative Werte. Da die `Style` Argument der `Format` Funktion akzeptiert eine Zeichenfolge, die von Anführungszeichen eingeschlossen ist.  
  
 [!code-vb[VbVbalrStrings#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#18)]  
  
 Wenn Sie zwei Semikolons ohne etwas dazwischen einfügen, wird der fehlende Abschnitt mit dem Format des positiven Werts ausgegeben. Beispielsweise das folgende Format zeigt positive und Negative Werte mit dem Format im ersten Abschnitt und zeigt `Zero` , wenn der Wert 0 (null) ist.  
  
 [!code-vb[VbVbalrStrings#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#19)]  
  
## <a name="predefined-numeric-formats"></a>Vordefinierte numerische Formate  
 Der folgenden Tabelle sind die Namen vordefinierter numerischer Formate. Diese können verwendet werden, mit Namen wie die `Style` Argument für die `Format` Funktion:  
  
|Formatname|Beschreibung |  
|-|-|  
|`General Number`, `G`oder `g`|Zeigt eine Zahl ohne Tausendertrennzeichen an.<br /><br /> Z. B. `Format(&H3FA, "g")` gibt `1018`.|  
|`Currency`, `C`oder `c`|Zeigt eine Zahl ggf. mit Tausendertrennzeichen an; zeigt zwei Ziffern rechts vom Dezimaltrennzeichen an. Ausgabe basiert auf vom verwendeten Systemgebietsschema ab.<br /><br /> Z. B. `Format(1234567, "c")` gibt `$1,234,567.00`.|  
|`Fixed`, `F`oder `f`|Zeigt mindestens eine Ziffer links sowie zwei Ziffern rechts vom Dezimaltrennzeichen an.<br /><br /> Z. B. `Format(1234567, "f")` gibt `1234567.00`.|  
|`Standard`, `N`oder `n`|Zeigt die Zahl mit Tausendertrennzeichen und mindestens eine Ziffer links sowie zwei Ziffern rechts vom Dezimaltrennzeichen an.<br /><br /> Z. B. `Format(1234567, "n")` gibt `1,234,567.00`.|  
|`Percent`|Zeigt die Zahl, die multipliziert mit 100 mit einem Prozentzeichen (%) auf der rechten Seite angefügt, zeigt immer zwei Ziffern rechts vom Dezimaltrennzeichen.<br /><br /> Z. B. `Format(0.4744, "Percent")` gibt `47.44%`.|  
|`P`, oder `p`|Zeigt eine Zahl mit Tausendertrennzeichen multipliziert mit 100 mit einem Prozentzeichen (%), die die richtigen und getrennt durch ein Leerzeichen hinzugefügt; zeigt immer zwei Ziffern rechts vom Dezimaltrennzeichen.<br /><br /> Z. B. `Format(0.80345, "p")` gibt `80.35 %`.|  
|`Scientific`|Verwendet standardmäßige wissenschaftliche Schreibweise und stellt zwei signifikante Stellen bereit.<br /><br /> Z. B. `Format(1234567, "Scientific")` gibt `1.23E+06`.|  
|`E`, oder `e`|Verwendet standardmäßige wissenschaftliche Schreibweise und stellt sechs signifikante Stellen bereit.<br /><br /> Z. B. `Format(1234567, "e")` gibt `1.234567e+006`.|  
|`D`, oder `d`|Zeigt eine Zahl als eine Zeichenfolge, die den Wert der Zahl in dezimale (Basis 10)-Format enthält. Diese Option wird für ganzzahlige Typen unterstützt (`Byte`, `Short`, `Integer`, `Long`) nur.<br /><br /> Z. B. `Format(&H7F, "d")` gibt `127`.|  
|`X`, oder `x`|Zeigt eine Zahl als eine Zeichenfolge, die den Wert der Zahl im Hexadezimalformat (Basis 16) enthält. Diese Option wird für ganzzahlige Typen unterstützt (`Byte`, `Short`, `Integer`, `Long`) nur.<br /><br /> Z. B. `Format(127, "x")` gibt `7f`.|  
|`Yes/No`|Zeigt `No` Wenn Zahl, andernfalls 0 ist, zeigt `Yes`.<br /><br /> Z. B. `Format(0, "Yes/No")` gibt `No`.|  
|`True/False`|Zeigt `False` Wenn Zahl, andernfalls 0 ist, zeigt `True`.<br /><br /> Z. B. `Format(1, "True/False")` gibt `True`.|  
|`On/Off`|Zeigt `Off` Wenn Zahl, andernfalls 0 ist, zeigt `On`.<br /><br /> Z. B. `Format(1, "On/Off")` gibt `On`.|  
  
### <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Yes/No`, `True/False`, und `On/Off` Formate werden nicht unterstützt.  
  
## <a name="user-defined-numeric-formats"></a>Benutzerdefinierte numerische Formate  
 Der folgenden Tabelle sind die Zeichen, die Sie verwenden können, um eine benutzerdefinierte Zahlenformate erstellen. Diese können verwendet werden, zum Erstellen der `Style` Argument für die `Format` Funktion:  
  
|Zeichen|Beschreibung |  
|-|-|  
|Keiner|Zeigt die Zahl ohne Formatierung an.|  
|(`0`)|Ziffernplatzhalter. Zeigt eine Ziffer oder eine 0 (null). Wenn der Ausdruck eine Ziffer an der Position verfügt, an der 0 (null) in der Formatzeichenfolge angezeigt wird, angezeigt. andernfalls zeigt an dieser Position eine NULL an.<br /><br /> Hat die Zahl sind weniger Ziffern als Nullen (auf beiden Seiten des Dezimaltrennzeichens), in der Formatzeichenfolge, zeigt führende oder nachfolgende Nullen. Hat die Zahl mehr Stellen rechts vom Dezimaltrennzeichen als stehen Nullen auf der rechten Seite des Dezimaltrennzeichens im Formatausdruck rundet die Zahl auf so viele Dezimalstellen wie Nullen vorhanden sind. Hat die Zahl mehr Stellen links vom Dezimaltrennzeichen als stehen Nullen auf der linken Seite des Dezimaltrennzeichens im Formatausdruck, zeigt die zusätzlichen Ziffern unverändert.|  
|(`#`)|Ziffernplatzhalter. Zeigt eine Ziffer oder nichts an. Wenn der Ausdruck eine Ziffer aufweist, in denen die `#` Zeichen wird in der Formatzeichenfolge angezeigt wird; andernfalls zeigt nichts an dieser Position.<br /><br /> Dieses Symbol funktioniert wie die `0` Ziffernplatzhalter, mit der Ausnahme, die führenden und nachfolgenden Nullen angezeigt werden, hat die Zahl weniger Ziffern stehen `#` Zeichen auf beiden Seiten des Dezimaltrennzeichens im Formatausdruck.|  
|(`.`)|Dezimalplatzhalter. Der dezimalplatzhalter legt fest, wie viele Ziffern links und rechts vom Dezimaltrennzeichen angezeigt werden. Wenn der Formatausdruck nur enthält `#` Zeichen links von diesem Symbol, Zahlen, die kleiner als 1 mit dem Dezimaltrennzeichen beginnen. Verwenden Sie zum Anzeigen einer führenden Null angezeigt werden, sollen Bruchzahlen mit 0 (null) als ersten Ziffernplatzhalter links vom Dezimaltrennzeichen an. In manchen Gebietsschemas wird ein Komma als Dezimaltrennzeichen verwendet. Welches Zeichen tatsächliche als Dezimaltrennzeichen in der formatierten Ausgabe verwendet, hängt von dem Zahlenformat vom System erkannt ab. Daher sollten Sie den Zeitraum als dezimalplatzalter in den Formaten verwenden, auch wenn Sie in einem Gebietsschema arbeiten, die ein Komma als Dezimaltrennzeichen verwendet. Die formatierte Zeichenfolge wird im richtigen Format für das Gebietsschema angezeigt.|  
|(`%`)|Prozentplatzhalter. Den Ausdruck multipliziert mit 100. Das Prozentzeichen (`%`) eingefügt wird, an der Position, wo sie in der Formatzeichenfolge angezeigt wird.|  
|(`,`)|Tausendertrennzeichen an. Das Tausendertrennzeichen trennt Tausender von den Hundertern in eine Zahl mit vier oder mehr Stellen links vom Dezimaltrennzeichen an. Standardmäßige Verwendung des Tausendertrennzeichens wird angegeben, wenn das Format ein Tausendertrennzeichen Ziffernplatzhaltern umgeben enthält (`0` oder `#`).<br /><br /> Ein Tausendertrennzeichen direkt links vom Dezimaltrennzeichen (unabhängig davon, ob ein Dezimaltrennzeichen angegeben ist) oder der äußersten rechten Zeichen in der Zeichenfolge bedeutet "Skalieren die Zahl durch Division durch 1000, gegebenenfalls mit Rundung". Zahlen, die kleiner als 1.000 jedoch größer oder gleich 500 werden angezeigt, als `1`, und Zahlen, die kleiner als 500, als angezeigt werden `0`. Zwei benachbarte Tausendertrennzeichen an dieser Position skalieren, indem Sie einen Faktor von 1 Million sowie einem zusätzlichen Faktor von 1000 für jedes zusätzliche Trennzeichen.<br /><br /> Mehrere Trennzeichen in jeder anderen Position als direkt links vom Dezimaltrennzeichen oder ganz rechts in der Zeichenfolge werden behandelt, als würden Sie die Verwendung eines Tausendertrennzeichens angeben. In manchen Gebietsschemas wird der Punkt als Tausendertrennzeichen verwendet. Welches Zeichen tatsächliche als Tausendertrennzeichen in der formatierten Ausgabe verwendet, hängt von der Zahlenformat, die vom System erkannt wird. Daher sollten Sie das Komma als Tausendertrennzeichen in den Formaten verwenden, auch wenn Sie in einem Gebietsschema arbeiten, die einen Punkt als Tausendertrennzeichen verwendet. Die formatierte Zeichenfolge wird im richtigen Format für das Gebietsschema angezeigt.<br /><br /> Betrachten Sie beispielsweise die folgenden drei Formatzeichenfolgen:<br /><br /> -   `"#,0."`, welche wird das Tausendertrennzeichen verwendet, um die Zahl 100 Millionen als die Zeichenfolge "100,000,000" zu formatieren.<br />-   `"#0,."`, um die Zahl 100 Millionen als die Zeichenfolge "100000" zu formatieren verwendet eine Skalierung mit einem Faktor von 1000.<br />-   `"#,0,."`, verwendet das Tausendertrennzeichen und die Skalierung durch Eintausend, um die Zahl 100 Millionen als die Zeichenfolge "100,000" zu formatieren.|  
|(`:`)|Trennzeichen für Zeitangaben. In manchen Gebietsschemas unter Umständen andere Zeichen Zeittrennzeichen verwendet werden. Das Trennzeichen für Zeitangaben trennt, Stunden, Minuten und Sekunden, wenn Zeitwerte formatiert werden. Welches Zeichen tatsächliche als Zeittrennzeichen in der formatierten Ausgabe verwendet, wird von den Systemeinstellungen bestimmt.|  
|(`/`)|Datumstrennzeichen. In manchen Gebietsschemas unter Umständen andere Zeichen Datumstrennzeichen verwendet werden. Das Trennzeichen trennt den Tag, Monat und Jahr wenn Datumswerte formatiert werden. Welches Zeichen tatsächliche als Datumstrennzeichen in der formatierten Ausgabe verwendet, wird von den Systemeinstellungen bestimmt.|  
|(`E-``E+``e-``e+`)|Wissenschaftliches Format. Wenn der Formatausdruck mindestens einen Ziffernplatzhalter (`0` oder `#`) auf der linken Seite des `E-`, `E+`, `e-`, oder `e+`, die Zahl im wissenschaftlichen Format angezeigt und `E` oder `e` zwischen der Anzahl und dem Exponenten eingefügt wird. Die Anzahl der Ziffernplatzhalter auf der linken Seite bestimmt die Anzahl der Ziffern im Exponenten. Verwendung `E-` oder `e-` negativen Exponenten ein Minuszeichen (-) zu platzieren. Verwendung `E+` oder `e+` negativen Exponenten ein Minuszeichen (-) und positiven Exponenten ein Pluszeichen zu platzieren. Sie müssen auch Ziffernplatzhalter auf rechts neben diesem Symbol, um die richtige Formatierung einschließen.|  
|`-` `+` `$` ( )|Literalzeichen. Diese Zeichen werden genau wie in der Formatzeichenfolge eingegeben angezeigt. Um ein Zeichen als die hier aufgeführten anzuzeigen, fügen sie davor ein umgekehrter Schrägstrich (`\`), oder schließen Sie ihn in doppelte Anführungszeichen ("").|  
|(`\`)|Zeigt das nächste Zeichen in der Formatzeichenfolge an. Um ein Zeichen anzuzeigen, die besondere Bedeutung als Literalzeichen hat, fügen sie davor ein umgekehrter Schrägstrich (`\`). Der umgekehrte Schrägstrich selbst wird nicht angezeigt. Verwenden des umgekehrten Schrägstrichs ist identisch mit das nächste Zeichen in doppelte Anführungszeichen einschließen. Um einen umgekehrten Schrägstrich anzuzeigen, verwenden Sie zwei umgekehrte Schrägstriche (`\\`).<br /><br /> Beispiele für Zeichen, die nicht angezeigt werden können, als Literalzeichen Formatieren von Datums- und uhrzeitformatierungen Zeichen sind (`a`, `c`, `d`, `h`, `m`, `n`, `p`, `q`, `s`, `t`, `w`, `y`, `/`, und `:`), die Zeichen zum Formatieren von Zahlen (`#`, `0`, `%`, `E`, `e`, Komma und Punkt), und die Zeichen zum Formatieren von Zeichenfolgen (`@`, `&`, `<`, `>`, und `!`).|  
|(`"``ABC``"`)|Zeigt die Zeichenfolge innerhalb der doppelten Anführungszeichen (""). Um eine Zeichenfolge im Stilargument von Code einzuschließen, verwenden Sie `Chr(34)` zum Einschließen von Text (`34` ist der Zeichencode für ein Anführungszeichen (")).|  
  
### <a name="legacy-code-example"></a>Legacy-Codebeispiel  
 Die folgende Tabelle enthält einige Beispiele für Formatausdrücke für Zahlen. (In allen diesen Beispielen wird davon ausgegangen, dass Ihr Gebietsschema Englisch-US ist) Die erste Spalte enthält die Formatzeichenfolgen für die `Style` Argument der `Format` -Funktion, die anderen Spalten, die die resultierende Ausgabe enthalten, wenn die formatierten Daten den in den Spaltenüberschriften angegebenen Wert verfügt.  
  
|Format (`Style`)|"5" formatiert als|"-5" formatiert als.|als formatiert "0.5"|  
|-|-|-|-|  
|`Zero-length string ("")`|`5`|`-5`|`0.5`|  
|`0`|`5`|`-5`|`1`|  
|`0.00`|`5.00`|`-5.00`|`0.50`|  
|`#,##0`|`5`|`-5`|`1`|  
|`$#,##0;($#,##0)`|`$5`|`($5)`|`$1`|  
|`$#,##0.00;($#,##0.00)`|`$5.00`|`($5.00)`|`$0.50`|  
|`0%`|`500%`|`-500%`|`50%`|  
|`0.00%`|`500.00%`|`-500.00%`|`50.00%`|  
|`0.00E+00`|`5.00E+00`|`-5.00E+00`|`5.00E-01`|  
|`0.00E-00`|`5.00E00`|`-5.00E00`|`5.00E-01`|  
  
## <a name="predefined-datetime-formats"></a>Vordefinierte Datums-/Uhrzeitformate  
 Der folgenden Tabelle sind die vordefinierten Datums- und Zeitformate. Diese möglicherweise nach Namen als Formatargument für verwendet werden die `Format` Funktion:  
  
|Formatname|Beschreibung |  
|-|-|  
|`General Date`, oder `G`|Zeigt ein Datum und/oder eine Uhrzeit. Beispielsweise `3/12/2008 11:07:31 AM`. Datumsanzeige wird vom aktuellen Kulturwert in Ihrer Anwendung bestimmt.|  
|`Long Date`, `Medium Date`oder `D`|Zeigt ein Datum entsprechend dem langen Datumsformat Ihrer aktuellen kultureinstellung an. Beispielsweise `Wednesday, March 12, 2008`.|  
|`Short Date`, oder `d`|Zeigt ein Datum unter Verwendung von kurzen Datumsformat Ihrer aktuellen kultureinstellung an. Beispielsweise `3/12/2008`.<br /><br /> Die `d` Zeichen zeigt den Tag in einem benutzerdefinierten Datumsformat.|  
|`Long Time`, `Medium Time`oder `T`|Zeigt eine Uhrzeit mit lange Uhrzeitformat Ihrer aktuellen kultureinstellung an. in der Regel enthält, Stunden, Minuten und Sekunden. Beispielsweise `11:07:31 AM`.|  
|`Short Time` oder `t`|Zeigt eine Uhrzeit, die mit Ihrer aktuellen kultureinstellung kurze Uhrzeitformat. Beispielsweise `11:07 AM`.<br /><br /> Die `t` Zeichen zeigt `AM` oder `PM` Werte für Gebietsschemas, die 12-Stunden-Format in einem benutzerdefinierten Uhrzeitformat verwenden.|  
|`f`|Zeigt das lange Datum und die kurze Uhrzeit Format Ihrer aktuellen kultureinstellung an. Beispielsweise `Wednesday, March 12, 2008 11:07 AM`.|  
|`F`|Zeigt das lange Datum und lange Zeit entsprechend Ihrer aktuellen kultureinstellung-Format. Beispielsweise `Wednesday, March 12, 2008 11:07:31 AM`.|  
|`g`|Zeigt das kurze Datum und kurze Zeit entsprechend Ihrer aktuellen kultureinstellung-Format. Beispielsweise `3/12/2008 11:07 AM`.|  
|`M`, `m`|Zeigt den Monat und Tag eines Datums. Beispielsweise `March 12`.<br /><br /> Die `M` Zeichen zeigt den Monat in einem benutzerdefinierten Datumsformat. Die `m` Zeichen zeigt die Minuten in einem benutzerdefinierten Uhrzeitformat.|  
|`R`, `r`|Formatiert das Datum gemäß der <xref:System.Globalization.DateTimeFormatInfo.RFC1123Pattern%2A> Eigenschaft. Beispielsweise `Wed, 12 Mar 2008 11:07:31 GMT`. Das formatierte Datum passt nicht den Wert von Datum und Uhrzeit an. Sie müssen den Datums-/Uhrzeitwert in GMT anpassen, vor dem Aufruf der `Format` Funktion.|  
|`s`|Formatiert das Datum und Uhrzeit als sortierbaren Index. Beispielsweise `2008-03-12T11:07:31`.<br /><br /> Die `s` Zeichen zeigt die Sekunden in einem benutzerdefinierten Uhrzeitformat.|  
|`u`|Formatiert das Datum und Uhrzeit als sortierbaren GMT-Index. Beispielsweise `2008-03-12 11:07:31Z`.|  
|`U`|Formatiert das Datum und Zeit mit das lange Datum und lange Zeit als GMT. Beispielsweise `Wednesday, March 12, 2008 6:07:31 PM`.|  
|`Y`, `y`|Formatiert das Datum als Jahr und Monat. Beispielsweise `March, 2008`.<br /><br /> Die `Y` und `y` Zeichen zeigt das Jahr in einem benutzerdefinierten Datumsformat.|  
  
 Weitere Informationen zu der Anwendung Informationen zur aktuellen Kultur, finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
## <a name="user-defined-datetime-formats"></a>Benutzerdefinierte Datums-/Uhrzeitformate  
 Die folgende Tabelle zeigt die Zeichen, dass Sie zum Erstellen von benutzerdefinierten Datums-/Zeitformate verwenden können. Anders als in früheren Versionen von Visual Basic, sind diese Zeichen Groß-/Kleinschreibung beachtet.  
  
|Zeichen|Beschreibung |  
|-|-|  
|(`:`)|Trennzeichen für Zeitangaben. In manchen Gebietsschemas unter Umständen andere Zeichen Zeittrennzeichen verwendet werden. Das Trennzeichen für Zeitangaben trennt, Stunden, Minuten und Sekunden, wenn Zeitwerte formatiert werden. Welches Zeichen tatsächliche als Zeittrennzeichen in der formatierten Ausgabe verwendet wird, wird vom aktuellen Kulturwert in Ihrer Anwendung bestimmt.|  
|(`/`)|Datumstrennzeichen. In manchen Gebietsschemas unter Umständen andere Zeichen Datumstrennzeichen verwendet werden. Das Trennzeichen trennt den Tag, Monat und Jahr wenn Datumswerte formatiert werden. Welches Zeichen tatsächliche als Datumstrennzeichen in der formatierten Ausgabe verwendet wird, wird von der aktuellen Kultur der Anwendung bestimmt.|  
|(`%`)|Wird verwendet, um anzugeben, dass das nachfolgende Zeichen als ein Einzelbuchstabenformat ohne Berücksichtigung der alle nachfolgenden Buchstaben gelesen werden soll. Auch verwendet, um anzugeben, dass ein Einzelbuchstabenformat als benutzerdefiniertes Format gelesen wird. Finden Sie hier weitere Informationen.|  
|`d`|Zeigt den Tag als Zahl ohne führende Null an (z. B. `1`). Verwendung `%d` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`dd`|Zeigt den Tag als Zahl mit führender Null an (z. B. `01`).|  
|`ddd`|Zeigt den Tag als Abkürzung an (z. B. `Sun`).|  
|`dddd`|Zeigt den Tag als vollständigen Namen (z. B. `Sunday`).|  
|`M`|Zeigt den Monat als Zahl ohne führende Null an (Januar wird z. B. als dargestellt `1`). Verwendung `%M` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`MM`|Zeigt den Monat als Zahl mit führender Null an (z. B. `01/12/01`).|  
|`MMM`|Zeigt den Monat als Abkürzung an (z. B. `Jan`).|  
|`MMMM`|Zeigt den Monat als vollständigen Monatsnamen an (z. B. `January`).|  
|`gg`|Zeigt die Zeichenfolge für die Dauer/Zeitraum (z. B. `A.D.`).|  
|`h`|Zeigt die Stunde als Zahl ohne führende Nullen im 12-Stunden-Format (z. B. `1:15:15 PM`). Verwendung `%h` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`hh`|Zeigt die Stunde als Zahl mit führenden Nullen im 12-Stunden-Format (z. B. `01:15:15 PM`).|  
|`H`|Zeigt die Stunde als Zahl ohne führende Nullen im 24-Stunden-Format (z. B. `1:15:15`). Verwendung `%H` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`HH`|Zeigt die Stunde als Zahl mit führenden Nullen im 24-Stunden-Format (z. B. `01:15:15`).|  
|`m`|Zeigt die Minute als Zahl ohne führende Nullen an (z. B. `12:1:15`). Verwendung `%m` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`mm`|Zeigt die Minute als Zahl mit führenden Nullen an (z. B. `12:01:15`).|  
|`s`|Zeigt die Sekunde als Zahl ohne führende Nullen an (z. B. `12:15:5`). Verwendung `%s` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`ss`|Zeigt die Sekunde als Zahl mit führenden Nullen an (z. B. `12:15:05`).|  
|`f`|Zeigt Sekundenbruchteile an. Z. B. `ff` zeigt Hundertstelsekunden an, aus, während `ffff` zeigt Zehntausendstelsekunden Sekunden. Sie können bis zu sieben `f` Symbole im benutzerdefinierten Format. Verwendung `%f` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`t`|Verwendet ein 12-Stunden-Format und zeigt die Großbuchstaben `A` für jede Stunde vor Mittag zeigt den Großbuchstaben `P` für jede Stunde zwischen Mittag und 23:59 Uhr Verwendung `%t` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`tt`|Für Gebietsschemas, die 12-Stunden-Format verwenden, zeigt die Großbuchstaben `AM` für jede Stunde vor Mittag zeigt den Großbuchstaben `PM` für jede Stunde zwischen Mittag und 23:59 Uhr<br /><br /> Für Gebietsschemas, die das 24-Stunden-Format verwenden, zeigt nichts an.|  
|`y`|Zeigt die Jahreszahl (0-9) ohne führende Nullen an. Verwendung `%y` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`yy`|Zeigt das Jahr im zweistelligen numerischen Format mit einer führenden Null an, an, falls zutreffend.|  
|`yyy`|Zeigt das Jahr im vierstelligen numerischen Format an.|  
|`yyyy`|Zeigt das Jahr im vierstelligen numerischen Format an.|  
|`z`|Zeigt den Zeitzonenunterschied ohne führende Null an (z. B. `-8`). Verwendung `%z` ist dies das einzige Zeichen im benutzerdefinierten numerischen Format.|  
|`zz`|Zeigt den Zeitzonenunterschied mit einer führenden Null an (z. B. `-08`)|  
|`zzz`|Zeigt den vollständigen Zeitzonenunterschied (z. B. `-08:00`)|  
  
### <a name="legacy-code-example"></a>Legacy-Codebeispiel  
 Im folgenden sind Beispiele für benutzerdefinierte Datums- und Zeitformate für `December 7, 1958, 8:50 PM, 35 seconds`:  
  
|Format|Anzeige|  
|-|-|  
|`M/d/yy`|`12/7/58`|  
|`d-MMM`|`7-Dec`|  
|`d-MMMM-yy`|`7-December-58`|  
|`d MMMM`|`7 December`|  
|`MMMM yy`|`December 58`|  
|`hh:mm tt`|`08:50 PM`|  
|`h:mm:ss t`|`8:50:35 P`|  
|`H:mm`|`20:50`|  
|`H:mm:ss`|`20:50:35`|  
|`M/d/yyyy H:mm`|`12/7/1958 20:50`|  
  
### <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die minimale zeitauflösung für ein Gerät wird vom Hersteller des Geräts bestimmt. Wenn die zeitauflösung für das Gerät grob genug ist, ist die `f` Formatzeichen gibt 0 bei Ausführung auf diesem Gerät.  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der `Format`-Funktion zur Formatierung von Werten mit `String`-Formaten und benutzerdefinierten Formaten. Die tatsächlich von Ihrem System ausgegebene Formatierung von Datumstrennzeichen (`/`), Trennzeichen für Zeitangaben (`:`) und AM/PM-Indikatoren (`t` und `tt`) richtet sich nach den Gebietsschemaeinstellungen des Codes. Wenn Datums- und Zeitangaben in der Entwicklungsumgebung angezeigt werden, werden das 24-Stunden-Zeitformat und das kurze Datumsformat des für den Code ausgewählten Gebietsschemas verwendet.  
  
> [!NOTE]
>  Für Gebietsschemas, die das 24-Stunden-Format verwenden, zeigen die AM/PM-Indikatoren (`t` und `tt`) nichts an.  
  
 [!code-vb[VbVbalrStrings#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#27)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Format(System.String,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Conversion.Str(System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="FormatCurrency">
      <MemberSignature Language="C#" Value="public static string FormatCurrency (object Expression, int NumDigitsAfterDecimal = -1, Microsoft.VisualBasic.TriState IncludeLeadingDigit = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState UseParensForNegativeNumbers = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState GroupDigits = Microsoft.VisualBasic.TriState.UseDefault);" />
      <MemberSignature Language="ILAsm" Value=".method public static string FormatCurrency(object Expression, int32 NumDigitsAfterDecimal, valuetype Microsoft.VisualBasic.TriState IncludeLeadingDigit, valuetype Microsoft.VisualBasic.TriState UseParensForNegativeNumbers, valuetype Microsoft.VisualBasic.TriState GroupDigits) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.FormatCurrency(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
      <MemberSignature Language="VB.NET" Value="Public Function FormatCurrency (Expression As Object, Optional NumDigitsAfterDecimal As Integer = -1, Optional IncludeLeadingDigit As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional UseParensForNegativeNumbers As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional GroupDigits As TriState = Microsoft.VisualBasic.TriState.UseDefault) As String" />
      <MemberSignature Language="F#" Value="static member FormatCurrency : obj * int * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState -&gt; string" Usage="Microsoft.VisualBasic.Strings.FormatCurrency (Expression, NumDigitsAfterDecimal, IncludeLeadingDigit, UseParensForNegativeNumbers, GroupDigits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Object" />
        <Parameter Name="NumDigitsAfterDecimal" Type="System.Int32" />
        <Parameter Name="IncludeLeadingDigit" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="UseParensForNegativeNumbers" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="GroupDigits" Type="Microsoft.VisualBasic.TriState" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Der zu formatierende Ausdruck.</param>
        <param name="NumDigitsAfterDecimal">Dies ist optional. Numerischer Wert, der angibt, wie viele Stellen hinter dem Dezimaltrennzeichen angezeigt werden. Der Standardwert ist -1 und gibt an, dass die regionalen Einstellungen des Computers verwendet werden.</param>
        <param name="IncludeLeadingDigit">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Enumeration, die angibt, ob bei Bruchwerten eine führende Null angezeigt wird. Weitere Informationen finden Sie in den Hinweisen zu Werten.</param>
        <param name="UseParensForNegativeNumbers">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Enumeration, die angibt, ob negative Werte in Klammern gesetzt werden. Weitere Informationen finden Sie in den Hinweisen zu Werten.</param>
        <param name="GroupDigits">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Enumeration, die angibt, ob Zahlen mithilfe des Gruppentrennzeichens gruppiert werden, das in den regionalen Einstellungen des Computers definiert ist. Weitere Informationen finden Sie in den Hinweisen zu Werten.</param>
        <summary>Gibt einen Ausdruck als Währungsbetrag zurück, der mit dem in der Systemsteuerung festgelegten Währungssymbol formatiert ist.</summary>
        <returns>Gibt einen Ausdruck als Währungsbetrag zurück, der mit dem in der Systemsteuerung festgelegten Währungssymbol formatiert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine oder mehrere optionale Argumente ausgelassen werden, werden stattdessen übereinstimmenden regionalen-Settings-Werte des Computers verwendet.  
  
 Die Position des Währungssymbols relativ zu den Currency-Wert wird von regionalen Einstellungen des Systems bestimmt.  
  
> [!NOTE]
>  Alle Einstellungsinformationen stammen aus dem Gebietsschema der Anwendung. Standardmäßig werden, die das Gebietsschema, in der Systemsteuerung festgelegt. Aber sie können programmgesteuert geändert werden mithilfe von .NET Framework, mit Ausnahme von führenden Null an, die aus stammt die `Number` Registerkarte.  
  
 Die `IncludeLeadingDigit`, `UseParensForNegativeNumbers`, und `GroupDigits` Argumente im folgenden aufgeführten Enumerationswerte für einen dreifachen Zustand.  
  
|Wert|Beschreibung |  
|-|-|  
|`TriState.True`|True|  
|`TriState.False`|False|  
|`TriState.UseDefault`|Regionalen Einstellungen des Computers|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `FormatCurrency`-Funktion.  
  
 [!code-vb[VbVbalrStrings#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Anzahl der Stellen nach dem Dezimalzeichen ist größer als 99.</exception>
        <exception cref="T:System.InvalidCastException">Typ ist nicht numerisch.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatDateTime(System.DateTime,Microsoft.VisualBasic.DateFormat)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatNumber(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatPercent(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="T:Microsoft.VisualBasic.TriState" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Format(System.Object,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.InvalidCastException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung</related>
      </Docs>
    </Member>
    <Member MemberName="FormatDateTime">
      <MemberSignature Language="C#" Value="public static string FormatDateTime (DateTime Expression, Microsoft.VisualBasic.DateFormat NamedFormat = Microsoft.VisualBasic.DateFormat.GeneralDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static string FormatDateTime(valuetype System.DateTime Expression, valuetype Microsoft.VisualBasic.DateFormat NamedFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.FormatDateTime(System.DateTime,Microsoft.VisualBasic.DateFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function FormatDateTime (Expression As DateTime, Optional NamedFormat As DateFormat = Microsoft.VisualBasic.DateFormat.GeneralDate) As String" />
      <MemberSignature Language="F#" Value="static member FormatDateTime : DateTime * Microsoft.VisualBasic.DateFormat -&gt; string" Usage="Microsoft.VisualBasic.Strings.FormatDateTime (Expression, NamedFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.DateTime" />
        <Parameter Name="NamedFormat" Type="Microsoft.VisualBasic.DateFormat" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Der zu formatierende <see langword="Date" />-Ausdruck.</param>
        <param name="NamedFormat">Dies ist optional. Numerischer Wert, der das verwendete Datum-/Zeitformat angibt. Wird der Wert nicht angegeben, so wird <see langword="DateFormat.GeneralDate" /> verwendet.</param>
        <summary>Gibt einen Zeichenfolgenausdruck für einen Datums- und Uhrzeitwert zurück.</summary>
        <returns>Gibt einen Zeichenfolgenausdruck für einen Datums- und Uhrzeitwert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Date` Datentyp immer sowohl Datums-und Uhrzeitinformationen enthält. Bei der typkonvertierung wird berücksichtigt Visual Basic 1/1/1 (1. Januar des Jahres 1) auf einen neutralen Wert für Datum und 00:00:00 (Mitternacht) einen neutralen Wert für die Zeit sein werden. Wenn Sie nicht Formatieren einer `Date` Wert als Datum/Uhrzeit-Zeichenfolge, `FormatDateTime` enthält keine neutralen Werte in der Ergebniszeichenfolge. Wenn Sie #1/1/0001 konvertieren, z. B. 9:30:00 # in eine Zeichenfolge, die das Ergebnis wird "9:30:00 Uhr"; Die Datumsinformationen wird unterdrückt. Die Datumsinformationen ist jedoch weiterhin vorhanden, in der ursprünglichen `Date` Wert und kann mit Funktionen wiederhergestellt werden, z. B. `DatePart`.  
  
> [!NOTE]
>  Übergeben der `Expression` Argument als ein `String` Zeichenliteral `FormatDateTime` interpretiert es gemäß der <xref:System.Globalization.CultureInfo.CurrentCulture%2A> Ihrer Anwendung festlegen. Jedoch wenn Sie ihn als übergeben eine `Date` literal, verwenden Sie das Format #mm/tt/jjjj #, da `FormatDateTime` immer interpretiert eine `Date` Zeichenfolgenliteral entsprechend der Kultur Englisch (USA). Dies ist erforderlich, da, wenn eine Anwendung entwickelt wurde und mit programmiert `Date` Literale aus einem Kultur, aber anschließend ausgeführt wird, auf einer Plattform mit einer anderen Kultur, die `Date` Literale konnte nicht ordnungsgemäß analysiert werden.  
  
 Die `NamedFormat` Argument weist die folgenden Einstellungen.  
  
|Konstante|Beschreibung |  
|-|-|  
|`DateFormat.GeneralDate`|Zeigen Sie ein Datum und/oder eine Uhrzeit. Ein Date-Teil als kurze Datumsformat angezeigt. Bei ein Uhrzeitteil wird als eine lange Zeit anzeigen. Falls vorhanden, werden beide Teile angezeigt.|  
|`DateFormat.LongDate`|Zeigen Sie ein Datum in das lange Datumsformat in regionalen Einstellungen des Computers angegeben.|  
|`DateFormat.ShortDate`|Zeigt ein Datum unter Verwendung des kurzen Datumsformat in regionalen Einstellungen des Computers angegeben.|  
|`DateFormat.LongTime`|Zeigt eine Uhrzeit, die Verwendung des Zeitformats in regionalen Einstellungen des Computers angegeben.|  
|`DateFormat.ShortTime`|Zeigt eine Uhrzeit mit dem 24-Stunden-Format (hh: mm).|  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `FormatDateTime` Funktion.  
  
 [!code-vb[VbVbalrStrings#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Einstellung <paramref name="NamedFormat" /> ist nicht gültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Format(System.Object,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatCurrency(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatNumber(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatPercent(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="M:Microsoft.VisualBasic.DateAndTime.DatePart(Microsoft.VisualBasic.DateInterval,System.DateTime,Microsoft.VisualBasic.FirstDayOfWeek,Microsoft.VisualBasic.FirstWeekOfYear)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="FormatNumber">
      <MemberSignature Language="C#" Value="public static string FormatNumber (object Expression, int NumDigitsAfterDecimal = -1, Microsoft.VisualBasic.TriState IncludeLeadingDigit = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState UseParensForNegativeNumbers = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState GroupDigits = Microsoft.VisualBasic.TriState.UseDefault);" />
      <MemberSignature Language="ILAsm" Value=".method public static string FormatNumber(object Expression, int32 NumDigitsAfterDecimal, valuetype Microsoft.VisualBasic.TriState IncludeLeadingDigit, valuetype Microsoft.VisualBasic.TriState UseParensForNegativeNumbers, valuetype Microsoft.VisualBasic.TriState GroupDigits) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.FormatNumber(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
      <MemberSignature Language="VB.NET" Value="Public Function FormatNumber (Expression As Object, Optional NumDigitsAfterDecimal As Integer = -1, Optional IncludeLeadingDigit As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional UseParensForNegativeNumbers As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional GroupDigits As TriState = Microsoft.VisualBasic.TriState.UseDefault) As String" />
      <MemberSignature Language="F#" Value="static member FormatNumber : obj * int * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState -&gt; string" Usage="Microsoft.VisualBasic.Strings.FormatNumber (Expression, NumDigitsAfterDecimal, IncludeLeadingDigit, UseParensForNegativeNumbers, GroupDigits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Object" />
        <Parameter Name="NumDigitsAfterDecimal" Type="System.Int32" />
        <Parameter Name="IncludeLeadingDigit" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="UseParensForNegativeNumbers" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="GroupDigits" Type="Microsoft.VisualBasic.TriState" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Der zu formatierende Ausdruck.</param>
        <param name="NumDigitsAfterDecimal">Dies ist optional. Numerischer Wert, der angibt, wie viele Stellen hinter dem Dezimaltrennzeichen angezeigt werden. Der Standardwert ist -1 und gibt an, dass die regionalen Einstellungen des Computers verwendet werden.</param>
        <param name="IncludeLeadingDigit">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob bei Bruchwerten eine führende 0 angezeigt wird. Die Werte finden Sie unter „Einstellungen“.</param>
        <param name="UseParensForNegativeNumbers">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob negative Werte in Klammern gesetzt werden. Die Werte finden Sie unter „Einstellungen“.</param>
        <param name="GroupDigits">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob Ziffern mithilfe des in den Gebietsschemaeinstellungen angegebenen Gruppentrennzeichens gruppiert werden sollen. Die Werte finden Sie unter „Einstellungen“.</param>
        <summary>Gibt einen als Zahl formatierten Ausdruck zurück.</summary>
        <returns>Gibt einen als Zahl formatierten Ausdruck zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine oder mehrere optionale Argumente ausgelassen werden, werden die Werte für ausgelassene Argumente durch die gebietsschemaeinstellungen bereitgestellt.  
  
> [!NOTE]
>  Alle Einstellungsinformationen stammen aus dem Gebietsschema der Anwendung. Standardmäßig werden, die das Gebietsschema, in der Systemsteuerung festgelegt. Allerdings können sie programmgesteuert geändert werden mithilfe von .NET Framework.  
  
 Die `IncludeLeadingDigit`, `UseParensForNegativeNumbers`, und `GroupDigits` Argumente haben die folgenden Einstellungen.  
  
|Konstante|Beschreibung |  
|-|-|  
|`TriState.True`|True|  
|`TriState.False`|False|  
|`TriState.UseDefault`|Regionalen Einstellungen des Computers|  
  
   
  
## Examples  
 Dieses Beispiel zeigt die `FormatNumber` Funktion.  
  
 [!code-vb[VbVbalrStrings#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Typ ist nicht numerisch.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatCurrency(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatDateTime(System.DateTime,Microsoft.VisualBasic.DateFormat)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatPercent(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="T:Microsoft.VisualBasic.TriState" />
        <altmember cref="T:System.InvalidCastException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="FormatPercent">
      <MemberSignature Language="C#" Value="public static string FormatPercent (object Expression, int NumDigitsAfterDecimal = -1, Microsoft.VisualBasic.TriState IncludeLeadingDigit = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState UseParensForNegativeNumbers = Microsoft.VisualBasic.TriState.UseDefault, Microsoft.VisualBasic.TriState GroupDigits = Microsoft.VisualBasic.TriState.UseDefault);" />
      <MemberSignature Language="ILAsm" Value=".method public static string FormatPercent(object Expression, int32 NumDigitsAfterDecimal, valuetype Microsoft.VisualBasic.TriState IncludeLeadingDigit, valuetype Microsoft.VisualBasic.TriState UseParensForNegativeNumbers, valuetype Microsoft.VisualBasic.TriState GroupDigits) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.FormatPercent(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
      <MemberSignature Language="VB.NET" Value="Public Function FormatPercent (Expression As Object, Optional NumDigitsAfterDecimal As Integer = -1, Optional IncludeLeadingDigit As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional UseParensForNegativeNumbers As TriState = Microsoft.VisualBasic.TriState.UseDefault, Optional GroupDigits As TriState = Microsoft.VisualBasic.TriState.UseDefault) As String" />
      <MemberSignature Language="F#" Value="static member FormatPercent : obj * int * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState * Microsoft.VisualBasic.TriState -&gt; string" Usage="Microsoft.VisualBasic.Strings.FormatPercent (Expression, NumDigitsAfterDecimal, IncludeLeadingDigit, UseParensForNegativeNumbers, GroupDigits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Object" />
        <Parameter Name="NumDigitsAfterDecimal" Type="System.Int32" />
        <Parameter Name="IncludeLeadingDigit" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="UseParensForNegativeNumbers" Type="Microsoft.VisualBasic.TriState" />
        <Parameter Name="GroupDigits" Type="Microsoft.VisualBasic.TriState" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Der zu formatierende Ausdruck.</param>
        <param name="NumDigitsAfterDecimal">Dies ist optional. Numerischer Wert, der angibt, wie viele Stellen rechts neben dem Dezimaltrennzeichen angezeigt werden. Der Standardwert ist –1, was darauf hinweist, dass die Einstellungen des Gebietsschemas verwendet werden.</param>
        <param name="IncludeLeadingDigit">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob bei Dezimalzahlen eine führende Null angezeigt werden soll. Die Werte finden Sie unter „Einstellungen“.</param>
        <param name="UseParensForNegativeNumbers">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob negative Werte in Klammern gesetzt werden sollen. Die Werte finden Sie unter „Einstellungen“.</param>
        <param name="GroupDigits">Dies ist optional. <see cref="T:Microsoft.VisualBasic.TriState" />-Konstante, die angibt, ob Ziffern mithilfe des in den Gebietsschemaeinstellungen angegebenen Gruppentrennzeichens gruppiert werden sollen. Die Werte finden Sie unter „Einstellungen“.</param>
        <summary>Gibt einen Ausdruck als Prozentangabe (d. h. multipliziert mit 100) und einem abschließenden %-Zeichen zurück.</summary>
        <returns>Gibt einen Ausdruck als Prozentangabe (d. h. multipliziert mit 100) und einem abschließenden %-Zeichen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine oder mehrere optionale Argumente ausgelassen werden, werden die Werte für ausgelassene Argumente durch die gebietsschemaeinstellungen bereitgestellt.  
  
> [!NOTE]
>  Alle Einstellungsinformationen stammen aus dem Gebietsschema der Anwendung. Standardmäßig werden, die das Gebietsschema, in der Systemsteuerung festgelegt. Allerdings können sie programmgesteuert geändert werden mithilfe von .NET Framework.  
  
 Die `IncludeLeadingDigit`, `UseParensForNegativeNumbers`, und `GroupDigits` Argumente haben die folgenden Einstellungen.  
  
|Konstante|Beschreibung |  
|-|-|  
|`TriState.True`|True|  
|`TriState.False`|False|  
|`TriState.Default`|Regionalen Einstellungen des Computers|  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `FormatPercent` Funktion.  
  
 [!code-vb[VbVbalrStrings#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Typ ist nicht numerisch.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatCurrency(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatDateTime(System.DateTime,Microsoft.VisualBasic.DateFormat)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.FormatNumber(System.Object,System.Int32,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState,Microsoft.VisualBasic.TriState)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Format(System.Object,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.TriState" />
        <altmember cref="T:System.InvalidCastException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public static char GetChar (string str, int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public static char GetChar(string str, int32 Index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.GetChar(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChar (str As String, Index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char GetChar(System::String ^ str, int Index);" />
      <MemberSignature Language="F#" Value="static member GetChar : string * int -&gt; char" Usage="Microsoft.VisualBasic.Strings.GetChar (str, Index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <param name="Index">Erforderlich. <see langword="Integer" />-Ausdruck. Der (1-basierte) Index des Zeichens in <c>str</c>, der zurückgegeben werden soll.</param>
        <summary>Gibt einen <see langword="Char" />-Wert zurück, der das Zeichen am angegebenen Index in der angegebenen Zeichenfolge darstellt.</summary>
        <returns>
          <see langword="Char" />-Wert, der das Zeichen am angegebenen Index in der angegebenen Zeichenfolge darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Index` ist kleiner als 1 oder größer als der Index des letzten Zeichens in `str`, `ArgumentException` ausgelöst.  
  
   
  
## Examples  
 Dieses Beispiel zeigt, wie Sie mit der `GetChar` -Funktion zum Zurückgeben eines Zeichens aus einem angegebenen Index in einer `String`.  
  
 [!code-vb[VbVbalrStrings#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> ist <see langword="Nothing" />, <paramref name="Index" /> &lt; 1 oder <paramref name="Index" /> ist größer als der Index des letzten Zeichens von <paramref name="str" />.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Mid" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InStr">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Integer-Wert zurück, der die Anfangsposition des ersten Auftretens einer Zeichenfolge innerhalb einer anderen Zeichenfolge angibt.  Die Ganzzahl ist ein auf Eins basierter Index, wenn eine Übereinstimmung gefunden wird.  Wenn keine Übereinstimmung gefunden wird, gibt die Funktion 0 (null) zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InStr">
      <MemberSignature Language="C#" Value="public static int InStr (string String1, string String2, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 InStr(string String1, string String2, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.InStr(System.String,System.String,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function InStr (String1 As String, String2 As String, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As Integer" />
      <MemberSignature Language="F#" Value="static member InStr : string * string * Microsoft.VisualBasic.CompareMethod -&gt; int" Usage="Microsoft.VisualBasic.Strings.InStr (String1, String2, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String1" Type="System.String" />
        <Parameter Name="String2" Type="System.String" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="String1">Erforderlich. <see langword="String" />-Ausdruck, der durchsucht wird.</param>
        <param name="String2">Erforderlich. Gesuchter <see langword="String" />-Ausdruck.</param>
        <param name="Compare">Dies ist optional. Gibt den Typ des Zeichenfolgenvergleichs an. Wenn <c>Compare</c> ausgelassen wird, bestimmt die <see langword="Option Compare" />-Einstellung den Typ des Vergleichs.</param>
        <summary>Gibt einen Integer-Wert zurück, der die Anfangsposition des ersten Auftretens einer Zeichenfolge innerhalb einer anderen Zeichenfolge angibt.</summary>
        <returns>
          <list type="table">
            <item>
              <term> If 
 </term>
              <description> Rückgabewert von InStr 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String1" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />.</term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />.</term>
              <description> Die Startposition für die Suche, mit Standard an der ersten Zeichenposition.  
  
 </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> wird nicht gefunden. 
 </term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> wurde in <paramref name="String1" /> gefunden.</term>
              <description> Position, an der die gefundene Zeichenfolge beginnt 
 </description>
            </item>
            <item>
              <term></term>
              <description></description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die `InStr` Funktion wird beim Analysieren von Zeichenfolgen verwendet.  
  
> [!NOTE]
>  Die `InStrB` -Funktion in früheren Versionen von Visual Basic gibt eine Anzahl von Bytes anstatt einer Zeichenposition. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `InStrB` wird nicht mehr unterstützt.  
  
 Die `Compare`-Argumenteinstellungen lauten:  
  
|Konstante|Wert|Beschreibung |  
|-|-|-|  
|`Binary`|0|Führt einen binären Vergleich|  
|`Text`|1|Führt einen Textvergleich|  
  
   
  
## Examples  
 In diesem Beispiel wird die `InStr`-Funktion verwendet, um die Position des ersten Auftretens einer Zeichenfolge innerhalb einer anderen Zeichenfolge zurückzugeben.  
  
 [!code-vb[VbVbalrStrings#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.InStrRev(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.StrComp(System.String,System.String,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-compare-statement.md">Option Compare-Anweisung</related>
      </Docs>
    </Member>
    <Member MemberName="InStr">
      <MemberSignature Language="C#" Value="public static int InStr (int Start, string String1, string String2, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 InStr(int32 Start, string String1, string String2, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.InStr(System.Int32,System.String,System.String,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function InStr (Start As Integer, String1 As String, String2 As String, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As Integer" />
      <MemberSignature Language="F#" Value="static member InStr : int * string * string * Microsoft.VisualBasic.CompareMethod -&gt; int" Usage="Microsoft.VisualBasic.Strings.InStr (Start, String1, String2, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Start" Type="System.Int32" />
        <Parameter Name="String1" Type="System.String" />
        <Parameter Name="String2" Type="System.String" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Start">Dies ist optional. Numerischer Ausdruck, der die Anfangsposition für jede Suche festlegt. Wenn dieser ausgelassen wird, beginnt die Suche an der ersten Zeichenposition. Der Anfangsindex ist 1-basiert.</param>
        <param name="String1">Erforderlich. <see langword="String" />-Ausdruck, der durchsucht wird.</param>
        <param name="String2">Erforderlich. Gesuchter <see langword="String" />-Ausdruck.</param>
        <param name="Compare">Dies ist optional. Gibt den Typ des Zeichenfolgenvergleichs an. Wenn <c>Compare</c> ausgelassen wird, bestimmt die <see langword="Option Compare" />-Einstellung den Typ des Vergleichs.</param>
        <summary>Gibt einen Integer-Wert zurück, der die Anfangsposition des ersten Auftretens einer Zeichenfolge innerhalb einer anderen Zeichenfolge angibt.</summary>
        <returns>
          <list type="table">
            <item>
              <term> If 
 </term>
              <description> Rückgabewert von InStr 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String1" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />.</term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />.</term>
              <description>
                <paramref name="start" />
              </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> wird nicht gefunden. 
 </term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="String2" /> wurde in <paramref name="String1" /> gefunden.</term>
              <description> Position, an der die gefundene Zeichenfolge beginnt 
 </description>
            </item>
            <item>
              <term>
                <paramref name="Start" /> &gt; Länge von <paramref name="String1" /></term>
              <description> 0 
 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die `InStr` Funktion wird beim Analysieren von Zeichenfolgen verwendet.  
  
> [!NOTE]
>  Die `InStrB` -Funktion in früheren Versionen von Visual Basic gibt eine Anzahl von Bytes anstatt einer Zeichenposition. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic 2005-Zeichenfolgen werden in Unicode und `InStrB` wird nicht mehr unterstützt.  
  
 Die `Compare`-Argumenteinstellungen lauten:  
  
|Konstante|Wert|Beschreibung |  
|-|-|-|  
|`Binary`|0|Führt einen binären Vergleich|  
|`Text`|1|Führt einen Textvergleich|  
  
   
  
## Examples  
 In diesem Beispiel wird die `InStr`-Funktion verwendet, um die Position des ersten Auftretens einer Zeichenfolge innerhalb einer anderen Zeichenfolge zurückzugeben.  
  
 [!code-vb[VbVbalrStrings#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 1.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.InStrRev(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.StrComp(System.String,System.String,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-compare-statement.md">Option Compare-Anweisung</related>
      </Docs>
    </Member>
    <Member MemberName="InStrRev">
      <MemberSignature Language="C#" Value="public static int InStrRev (string StringCheck, string StringMatch, int Start = -1, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 InStrRev(string StringCheck, string StringMatch, int32 Start, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.InStrRev(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function InStrRev (StringCheck As String, StringMatch As String, Optional Start As Integer = -1, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As Integer" />
      <MemberSignature Language="F#" Value="static member InStrRev : string * string * int * Microsoft.VisualBasic.CompareMethod -&gt; int" Usage="Microsoft.VisualBasic.Strings.InStrRev (StringCheck, StringMatch, Start, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="StringCheck" Type="System.String" />
        <Parameter Name="StringMatch" Type="System.String" />
        <Parameter Name="Start" Type="System.Int32" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="StringCheck">Erforderlich. Der gesuchte Zeichenfolgenausdruck.</param>
        <param name="StringMatch">Erforderlich. Der gesuchte Zeichenfolgenausdruck.</param>
        <param name="Start">Dies ist optional. Numerischer Ausdruck, der die 1-basierte Anfangsposition für jede Suche festlegt, beginnend auf der linken Seite der Zeichenfolge. Wenn <c>Start</c> weggelassen wird, wird – 1 verwendet, d.h., dass die Suche an der letzten Zeichenposition beginnt. Die Suche wird dann von rechts nach links fortgesetzt.</param>
        <param name="Compare">Dies ist optional. Numerischer Wert, der den Typ des Vergleichs angibt, der für das Auswerten von untergeordneten Zeichenfolgen verwendet wird. Wenn dieser ausgelassen wird, wird ein binärer Vergleich durchgeführt. Werte finden Sie im Abschnitt "Einstellungen".</param>
        <summary>Gibt die Position des ersten Vorkommens einer Zeichenfolge innerhalb einer anderen Zeichenfolge von rechts nach links gesehen zurück.</summary>
        <returns>
          <list type="table">
            <item>
              <term> If 
 </term>
              <description> InStrRev gibt Folgendes zurück 
 </description>
            </item>
            <item>
              <term>
                <paramref name="StringCheck" /> ist eine Zeichenfolge mit der Länge 0 (null) 
 </term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="StringMatch" /> ist eine Zeichenfolge mit der Länge 0 (null) 
 </term>
              <description>
                <paramref name="Start" />
              </description>
            </item>
            <item>
              <term>
                <paramref name="StringMatch" /> wird nicht gefunden. 
 </term>
              <description> 0 
 </description>
            </item>
            <item>
              <term>
                <paramref name="StringMatch" /> wurde in <paramref name="StringCheck" /> gefunden.</term>
              <description> Position, an der die erste Übereinstimmung gefunden wird, beginnend mit der rechten Seite der Zeichenfolge.  
  
 </description>
            </item>
            <item>
              <term>
                <paramref name="Start" /> ist größer als die Länge von <paramref name="StringMatch" />.</term>
              <description> 0 
 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Syntax für die `InStrRev` Funktion ist nicht identisch mit der Syntax für die `InStr` Funktion.  
  
 Die `Compare` Argument kann die folgenden Werte haben.  
  
|Konstante|Beschreibung |  
|-|-|  
|`Binary`|Führt einen binären Vergleich durch.|  
|`Text`|Führt einen Textvergleich durch.|  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `InStrRev` Funktion.  
  
 [!code-vb[VbVbalrStrings#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> = 0 oder <paramref name="Start" /> &lt; –1.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.InStr" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die durch Verknüpfen mehrerer Teilzeichenfolgen aus einem Array erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (object[] SourceArray, string Delimiter = &quot; &quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Join(object[] SourceArray, string Delimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Join(System.Object[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (SourceArray As Object(), Optional Delimiter As String = &quot; &quot;) As String" />
      <MemberSignature Language="F#" Value="static member Join : obj[] * string -&gt; string" Usage="Microsoft.VisualBasic.Strings.Join (SourceArray, Delimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="SourceArray" Type="System.Object[]" />
        <Parameter Name="Delimiter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="SourceArray">Erforderlich. Ein eindimensionales Array, das untergeordnete Zeichenfolgen enthält, die verknüpft werden sollen.</param>
        <param name="Delimiter">Dies ist optional. Eine beliebige Zeichenfolge, mit der die untergeordneten Zeichenfolgen in der zurückgegebenen Zeichenfolge getrennt werden. Wenn diese ausgelassen wird, wird das Leerzeichen (" ") verwendet. Wenn <c>Delimiter</c> eine leere Zeichenfolge ("") oder <see langword="Nothing" /> ist, werden alle Elemente der Liste ohne Trennzeichen verkettet.</param>
        <summary>Gibt eine Zeichenfolge zurück, die durch Verknüpfen mehrerer Teilzeichenfolgen aus einem Array erstellt wurde.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die durch Verknüpfen mehrerer Teilzeichenfolgen aus einem Array erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt eine Parität zwischen der `Join` und `Split` Funktionen. Die `Join` -Funktion akzeptiert ein Array von Zeichenfolgen und verknüpft sie mit einer Trennzeichenfolge, um eine einzelne Zeichenfolge zurückzugeben. Die `Split` Funktion nimmt eine Zeichenfolge, und trennt sie mit dem Trennzeichen um ein Array von Zeichenfolgen zurückzugeben. Ein wichtiger Unterschied ist jedoch `Join` können Zeichenfolgen mit einer beliebigen Trennzeichenfolge verketten `Split` nur Zeichenfolgen, die mit einem einzigen Trennzeichen trennen kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `Join` Funktion, um eine Liste von mehreren Zeichenfolgen zu erstellen.  
  
 [!code-vb[VbVbalrStrings#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="SourceArray" /> ist nicht eindimensional.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Split(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string[] SourceArray, string Delimiter = &quot; &quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Join(string[] SourceArray, string Delimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Join(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (SourceArray As String(), Optional Delimiter As String = &quot; &quot;) As String" />
      <MemberSignature Language="F#" Value="static member Join : string[] * string -&gt; string" Usage="Microsoft.VisualBasic.Strings.Join (SourceArray, Delimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="SourceArray" Type="System.String[]" />
        <Parameter Name="Delimiter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="SourceArray">Erforderlich. Ein eindimensionales Array, das untergeordnete Zeichenfolgen enthält, die verknüpft werden sollen.</param>
        <param name="Delimiter">Dies ist optional. Eine beliebige Zeichenfolge, mit der die untergeordneten Zeichenfolgen in der zurückgegebenen Zeichenfolge getrennt werden. Wenn diese ausgelassen wird, wird das Leerzeichen (" ") verwendet. Wenn <c>Delimiter</c> eine leere Zeichenfolge ("") oder <see langword="Nothing" /> ist, werden alle Elemente der Liste ohne Trennzeichen verkettet.</param>
        <summary>Gibt eine Zeichenfolge zurück, die durch Verknüpfen mehrerer Teilzeichenfolgen aus einem Array erstellt wurde.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die durch Verknüpfen mehrerer Teilzeichenfolgen aus einem Array erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt eine Parität zwischen der `Join` und `Split` Funktionen. Die `Join` -Funktion akzeptiert ein Array von Zeichenfolgen und verknüpft sie mit einer Trennzeichenfolge, um eine einzelne Zeichenfolge zurückzugeben. Die `Split` Funktion nimmt eine Zeichenfolge, und trennt sie mit dem Trennzeichen um ein Array von Zeichenfolgen zurückzugeben. Ein wichtiger Unterschied ist jedoch `Join` können Zeichenfolgen mit einer beliebigen Trennzeichenfolge verketten `Split` nur Zeichenfolgen, die mit einem einzigen Trennzeichen trennen kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `Join` Funktion, um eine Liste von mehreren Zeichenfolgen zu erstellen.  
  
 [!code-vb[VbVbalrStrings#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="SourceArray" /> ist nicht eindimensional.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Split(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LCase">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das in Kleinbuchstaben konvertiert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LCase">
      <MemberSignature Language="C#" Value="public static char LCase (char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static char LCase(char Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.LCase(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LCase (Value As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char LCase(char Value);" />
      <MemberSignature Language="F#" Value="static member LCase : char -&gt; char" Usage="Microsoft.VisualBasic.Strings.LCase Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Value">Erforderlich. Alle gültigen <see langword="String" />-Ausdrücke oder <see langword="Char" />-Ausdrücke.</param>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das in Kleinbuchstaben konvertiert wurde.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das in Kleinbuchstaben konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Großbuchstaben konvertiert werden in Kleinbuchstaben; Alle Kleinbuchstaben und sonstigen Zeichen bleiben unverändert.  
  
 Diese Funktion verwendet die Informationen zur Kultur der Anwendung, wenn die Zeichenfolge zu bearbeiten, so dass die Groß-/Kleinschreibung Änderungen für das Gebietsschema geeignet sind, in denen die Anwendung verwendet wird.  
  
> [!IMPORTANT]
>  Wenn die Anwendung die Sicherheitsfragen die richtigen Entscheidungen basierend auf dem Ergebnis eines Vergleichs oder einer Änderung der Groß-/Kleinschreibung verwendet, und dann den Vorgang verwenden, sollten die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode, und übergeben Sie <xref:System.StringComparison.Ordinal> oder <xref:System.StringComparison.OrdinalIgnoreCase> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LCase` -Funktion eine Zeichenfolge in Kleinbuchstaben zurückgibt.  
  
 [!code-vb[VbVbalrStrings#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.UCase" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LCase">
      <MemberSignature Language="C#" Value="public static string LCase (string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LCase(string Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.LCase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LCase (Value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LCase(System::String ^ Value);" />
      <MemberSignature Language="F#" Value="static member LCase : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.LCase Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Value">Erforderlich. Alle gültigen <see langword="String" />-Ausdrücke oder <see langword="Char" />-Ausdrücke.</param>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das in Kleinbuchstaben konvertiert wurde.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das in Kleinbuchstaben konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Großbuchstaben konvertiert werden in Kleinbuchstaben; Alle Kleinbuchstaben und sonstigen Zeichen bleiben unverändert.  
  
 Diese Funktion verwendet die Informationen zur Kultur der Anwendung, wenn die Zeichenfolge zu bearbeiten, so dass die Groß-/Kleinschreibung Änderungen für das Gebietsschema geeignet sind, in denen die Anwendung verwendet wird.  
  
> [!IMPORTANT]
>  Wenn die Anwendung die Sicherheitsfragen die richtigen Entscheidungen basierend auf dem Ergebnis eines Vergleichs oder einer Änderung der Groß-/Kleinschreibung verwendet, und dann den Vorgang verwenden, sollten die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode, und übergeben Sie <xref:System.StringComparison.Ordinal> oder <xref:System.StringComparison.OrdinalIgnoreCase> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LCase` -Funktion eine Zeichenfolge in Kleinbuchstaben zurückgibt.  
  
 [!code-vb[VbVbalrStrings#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.UCase" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public static string Left (string str, int Length);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Left(string str, int32 Length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Left (str As String, Length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Left(System::String ^ str, int Length);" />
      <MemberSignature Language="F#" Value="static member Left : string * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.Left (str, Length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. <see langword="String" />-Ausdruck, von dem die äußersten linken Zeichen zurückgegeben werden.</param>
        <param name="Length">Erforderlich. <see langword="Integer" />-Ausdruck. Numerischer Ausdruck, der angibt, wie viele Zeichen zurückgegeben werden sollen. Wenn der Wert 0 ist, wird eine Zeichenfolge ("") der Länge 0 (null) zurückgegeben. Wenn der Wert größer oder gleich der Anzahl von Zeichen in <c>str</c> ist, wird die ganze Zeichenfolge zurückgegeben.</param>
        <summary>Gibt eine Zeichenfolge zurück, die eine angegebene Zeichenanzahl von der linken Seite einer Zeichenfolge enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die eine angegebene Zeichenanzahl von der linken Seite einer Zeichenfolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu bestimmen, die Anzahl der Zeichen in `str`, verwenden Sie die `Len` Funktion. Bei Verwendung in einer Windows Forms-Anwendung oder einer anderen Klasse, die eine `Left` -Eigenschaft, müssen Sie vollständig-Funktion mit qualifizieren `Microsoft.VisualBasic.Left`.  
  
> [!NOTE]
>  Die `LeftB` -Funktion in früheren Versionen von Visual Basic gibt eine Zeichenfolge zurück, in Byte anstatt in Zeichen. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LeftB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `Left` -Funktion zum Zurückgeben einer Teilzeichenfolge einer angegebenen `String`. In einer Klasse, die eine `Left` -Eigenschaft, es kann erforderlich sein, vollständig qualifizieren der `Left` Funktion.  
  
 [!code-vb[VbVbalrStrings#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Length" /> &lt; 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Mid" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Len">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (bool Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(bool Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(bool Expression);" />
      <MemberSignature Language="F#" Value="static member Len : bool -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (byte Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(unsigned int8 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Byte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::Byte Expression);" />
      <MemberSignature Language="F#" Value="static member Len : byte -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (char Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(char Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(char Expression);" />
      <MemberSignature Language="F#" Value="static member Len : char -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (DateTime Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(valuetype System.DateTime Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(DateTime Expression);" />
      <MemberSignature Language="F#" Value="static member Len : DateTime -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (decimal Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(valuetype System.Decimal Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::Decimal Expression);" />
      <MemberSignature Language="F#" Value="static member Len : decimal -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (double Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(float64 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(double Expression);" />
      <MemberSignature Language="F#" Value="static member Len : double -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (short Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(int16 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(short Expression);" />
      <MemberSignature Language="F#" Value="static member Len : int16 -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(int Expression);" />
      <MemberSignature Language="F#" Value="static member Len : int -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (long Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(int64 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(long Expression);" />
      <MemberSignature Language="F#" Value="static member Len : int64 -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (object Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(object Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::Object ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Len : obj -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (sbyte Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(int8 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::SByte Expression);" />
      <MemberSignature Language="F#" Value="static member Len : sbyte -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:Microsoft.VisualBasic.Strings.Len(System.Byte)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (float Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(float32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(float Expression);" />
      <MemberSignature Language="F#" Value="static member Len : single -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Len : string -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (ushort Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(unsigned int16 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As UShort) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::UInt16 Expression);" />
      <MemberSignature Language="F#" Value="static member Len : uint16 -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:Microsoft.VisualBasic.Strings.Len(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (uint Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(unsigned int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As UInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::UInt32 Expression);" />
      <MemberSignature Language="F#" Value="static member Len : uint32 -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:Microsoft.VisualBasic.Strings.Len(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Len">
      <MemberSignature Language="C#" Value="public static int Len (ulong Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Len(unsigned int64 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Len(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Len (Expression As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Len(System::UInt64 Expression);" />
      <MemberSignature Language="F#" Value="static member Len : uint64 -&gt; int" Usage="Microsoft.VisualBasic.Strings.Len Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="Expression">Jeder gültige <see langword="String" />-Ausdruck oder -Variablenname. Wenn <c>Expression</c> vom Typ <see langword="Object" /> ist, gibt die <see langword="Len" />-Funktion die Größe zurück, wie sie von der <see langword="FilePut" />-Funktion in die Datei geschrieben wird.</param>
        <summary>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</summary>
        <returns>Gibt eine ganze Zahl zurück, die entweder die Anzahl der Zeichen in einer Zeichenfolge oder die zum Speichern einer Variablen erforderliche nominale Byteanzahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit benutzerdefinierten Typen und `Object` Variablen, die `Len` Funktion gibt die Größe zurück, wie sie auf die Datei geschrieben wird die `FilePut` Funktion. Wenn ein `Object` enthält eine `String`, wird die Länge der Zeichenfolge zurückgegeben. Wenn ein `Object` enthält einen anderen Typ, es gibt die Größe des Objekts zurück, wie es in die Datei geschrieben wird die `FilePut` Funktion.  
  
 Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in Objekten, das die Größe der Zeichenfolge ist, in Bytes, der beim Schreiben auf den Datenträger. Die `Len` Funktion verwendet die `VBFixedString` Attribut, falls verfügbar, beim Bestimmen der Größe der `Object` Variablen.  
  
> [!NOTE]
>  Die `Len` Funktion kann nicht in der Lage, um zu bestimmen, die tatsächliche Anzahl der Speicherplatz in Bytes erforderlich, wenn Sie mit Zeichenfolgen variabler Länge in benutzerdefinierte Datentypen verwendet.  
  
> [!NOTE]
>  Die `LenB` -Funktion in früheren Versionen von Visual Basic gibt die Anzahl der Bytes in eine Zeichenfolge anstatt in Zeichen zurück. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `LenB` wird nicht mehr unterstützt.  
  
## <a name="smart-device-developer-notes"></a>Hinweise für Entwickler intelligente Geräte  
 Die `Len` -Funktion akzeptiert nur `String` und `Object` Variablen als Parameter. Wenn ein `Object` enthält eine `String`, wird zurückgegeben, die Länge der `String`. Wenn ein Parameter ein NULL-Wert ist `Object` Verweis ist, gibt die Funktion 0 (null) zurück. Wenn ein `Object` enthält einen anderen Typ eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird mit der `Len`-Funktion die Anzahl der Zeichen in einer Zeichenfolge zurückgegeben.  
  
 [!code-vb[VbVbalrStrings#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:Microsoft.VisualBasic.Strings.Len(System.Int64)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="LSet">
      <MemberSignature Language="C#" Value="public static string LSet (string Source, int Length);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LSet(string Source, int32 Length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.LSet(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LSet (Source As String, Length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LSet(System::String ^ Source, int Length);" />
      <MemberSignature Language="F#" Value="static member LSet : string * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.LSet (Source, Length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. <see langword="String" />-Ausdruck. Name der Zeichenfolgenvariablen.</param>
        <param name="Length">Erforderlich. <see langword="Integer" />-Ausdruck. Länge der zurückgegebenen Zeichenfolge.</param>
        <summary>Gibt eine links ausgerichtete Zeichenfolge zurück, die die angegebene Zeichenfolge angepasst an die angegebene Länge enthält.</summary>
        <returns>Gibt eine links ausgerichtete Zeichenfolge zurück, die die angegebene Zeichenfolge angepasst an die angegebene Länge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Zeichenfolge länger als die angegebene Länge ist, wird die zurückgegebene Zeichenfolge auf die angegebene Länge gekürzt. Wenn die angegebene Zeichenfolge kürzer als die angegebene Länge ist, werden Leerzeichen auf das rechte Ende der zurückgegebenen Zeichenfolge auf die entsprechende Länge erzeugt hinzugefügt.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `LSet` Funktion.  
  
 [!code-vb[VbVbalrStrings#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.RSet(System.String,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md">Effiziente Verwendung von Datentypen</related>
      </Docs>
    </Member>
    <Member MemberName="LTrim">
      <MemberSignature Language="C#" Value="public static string LTrim (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LTrim(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.LTrim(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LTrim (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LTrim(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member LTrim : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.LTrim str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <summary>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LTrim`, `RTrim`, und `Trim` Funktionen entfernen von Leerzeichen am Ende von Zeichenfolgen.  
  
   
  
## Examples  
 In diesem Beispiel werden mit der `LTrim`-Funktion führende Leerzeichen und mit der `RTrim`-Funktion nachstehende Leerzeichen aus einer Zeichenfolgenvariablen entfernt. Mit der `Trim`-Funktion werden beide Typen von Leerzeichen entfernt.  
  
 [!code-vb[VbVbalrStrings#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Trim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.RTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Mid">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die Zeichen aus einer festgelegten Zeichenfolge enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Mid">
      <MemberSignature Language="C#" Value="public static string Mid (string str, int Start);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Mid(string str, int32 Start) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Mid(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Mid (str As String, Start As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Mid(System::String ^ str, int Start);" />
      <MemberSignature Language="F#" Value="static member Mid : string * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.Mid (str, Start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. <see langword="String" />-Ausdruck, aus dem Zeichen zurückgegeben werden.</param>
        <param name="Start">Erforderlich. <see langword="Integer" />-Ausdruck. Anfangsposition der zurückzugebenden Zeichen. Wenn <c>Start</c> größer als die Anzahl der Zeichen in <c>str</c> ist, gibt die <see langword="Mid" />-Funktion eine Zeichenfolge ("") der Länge 0 zurück. <c>Start</c> ist 1-basiert.</param>
        <summary>Gibt eine Zeichenfolge zurück, die alle Zeichen enthält, beginnend bei einer angegebenen Position in einer Zeichenfolge.</summary>
        <returns>Eine Zeichenfolge, die aus allen Zeichen beginnend bei der angegebenen Position in der Zeichenfolge besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu bestimmen, die Anzahl der Zeichen in `str`, verwenden Sie die `Len` Funktion.  
  
 Visual Basic verfügt über eine `Mid` Funktion und ein `Mid` Anweisung. Diese Elemente beide für eine angegebene Anzahl von Zeichen in eine Zeichenfolge funktionieren, aber die `Mid` Funktionsergebnis ist die Zeichen bei der die `Mid` Anweisung ersetzt die Zeichen. Weitere Informationen finden Sie unter [Mid-Anweisung](~/docs/visual-basic/language-reference/statements/mid-statement.md).  
  
> [!NOTE]
>  Die `MidB` -Funktion in früheren Versionen von Visual Basic gibt eine Zeichenfolge zurück, in Byte anstatt in Zeichen. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic-Zeichenfolgen werden in Unicode und `MidB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Die letzte Zeile in diesem Beispiel verwendet diese Überladung der `Mid` Funktion, um die fünften und nachfolgende Zeichen aus einer Zeichenfolge zurückzugeben.  
  
 [!code-vb[VbVbalrStrings#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt;= 0 oder <paramref name="Length" /> &lt; 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Trim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.LTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.RTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/mid-statement.md">Mid-Anweisung</related>
      </Docs>
    </Member>
    <Member MemberName="Mid">
      <MemberSignature Language="C#" Value="public static string Mid (string str, int Start, int Length);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Mid(string str, int32 Start, int32 Length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Mid(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Mid (str As String, Start As Integer, Length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Mid(System::String ^ str, int Start, int Length);" />
      <MemberSignature Language="F#" Value="static member Mid : string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.Mid (str, Start, Length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Start" Type="System.Int32" />
        <Parameter Name="Length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. <see langword="String" />-Ausdruck, aus dem Zeichen zurückgegeben werden.</param>
        <param name="Start">Erforderlich. <see langword="Integer" />-Ausdruck. Anfangsposition der zurückzugebenden Zeichen. Wenn <c>Start</c> größer als die Anzahl der Zeichen in <c>str</c> ist, gibt die <see langword="Mid" />-Funktion eine Zeichenfolge ("") der Länge 0 zurück. <c>Start</c> ist 1-basiert.</param>
        <param name="Length">Dies ist optional. <see langword="Integer" />-Ausdruck. Die Anzahl der zurückzugebenden Zeichen. Wenn der Ausdruck ausgelassen wird oder weniger als <c>Length</c> Zeichen im Text enthalten sind (einschließlich des Zeichens an Position <c>Start</c>), werden alle Zeichen von der Anfangs- bis zur Endposition der Zeichenfolge zurückgegeben.</param>
        <summary>Gibt eine Zeichenfolge zurück, die eine angegebene Anzahl von Zeichen enthält, beginnend bei einer angegebenen Position in einer Zeichenfolge.</summary>
        <returns>Eine Zeichenfolge, die aus der angegebenen Anzahl von Zeichen besteht, beginnend bei der angegebenen Position in der Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu bestimmen, die Anzahl der Zeichen in `str`, verwenden Sie die `Len` Funktion.  
  
 Visual Basic verfügt über eine `Mid` Funktion und ein `Mid` Anweisung. Diese Elemente beide für eine angegebene Anzahl von Zeichen in eine Zeichenfolge funktionieren, aber die `Mid` Funktionsergebnis ist die Zeichen bei der die `Mid` Anweisung ersetzt die Zeichen. Weitere Informationen finden Sie unter [Mid-Anweisung](~/docs/visual-basic/language-reference/statements/mid-statement.md).  
  
> [!NOTE]
>  Die `MidB` -Funktion in früheren Versionen von Visual Basic gibt eine Zeichenfolge zurück, in Byte anstatt in Zeichen. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle Visual Basic-Zeichenfolgen werden in Unicode und `MidB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Die ersten beiden `Mid` Funktionen in diesem Beispiel wird die angegebene Anzahl von Zeichen zurückgeben, aus einer Zeichenfolge, beginnend mit den angegebenen Positionen. (Die letzte Funktion veranschaulicht die <xref:Microsoft.VisualBasic.Strings.Mid%28System.String%2CSystem.Int32%29> überladen werden und nur den Ausgangspunkt für die zeichenfolgenextraktion angibt.)  
  
 [!code-vb[VbVbalrStrings#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt;= 0 oder <paramref name="Length" /> &lt; 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Trim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.LTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.RTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/mid-statement.md">Mid-Anweisung</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string Expression, string Find, string Replacement, int Start = 1, int Count = -1, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Replace(string Expression, string Find, string Replacement, int32 Start, int32 Count, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Replace(System.String,System.String,System.String,System.Int32,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (Expression As String, Find As String, Replacement As String, Optional Start As Integer = 1, Optional Count As Integer = -1, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As String" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * int * int * Microsoft.VisualBasic.CompareMethod -&gt; string" Usage="Microsoft.VisualBasic.Strings.Replace (Expression, Find, Replacement, Start, Count, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
        <Parameter Name="Find" Type="System.String" />
        <Parameter Name="Replacement" Type="System.String" />
        <Parameter Name="Start" Type="System.Int32" />
        <Parameter Name="Count" Type="System.Int32" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Zeichenfolgenausdruck mit der zu ersetzenden untergeordneten Zeichenfolge.</param>
        <param name="Find">Erforderlich. Die gesuchte untergeordnete Zeichenfolge.</param>
        <param name="Replacement">Erforderlich. Untergeordnete Ersetzungszeichenfolge.</param>
        <param name="Start">Dies ist optional. Position in <c>Expression</c>, die eine für die Ersetzung verwendete Teilzeichenfolge startet. Der Rückgabewert von <see langword="Replace" /> ist eine Zeichenfolge, die bei <c>Start</c> beginnt, mit entsprechenden Ersetzungen. Wenn der Wert nicht angegeben wird, wird 1 angenommen.</param>
        <param name="Count">Dies ist optional. Die Anzahl der durchzuführenden Ersetzungen für untergeordnete Zeichenfolgen. Wenn der Wert nicht angegeben wird, ist der Standardwert -1, d. h., dass alle möglichen Ersetzungen vorgenommen werden.</param>
        <param name="Compare">Dies ist optional. Numerischer Wert, der den Typ des Vergleichs angibt, der für das Auswerten von untergeordneten Zeichenfolgen verwendet wird. Werte finden Sie im Abschnitt "Einstellungen".</param>
        <summary>Gibt eine Zeichenfolge zurück, in der eine bestimmte untergeordnete Zeichenfolge so oft wie angegeben durch eine andere Zeichenfolge ersetzt wurde.</summary>
        <returns>
          <see langword="Replace" /> gibt die folgenden Werte zurück.  
  
 <list type="table"><item><term> If 
 </term><description> Replace gibt Folgendes zurück 
 </description></item><item><term><paramref name="Find" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />.</term><description> Kopie von <paramref name="Expression" /></description></item><item><term><paramref name="Replace" /> ist eine Zeichenfolge mit der Länge 0 (null) 
 </term><description> Kopie von <paramref name="Expression" /> ohne Vorkommen von <paramref name="Find" /></description></item><item><term><paramref name="Expression" /> ist eine Zeichenfolge mit der Länge 0 (null) oder <see langword="Nothing" />, oder <paramref name="Start" /> ist größer als die Länge von <paramref name="Expression" /></term><description><see langword="Nothing" /></description></item><item><term><paramref name="Count" /> ist 0 
 </term><description> Kopie von <paramref name="Expression" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von der `Replace` Funktion ist eine Zeichenfolge, die an der angegebenen Position beginnt `Start` und endet am Ende der `Expression` Zeichenfolge mit de vorgenommenen Ersetzungen gemäß der `Find` und `Replace` Werte.  
  
 Die `Compare` Argument kann die folgenden Werte haben.  
  
|Konstante|Beschreibung |  
|-|-|  
|`Binary`|Führt einen binären Vergleich|  
|`Text`|Führt einen Textvergleich|  
  
   
  
## Examples  
 Dieses Beispiel zeigt die `Replace` Funktion.  
  
```vb  
Dim TestString As String = "Shopping List"  
' Returns "Shipping List".  
Dim aString As String = Replace(TestString, "o", "i")  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Count" /> &lt; –1 oder <paramref name="Start" /> &lt;= 0.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Filter" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public static string Right (string str, int Length);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Right(string str, int32 Length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Right (str As String, Length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Right(System::String ^ str, int Length);" />
      <MemberSignature Language="F#" Value="static member Right : string * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.Right (str, Length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. <see langword="String" />-Ausdruck, von dem die äußersten rechten Zeichen zurückgegeben werden.</param>
        <param name="Length">Erforderlich. <see langword="Integer" /> Numerischer Ausdruck, der angibt, wie viele Zeichen zurückgegeben werden sollen. Wenn der Wert 0 ist, wird eine Zeichenfolge ("") der Länge 0 (null) zurückgegeben. Wenn der Wert größer oder gleich der Anzahl von Zeichen in <c>str</c> ist, wird die ganze Zeichenfolge zurückgegeben.</param>
        <summary>Gibt eine Zeichenfolge mit einer bestimmten Anzahl von Zeichen ab dem ersten Zeichen rechts von einer Zeichenfolge zurück.</summary>
        <returns>Gibt eine Zeichenfolge mit einer bestimmten Anzahl von Zeichen ab dem ersten Zeichen rechts von einer Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu bestimmen, die Anzahl der Zeichen in `str`, verwenden Sie die `Len` Funktion. Bei der Verwendung in einem Windows-Formular oder einer anderen Klasse, die eine `Right` -Eigenschaft, müssen Sie vollständig-Funktion mit qualifizieren `Microsoft.VisualBasic.Strings.Right`.  
  
> [!NOTE]
>  Die `RightB` -Funktion in früheren Versionen von Visual Basic gibt eine Zeichenfolge zurück, in Byte, anstatt in Zeichen. Es dient in erster Linie für das Konvertieren von Zeichenfolgen in Doppelbyte-Zeichensatz (DBCS)-Satz Anwendungen. Alle aktuelle Visual Basic-Zeichenfolgen werden in Unicode und `RightB` wird nicht mehr unterstützt.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `Right` -Funktion zum Zurückgeben einer Teilzeichenfolge einer angegebenen `String`. In einer Klasse, die eine `Right` -Eigenschaft, es kann erforderlich sein, vollständig qualifizieren der `Right` Funktion.  
  
 [!code-vb[VbVbalrStrings#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Length" /> &lt; 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Len" />
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Mid" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="RSet">
      <MemberSignature Language="C#" Value="public static string RSet (string Source, int Length);" />
      <MemberSignature Language="ILAsm" Value=".method public static string RSet(string Source, int32 Length) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.RSet(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RSet (Source As String, Length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ RSet(System::String ^ Source, int Length);" />
      <MemberSignature Language="F#" Value="static member RSet : string * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.RSet (Source, Length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. <see langword="String" />-Ausdruck. Name der Zeichenfolgenvariablen.</param>
        <param name="Length">Erforderlich. <see langword="Integer" />-Ausdruck. Länge der zurückgegebenen Zeichenfolge.</param>
        <summary>Gibt eine rechts ausgerichtete Zeichenfolge zurück, die die angegebene Zeichenfolge in der vorgegebenen Länge enthält.</summary>
        <returns>Gibt eine rechts ausgerichtete Zeichenfolge zurück, die die angegebene Zeichenfolge in der vorgegebenen Länge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Source` ist länger als `Length`, `RSet` fügt nur die äußersten linken Zeichen bis zur Länge `Source`, in der zurückgegebenen Zeichenfolge. Wenn die angegebene Zeichenfolge kürzer als die angegebene Länge ist, werden das linke Ende der Zeichenfolge, die entsprechende Länge erzeugt Leerzeichen hinzugefügt. Wenn die angegebene Zeichenfolge länger als die angegebene Länge ist, wird es auf die angegebene Länge gekürzt.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung von der `RSet` Funktion.  
  
 [!code-vb[VbVbalrStrings#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.LSet(System.String,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/data-types/data-type-summary.md">Datentyp: Zusammenfassung (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md">Effiziente Verwendung von Datentypen</related>
      </Docs>
    </Member>
    <Member MemberName="RTrim">
      <MemberSignature Language="C#" Value="public static string RTrim (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static string RTrim(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.RTrim(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RTrim (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ RTrim(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member RTrim : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.RTrim str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <summary>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LTrim`, `RTrim`, und `Trim` Funktionen entfernen von Leerzeichen am Ende von Zeichenfolgen.  
  
   
  
## Examples  
 In diesem Beispiel werden mit der `LTrim`-Funktion führende Leerzeichen und mit der `RTrim`-Funktion nachstehende Leerzeichen aus einer Zeichenfolgenvariablen entfernt. Mit der `Trim`-Funktion werden beide Typen von Leerzeichen entfernt.  
  
 [!code-vb[VbVbalrStrings#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Trim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.LTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Space">
      <MemberSignature Language="C#" Value="public static string Space (int Number);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Space(int32 Number) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Space (Number As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Space(int Number);" />
      <MemberSignature Language="F#" Value="static member Space : int -&gt; string" Usage="Microsoft.VisualBasic.Strings.Space Number" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Integer" />-Ausdruck. Die Anzahl der gewünschten Leerzeichen in der Zeichenfolge.</param>
        <summary>Gibt eine Zeichenfolge mit der angegebenen Anzahl von Leerzeichen zurück.</summary>
        <returns>Gibt eine Zeichenfolge mit der angegebenen Anzahl von Leerzeichen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Space` Funktion ist nützlich für das Formatieren der Ausgabe, und Löschen von Daten in Zeichenfolgen mit fester Länge.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Space` Funktion gibt eine Zeichenfolge, bestehend aus einer angegebenen Anzahl von Leerzeichen zurück.  
  
 [!code-vb[VbVbalrStrings#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Number" /> &lt; 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string Expression, string Delimiter = &quot; &quot;, int Limit = -1, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[] Split(string Expression, string Delimiter, int32 Limit, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Split(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (Expression As String, Optional Delimiter As String = &quot; &quot;, Optional Limit As Integer = -1, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As String()" />
      <MemberSignature Language="F#" Value="static member Split : string * string * int * Microsoft.VisualBasic.CompareMethod -&gt; string[]" Usage="Microsoft.VisualBasic.Strings.Split (Expression, Delimiter, Limit, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
        <Parameter Name="Delimiter" Type="System.String" />
        <Parameter Name="Limit" Type="System.Int32" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. <see langword="String" />-Ausdruck mit untergeordneten Zeichenfolgen und Trennzeichen.</param>
        <param name="Delimiter">Dies ist optional. Jedes einzelne Zeichen, mit dem Grenzen von untergeordneten Zeichenfolgen gekennzeichnet werden. Wenn <c>Delimiter</c> nicht angegeben wird, wird als Trennzeichen das Leerzeichen (" ") angenommen.</param>
        <param name="Limit">Dies ist optional. Die maximale Anzahl von untergeordneten Zeichenfolgen, in die die Eingabezeichenfolge geteilt werden soll. Der Standardwert – 1 gibt an, dass die Eingabezeichenfolge an jedem Vorkommen der <c>Delimiter</c>-Zeichenfolge getrennt werden soll.</param>
        <param name="Compare">Dies ist optional. Numerischer Wert, der den Vergleich angibt, der für das Auswerten von untergeordneten Zeichenfolgen verwendet wird. Die Werte finden Sie unter „Einstellungen“.</param>
        <summary>Gibt ein nullbasiertes, eindimensionales Array zurück, das eine angegebene Anzahl von Teilzeichenfolgen enthält.</summary>
        <returns>
          <see langword="String" />-Array. Wenn <paramref name="Expression" /> eine Zeichenfolge ("") der Länge 0 (null) ist, gibt <see langword="Split" /> ein Array mit einem Element zurück, das eine Zeichenfolge der Länge 0 (null) enthält. Wenn <paramref name="Delimiter" /> eine Zeichenfolge der Länge 0 (null) ist oder nicht in <paramref name="Expression" /> vorkommt, gibt <see langword="Split" /> ein Array mit einem Element zurück, das die gesamte <paramref name="Expression" />-Zeichenfolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig oder wenn `Limit` gleich 1, die `Split` Funktion wird die Eingabezeichenfolge an jedem Vorkommen der Trennzeichenfolge und gibt die Teilzeichenfolgen in einem Array zurück. Wenn die `Limit` -Parameter ist größer als 0 (null), die `Split` Funktion teilt die Zeichenfolge bei der ersten `Limit`-1 Vorkommen des Trennzeichens, und gibt ein Array mit den resultierenden untergeordneten Zeichenfolgen zurück. Z. B. `Split("a:b:c", ":")` gibt das Array `{"a", "b", "c"}`, während `Split("a:b:c", ":", 2)` gibt das Array `{"a", "b:c"}`.  
  
 Wenn die `Split` Funktion zwei Trennzeichen in einer Zeile oder ein Trennzeichen am Anfang oder Ende der Zeichenfolge auftritt, diese so interpretiert, als Sie rund um eine leere Zeichenfolge (""). Z. B. `Split("xx", "x")` das Array mit drei leere Zeichenfolgen zurückgegeben wird: ein vom Anfang der Zeichenfolge und der ersten "x", eine von, einschließlich der zwei "x" Zeichenfolgen und eine der letzten "X" und das Ende der Zeichenfolge.  
  
 Diese Tabelle wird veranschaulicht, wie das optionale `Delimiter`, `Limit`, und `Compare` Parameter können das Verhalten des Ändern der `Split` Funktion.  
  
|Split-Aufruf|Rückgabewert|  
|-|-|  
|`Split("42, 12, 19")`|{"42," , "12," , "19"}|  
|`Split("42, 12, 19", ", ")`|{"42", "12", "19"}|  
|`Split("42, 12, 19", ", ", 2)`|{"42", "12, 19"}|  
|`Split("192.168.0.1", ".")`|{"192", "168", "0", "1"}|  
|`Split("Alice and Bob", " AND ")`|{"Alice und Bob"}|  
|`Split("Alice and Bob", " AND ", ,CompareMethod.Text)`|{"Alice", "Bob"}|  
|`Split("someone@example.com", "@",1)`|{"someone@example.com"}|  
|`Split("someone@example.com", "@",2)`|{"someone", "example.com"}|  
  
 Die `Compare` Argument kann die folgenden Werte haben.  
  
|Konstante|Beschreibung |Wert|  
|-|-|-|  
|`CompareMethod.Binary`|Führt einen binären Vergleich|0|  
|`CompareMethod.Text`|Führt einen Textvergleich|1|  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zum Aufteilen einer Zeichenfolge an ihren Leerzeichen wird.  
  
 [!code-vb[VbVbalrStrings#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#13)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie zum Aufteilen von Zeichenfolgen mit mehreren Trennzeichen in einer Zeile und die leeren Zeichenfolgen herausgefiltert wird.  
  
 [!code-vb[VbVbalrStrings#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.Join" />
        <altmember cref="T:Microsoft.VisualBasic.CompareMethod" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="StrComp">
      <MemberSignature Language="C#" Value="public static int StrComp (string String1, string String2, Microsoft.VisualBasic.CompareMethod Compare = Microsoft.VisualBasic.CompareMethod.Binary);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 StrComp(string String1, string String2, valuetype Microsoft.VisualBasic.CompareMethod Compare) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrComp(System.String,System.String,Microsoft.VisualBasic.CompareMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrComp (String1 As String, String2 As String, Optional Compare As CompareMethod = Microsoft.VisualBasic.CompareMethod.Binary) As Integer" />
      <MemberSignature Language="F#" Value="static member StrComp : string * string * Microsoft.VisualBasic.CompareMethod -&gt; int" Usage="Microsoft.VisualBasic.Strings.StrComp (String1, String2, Compare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="String1" Type="System.String" />
        <Parameter Name="String2" Type="System.String" />
        <Parameter Name="Compare" Type="Microsoft.VisualBasic.CompareMethod">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.VisualBasic.CompilerServices.OptionCompare</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="String1">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <param name="String2">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <param name="Compare">Dies ist optional. Gibt den Typ des Zeichenfolgenvergleichs an. Wenn <c>Compare</c> ausgelassen wird, bestimmt die <see langword="Option Compare" />-Einstellung den Typ des Vergleichs.</param>
        <summary>Gibt abhängig vom Ergebnis eines Zeichenfolgenvergleichs den Wert -1, 0 oder 1 zurück.</summary>
        <returns>Die <see langword="StrComp" />-Funktion besitzt die folgenden Rückgabewerte.  
  
 <list type="table"><item><term> If 
 </term><description> Rückgabewert von StrComp 
 </description></item><item><term><paramref name="String1" /> Sortierung vor <paramref name="String2" /></term><description> -1 
 </description></item><item><term><paramref name="String1" /> ist gleich <paramref name="String2" />.</term><description> 0 
 </description></item><item><term><paramref name="String1" /> Sortierung nach <paramref name="String2" /></term><description> 1 
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolgen werden anhand alphanumerischer ab, mit dem ersten Zeichen verglichen. Weitere Informationen zu binäre Vergleiche Textvergleiche und Sortierreihenfolge zu erhalten, finden Sie unter [Option Compare-Anweisung](~/docs/visual-basic/language-reference/statements/option-compare-statement.md).  
  
 Die `Compare`-Argumenteinstellungen lauten:  
  
|Konstante|Beschreibung |  
|-|-|  
|`Binary`|Führt einen binären Vergleich, basierend auf einer Sortierreihenfolge, die von der internen binären Darstellungen der Zeichen abgeleitet.|  
|`Text`|Führt einen Textvergleich, basierend auf einer schreibungsunabhängigen Textsortierreihenfolge Maßgabe Ihres Systems `LocaleID` Wert.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `StrComp` Funktion, um die Ergebnisse eines Zeichenfolgenvergleichs zurück.  
  
 [!code-vb[VbVbalrStrings#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="Compare" />-Wert ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.InStr" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="StrConv">
      <MemberSignature Language="C#" Value="public static string StrConv (string str, Microsoft.VisualBasic.VbStrConv Conversion, int LocaleID = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public static string StrConv(string str, valuetype Microsoft.VisualBasic.VbStrConv Conversion, int32 LocaleID) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrConv(System.String,Microsoft.VisualBasic.VbStrConv,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrConv (str As String, Conversion As VbStrConv, Optional LocaleID As Integer = 0) As String" />
      <MemberSignature Language="F#" Value="static member StrConv : string * Microsoft.VisualBasic.VbStrConv * int -&gt; string" Usage="Microsoft.VisualBasic.Strings.StrConv (str, Conversion, LocaleID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="Conversion" Type="Microsoft.VisualBasic.VbStrConv" />
        <Parameter Name="LocaleID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. Der zu konvertierende <see langword="String" />-Ausdruck.</param>
        <param name="Conversion">Erforderlich. <see cref="T:Microsoft.VisualBasic.VbStrConv" />-Member. Der Enumerationswert, der den Typ der auszuführenden Konvertierung angibt.</param>
        <param name="LocaleID">Dies ist optional. Der <see langword="LocaleID" />-Wert, wenn dieser sich vom <see langword="LocaleID" />-Wert des Systems unterscheidet. (Der <see langword="LocaleID" />-Wert des Systems ist der Standardwert.)</param>
        <summary>Gibt eine wie angegeben konvertierte Zeichenfolge zurück.</summary>
        <returns>Gibt eine wie angegeben konvertierte Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstanten `VbStrConv.Wide`, `VbStrConv.Narrow`, `VbStrConv.SimplifiedChinese`, `VbStrConv.TraditionalChinese`, `VbStrConv.Katakana`, und `VbStrConv.Hiragana` kann dazu führen, dass Laufzeitfehler bei der Verwendung in Gebietsschemas, in dem sie nicht gelten, aber nicht immer: die Konstanten `VbStrConv.Katakana` und `VbStrConv.Hiragana`können in einem nicht japanischen-System verwendet werden, mit das japanische Sprachpaket installiert. Darüber hinaus verwenden, der Konstanten `VbStrConv.Wide` und `VbStrConv.Narrow` auf jedem System mit eine ostasiatische Sprache installiert werden.  
  
 Diese Funktion verwendet die Informationen zur Kultur der Anwendung, wenn die Zeichenfolge zu bearbeiten, so dass die Groß-/Kleinschreibung Änderungen für das Gebietsschema geeignet sind, in denen die Anwendung verwendet wird.  
  
> [!IMPORTANT]
>  Wenn die Anwendung die Sicherheitsfragen die richtigen Entscheidungen basierend auf dem Ergebnis eines Vergleichs oder einer Änderung der Groß-/Kleinschreibung verwendet, und dann den Vorgang verwenden, sollten die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode, und übergeben Sie <xref:System.StringComparison.Ordinal> oder <xref:System.StringComparison.OrdinalIgnoreCase> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
 Die `Conversion`-Argumenteinstellungen lauten:  
  
|Enumerationsmember|Beschreibung |  
|-|-|  
|`VbStrConv.None`|Führt keine Konvertierung|  
|`VbStrConv.LinguisticCasing`|Verwendet linguistische Regeln für Groß-/Kleinschreibung, anstatt File System (Standard). Mit gültigen `VbStrConv.UpperCase` und `VbStrConv.LowerCase` nur.|  
|`VbStrConv.UpperCase`|Konvertiert die Zeichenfolge in Großbuchstaben.|  
|`VbStrConv.LowerCase`|Konvertiert die Zeichenfolge in Kleinbuchstaben.|  
|`VbStrConv.ProperCase`|Konvertiert den ersten Buchstaben jedes Worts in einer Zeichenfolge in Großbuchstaben.|  
|`VbStrConv.Wide` <sup>*</sup>|Konvertiert schmale Zeichen (halbe Breite), in der Zeichenfolge in Breitzeichen (normale Breite) Zeichen. [!INCLUDE[vbstrconv-wide](~/includes/vbstrconv-wide-md.md)]|  
|`VbStrConv.Narrow` <sup>*</sup>|Konvertiert die Breite (normale Breite)-Zeichen in der Zeichenfolge in schmale (halbe Breite) Zeichen.|  
|`VbStrConv.Katakana` <sup>**</sup>|Konvertiert Hiragana-Zeichen in der Zeichenfolge in Katakana-Zeichen.|  
|`VbStrConv.Hiragana` <sup>**</sup>|Konvertiert Katakana-Zeichen in der Zeichenfolge in Hiragana-Zeichen.|  
|`VbStrConv.SimplifiedChinese` <sup>*</sup>|Konvertiert traditionelle chinesische Zeichen in vereinfachtem Chinesisch an.|  
|`VbStrConv.TraditionalChinese` <sup>*</sup>|Vereinfachte chinesische Zeichen in traditionellem Chinesisch konvertiert.|  
  
 <sup>*</sup> Gilt für asiatische Gebietsschemas.  
  
 <sup>**</sup> Gilt nur für Japan.  
  
> [!NOTE]
>  Diese Konstanten sind in der .NET Framework common Language Runtime angegeben. Daher können sie eine beliebige Stelle im Code anstelle von tatsächlichen Werten verwendet werden. Die meisten kombiniert werden können (z. B. `UpperCase + Wide`), außer wenn sie sich gegenseitig ausschließende sind (z. B. `VbStrConv.Wide + VbStrConv.Narrow`).  
  
 Im folgenden sind die gültigen Worttrennzeichen für Groß-/Kleinschreibung korrekt: Null (`Chr$(0)`), horizontaler Tabulator (`Chr$(9)`), Zeilenvorschub (`Chr$(10)`), vertikaler Tabulator (`Chr$(11)`), Seitenvorschub (`Chr$(12)`), Wagenrücklauf (`Chr$(13)`), Leerzeichen () Einzelbyte-Zeichensatz) (`Chr$(32)`). Der tatsächliche Wert für ein Leerzeichen, was die voller oder halber Breite sein kann, variiert je nach Land/Region für ostasiatische Kulturen.  
  
   
  
## Examples  
 In diesem Beispiel konvertiert Text in Kleinbuchstaben.  
  
 [!code-vb[VbVbalrStrings#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="LocaleID" /> nicht unterstützt, <paramref name="Conversion" /> &lt; 0 oder &gt; 2048, oder nicht unterstützte Konvertierung für das angegebene Gebietsschema.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StrDup">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StrDup">
      <MemberSignature Language="C#" Value="public static string StrDup (int Number, char Character);" />
      <MemberSignature Language="ILAsm" Value=".method public static string StrDup(int32 Number, char Character) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrDup(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrDup (Number As Integer, Character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ StrDup(int Number, char Character);" />
      <MemberSignature Language="F#" Value="static member StrDup : int * char -&gt; string" Usage="Microsoft.VisualBasic.Strings.StrDup (Number, Character)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int32" />
        <Parameter Name="Character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Integer" />-Ausdruck. Die Länge der zurückzugebenden Zeichenfolge.</param>
        <param name="Character">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke, <see langword="String" />-Ausdrücke oder <see langword="Object" />-Ausdrücke. Es wird nur das erste Zeichen des Ausdrucks verwendet. Wenn das Zeichen vom Typ <see langword="Object" /> ist, muss es entweder einen <see langword="Char" />-Wert oder einen <see langword="String" />-Wert enthalten.</param>
        <summary>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine `String` wiederholter Zeichen bestehen. Das Zeichen, das die Zeichenfolge bildet, ist das erste Zeichen in der `Character` Argument, und es wird dupliziert `Number` -Mal.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `StrDup` Funktion zum Zurückgeben einer Zeichenfolge der duplizierten Zeichen.  
  
 [!code-vb[VbVbalrStrings#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Number" /> ist kleiner als 0 (null), oder der <paramref name="Character" />-Typ ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Character" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.ArgumentNullException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="StrDup">
      <MemberSignature Language="C#" Value="public static object StrDup (int Number, object Character);" />
      <MemberSignature Language="ILAsm" Value=".method public static object StrDup(int32 Number, object Character) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrDup(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrDup (Number As Integer, Character As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ StrDup(int Number, System::Object ^ Character);" />
      <MemberSignature Language="F#" Value="static member StrDup : int * obj -&gt; obj" Usage="Microsoft.VisualBasic.Strings.StrDup (Number, Character)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int32" />
        <Parameter Name="Character" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Integer" />-Ausdruck. Die Länge der zurückzugebenden Zeichenfolge.</param>
        <param name="Character">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke, <see langword="String" />-Ausdrücke oder <see langword="Object" />-Ausdrücke. Es wird nur das erste Zeichen des Ausdrucks verwendet. Wenn das Zeichen vom Typ <see langword="Object" /> ist, muss es entweder einen <see langword="Char" />-Wert oder einen <see langword="String" />-Wert enthalten.</param>
        <summary>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine `String` wiederholter Zeichen bestehen. Das Zeichen, das die Zeichenfolge bildet, ist das erste Zeichen in der `Character` Argument, und es wird dupliziert `Number` -Mal.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `StrDup` Funktion zum Zurückgeben einer Zeichenfolge der duplizierten Zeichen.  
  
 [!code-vb[VbVbalrStrings#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Number" /> ist kleiner als 0 (null), oder der <paramref name="Character" />-Typ ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Character" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.ArgumentNullException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="StrDup">
      <MemberSignature Language="C#" Value="public static string StrDup (int Number, string Character);" />
      <MemberSignature Language="ILAsm" Value=".method public static string StrDup(int32 Number, string Character) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrDup(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrDup (Number As Integer, Character As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ StrDup(int Number, System::String ^ Character);" />
      <MemberSignature Language="F#" Value="static member StrDup : int * string -&gt; string" Usage="Microsoft.VisualBasic.Strings.StrDup (Number, Character)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int32" />
        <Parameter Name="Character" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Integer" />-Ausdruck. Die Länge der zurückzugebenden Zeichenfolge.</param>
        <param name="Character">Erforderlich. Alle gültigen <see langword="Char" />-Ausdrücke, <see langword="String" />-Ausdrücke oder <see langword="Object" />-Ausdrücke. Es wird nur das erste Zeichen des Ausdrucks verwendet. Wenn das Zeichen vom Typ <see langword="Object" /> ist, muss es entweder einen <see langword="Char" />-Wert oder einen <see langword="String" />-Wert enthalten.</param>
        <summary>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Objekt zurück, in der bzw. dem das angegebene Zeichen so häufig wie angegeben wiederholt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine `String` wiederholter Zeichen bestehen. Das Zeichen, das die Zeichenfolge bildet, ist das erste Zeichen in der `Character` Argument, und es wird dupliziert `Number` -Mal.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `StrDup` Funktion zum Zurückgeben einer Zeichenfolge der duplizierten Zeichen.  
  
 [!code-vb[VbVbalrStrings#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Number" /> ist kleiner als 0 (null), oder der <paramref name="Character" />-Typ ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Character" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.ArgumentNullException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="StrReverse">
      <MemberSignature Language="C#" Value="public static string StrReverse (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string StrReverse(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.StrReverse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StrReverse (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ StrReverse(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member StrReverse : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.StrReverse Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Zeichenfolgenausdruck, dessen Zeichen umgekehrt werden müssen. Wenn <c>Expression</c> eine Zeichenfolge der Länge 0 ("") ist, wird eine Zeichenfolge der Länge 0 (null) zurückgegeben.</param>
        <summary>Gibt eine Zeichenfolge zurück, in der die Reihenfolge der Zeichen in einer bestimmten Zeichenfolge umgekehrt wurde.</summary>
        <returns>Gibt eine Zeichenfolge zurück, in der die Reihenfolge der Zeichen in einer bestimmten Zeichenfolge umgekehrt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `StrReverse` Funktionsergebnis ist eine Zeichenfolge, die dieselben Zeichen wie enthält `Expression`, aber in umgekehrter Reihenfolge.  
  
   
  
## Examples  
 [!code-vb[VbVbalrStrings#29](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#29)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.InStrRev(System.String,System.String,System.Int32,Microsoft.VisualBasic.CompareMethod)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static string Trim (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Trim(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.Trim(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Trim(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Trim : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.Trim str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Erforderlich. Jeder gültige <see langword="String" />-Ausdruck.</param>
        <summary>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die eine Kopie einer angegebenen Zeichenfolge ohne führende Leerzeichen (<see langword="LTrim" />), ohne nachstehende Leerzeichen (<see langword="RTrim" />) bzw. ohne führende und nachstehende Leerzeichen (<see langword="Trim" />) enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LTrim`, `RTrim`, und `Trim` Funktionen entfernen von Leerzeichen am Ende von Zeichenfolgen.  
  
   
  
## Examples  
 In diesem Beispiel werden mit der `LTrim`-Funktion führende Leerzeichen und mit der `RTrim`-Funktion nachstehende Leerzeichen aus einer Zeichenfolgenvariablen entfernt. Mit der `Trim`-Funktion werden beide Typen von Leerzeichen entfernt.  
  
 [!code-vb[VbVbalrStrings#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Strings.RTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.LTrim(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Left(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Right(System.String,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UCase">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das die angegebene Zeichenfolge in Großbuchstaben enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UCase">
      <MemberSignature Language="C#" Value="public static char UCase (char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static char UCase(char Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.UCase(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function UCase (Value As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char UCase(char Value);" />
      <MemberSignature Language="F#" Value="static member UCase : char -&gt; char" Usage="Microsoft.VisualBasic.Strings.UCase Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Value">Erforderlich. Alle gültigen <see langword="String" />-Ausdrücke oder <see langword="Char" />-Ausdrücke.</param>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das die angegebene Zeichenfolge in Großbuchstaben enthält.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das die angegebene Zeichenfolge in Großbuchstaben enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur aus Kleinbuchstaben konvertiert werden in Großbuchstaben; alle Großbuchstaben und sonstigen Zeichen bleiben unverändert.  
  
 Diese Funktion verwendet die Informationen zur Kultur der Anwendung, wenn die Zeichenfolge zu bearbeiten, so dass die Groß-/Kleinschreibung Änderungen für das Gebietsschema geeignet sind, in denen die Anwendung verwendet wird.  
  
> [!IMPORTANT]
>  Wenn die Anwendung die Sicherheitsfragen die richtigen Entscheidungen basierend auf dem Ergebnis eines Vergleichs oder einer Änderung der Groß-/Kleinschreibung verwendet, und dann den Vorgang verwenden, sollten die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode, und übergeben Sie <xref:System.StringComparison.Ordinal> oder <xref:System.StringComparison.OrdinalIgnoreCase> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
   
  
## Examples  
 In diesem Beispiel wird die `UCase`-Funktion verwendet, um eine Zeichenfolge in Großbuchstaben zurückzugeben:  
  
 [!code-vb[VbVbalrStrings#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.LCase" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="UCase">
      <MemberSignature Language="C#" Value="public static string UCase (string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static string UCase(string Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Strings.UCase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UCase (Value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UCase(System::String ^ Value);" />
      <MemberSignature Language="F#" Value="static member UCase : string -&gt; string" Usage="Microsoft.VisualBasic.Strings.UCase Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Value">Erforderlich. Alle gültigen <see langword="String" />-Ausdrücke oder <see langword="Char" />-Ausdrücke.</param>
        <summary>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das die angegebene Zeichenfolge in Großbuchstaben enthält.</summary>
        <returns>Gibt eine Zeichenfolge oder ein Zeichen zurück, die bzw. das die angegebene Zeichenfolge in Großbuchstaben enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur aus Kleinbuchstaben konvertiert werden in Großbuchstaben; alle Großbuchstaben und sonstigen Zeichen bleiben unverändert.  
  
 Diese Funktion verwendet die Informationen zur Kultur der Anwendung, wenn die Zeichenfolge zu bearbeiten, so dass die Groß-/Kleinschreibung Änderungen für das Gebietsschema geeignet sind, in denen die Anwendung verwendet wird.  
  
> [!IMPORTANT]
>  Wenn die Anwendung die Sicherheitsfragen die richtigen Entscheidungen basierend auf dem Ergebnis eines Vergleichs oder einer Änderung der Groß-/Kleinschreibung verwendet, und dann den Vorgang verwenden, sollten die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode, und übergeben Sie <xref:System.StringComparison.Ordinal> oder <xref:System.StringComparison.OrdinalIgnoreCase> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [wie Kultur wirkt sich auf Zeichenfolgen in Visual Basic](~/docs/visual-basic/programming-guide/language-features/strings/how-culture-affects-strings.md).  
  
   
  
## Examples  
 In diesem Beispiel wird die `UCase`-Funktion verwendet, um eine Zeichenfolge in Großbuchstaben zurückzugeben:  
  
 [!code-vb[VbVbalrStrings#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStrings/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.Strings.LCase" />
        <related type="Article" href="~/docs/visual-basic/language-reference/keywords/string-manipulation-summary.md">Zeichenfolgenbearbeitung: Zusammenfassung</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/index.md">Zeichenfolgen in Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/strings/introduction-to-strings.md">Einführung in Zeichenfolgen in Visual Basic</related>
      </Docs>
    </Member>
  </Members>
</Type>