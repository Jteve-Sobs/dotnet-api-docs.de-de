<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d54134cd8f60933b55014a55198345e51b40b2a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37712002" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Eigenschaften und Methoden für die Arbeit mit Laufwerken, Dateien und Verzeichnissen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem` Objekt.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Lesen aus einer Binärdatei|[Gewusst wie: Lesen aus Binärdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lesen aus einer Textdatei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Fügen Sie in eine Textdatei|[Gewusst wie: Anfügen an Textdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Schreiben in eine Binärdatei|[Gewusst wie: Schreiben in Binärdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Schreiben in Textdateien in das **MyDocuments** Verzeichnis|[Gewusst wie: Schreiben von Text in Dateien im Verzeichnis „Eigene Dokumente“](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Schreiben in eine Textdatei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Kopieren von Dateien mit einem bestimmten Muster|[Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Kopieren einer Datei in dasselbe Verzeichnis|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Erstellen Sie eine Datei|[Gewusst wie: Erstellen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Löschen einer Datei|[Gewusst wie: Löschen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Suchen nach Dateien mit einem bestimmten Muster|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Umbenennen einer Datei|[Gewusst wie: Umbenennen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Kopieren eines Verzeichnisses in ein anderes Verzeichnis|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Erstellen eines Verzeichnisses|[Gewusst wie: Erstellen eines Verzeichnisses](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Suchen nach Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Ruft die Auflistung der Dateien in einem Verzeichnis|[Gewusst wie: Abrufen einer Sammlung von Dateien in einem Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Lesen aus der **MyDocuments** Verzeichnis|[Gewusst wie: Abrufen des Inhalts des Verzeichnisses „Eigene Dokumente“](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analysieren Sie einen Dateipfad|[Gewusst wie: Analysieren von Dateipfaden](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, um zu bestimmen, ob der Ordner `C:\backup\logs` vorhanden ist und seine Eigenschaften werden überprüft.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objekte (Visual Basic)](http://msdn.microsoft.com/library/651c73e4-dca8-402b-9c6b-e3902b3a3f4b)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" /> Erster Pfad, der kombiniert werden soll.</param>
        <param name="relativePath">
          <see langword="String" /> Zweiter Pfad, der kombiniert werden soll.</param>
        <summary>Verknüpft zwei Pfade und gibt einen ordnungsgemäß formatierten Pfad zurück.</summary>
        <returns>Die Kombination der angegebenen Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entfernt zusätzliche Schrägstriche, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CombinePath` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kombiniert einen Verzeichnisnamen Pfad und Dateiname|[Vorgehensweise: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Dieses Beispiel kombiniert einen Verzeichnisnamen Pfad und Dateiname einen ordnungsgemäß formatierten Pfad erstellen.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Dieses Beispiel kombiniert zwei Pfade aus, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 In diesem Beispiel zurückgegeben `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> oder <paramref name="relativePath" /> sind fehlerhafte Pfade.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Quellverzeichnisses in das Zielverzeichnis an. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn ein Verzeichnis mit dem gleichen Namen am Zielspeicherort vorhanden ist, wird der Inhalt der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien innerhalb eines Verzeichnisses können Ausnahmen ausgelöst werden, die verursacht werden durch eine bestimmte Datei. Wenn solche Ausnahmen ausgelöst werden, sie sind zusammengefasst zu einer einzigen Ausnahme, deren `Data` -Eigenschaft Einträge enthält, in Form einer <xref:System.Collections.IDictionary> in dem die Datei- oder Verzeichnispfad ist der Schlüssel, und die spezifische Ausnahmemeldung befindet sich der entsprechende Wert. Verwendung `For…Each` zum Auflisten der Einträge.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Vorgehensweise: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Das folgende Beispiel kopiert den Inhalt des Verzeichnisses `TestDirectory1` in `TestDirectory2`, wobei vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie dies `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten und den Speicherort, zu dem Sie sie kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Quellverzeichnisses in das Zielverzeichnis an. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn ein Verzeichnis mit dem gleichen Namen am Zielspeicherort vorhanden ist, wird der Inhalt der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien innerhalb eines Verzeichnisses können Ausnahmen ausgelöst werden, die verursacht werden durch eine bestimmte Datei. Wenn solche Ausnahmen ausgelöst werden, sie sind zusammengefasst zu einer einzigen Ausnahme, deren `Data` -Eigenschaft Einträge enthält, in Form einer <xref:System.Collections.IDictionary> in dem die Datei- oder Verzeichnispfad ist der Schlüssel, und die spezifische Ausnahmemeldung befindet sich der entsprechende Wert. Verwendung `For…Each` zum Auflisten der Einträge.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Vorgehensweise: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Das folgende Beispiel kopiert den Inhalt des Verzeichnisses `TestDirectory1` in `TestDirectory2`, wobei vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie dies `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten und den Speicherort, zu dem Sie sie kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="overwrite">
          <see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Quellverzeichnisses in das Zielverzeichnis an. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn ein Verzeichnis mit dem gleichen Namen am Zielspeicherort vorhanden ist, wird der Inhalt der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien innerhalb eines Verzeichnisses können Ausnahmen ausgelöst werden, die verursacht werden durch eine bestimmte Datei, z. B. eine Datei, die während einer Zusammenführung beim vorhanden `overwrite` nastaven NA hodnotu `False`. Wenn solche Ausnahmen ausgelöst werden, sie sind zusammengefasst zu einer einzigen Ausnahme, deren `Data` -Eigenschaft Einträge enthält, in Form einer <xref:System.Collections.IDictionary> in dem die Datei- oder Verzeichnispfad ist der Schlüssel, und die spezifische Ausnahmemeldung befindet sich der entsprechende Wert. Verwendung `For…Each` zum Auflisten der Einträge.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Vorgehensweise: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Das folgende Beispiel kopiert den Inhalt des Verzeichnisses `TestDirectory1` in `TestDirectory2`, wobei vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie dies `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten und den Speicherort, zu dem Sie sie kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Quellverzeichnisses in das Zielverzeichnis an. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn ein Verzeichnis mit dem gleichen Namen am Zielspeicherort vorhanden ist, wird der Inhalt der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien innerhalb eines Verzeichnisses können Ausnahmen ausgelöst werden, die verursacht werden durch eine bestimmte Datei. Wenn solche Ausnahmen ausgelöst werden, sie sind zusammengefasst zu einer einzigen Ausnahme, deren `Data` -Eigenschaft Einträge enthält, in Form einer <xref:System.Collections.IDictionary> in dem die Datei- oder Verzeichnispfad ist der Schlüssel, und die spezifische Ausnahmemeldung befindet sich der entsprechende Wert. Verwendung `For…Each` zum Auflisten der Einträge.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Vorgehensweise: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Das folgende Beispiel kopiert den Inhalt des Verzeichnisses `TestDirectory1` in `TestDirectory2`, wobei vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie dies `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten und den Speicherort, zu dem Sie sie kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ACEs (Access Control Entries) beibehalten nicht. Die neu erstellte Datei erbt die Standard-ACEs aus dem Verzeichnis, in dem es erstellt wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.CopyFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren einer Datei in dasselbe Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei im gleichen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` und benennt es `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Zielverzeichnis mit demselben Namen wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ACEs (Access Control Entries) beibehalten nicht. Die neu erstellte Datei erbt die Standard-ACEs aus dem Verzeichnis, in dem es erstellt wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.CopyFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren einer Datei in dasselbe Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei im gleichen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` und benennt es `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="overwrite">
          <see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ACEs (Access Control Entries) beibehalten nicht. Die neu erstellte Datei erbt die Standard-ACEs aus dem Verzeichnis, in dem es erstellt wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.CopyFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren einer Datei in dasselbe Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei im gleichen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` und benennt es `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ACEs (Access Control Entries) beibehalten nicht. Die neu erstellte Datei erbt die Standard-ACEs aus dem Verzeichnis, in dem es erstellt wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.CopyFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren einer Datei in dasselbe Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei im gleichen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis.|[Vorgehensweise: Erstellen Sie eine Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 In diesem Beispiel kopiert die Datei `Test.txt` in das Verzeichnis `TestFiles2` und benennt es `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Pfade der Dateien mit den Pfaden, die Sie in Ihrem Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Name und der Speicherort des Verzeichnisses.</param>
        <summary>Erstellt ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis bereits vorhanden ist, werden keine Ausnahmen ausgelöst.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CreateDirectory` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Erstellen eines Verzeichnisses|[Vorgehensweise: erstellen ein Verzeichnisses in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel erstellt das Verzeichnis, `NewDirectory`im `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name des Verzeichnisses ist falsch formatiert. Er enthält beispielsweise unzulässige Zeichen oder besteht nur aus Leerzeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Verzeichnisname ist zu lang.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname besteht nur aus einem Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.IOException">Das übergeordnete Verzeichnis des zu erstellenden Verzeichnisses ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer ist nicht zum Erstellen des Verzeichnisses berechtigt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Verzeichnis ab oder legt dieses fest.</summary>
        <value>Das aktuelle Verzeichnis für Datei-E/A-Operationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` ist eine systemweite Umgebungsvariablen.  
  
   
  
## Examples  
 In diesem Beispiel wird das aktuelle Verzeichnis zurückgegeben und in einem Meldungsfeld angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 In diesem Beispiel wird das aktuelle Verzeichnis zu `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist nicht gültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="onDirectoryNotEmpty">Gibt an, was geschehen soll, wenn ein Verzeichnis, das gelöscht werden soll, Dateien oder Verzeichnisse enthält. Der Standardwert ist <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im Beispiel löscht das Verzeichnis `OldDirectory` nur, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und alle von dessen Inhalt, den Benutzer auffordert, den Löschvorgang zu bestätigen, sendet Sie aber nicht den Inhalt in die **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt, senden sie die **Papierkorb**, jedoch nicht den Status des Vorgangs.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI` und `recycle` Parameter werden in Anwendungen, die nicht interaktive, z. B. Windows Services-Benutzer sind nicht unterstützt.  
  
   
  
## Examples  
 Im Beispiel löscht das Verzeichnis `OldDirectory` nur, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und alle von dessen Inhalt, den Benutzer auffordert, den Löschvorgang zu bestätigen, sendet Sie aber nicht den Inhalt in die **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt, senden sie die **Papierkorb**, jedoch nicht den Status des Vorgangs.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der Benutzer auf **Abbrechen** klickt.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`, `recycle`, und `onUserCancel` Parameter werden in Anwendungen, die nicht interaktive, z. B. Windows Services-Benutzer sind nicht unterstützt.  
  
   
  
## Examples  
 Im Beispiel löscht das Verzeichnis `OldDirectory` nur, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und alle von dessen Inhalt, den Benutzer auffordert, den Löschvorgang zu bestätigen, sendet Sie aber nicht den Inhalt in die **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel löscht das Verzeichnis `OldDirectory` und seinen gesamten Inhalt, senden sie die **Papierkorb**, jedoch nicht den Status des Vorgangs.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Zum Löschen einer Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei gelöscht `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und ermöglicht dem Benutzer, um sicherzustellen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und sendet sie an der **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI` und `recycle` Parameter werden in Anwendungen, die nicht interaktive, z. B. Windows Services-Benutzer sind nicht unterstützt.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Zum Löschen einer Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei gelöscht `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und ermöglicht dem Benutzer, um sicherzustellen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und sendet sie an der **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`, `recycle`, und `onUserCancel` Parameter werden in Anwendungen, die nicht interaktive, z. B. Windows Services-Benutzer sind nicht unterstützt.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Zum Löschen einer Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei gelöscht `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und ermöglicht dem Benutzer, um sicherzustellen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei gelöscht `Test.txt` und sendet sie an der **Papierkorb**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer hat den Vorgang abgebrochen, und <paramref name="onUserCancel" /> ist auf <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad des Verzeichnisses.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn das angegebene Verzeichnis vorhanden ist.</summary>
        <returns>
          <see langword="True" />, wenn das Verzeichnis vorhanden ist, andernfalls <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird bestimmt, ob das Verzeichnis `C:\backup\logs` vorhanden ist und seine Eigenschaften werden überprüft.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung aller verfügbaren Laufwerknamen zurück.</summary>
        <value>Eine schreibgeschützte Auflistung aller verfügbaren Laufwerke als <see cref="T:System.IO.DriveInfo" />-Objekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt aller logischen Datenträger zurück.  
  
   
  
## Examples  
 In diesem Beispiel zeigt den Namen der verfügbaren Laufwerke in einem Meldungsfeld an.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn die angegebene Datei vorhanden ist.</summary>
        <returns>Diese Methode gibt <see langword="True" /> zurück, wenn die Datei vorhanden ist, andernfalls gibt sie <see langword="False" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung nicht über ausreichende Berechtigungen zum Lesen der angegebenen Datei, verfügt die `FileExists` Methodenrückgabe `False`, unabhängig vom Vorhandensein des Pfads wird die Methode keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, ob die Datei `Check.txt` vorhanden ist, und die Informationen in einem Meldungsfeld.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Datei endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase">
          <see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.FindInFiles` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Durchsuchen eines Verzeichnisses nach Dateien mit einer bestimmten Zeichenfolge|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis durchsucht `C:\TestDir` für alle Dateien, die mit der Zeichenfolge `"sample string"` und zeigt die Ergebnisse in `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Das Projekt muss für die Arbeit enthalten eine `ListBox` mit dem Namen `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase">
          <see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.FindInFiles` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Durchsuchen eines Verzeichnisses nach Dateien mit einer bestimmten Zeichenfolge|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis durchsucht `C:\TestDir` für alle Dateien, die mit der Zeichenfolge `"sample string"` und zeigt die Ergebnisse in `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Das Projekt muss für die Arbeit enthalten eine `ListBox` mit dem Namen `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetDirectories` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Vorgehensweise: Suchen nach Unterverzeichnissen mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Das folgende Beispiel gibt alle Verzeichnisse in der Verzeichnisstruktur mit dem Wort `Logs` in ihren Namen und fügt sie `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster für den Namensvergleich.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den `wildcards` -Parameter verwenden, um ein bestimmtes Muster anzugeben. Wenn Sie den Inhalt der Unterverzeichnisse in Ihre Suche mit einbeziehen möchten, legen Sie den `searchType`-Parameter auf `SearchAllSubDirectories` fest.  
  
 Es wird eine leere Auflistung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetDirectories` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Vorgehensweise: Suchen nach Unterverzeichnissen mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Das folgende Beispiel gibt alle Verzeichnisse in der Verzeichnisstruktur mit dem Wort `Logs` in ihren Namen und fügt sie `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens eines der angegebenen Platzhalterzeichen ist <see langword="Nothing" />, eine leere Zeichenfolge oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" /> Pfad des Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad ein <see cref="T:System.IO.DirectoryInfo" />-Objekt zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DirectoryInfo" />-Objekt für den angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis nicht vorhanden ist, eine Ausnahme wird nicht ausgelöst, bis zum ersten Mal eine Eigenschaft auf die <xref:System.IO.DirectoryInfo> Objekt zugegriffen wird.  
  
   
  
## Examples  
 In diesem Beispiel wird eine <xref:System.IO.DirectoryInfo> Objekt für das Verzeichnis `C:\Documents and Settings` und zeigt des Verzeichnis der Zeitpunkt der Erstellung, letzte Zugriffszeit und letzte Schreibzeit.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Das zu überprüfende Laufwerk.</param>
        <summary>Gibt ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.DriveInfo> Klasse modelliert ein Laufwerk und stellt Methoden und Eigenschaften zum Laufwerk Informationen Abfragen. Verwendung <xref:System.IO.DriveInfo> um zu bestimmen, welche Laufwerke verfügbar sind und welche Art von Laufwerken werden. Sie können auch die Eigenschaft, um die Kapazität und der verfügbare freie Speicherplatz auf dem Laufwerk ermitteln Abfragen.  
  
   
  
## Examples  
 In diesem Beispiel erhält eine <xref:System.IO.DriveInfo> Objekt für das Laufwerk C und zum Anzeigen von Informationen über das Laufwerk verwendet.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Weitere Informationen zu den anderen Laufwerk, finden Sie unter <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="drive" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei zurück.</summary>
        <returns>Ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme wird nicht ausgelöst, wenn die Datei nicht vorhanden ist; Sie werden stattdessen beim ersten ausgelöst werden, auf die Eigenschaften des Objekts zugegriffen werden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetFileInfo` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Bestimmen Sie Name und Pfad einer Datei|[Vorgehensweise: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Ruft ab, in diesem Beispiel wird eine <xref:System.IO.FileInfo?displayProperty=nameWithType> Objekt für die Datei `MyLogFile.log` und wird verwendet, um den vollständigen Namen der Datei, Zeitpunkt des letzten Zugriffs und Länge zu melden.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfadname ist falsch formatiert. Er enthält beispielsweise ungültige Zeichen oder besteht nur aus Leerzeichen. Der Dateiname enthält einen nachgestellten Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.NotSupportedException">Der Pfad enthält einen Doppelpunkt in der Mitte der Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad ist zu lang.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt über keinen ACL (Access Control List)-Zugriff auf die Datei.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.GetFiles` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Ruft die Auflistung der Dateien in einem Verzeichnis|[Vorgehensweise: Abrufen der Sammlung von Dateien in einem Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Vorgehensweise: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung zurückgegeben `.txt` hinzugefügt `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.GetFiles` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Ruft die Auflistung der Dateien in einem Verzeichnis|[Vorgehensweise: Abrufen der Sammlung von Dateien in einem Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Vorgehensweise: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung zurückgegeben `.txt` hinzugefügt `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 In diesem Beispiel benötigen Sie eine `ListBox` mit dem Namen `ListBox1` in Ihrem Formular.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Erforderlich. Der zu analysierende Pfad. <see langword="String" /></param>
        <summary>Analysiert den Dateinamen aus dem bereitgestellten Pfad.</summary>
        <returns>Der Dateiname aus dem angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Zeichenfolgenoperation; die `FileSystem` wird nicht überprüft.  
  
 Die `GetName` Methode ignoriert Schrägstriche am Ende des Pfads.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetFileName` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Analysieren Sie einen Dateipfad|[Vorgehensweise: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Dateipfad analysiert und gibt den Namen der Datei zurück.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Ersetzen Sie den Pfad `C:\Testdirectory\Testfile` mit dem Pfad, die Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu überprüfende Pfad.</param>
        <summary>Gibt den übergeordneten Pfad des bereitgestellten Pfades zurück.</summary>
        <returns>Der übergeordnete Pfad des bereitgestellten Pfads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Zeichenfolgenoperation; das Dateisystem wird nicht überprüft.  
  
   
  
## Examples  
 In diesem Beispiel ruft den übergeordneten Pfad für `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad verfügt über keinen übergeordneten Pfad, weil er ein Stammpfad ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine eindeutig benannte temporäre Datei mit einer Größe von 0 Byte auf dem Datenträger und gibt den vollständigen Pfad dieser Datei zurück.</summary>
        <returns>Ein <see langword="String" />, der den vollständigen Pfad der temporären Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um eine temporäre Datei zu erstellen.  
  
   
  
## Examples  
 In diesem Beispiel wird eine temporäre Datei erstellt und gibt den Pfad.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis in ein Verzeichnis zu verschieben, die nicht vorhanden ist, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`, überschreiben das Verzeichnis bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Quelle ist ein Stammverzeichnis, oder der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis in ein Verzeichnis zu verschieben, die nicht vorhanden ist, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`, überschreiben das Verzeichnis bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="overwrite">
          <see langword="True" />, wenn vorhandene Verzeichnisse überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis in ein Verzeichnis zu verschieben, die nicht vorhanden ist, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`, überschreiben das Verzeichnis bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis in ein Verzeichnis zu verschieben, die nicht vorhanden ist, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel verschiebt `Directory1` in `Directory2`, überschreiben das Verzeichnis bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und ein Unterverzeichnis der Datei kann nicht kopiert werden.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und der Benutzer bricht den Vorgang ab, oder der Vorgang kann nicht abgeschlossen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird es erstellt.  
  
 Die `MoveFile` Methode behält ACEs (Access Control Entries), die nur beim Verschieben der Datei, in dem gleichen Volume. Dies schließt die geerbten ACEs, die direkte ACEs (direkte ACEs haben Vorrang vor geerbten Entries, ACEs) bewegt werden. Wenn eine Datei zwischen Volumes verschoben wird, werden die ACEs nicht kopiert werden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: verschieben eine Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2` und benennt es `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird es erstellt.  
  
 Die `MoveFile` Methode behält ACEs (Access Control Entries), die nur beim Verschieben der Datei, in dem gleichen Volume. Dies schließt die geerbten ACEs, die direkte ACEs (direkte ACEs haben Vorrang vor geerbten Entries, ACEs) bewegt werden. Wenn eine Datei zwischen Volumes verschoben wird, werden die ACEs nicht kopiert werden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: verschieben eine Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2` und benennt es `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="overwrite">
          <see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird es erstellt.  
  
 Die `MoveFile` Methode behält ACEs (Access Control Entries), die nur beim Verschieben der Datei, in dem gleichen Volume. Dies schließt die geerbten ACEs, die direkte ACEs (direkte ACEs haben Vorrang vor geerbten Entries, ACEs) bewegt werden. Wenn eine Datei zwischen Volumes verschoben wird, werden die ACEs nicht kopiert werden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: verschieben eine Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2` und benennt es `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird es erstellt.  
  
 Die `MoveFile` Methode behält ACEs (Access Control Entries), die nur beim Verschieben der Datei, in dem gleichen Volume. Dies schließt die geerbten ACEs, die direkte ACEs (direkte ACEs haben Vorrang vor geerbten Entries, ACEs) bewegt werden. Wenn eine Datei zwischen Volumes verschoben wird, werden die ACEs nicht kopiert werden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: verschieben eine Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` zu `TestDir2` und benennt es `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Steuert die Fähigkeit, den Zugriff auf alle Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Steuert die Fähigkeit, auf Registrierungsvariablen zugreifen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Steuert die Berechtigungen, die im Zusammenhang mit der Benutzeroberfläche und die Zwischenablage. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z.B. Protokolle, sowohl einfach, als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.OpenTextFieldParser` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Vorgehensweise: Lesen aus durch Trennzeichen getrennte Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Vorgehensweise: Lesen aus Textdateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Vorgehensweise: Lesen aus Textdateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet der `TextFieldParser.reader` und verwendet ihn zum Lesen aus `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Beschreibt einen Satz von Sicherheitsberechtigungen, die auf Code angewendet werden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="fieldWidths">Die Breiten der Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.OpenTextFieldParser` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Vorgehensweise: Lesen aus durch Trennzeichen getrennte Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Vorgehensweise: Lesen aus Textdateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Vorgehensweise: Lesen aus Textdateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet der `TextFieldParser.reader` und verwendet ihn zum Lesen aus `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Beschreibt einen Satz von Sicherheitsberechtigungen, die auf Code angewendet werden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="delimiters">Trennzeichen für die Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.OpenTextFieldParser` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Vorgehensweise: Lesen aus durch Trennzeichen getrennte Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Vorgehensweise: Lesen aus Textdateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Vorgehensweise: Lesen aus Textdateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet der `TextFieldParser.reader` und verwendet ihn zum Lesen aus `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Beschreibt einen Satz von Sicherheitsberechtigungen, die auf Code angewendet werden. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns>
          <see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur-Text-Dateien gelesen werden können, mit einem <xref:System.IO.StreamReader>.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileReader` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Vorgehensweise: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei geöffnet `Testfile.txt`, es wird eine Zeile aus und zeigt die Zeile in einer `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <param name="encoding">Die für den Inhalt der Datei zu verwendende Codierung. Der Standardwert ist ASCII.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns>
          <see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur-Text-Dateien gelesen werden können, mit einem <xref:System.IO.StreamReader>.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileReader` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Vorgehensweise: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei geöffnet `Testfile.txt`, es wird eine Zeile aus und zeigt die Zeile in einer `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append">
          <see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter` -Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann zurück, die <xref:System.IO.StreamWriter> Objekt für den Stream. Sie können in den Datenstrom als beliebig oft geschrieben und schließen sie dann, wenn Sie fertig sind.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.IO.StreamWriter.Close%2A> Methode für die <xref:System.IO.StreamWriter> Objekt, um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben.  
  
 Wenn Sie nur ein paar Zeichenfolgen in eine Datei schreiben, ist es möglicherweise einfacher, den <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> Methode.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Vorgehensweise: Schreiben von Text in Dateien mit einem StreamWriter in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet ein <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter` Methode und verwendet ihn zum Schreiben einer Zeichenfolge in eine Textdatei mit der `WriteLine` -Methode der der `StreamWriter` Klasse.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append">
          <see langword="True" />, wenn Daten an den Inhalt in der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <param name="encoding">Die Codierung, die beim Schreiben in die Datei verwendet werden soll. Der Standardwert ist ASCII.</param>
        <summary>Öffnet einen <see cref="T:System.IO.StreamWriter" />, der in die angegebene Datei geschrieben werden soll.</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter` -Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann zurück, die <xref:System.IO.StreamWriter> Objekt für den Stream. Sie können in den Datenstrom als beliebig oft geschrieben und schließen sie dann, wenn Sie fertig sind.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.IO.StreamWriter.Close%2A> Methode für die <xref:System.IO.StreamWriter> Objekt, um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben.  
  
 Wenn Sie nur ein paar Zeichenfolgen in eine Datei schreiben, ist es möglicherweise einfacher, den <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> Methode.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Vorgehensweise: Schreiben von Text in Dateien mit einem StreamWriter in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet ein <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter` Methode und verwendet ihn zum Schreiben einer Zeichenfolge in eine Textdatei mit der `WriteLine` -Methode der der `StreamWriter` Klasse.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Gibt den Inhalt einer Datei als Bytearray zurück.</summary>
        <returns>Ein <see langword="Byte" />-Array mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllBytes` Methode der `My.Computer.FileSystem` Objekt ermöglicht Ihnen das Lesen aus einer Binärdatei. Der Inhalt der Datei werden als ein Byte-Array zurückgegeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllBytes` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Binärdatei|[Vorgehensweise: Lesen von Binärdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest aus der Datei `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei werden als Zeichenfolge zurückgegeben.  
  
 Die dateicodierung kann angegeben werden, wenn der Inhalt der Datei in einer Codierung wie ASCII oder UTF-8. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie angeben, die mit einer anderen Überladung der dateicodierung die <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> Methode.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllText` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest den Inhalt der `Test.txt` in eine Zeichenfolge, und klicken Sie dann in einem Meldungsfeld wird angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel liest den Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge, und klicken Sie dann in einem Meldungsfeld wird angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <param name="encoding">Die Zeichencodierung, die beim Lesen der Datei verwendet werden soll. Die Standardeinstellung ist UTF-8.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei werden als Zeichenfolge zurückgegeben.  
  
 Die dateicodierung kann angegeben werden, wenn der Inhalt der Datei in einer Codierung wie ASCII oder UTF-8. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie die dateicodierung anzugeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllText` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest den Inhalt der `Test.txt` in eine Zeichenfolge, und klicken Sie dann in einem Meldungsfeld wird angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel liest den Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge, und klicken Sie dann in einem Meldungsfeld wird angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad und der Name des umzubenennenden Verzeichnisses.</param>
        <param name="newName">Neuer Name für das Verzeichnis.</param>
        <summary>Benennt ein Verzeichnis um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht verwendet werden, um ein Verzeichnis zu verschieben; Verwenden Sie die `MoveDirectory` Methode zum Verschieben und Umbenennen des Verzeichnisses.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Test` Verzeichnis `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> ist <see langword="Nothing" />.  Oder:  <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die umbenannt werden soll.</param>
        <param name="newName">Neuer Name der Datei.</param>
        <summary>Benennt eine Datei um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht dazu verwendet werden, um eine Datei zu verschieben; verwenden Sie die <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A>-Methode, um die Datei zu verschieben und umzubenennen.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.RenameFile` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Umbenennen einer Datei|[Vorgehensweise: Umbenennen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` zu `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Änderung "`C:\Test.txt`" auf den Pfad und Namen der Datei, die Sie umbenennen möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> enthält Pfadinformationen oder endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.  Oder:  <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Der Pfad und Name der Datei, in die geschrieben werden soll.</param>
        <param name="data">Die in die Datei zu schreibenden Daten.</param>
        <param name="append">
          <see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Daten in eine Binärdatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Pfad, mit dem Dateinamen nicht gültig ist, ist eine <xref:System.IO.DirectoryNotFoundException> Ausnahme ausgelöst. Wenn der Pfad gültig ist, aber die Datei ist nicht vorhanden, wird die Datei erstellt.  
  
> [!NOTE]
>  Die `WriteAllBytes` Methode öffnet eine Datei schreibt, und klicken Sie dann geschlossen wird. Code, verwendet der `WriteAllBytes` Methode ist einfacher als Code, der verwendet eine <xref:System.IO.BinaryWriter> Objekt. Jedoch, wenn Sie Daten in eine Datei mit einer Schleife, Hinzufügen einer <xref:System.IO.BinaryWriter> Objekt kann eine bessere Leistung bieten, da Sie nur zum Öffnen und schließen die Datei einmal.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.WriteAllBytes` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben in eine Binärdatei|[Vorgehensweise: Schreiben in Binärdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Datenarray `CustomerData` in die Datei `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Text in eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append">
          <see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UTF-8-Codierung wird verwendet, in die Datei geschrieben wird. Um eine andere Codierung anzugeben, verwenden Sie eine andere Überladung von der <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> Methode.  
  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei übereinstimmt, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText` Methode öffnet eine Datei schreibt, und klicken Sie dann geschlossen wird. Code, verwendet der `WriteAllText` Methode ist einfacher als Code, der verwendet eine <xref:System.IO.StreamWriter> Objekt. Jedoch, wenn Sie Zeichenfolgen in eine Datei hinzufügen mithilfe einer Schleife, einer <xref:System.IO.StreamWriter> Objekt kann eine bessere Leistung bieten, da Sie nur zum Öffnen und schließen die Datei einmal. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.WriteAllText` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei|[Vorgehensweise: Schreiben von Text in Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anfügen von Text an eine Datei|[Vorgehensweise: Anfügen an Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel schreibt die Zeile `"This is new text to be added."` in die Datei `Test.txt`, jeden vorhandenen Text in der Datei überschreiben.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel schreibt die Namen der Dateien in die `Documents and Settings` Ordner `FileList.txt`, Einfügen von einem Wagenrücklauf zur besseren Lesbarkeit zurück.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append">
          <see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll.</param>
        <param name="encoding">Die beim Schreiben in die Datei zu verwendende Codierung.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei übereinstimmt, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText` Methode öffnet eine Datei schreibt, und klicken Sie dann geschlossen wird. Code, verwendet der `WriteAllText` Methode ist einfacher als Code, der verwendet eine <xref:System.IO.StreamWriter> Objekt. Jedoch, wenn Sie Zeichenfolgen in eine Datei hinzufügen mithilfe einer Schleife, einer <xref:System.IO.StreamWriter> Objekt kann eine bessere Leistung bieten, da Sie nur zum Öffnen und schließen die Datei einmal. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `My.Computer.FileSystem.WriteAllText` Methode.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei|[Vorgehensweise: Schreiben von Text in Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anfügen von Text an eine Datei|[Vorgehensweise: Anfügen an Textdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel schreibt die Zeile `"This is new text to be added."` in die Datei `Test.txt`, jeden vorhandenen Text in der Datei überschreiben.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel schreibt die Namen der Dateien in die `Documents and Settings` Ordner `FileList.txt`, Einfügen von einem Wagenrücklauf zur besseren Lesbarkeit zurück.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Steuert die Fähigkeit, auf Dateien und Ordner zuzugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>