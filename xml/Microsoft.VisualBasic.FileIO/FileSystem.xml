<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c04cfb999352058df271e39e2c25f2d6035fdc07" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78804566" /></Metadata><TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
    <AssemblyVersion>10.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Eigenschaften und Methoden für die Arbeit mit Laufwerken, Dateien und Verzeichnissen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben im Zusammenhang mit dem `My.Computer.FileSystem` Objekt aufgeführt.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Lesen aus einer Binärdatei|[Gewusst wie: Lesen aus Binärdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lesen aus einer Textdatei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|An eine Textdatei anfügen|[Gewusst wie: Anfügen an Textdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Schreiben in eine Binärdatei|[Gewusst wie: Schreiben in Binärdateien](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Schreiben in Textdateien im Verzeichnis " **MyDocuments** "|[Gewusst wie: Schreiben von Text in Dateien im Verzeichnis „Eigene Dokumente“](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Schreiben in eine Textdatei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Kopieren von Dateien mit einem bestimmten Muster|[Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Datei in dasselbe Verzeichnis kopieren|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren einer Datei in ein anderes Verzeichnis|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Erstellen von Dateien|[Gewusst wie: Erstellen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Löschen einer Datei|[Gewusst wie: Löschen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Suchen nach Dateien mit einem bestimmten Muster|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Umbenennen einer Datei|[Gewusst wie: Umbenennen einer Datei](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Kopieren eines Verzeichnisses in ein anderes Verzeichnis|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Erstellen eines Verzeichnisses|[Gewusst wie: Erstellen eines Verzeichnisses](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Suchen nach Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Abrufen einer Sammlung von Dateien in einem Verzeichnis](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Aus dem Verzeichnis " **MyDocuments** " lesen|[Gewusst wie: Abrufen des Inhalts des Verzeichnisses „Eigene Dokumente“](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analysieren eines Dateipfads|[Gewusst wie: Analysieren von Dateipfaden](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, um zu bestimmen, ob der Ordner `C:\backup\logs` vorhanden ist, und seine Eigenschaften überprüft.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objekte (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objekte (Visual Basic)](~/docs/visual-basic/language-reference/objects/index.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CombinePath(string baseDirectory, string relativePath) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" /> Erster Pfad, der kombiniert werden soll.</param>
        <param name="relativePath"><see langword="String" /> Zweiter Pfad, der kombiniert werden soll.</param>
        <summary>Verknüpft zwei Pfade und gibt einen ordnungsgemäß formatierten Pfad zurück.</summary>
        <returns>Die Kombination der angegebenen Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schneidet überflüssige Zeichen, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CombinePath`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verzeichnispfad und Dateiname kombinieren|[Gewusst wie: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 In diesem Beispiel werden ein Verzeichnispfad und ein Dateiname kombiniert, um einen korrekt formatierten Pfad zu erstellen.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 In diesem Beispiel werden zwei Pfade kombiniert, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird `C:\Dir1\Dir2\Dir4\Dir5\File.txt`zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseDirectory" /> oder <paramref name="relativePath" /> sind fehlerhafte Pfade.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird der Inhalt des Quell Verzeichnisses in das Zielverzeichnis kopiert. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#94)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird der Inhalt des Quell Verzeichnisses in das Zielverzeichnis kopiert. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Inhalte der Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert, und es werden Status Dialogfelder und Fehler Dialogfelder angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#92)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird der Inhalt des Quell Verzeichnisses in das Zielverzeichnis kopiert. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden, z. b. eine Datei, die während eines Merge vorhanden ist, während `overwrite` auf `False`festgelegt ist. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Inhalte der Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert und vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den der Verzeichnisinhalt kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert den Inhalt eines Verzeichnisses in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird der Inhalt des Quell Verzeichnisses in das Zielverzeichnis kopiert. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CopyDirectory`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Inhalte der Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert, das Status Dialogfeld und alle Fehler Dialogfelder angezeigt, und es wird keine Aktion ausgeführt, wenn der Benutzer während des Vorgangs auf **Abbrechen** klickt.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#93)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in demselben Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Zielverzeichnis mit demselben Namen wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in demselben Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in demselben Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in demselben Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDirectory(string directory) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Name und der Speicherort des Verzeichnisses.</param>
        <summary>Erstellt ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis bereits vorhanden ist, werden keine Ausnahmen ausgelöst.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.CreateDirectory`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Erstellen eines Verzeichnisses|[Vorgehensweise: Erstellen eines Verzeichnisses in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `NewDirectory`in `C:\Documents and Settings\All Users\Documents`erstellt.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name des Verzeichnisses ist falsch formatiert. Er enthält beispielsweise unzulässige Zeichen oder besteht nur aus Leerzeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Verzeichnisname ist zu lang.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname besteht nur aus einem Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.IOException">Das übergeordnete Verzeichnis des zu erstellenden Verzeichnisses ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer ist nicht zum Erstellen des Verzeichnisses berechtigt.</exception>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Verzeichnis ab oder legt dieses fest.</summary>
        <value>Das aktuelle Verzeichnis für Datei-E/A-Operationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` ist eine systemweite Umgebungsvariable.  
  
   
  
## Examples  
 In diesem Beispiel wird das aktuelle Verzeichnis zurückgegeben und in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 In diesem Beispiel wird das aktuelle Verzeichnis auf `C:\TestDirectory`festgelegt.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist nicht gültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="onDirectoryNotEmpty">Gibt an, was geschehen soll, wenn ein Verzeichnis, das gelöscht werden soll, Dateien oder Verzeichnisse enthält. Der Standardwert ist <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter `showUI` und `recycle` werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
   
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn auf **Abbrechen** geklickt wird.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`-, `recycle`-und `onUserCancel`-Parameter werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
   
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|So löschen Sie eine Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter `showUI` und `recycle` werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|So löschen Sie eine Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`-, `recycle`-und `onUserCancel`-Parameter werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.DeleteFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|So löschen Sie eine Datei|[Vorgehensweise: Löschen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer hat den Vorgang abgebrochen, und <paramref name="onUserCancel" /> ist auf <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" /> festgelegt.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DirectoryExists(string directory) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad des Verzeichnisses.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn das angegebene Verzeichnis vorhanden ist.</summary>
        <returns><see langword="True" />, wenn das Verzeichnis vorhanden ist, andernfalls <see langword="False" />. Diese Methode gibt auch <see langword="False" /> zurück, wenn der Parameter den Namen und Pfad einer Datei statt ein Verzeichnis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird ermittelt, ob das Verzeichnis `C:\backup\logs` vorhanden ist, und seine Eigenschaften werden überprüft.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung aller verfügbaren Laufwerknamen zurück.</summary>
        <value>Eine schreibgeschützte Auflistung aller verfügbaren Laufwerke als <see cref="T:System.IO.DriveInfo" />-Objekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt alle logischen Laufwerke zurück.  
  
   
  
## Examples  
 In diesem Beispiel werden die verfügbaren Laufwerks Namen in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FileExists(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn die angegebene Datei vorhanden ist.</summary>
        <returns>Diese Methode gibt <see langword="True" /> zurück, wenn die Datei vorhanden ist, andernfalls gibt sie <see langword="False" /> zurück. Diese Methode gibt auch <see langword="False" /> zurück, wenn der Parameter den Pfad eines Verzeichnisses statt einer Datei darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung nicht über ausreichende Berechtigungen zum Lesen der angegebenen Datei verfügt, gibt die `FileExists` Methode `False`zurück, unabhängig davon, ob der Pfad vorhanden ist. die-Methode löst keine Ausnahme aus.  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, ob die Datei `Check.txt` vorhanden ist, und die Informationen werden in einem Meldungs Feld bereitstellt.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Datei endet mit einem umgekehrten Schrägstrich (\\).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase"><see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Collection der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.FindInFiles`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Durchsuchen eines Verzeichnisses nach Dateien, die eine bestimmte Zeichenfolge enthalten|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `C:\TestDir` nach Dateien durchsucht, die die Zeichenfolge `"sample string"` enthalten, und die Ergebnisse werden in `ListBox1`angezeigt.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Um zu funktionieren, muss das Projekt eine `ListBox` mit dem Namen `ListBox1`enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase"><see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Collection der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.FindInFiles`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Durchsuchen eines Verzeichnisses nach Dateien, die eine bestimmte Zeichenfolge enthalten|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `C:\TestDir` nach Dateien durchsucht, die die Zeichenfolge `"sample string"` enthalten, und die Ergebnisse werden in `ListBox1`angezeigt.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Um zu funktionieren, muss das Projekt eine `ListBox` mit dem Namen `ListBox1`enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetDirectories`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse in der Verzeichnisstruktur zurückgegeben, die das Wort `Logs` in ihren Namen enthalten, und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster für den Namensvergleich.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den `wildcards` -Parameter verwenden, um ein bestimmtes Muster anzugeben. Wenn Sie den Inhalt der Unterverzeichnisse in Ihre Suche mit einbeziehen möchten, legen Sie den `searchType`-Parameter auf `SearchAllSubDirectories` fest.  
  
 Es wird eine leere Auflistung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetDirectories`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse in der Verzeichnisstruktur zurückgegeben, die das Wort `Logs` in ihren Namen enthalten, und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens eines der angegebenen Platzhalterzeichen ist <see langword="Nothing" />, eine leere Zeichenfolge oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" /> Pfad des Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad ein <see cref="T:System.IO.DirectoryInfo" />-Objekt zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DirectoryInfo" />-Objekt für den angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis nicht vorhanden ist, wird keine Ausnahme ausgelöst, bis das erste Mal auf eine Eigenschaft des <xref:System.IO.DirectoryInfo> Objekts zugegriffen wird.  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.DirectoryInfo> Objekt für das Verzeichnis `C:\Documents and Settings` abgerufen, und es werden die Erstellungszeit des Verzeichnisses, der Zeitpunkt des letzten Zugriffs und der letzte Schreib Zeitpunkt angezeigt.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Das zu überprüfende Laufwerk.</param>
        <summary>Gibt ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.DriveInfo>-Klasse modelliert ein Laufwerk und stellt Methoden und Eigenschaften zum Abfragen von Laufwerk Informationen bereit. Verwenden Sie <xref:System.IO.DriveInfo>, um zu bestimmen, welche Laufwerke verfügbar sind und welche Art von Laufwerken Sie sind. Sie können die-Eigenschaft auch Abfragen, um die Kapazität und den verfügbaren freien Speicherplatz auf dem Laufwerk zu ermitteln.  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.DriveInfo> Objekt für das Laufwerk C abgerufen und zum Anzeigen von Informationen über das Laufwerk verwendet.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Informationen zu den verschiedenen Laufwerkstypen finden Sie unter <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="drive" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileInfo GetFileInfo(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei zurück.</summary>
        <returns>Ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Datei nicht vorhanden ist, wird keine Ausnahme ausgelöst. Stattdessen wird Sie ausgelöst, wenn auf die Eigenschaften des Objekts zum ersten Mal zugegriffen wird.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetFileInfo`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Festlegen eines Datei namens und-Pfads|[Gewusst wie: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.FileInfo?displayProperty=nameWithType> Objekt für die Datei `MyLogFile.log` abgerufen und verwendet, um den vollständigen Namen der Datei, den Zeitpunkt des letzten Zugriffs und die Länge zu melden.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfadname ist falsch formatiert. Er enthält beispielsweise ungültige Zeichen oder besteht nur aus Leerzeichen. Der Dateiname enthält einen nachgestellten Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.NotSupportedException">Der Pfad enthält einen Doppelpunkt in der Mitte der Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad ist zu lang.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt über keinen ACL (Access Control List)-Zugriff auf die Datei.</exception>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Sammeln von Dateien in einem Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung `.txt` zurückgegeben und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Sammeln von Dateien in einem Verzeichnis in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung `.txt` zurückgegeben und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(string path) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Erforderlich. Der zu analysierende Pfad. <see langword="String" /></param>
        <summary>Analysiert den Dateinamen aus dem bereitgestellten Pfad.</summary>
        <returns>Der Dateiname aus dem angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein Zeichen folgen Vorgang. die `FileSystem` wird nicht untersucht.  
  
 Die `GetName`-Methode ignoriert einen Schrägstrich am Ende des Pfads.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetFileName`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Analysieren eines Dateipfads|[Gewusst wie: Analysieren von Dateipfaden in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Dateipfad analysiert und der Name der Datei zurückgegeben.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Ersetzen Sie den Pfad `C:\Testdirectory\Testfile` durch den Pfad, den Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetParentPath(string path) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu überprüfende Pfad.</param>
        <summary>Gibt den übergeordneten Pfad des bereitgestellten Pfades zurück.</summary>
        <returns>Der übergeordnete Pfad des bereitgestellten Pfads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein Zeichen folgen Vorgang. das Dateisystem wird nicht untersucht.  
  
   
  
## Examples  
 In diesem Beispiel wird der übergeordnete Pfad für `C:\Backups\Tmp\Test`abgerufen.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad verfügt über keinen übergeordneten Pfad, weil er ein Stammpfad ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine eindeutig benannte temporäre Datei mit einer Größe von 0 Byte auf dem Datenträger und gibt den vollständigen Pfad dieser Datei zurück.</summary>
        <returns>Ein <see langword="String" />, der den vollständigen Pfad der temporären Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann zum Erstellen einer temporären Datei verwendet werden.  
  
   
  
## Examples  
 In diesem Beispiel wird eine temporäre Datei erstellt und der Pfad zurückgegeben.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Quelle ist ein Stammverzeichnis, oder der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Verzeichnisse überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und ein Unterverzeichnis der Datei kann nicht kopiert werden.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und der Benutzer bricht den Vorgang ab, oder der Vorgang kann nicht abgeschlossen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: Verschieben einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: Verschieben einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: Verschieben einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Verschieben einer Datei|[Vorgehensweise: Verschieben einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z.B. Protokolle, sowohl einfach, als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus durch Kommas getrennten Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus Text Dateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Text Dateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="fieldWidths">Die Breiten der Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus durch Kommas getrennten Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus Text Dateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Text Dateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="delimiters">Trennzeichen für die Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus durch Kommas getrennten Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus Text Dateien mit fester Breite in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Text Dateien mit mehreren Formaten in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenTextFileReader(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns><see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Textdateien können mit einem <xref:System.IO.StreamReader>gelesen werden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileReader`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Testfile.txt`geöffnet, eine Zeile aus ihr gelesen und die Zeile in einer `MessageBox`angezeigt.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String, encoding As Encoding) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <param name="encoding">Die für den Inhalt der Datei zu verwendende Codierung. Der Standardwert ist ASCII.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns><see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Textdateien können mit einem <xref:System.IO.StreamReader>gelesen werden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileReader`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Testfile.txt`geöffnet, eine Zeile aus ihr gelesen und die Zeile in einer `MessageBox`angezeigt.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
        <returns><see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter`-Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann das <xref:System.IO.StreamWriter>-Objekt für diesen Stream zurück. Sie können so oft wie nötig in den Dampf schreiben und ihn dann schließen, wenn Sie fertig sind.  
  
> [!NOTE]
>  Um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben werden, müssen Sie die <xref:System.IO.StreamWriter.Close%2A>-Methode für das <xref:System.IO.StreamWriter>-Objekt aufzurufen.  
  
 Wenn Sie nur einige wenige Zeichen folgen in eine Datei schreiben, ist es möglicherweise einfacher, die <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>-Methode zu verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode geöffnet und verwendet, um eine Zeichenfolge mit der `WriteLine`-Methode der `StreamWriter`-Klasse in eine Textdatei zu schreiben.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean, encoding As Encoding) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt in der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <param name="encoding">Die Codierung, die beim Schreiben in die Datei verwendet werden soll. Der Standardwert ist ASCII.</param>
        <summary>Öffnet einen <see cref="T:System.IO.StreamWriter" />, der in die angegebene Datei geschrieben werden soll.</summary>
        <returns><see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter`-Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann das <xref:System.IO.StreamWriter>-Objekt für diesen Stream zurück. Sie können so oft wie nötig in den Dampf schreiben und ihn dann schließen, wenn Sie fertig sind.  
  
> [!NOTE]
>  Um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben werden, müssen Sie die <xref:System.IO.StreamWriter.Close%2A>-Methode für das <xref:System.IO.StreamWriter>-Objekt aufzurufen.  
  
 Wenn Sie nur einige wenige Zeichen folgen in eine Datei schreiben, ist es möglicherweise einfacher, die <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>-Methode zu verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird eine <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode mit `Unicode` Codierung geöffnet und zum Schreiben einer Zeichenfolge in eine Textdatei mit der `WriteLine`-Methode der `StreamWriter`-Klasse verwendet.  
  
 [!code-vb[VbRefFile#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Gibt den Inhalt einer Datei als Bytearray zurück.</summary>
        <returns>Ein <see langword="Byte" />-Array mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllBytes`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Binärdatei. Der Inhalt der Datei wird als Bytearray zurückgegeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllBytes`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Binärdatei|[Vorgehensweise: Lesen aus Binärdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird aus der Datei gelesen `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string file) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei wird als Zeichenfolge zurückgegeben.  
  
 Die Datei Codierung kann angegeben werden, wenn der Inhalt der Datei eine Codierung wie ASCII oder UTF-8 enthält. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie die Datei Codierung mithilfe einer anderen Überladung der <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A>-Methode angeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllText`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird der Inhalt `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel wird der Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String, encoding As Encoding) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <param name="encoding">Die Zeichencodierung, die beim Lesen der Datei verwendet werden soll. Die Standardeinstellung ist UTF-8.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei wird als Zeichenfolge zurückgegeben.  
  
 Die Datei Codierung kann angegeben werden, wenn der Inhalt der Datei eine Codierung wie ASCII oder UTF-8 enthält. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie die Datei Codierung angeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.ReadAllText`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird der Inhalt `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel wird der Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RenameDirectory(string directory, string newName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad und der Name des umzubenennenden Verzeichnisses.</param>
        <param name="newName">Neuer Name für das Verzeichnis.</param>
        <summary>Benennt ein Verzeichnis um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht zum Verschieben eines Verzeichnisses verwendet werden. Verwenden Sie die `MoveDirectory`-Methode, um das Verzeichnis zu verschieben und umzubenennen.  
  
   
  
## Examples  
 In diesem Beispiel wird das `Test` Verzeichnis in `SecondTest`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.  
  
- oder - 
 Der <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RenameFile(string file, string newName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die umbenannt werden soll.</param>
        <param name="newName">Neuer Name der Datei.</param>
        <summary>Benennt eine Datei um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht dazu verwendet werden, um eine Datei zu verschieben; verwenden Sie die <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A>-Methode, um die Datei zu verschieben und umzubenennen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.RenameFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Umbenennen einer Datei|[Gewusst wie: Umbenennen einer Datei in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` in `SecondTest.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Ändern Sie "`C:\Test.txt`" in den Pfad und den Dateinamen der Datei, die Sie umbenennen möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> enthält Pfadinformationen oder endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.  
  
- oder - 
 Der <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Der Pfad und Name der Datei, in die geschrieben werden soll.</param>
        <param name="data">Die in die Datei zu schreibenden Daten.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Daten in eine Binärdatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Pfad ohne den Dateinamen ungültig ist, wird eine <xref:System.IO.DirectoryNotFoundException> Ausnahme ausgelöst. Wenn der Pfad gültig ist, die Datei jedoch nicht vorhanden ist, wird die Datei erstellt.  
  
> [!NOTE]
>  Die `WriteAllBytes`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllBytes`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.BinaryWriter> Objekt verwendet. Wenn Sie jedoch einer Datei mithilfe einer-Schleife Daten hinzufügen, kann ein <xref:System.IO.BinaryWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.WriteAllBytes`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben in eine Binärdatei|[Gewusst wie: Schreiben in Binärdateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Daten Array `CustomerData` an die Datei `CollectedData`angefügt.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Text in eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string file, string text, bool append) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die UTF-8-Codierung wird verwendet, um in die Datei zu schreiben. Verwenden Sie eine andere Überladung der <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>-Methode, um eine andere Codierung anzugeben.  
  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei identisch ist, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllText`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.StreamWriter> Objekt verwendet. Wenn Sie jedoch einer Datei Zeichen folgen mithilfe einer-Schleife hinzufügen, kann ein <xref:System.IO.StreamWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.WriteAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anfügen von Text an eine Datei|[Gewusst wie: Anfügen an Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Zeile `"This is new text to be added."` in die Datei `Test.txt`geschrieben, wobei vorhandener Text in der Datei überschrieben wird.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel werden die Namen der Dateien im `Documents and Settings` Ordner in `FileList.txt`geschrieben, sodass ein Wagen Rücklauf zur besseren Lesbarkeit eingefügt werden kann.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll.</param>
        <param name="encoding">Die beim Schreiben in die Datei zu verwendende Codierung.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei identisch ist, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllText`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.StreamWriter> Objekt verwendet. Wenn Sie jedoch einer Datei Zeichen folgen mithilfe einer-Schleife hinzufügen, kann ein <xref:System.IO.StreamWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.WriteAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|-|-|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anfügen von Text an eine Datei|[Gewusst wie: Anfügen an Text Dateien in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Zeile `"This is new text to be added."` in die Datei `Test.txt`geschrieben, wobei vorhandener Text in der Datei überschrieben wird.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel werden die Namen der Dateien im `Documents and Settings` Ordner in `FileList.txt`geschrieben, sodass ein Wagen Rücklauf zur besseren Lesbarkeit eingefügt werden kann.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>
