<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aa587ec6541764df18cb0755d02a2a56fb5d083a" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39771400" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <TypeSignature Language="VB.NET" Value="Public Class TextFieldParser&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextFieldParser : IDisposable" />
  <TypeSignature Language="F#" Value="type TextFieldParser = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt Methoden und Eigenschaften zur Analyse strukturierter Textdateien bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `TextFieldParser` Objekt bietet Methoden und Eigenschaften für die Analyse strukturierter Textdateien. Analysieren einer Textdatei mit dem `TextFieldParser` ähnelt dem Durchlaufen einer Textdatei, während die `ReadFields` ähnelt der Methode zum Extrahieren von Text zum Aufteilen von Zeichenfolgen.  
  
 Die `TextFieldParser` können zwei Arten von Dateien analysieren: durch Trennzeichen getrennten oder eine feste Breite. Einige Eigenschaften, z. B. `Delimiters` und `HasFieldsEnclosedInQuotes` sind nur sinnvoll bei der Arbeit mit durch Trennzeichen getrennte Dateien zwar die `FieldWidths` -Eigenschaft ist sinnvoll, nur bei der Arbeit mit Dateien mit fester Breite.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `Microsoft.VisualBasic.FileIO.TextFieldParser` Objekt.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird mithilfe einer Textdatei mit Tabstopptrennzeichen analysiert `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt, das Analysieren der Datei oder den stream, der durch dargestellt wird die `stream` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.TextReader -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser reader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Der zu analysierende <see cref="T:System.IO.TextReader" />-Datenstrom.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt, das Analysieren der Datei oder den stream, der durch dargestellt wird die `reader` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei, die gemäß der `path` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt, das Analysieren der Datei oder den stream, der durch dargestellt wird die `stream` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei, die gemäß der `path` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge, oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt, das Analysieren der Datei oder den stream, der durch dargestellt wird die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter `True`, diesen Konstruktor versucht, die Codierung anhand der ersten drei Bytes der Datei oder des Streams zu erkennen. Es erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit die entsprechenden Bytereihenfolge-Marken beginnt. Die Codierung angegeben, andernfalls von `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding, detectEncoding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : string * System.Text.Encoding * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (path, defaultEncoding, detectEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei, die gemäß der `path` Parameter.  
  
 Wenn die `detectEncoding` Parameter `True`, diesen Konstruktor versucht, die Codierung anhand der ersten drei Bytes der Datei oder des Streams zu erkennen. Es erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit die entsprechenden Bytereihenfolge-Marken beginnt. Die Codierung angegeben, andernfalls von `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge, oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.FileIO.TextFieldParser : System.IO.Stream * System.Text.Encoding * bool * bool -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="new Microsoft.VisualBasic.FileIO.TextFieldParser (stream, defaultEncoding, detectEncoding, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" /> Gibt an, ob <c>stream</c> geöffnet bleiben soll, wenn das <see langword="TextFieldParser" />-Objekt geschlossen wird. Der Standardwert ist <see langword="False" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt, das Analysieren der Datei oder den stream, der durch dargestellt wird die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter `True`, diesen Konstruktor versucht, die Codierung anhand der ersten drei Bytes der Datei oder des Streams zu erkennen. Es erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit die entsprechenden Bytereihenfolge-Marken beginnt. Die Codierung angegeben, andernfalls von `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="textFieldParser.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das aktuelle <see langword="TextFieldParser" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel schließt den `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property CommentTokens As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ CommentTokens { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommentTokens : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert Kommentartoken. Ein Kommentartoken ist eine Zeichenfolge am Anfang einer Zeile, die angibt, dass die Zeile ein Kommentar ist und vom Parser ignoriert werden soll.</summary>
        <value>Ein Zeichenfolgenarray, das alle Kommentartoken für das <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Dieser ist nicht in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Mit der Länge Null Kommentartoken werden ignoriert.  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass für die `TextFieldParser`, `FileReader` Zeilen, die mit einem einfachen Anführungszeichen (') ignoriert werden sollen.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Kommentartoken enthält Leerzeichen.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiters As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Delimiters { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiters : string[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Trennzeichen für eine Textdatei.</summary>
        <value>Ein Zeichenfolgenarray, das alle Feldtrennzeichen für das <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist sinnvoll, nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.Delimited`.  
  
 Definieren die Trennzeichen für eine Textdatei auch ausgeführt werden kann, können Sie mit der <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> Methode.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `Delimiters` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass das Trennzeichen für die `TextFieldParser` Objekt `FileReader`, ist ein Komma (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichenwert wird auf ein Neue-Zeile-Zeichen, eine leere Zeichenfolge oder <see langword="Nothing" /> festgelegt.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textFieldParser.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textFieldParser.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Boolesch. Bei <see langword="True" /> werden sowohl verwaltete als auch nicht verwaltete Ressourcen, bei <see langword="False" /> nur nicht verwaltete Ressourcen freigegeben.</param>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfData : bool" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt <see langword="True" /> zurück, wenn sich zwischen der aktuellen Cursorposition und dem Dateiende keine Zeilen befinden, die nicht leer bzw. keine Kommentare sind.</summary>
        <value>
          <see langword="True" />, wenn keine weiteren Daten gelesen werden, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann beim Lesen aus Dateien verwendet werden, um zu bestimmen, das Ende der Daten gelesen werden können.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `EndOfData` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Datei mit Trennzeichen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `EndofData` Eigenschaft so durchlaufen Sie alle Felder in der Datei mit den `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLine : string" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Zeile zurück, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</summary>
        <value>Die Zeile, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird eine leere Zeichenfolge zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLine` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Datei mit Trennzeichen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLine` Eigenschaft zum Anzeigen der Zeile, die die aktuelle verursacht <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ErrorLineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorLineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Nummer der Zeile zurück, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</summary>
        <value>Die Nummer der Zeile, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird-1 zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat. Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLineNumber` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Datei mit Trennzeichen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLineNumber` Eigenschaft, um den Speicherort der Zeile, die die aktuelle verursacht anzuzeigen <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberSignature Language="VB.NET" Value="Public Property FieldWidths As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ FieldWidths { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FieldWidths : int[] with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kennzeichnet die Breite der einzelnen Spalten in der Textdatei, die analysiert wird.</summary>
        <value>Ein Array mit ganzen Zahlen, das die Breite jeder Spalte in der Textdatei enthält, die analysiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist sinnvoll, nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.FixedWidth`. Wenn der letzte Eintrag im Array kleiner als oder gleich NULL ist, wird angenommen, dass das Feld von variabler Breite ist.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> Methode kann auch verwendet werden, um Feldbreiten festzulegen.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `FieldWidths` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest die Datei `ParserText.txt`, die erste Spalte ist 5 Zeichen breit, die zweite ist 10, das dritte hingegen ist 11 und die vierte ist von variabler Breite angeben der breiten;  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Wert für die Breite eines beliebigen Eintrags außer dem letzten Eintrag des Arrays ist kleiner oder gleich 0 (null).</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TextFieldParser ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="textFieldParser.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es dem <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor dieser vom Garbage Collector wieder zugänglich gemacht wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="VB.NET" Value="Public Property HasFieldsEnclosedInQuotes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasFieldsEnclosedInQuotes { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HasFieldsEnclosedInQuotes : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt beim Analysieren einer Datei mit Trennzeichen an, ob die Felder in Anführungszeichen eingeschlossen sind.</summary>
        <value>
          <see langword="True" />, wenn Felder in Anführungszeichen eingeschlossen sind, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Dieser ist nicht in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn die Eigenschaft `True`, der Parser wird davon ausgegangen, dass die Felder in Anführungszeichen eingeschlossen sind ("") und Zeilenenden enthalten kann.  
  
 Wenn ein Feld in Anführungszeichen, z. B. eingeschlossen ist `abc, "field2a,field2b", field3` und diese Eigenschaft ist `True`, klicken Sie dann alle Text in Anführungszeichen eingeschlossen werden unverändert zurückgegeben; in diesem Beispiel würde zurückgeben `abc|field2a,field2b|field3`. Wenn diese Eigenschaft auf `False` würde in diesem Beispiel stellen return `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 In diesem Beispiel wird die `HasFieldsEnclosedInQuotes` Eigenschaft `True` für `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LineNumber { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int64" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die aktuelle Zeilennummer oder -1 zurück, wenn im Stream keine weiteren Zeichen verfügbar sind.</summary>
        <value>Die aktuelle Zeilennummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Dieser ist nicht in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
   
  
## Examples  
 In diesem Beispiel sucht nach dem Namen "Jones" in der Textdatei und teilt welche Zeilen, die er sich befindet.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekChars (numberOfChars As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PeekChars(int numberOfChars);" />
      <MemberSignature Language="F#" Value="member this.PeekChars : int -&gt; string" Usage="textFieldParser.PeekChars numberOfChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" /> Anzahl der zu lesenden Zeichen. Erforderlich.</param>
        <summary>Liest die angegebene Anzahl von Zeichen, ohne die Cursorposition zu ändern.</summary>
        <returns>Eine Zeichenfolge, die die angegebene Anzahl gelesener Zeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `numberOfChars` Wert muss kleiner als die Gesamtzahl der Zeichen in der Zeile sein. Ist dies nicht der Fall, die von zurückgegebene Zeichenfolge `PeekChars` wird auf die Länge der Zeile abgeschnitten werden.  
  
 Leere Zeilen werden ignoriert.  
  
 End-of-Line-Zeichen werden nicht zurückgegeben.  
  
 Die `PeekChars` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als der tatsächliche Ende der Zeile interpretiert wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `PeekChars` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Bestimmen Sie das Format eines Felds, bevor Sie analysieren|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet `PeekChars` ermittelt das Ende der Daten und Analyse der Datei an diesem Punkt beenden.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> ist kleiner als 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadFields () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ ReadFields();" />
      <MemberSignature Language="F#" Value="member this.ReadFields : unit -&gt; string[]" Usage="textFieldParser.ReadFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle Felder in der aktuellen Zeile, gibt sie als Zeichenfolgenarray zurück und setzt den Cursor in die nächste Zeile mit Daten.</summary>
        <returns>Ein Array von Zeichenfolgen, das Feldwerte für die aktuelle Zeile enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit Benutzer beim Analysieren von Textdateien in verschiedenen Formaten können die `ReadFields` -Methode untersucht die Werte der `TextFieldType`, `Delimiters`, und `FieldWidths`, wenn sie festgelegt sind, jedes Mal, die sie aufgerufen wird. Benutzer müssen ordnungsgemäß konfiguriert die `TextFieldType` und `FieldWidths` oder `Delimiters` Eigenschaften nach Bedarf. Wenn `TextFieldType` nastaven NA hodnotu `Delimited`, und `Delimiters` nicht festgelegt ist, oder wenn `TextFieldType` nastaven NA hodnotu `FixedWidth` und `FieldWidths`, wird eine Ausnahme ausgelöst.  
  
 Wenn `ReadFields` erkennt leere Zeilen, sie werden übersprungen, und die nächste nicht leeren Zeile zurückgegeben wird.  
  
 Wenn die `ReadFields` Methode die aktuelle Zeile kann nicht analysiert werden, es wird eine Ausnahme ausgelöst und nicht in die nächste Zeile verschoben. Dadurch kann es sich um die Anwendung versucht, die die Zeile erneut analysiert werden.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ReadFields` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Datei mit Trennzeichen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadFields` -Methode zum Lesen aus der durch Trennzeichen getrennte Datei `ParserText.txt`. Das Beispiel schreibt die Felder `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Ein Feld kann mit dem angegebenen Format nicht analysiert werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="textFieldParser.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Zeile als Zeichenfolge zurück und setzt den Cursor in die nächste Zeile.</summary>
        <returns>Die aktuelle Zeile aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadLine` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als der tatsächliche Ende der Zeile interpretiert wird.  
  
 `Nothing` wird zurückgegeben, wenn das Ende der Datei erreicht ist.  
  
   
  
## Examples  
 In diesem Beispiel liest die Datei `ParserText.txt` und schreibt sie in `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird er erstellt, indem die `WriteAllText` Methode.  
  
 In diesem Beispiel werden die Felder als einzelne Zeichenfolge geschrieben; Jede Zeile in einer eigenen Zeile in der Zieldatei angezeigt haben eine `VbCrLf` Zeichen am Ende jeder Zeile angefügt werden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="member this.ReadToEnd : unit -&gt; string" Usage="textFieldParser.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die verbleibende Textdatei und gibt sie als Zeichenfolge zurück.</summary>
        <returns>Der verbleibende Text aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Dieser ist nicht in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn es nicht mehr ist gelesen werden, da das Ende der Datei erreicht wurde, `Nothing` zurückgegeben wird.  
  
 Die `ReadToEnd` -Methode ignoriert nicht Leerzeilen und Kommentare.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadToEnd` Methode, um die gesamte Datei lesen `ParserText.txt` und Schreiben sie in der Datei `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird er erstellt, indem die `WriteAllText` Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDelimiters (ParamArray delimiters As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDelimiters(... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.SetDelimiters : string[] -&gt; unit" Usage="textFieldParser.SetDelimiters delimiters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Array vom Typ <see langword="String" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf die angegebenen Werte und den Feldtyp auf <see langword="Delimited" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vorhandenen Inhalte von den `Delimiters` Eigenschaft sind deaktiviert, wenn diese Methode festgelegt wird.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne dass ein Array erstellt.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `SetDelimiters` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Analysieren einer Textdatei|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet einen Text-Feld-Parser und definiert das Trennzeichen als `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der zu analysierenden Datei.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichen hat die Länge 0 (null).</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFieldWidths (ParamArray fieldWidths As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFieldWidths(... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.SetFieldWidths : int[] -&gt; unit" Usage="textFieldParser.SetFieldWidths fieldWidths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Array von <see langword="Integer" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf die angegebenen Werte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vorhandenen Inhalte von den `Delimiters` Eigenschaft sind deaktiviert, wenn dieser Wert festgelegt wird.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne dass ein Array erstellt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `SetFieldWidths` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Eine Textdatei zu analysieren.|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet einen Textfeld Parser und definiert die Breite des Felds als `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der zu analysierenden Datei.  
  
 Im folgenden Beispiel öffnet einen Textfeld Parser und definiert die Feldbreiten `5`, `10`, und die Variable.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der zu analysierenden Datei.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberSignature Language="VB.NET" Value="Public Property TextFieldType As FieldType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::FileIO::FieldType TextFieldType { Microsoft::VisualBasic::FileIO::FieldType get(); void set(Microsoft::VisualBasic::FileIO::FieldType value); };" />
      <MemberSignature Language="F#" Value="member this.TextFieldType : Microsoft.VisualBasic.FileIO.FieldType with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die zu analysierende Datei Trennzeichen enthält oder eine feste Breite aufweist.</summary>
        <value>Ein <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />-Wert, der angibt, ob die zu analysierende Datei Trennzeichen enthält oder eine feste Breite aufweist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft wird getrennt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `TextFieldType` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass Trennzeichen verwendet werden.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass es mit fester Breite ist.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property TrimWhiteSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimWhiteSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrimWhiteSpace : bool with get, set" Usage="Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob vorangestellte und nachfolgende Leerzeichen aus Feldwerten entfernt werden sollen.</summary>
        <value>
          <see langword="True" />, wenn vorangestellte und nachfolgende Leerzeichen aus Feldwerten entfernt werden sollen, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `True`.  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und legt die `TrimWhiteSpace` Eigenschaft `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>