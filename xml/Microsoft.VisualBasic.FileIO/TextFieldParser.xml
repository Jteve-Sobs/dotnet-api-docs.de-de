<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="34fefd8e673d5edb9c2fb81e0c3d6c92c4fe6c0b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351104" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <TypeSignature Language="VB.NET" Value="Public Class TextFieldParser&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextFieldParser : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt Methoden und Eigenschaften zur Analyse strukturierter Textdateien bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `TextFieldParser` -Objekt stellt Methoden und Eigenschaften zur Analyse strukturierter Textdateien. Analysieren eine Textdatei mit der `TextFieldParser` ähnelt der Iteration über eine Textdatei, während die `ReadFields` Methode zum Extrahieren von Textfeldern ist vergleichbar mit Teilen der Zeichenfolgen.  
  
 Die `TextFieldParser` können zwei Arten von Dateien analysieren: mit Trennzeichen oder feste Breite. Einige Eigenschaften, z. B. `Delimiters` und `HasFieldsEnclosedInQuotes` sind nur sinnvoll bei der Arbeit mit durch Trennzeichen getrennte Dateien dagegen die `FieldWidths` Eigenschaft ist sinnvoll, nur bei der Arbeit mit Dateien mit fester Breite.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `Microsoft.VisualBasic.FileIO.TextFieldParser` Objekt.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird durch eine Tabstopps getrennte Textdatei analysiert `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::TextReader ^ reader);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Der zu analysierende <see cref="T:System.IO.TextReader" />-Datenstrom.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `reader` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge, oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, defaultEncoding As Encoding, detectEncoding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::String ^ path, System::Text::Encoding ^ defaultEncoding, bool detectEncoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" /> Der vollständige Pfad der zu analysierenden Datei.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge, oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextFieldParser(System::IO::Stream ^ stream, System::Text::Encoding ^ defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Der zu analysierende Datenstrom.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" /> Die zu verwendende Zeichencodierung, wenn die Codierung nicht aus der Datei ermittelt werden kann. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" /> Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" /> Gibt an, ob <c>stream</c> geöffnet bleiben soll, wenn das <see langword="TextFieldParser" />-Objekt geschlossen wird. Der Standardwert ist <see langword="False" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht gelesen werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das aktuelle <see langword="TextFieldParser" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel schließt den `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property CommentTokens As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ CommentTokens { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert Kommentartoken. Ein Kommentartoken ist eine Zeichenfolge am Anfang einer Zeile, die angibt, dass die Zeile ein Kommentar ist und vom Parser ignoriert werden soll.</summary>
        <value>Ein Zeichenfolgenarray, das alle Kommentartoken für das <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Mit der Länge Null Kommentartoken werden ignoriert.  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass für die `TextFieldParser`, `FileReader` Zeilen ab der ein einfaches Anführungszeichen (') ignoriert werden sollen.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Kommentartoken enthält Leerzeichen.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiters As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Delimiters { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Trennzeichen für eine Textdatei.</summary>
        <value>Ein Zeichenfolgenarray, das alle Feldtrennzeichen für das <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist genannte nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.Delimited`.  
  
 Definieren die Trennzeichen für eine Textdatei ebenfalls mit erreicht werden kann die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> Methode.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `Delimiters` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass das Trennzeichen für die `TextFieldParser` Objekt `FileReader`, ist ein Komma (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichenwert wird auf ein Neue-Zeile-Zeichen, eine leere Zeichenfolge oder <see langword="Nothing" /> festgelegt.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Boolesch. Bei <see langword="True" /> werden sowohl verwaltete als auch nicht verwaltete Ressourcen, bei <see langword="False" /> nur nicht verwaltete Ressourcen freigegeben.</param>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfData { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt <see langword="True" /> zurück, wenn sich zwischen der aktuellen Cursorposition und dem Dateiende keine Zeilen befinden, die nicht leer bzw. keine Kommentare sind.</summary>
        <value>
          <see langword="True" />, wenn keine weiteren Daten gelesen werden, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann beim Lesen aus Dateien verwendet werden, um zu bestimmen, das Ende der Daten gelesen werden können.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `EndOfData` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `EndofData` Eigenschaft so durchlaufen Sie alle Felder in der Datei mit den `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Zeile zurück, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</summary>
        <value>Die Zeile, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird eine leere Zeichenfolge zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLine` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLine` die Zeile, die das aktuelle verursacht anzuzeigende Eigenschaft <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorLineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ErrorLineNumber { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Nummer der Zeile zurück, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</summary>
        <value>Die Nummer der Zeile, die die letzte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" />-Ausnahme verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird-1 zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat. Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLineNumber` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLineNumber` Eigenschaft, um die Position der Zeile, die das aktuelle verursacht anzuzeigen <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberSignature Language="VB.NET" Value="Public Property FieldWidths As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ FieldWidths { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kennzeichnet die Breite der einzelnen Spalten in der Textdatei, die analysiert wird.</summary>
        <value>Ein Array mit ganzen Zahlen, das die Breite jeder Spalte in der Textdatei enthält, die analysiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist genannte nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.FixedWidth`. Wenn der letzte Eintrag im Array kleiner als oder gleich 0 (null) ist, wird davon ausgegangen, dass das Feld variabler Breite aufweisen.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> Methode kann auch verwendet werden, um Feldbreiten festzulegen.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `FieldWidths` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest die Datei `ParserText.txt`, die erste Spalte ist 5 Zeichen breit, die zweite ist 10, der dritte ist 11 und der vierte ist variabler Breite angeben der breiten;  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Wert für die Breite eines beliebigen Eintrags außer dem letzten Eintrag des Arrays ist kleiner oder gleich 0 (null).</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TextFieldParser ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es dem <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor dieser vom Garbage Collector wieder zugänglich gemacht wird.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="VB.NET" Value="Public Property HasFieldsEnclosedInQuotes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasFieldsEnclosedInQuotes { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt beim Analysieren einer Datei mit Trennzeichen an, ob die Felder in Anführungszeichen eingeschlossen sind.</summary>
        <value>
          <see langword="True" />, wenn Felder in Anführungszeichen eingeschlossen sind, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn die Eigenschaft `True`, der Parser wird davon ausgegangen, dass Felder in Anführungszeichen eingeschlossen sind ("") und Zeilenenden enthalten kann.  
  
 Wenn ein Feld in Anführungszeichen, z. B. eingeschlossen ist `abc, "field2a,field2b", field3` und diese Eigenschaft ist `True`, klicken Sie dann alle Text in Anführungszeichen eingeschlossen wird unverändert zurückgegeben werden, da in diesem Beispiel würden `abc|field2a,field2b|field3`. Wenn diese Eigenschaft auf `False` würde in diesem Beispiel machen return `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 In diesem Beispiel wird die `HasFieldsEnclosedInQuotes` Eigenschaft `True` für `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LineNumber { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die aktuelle Zeilennummer oder -1 zurück, wenn im Stream keine weiteren Zeichen verfügbar sind.</summary>
        <value>Die aktuelle Zeilennummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
   
  
## Examples  
 In diesem Beispiel sucht nach dem Namen "Jones" in der Textdatei und meldet welche Zeile(n) es auftritt.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekChars (numberOfChars As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PeekChars(int numberOfChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" /> Anzahl der zu lesenden Zeichen. Erforderlich.</param>
        <summary>Liest die angegebene Anzahl von Zeichen, ohne die Cursorposition zu ändern.</summary>
        <returns>Eine Zeichenfolge, die die angegebene Anzahl gelesener Zeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `numberOfChars` Wert muss kleiner als die Gesamtzahl der Zeichen in der Zeile sein. Ist dies nicht der Fall, die zurückgegebene Zeichenfolge `PeekChars` wird auf die Länge der Zeile abgeschnitten werden.  
  
 Leere Zeilen werden ignoriert.  
  
 End-of-Line-Zeichen werden nicht zurückgegeben.  
  
 Die `PeekChars` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als tatsächliches Ende der Zeile interpretiert wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `PeekChars` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Bestimmen Sie das Format eines Felds vor dem Analysieren ihn|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet `PeekChars` ermittelt das Ende der Daten und Analyse der Datei an diesem Punkt beendet.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> ist kleiner als 0.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadFields () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ ReadFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle Felder in der aktuellen Zeile, gibt sie als Zeichenfolgenarray zurück und setzt den Cursor in die nächste Zeile mit Daten.</summary>
        <returns>Ein Array von Zeichenfolgen, das Feldwerte für die aktuelle Zeile enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit Benutzer beim Analysieren von Textdateien in verschiedenen Formaten können die `ReadFields` -Methode untersucht dann die Werte der `TextFieldType`, `Delimiters`, und `FieldWidths`, wenn sie festgelegt sind, jedes Mal aufgerufen wird. Benutzer müssen nicht ordnungsgemäß konfiguriert die `TextFieldType` und `FieldWidths` oder `Delimiters` Eigenschaften nach Bedarf. Wenn `TextFieldType` festgelegt ist, um `Delimited`, und `Delimiters` nicht festgelegt ist, oder wenn `TextFieldType` auf festgelegt ist `FixedWidth` und `FieldWidths`, wird eine Ausnahme ausgelöst.  
  
 Wenn `ReadFields` erkennt leere Zeilen werden sie übersprungen und die nächste nicht leere Zeile zurückgegeben.  
  
 Wenn die `ReadFields` Methode die aktuelle Zeile kann nicht analysiert werden, es wird eine Ausnahme ausgelöst und nicht zur nächsten Zeile verschoben. Dadurch kann es sich um die Anwendung versucht, die Zeile erneut analysiert.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ReadFields` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadFields` Methode zum Lesen aus der durch Trennzeichen getrennte Datei `ParserText.txt`. Das Beispiel schreibt die Felder `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Ein Feld kann mit dem angegebenen Format nicht analysiert werden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
        <altmember cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Zeile als Zeichenfolge zurück und setzt den Cursor in die nächste Zeile.</summary>
        <returns>Die aktuelle Zeile aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadLine` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als tatsächliches Ende der Zeile interpretiert wird.  
  
 `Nothing` wird zurückgegeben, wenn das Ende der Datei erreicht ist.  
  
   
  
## Examples  
 In diesem Beispiel liest mithilfe der Datei `ParserText.txt` und schreibt ihn auf `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird erstellt, indem die `WriteAllText` Methode.  
  
 In diesem Beispiel schreibt die Felder als eine einzelne Zeichenfolge; Jede Zeile in einer eigenen Zeile in der Zieldatei angezeigt haben eine `VbCrLf` Zeichen am Ende jeder Zeile angefügt werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadToEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die verbleibende Textdatei und gibt sie als Zeichenfolge zurück.</summary>
        <returns>Der verbleibende Text aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn keine weiteren zu lesen, da das Ende der Datei erreicht wurde, `Nothing` wird zurückgegeben.  
  
 Die `ReadToEnd` Methode nicht leere Zeilen und Kommentare ignoriert.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadToEnd` Methode zum Lesen der vollständigen Datei `ParserText.txt` und schreibt es in die Datei `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird erstellt, indem die `WriteAllText` Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDelimiters (ParamArray delimiters As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDelimiters(... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Array vom Typ <see langword="String" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf die angegebenen Werte und den Feldtyp auf <see langword="Delimited" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den vorhandenen Inhalt der `Delimiters` Eigenschaft sind deaktiviert, wenn diese Methode festgelegt ist.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne das Erstellen eines Arrays.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `SetDelimiters` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Analysieren einer Textdatei|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet einen Text-Feld-Parser und definiert das Trennzeichen als `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichen hat die Länge 0 (null).</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFieldWidths (ParamArray fieldWidths As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFieldWidths(... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Array von <see langword="Integer" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf die angegebenen Werte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den vorhandenen Inhalt der `Delimiters` Eigenschaft sind deaktiviert, wenn diese Option festgelegt ist.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne das Erstellen eines Arrays.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `SetFieldWidths` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Eine Textdatei zu analysieren.|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird einen Textfeld Parser geöffnet und definiert die Breite des Felds als `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 Im folgenden Beispiel wird einen Textfeld Parser geöffnet und definiert die Feldbreiten `5`, `10`, und die Variable.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberSignature Language="VB.NET" Value="Public Property TextFieldType As FieldType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::FileIO::FieldType TextFieldType { Microsoft::VisualBasic::FileIO::FieldType get(); void set(Microsoft::VisualBasic::FileIO::FieldType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die zu analysierende Datei Trennzeichen enthält oder eine feste Breite aufweist.</summary>
        <value>Ein <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />-Wert, der angibt, ob die zu analysierende Datei Trennzeichen enthält oder eine feste Breite aufweist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft ist begrenzt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `TextFieldType` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass Trennzeichen verwendet werden.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass es mit fester Breite ist.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FieldType" />
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property TrimWhiteSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimWhiteSpace { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob vorangestellte und nachfolgende Leerzeichen aus Feldwerten entfernt werden sollen.</summary>
        <value>
          <see langword="True" />, wenn vorangestellte und nachfolgende Leerzeichen aus Feldwerten entfernt werden sollen, andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `True`.  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und legt die `TrimWhiteSpace` Eigenschaft `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>