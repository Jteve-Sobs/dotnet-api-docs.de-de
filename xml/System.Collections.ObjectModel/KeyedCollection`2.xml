<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8ce2597c1f3d8e4d98d5761be237988390ae5ae8" />
    <Meta Name="ms.sourcegitcommit" Value="6ee2e6b2c5d7c5bd66feeb362d29e65fdf858836" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/15/2018" />
    <Meta Name="ms.locfileid" Value="51691533" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel in der Auflistung.</typeparam>
    <typeparam name="TItem">Der Typ der Elemente in der Auflistung.</typeparam>
    <summary>Stellt die abstrakte Basisklasse für eine Auflistung bereit, deren Schlüssel in die Werte eingebettet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.ObjectModel.KeyedCollection%602> -Klasse stellt sowohl O(1) Abruf und als Schlüssel abrufen, die O(1) annähert. Es ist ein abstrakter Typ, oder genauer gesagt um eine unendliche Menge von abstrakten Typen, da jede konstruierten generischen Typen einer abstrakten Klasse ist. Verwendung von <xref:System.Collections.ObjectModel.KeyedCollection%602>, Ihren Auflistungstyp von entsprechenden konstruierten Typ ableiten.  
  
 Die <xref:System.Collections.ObjectModel.KeyedCollection%602> -Klasse ist eine Mischung aus einer Auflistung basierend auf den <xref:System.Collections.Generic.IList%601> generischen Schnittstellen und einer Sammlung basierend auf den <xref:System.Collections.Generic.IDictionary%602> generische Schnittstelle. Wie Sammlungen, die auf der Grundlage der <xref:System.Collections.Generic.IList%601> generische Schnittstelle <xref:System.Collections.ObjectModel.KeyedCollection%602> ist eine indizierte Liste von Elementen. Wie Sammlungen, die auf der Grundlage der <xref:System.Collections.Generic.IDictionary%602> generische Schnittstelle <xref:System.Collections.ObjectModel.KeyedCollection%602> verfügt über einen Schlüssel, die jedem Element zugeordnet.  
  
 Im Gegensatz zu Wörterbüchern, ein Element der <xref:System.Collections.ObjectModel.KeyedCollection%602> ist es sich nicht um Schlüssel/Wert-Paar; stattdessen das gesamte Element ist der Wert und der Schlüssel in den Wert eingebettet ist.  Z. B. ein Element einer Auflistung abgeleitet `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` in Visual Basic) ist möglicherweise "John Doe Jr." Dabei ist der Wert "John Doe Jr." und der Schlüssel ist "Doe"; oder eine Auflistung von Mitarbeiterdatensätze, enthält die ganzzahligen Schlüssel abgeleitet werden konnte `KeyedCollection\<int,Employee>`. Die abstrakte <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode extrahiert den Schlüssel des Elements.  
  
 In der Standardeinstellung die <xref:System.Collections.ObjectModel.KeyedCollection%602> umfasst ein Suchwörterbuch, die Sie erhalten mit der <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> Eigenschaft.  Wenn ein Element hinzugefügt wird, um die <xref:System.Collections.ObjectModel.KeyedCollection%602>, der Schlüssel des Elements einmal extrahiert und in das Suchwörterbuch für schnellere Suchvorgänge gespeichert ist. Dieses Verhalten wird überschrieben, indem ein Dictionary-erstellen-Schwellenwert bei der Erstellung der <xref:System.Collections.ObjectModel.KeyedCollection%602>. Das Suchwörterbuch wird erstmalig erstellt, wenn die Anzahl der Elemente dieser Schwellenwert überschreitet.  Bei Angabe von – 1 als der Schwellenwert wird nie das Suchwörterbuch erstellt.  
  
> [!NOTE]
>  Wenn das interne Suchwörterbuch verwendet wird, können sie Verweise auf alle Elemente in der Auflistung enthält, wenn `TItem` ein Verweistyp ist, oder aller Elemente in der Auflistung kopiert werden, wenn `TItem` ein Werttyp ist. Daher verwenden das Suchwörterbuch eventuell nicht möglich Wenn `TItem` ein Werttyp ist.  
  
 Sie können ein Element über seinen Index oder Schlüssel zugreifen, indem Sie mit der <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> Eigenschaft. Sie können Elemente ohne einen Schlüssel hinzufügen, aber diese Elemente können anschließend nur über den Index zugegriffen werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt den mindestens erforderlichen Code für abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und viele der geerbten Methoden veranschaulicht. Das zweite Beispiel zeigt, wie Sie die geschützten Methoden überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602> um benutzerdefiniertes Verhalten bereitzustellen.  
  
 **Beispiel 1**  
  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die einen Standardgleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.ObjectModel.KeyedCollection%602> erstellt, die mit diesem Konstruktor verwendet den Standardgleichheitsvergleich für den generischen aus, für der Typ des Schlüssels abgerufenes <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Verwenden Sie zum Angeben eines anderen generischen Gleichheitsvergleich die <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> Konstruktor oder die <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor.  
  
 In der Standardeinstellung die <xref:System.Collections.ObjectModel.KeyedCollection%602> umfasst ein Suchwörterbuch, die erstellt wird, wenn das erste Element hinzugefügt wird. Wenn ein Element hinzugefügt wird, um die <xref:System.Collections.ObjectModel.KeyedCollection%602>, der Schlüssel des Elements einmal extrahiert und in das Suchwörterbuch für schnellere Suchvorgänge gespeichert ist. Dieses Verhalten kann überschrieben werden, mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor und einen Wörterbuch Erstellung Schwellenwert angeben.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse ist abstrakt (`MustInherit` in Visual Basic), Sie müssen daraus ableiten, um sie zu verwenden. Im Konstruktor für den abgeleiteten Typ, rufen Sie die entsprechende <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, um Funktionen wie den Gleichheitsvergleich bzw. Wörterbuch erstellen in Ihre Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die den angegebenen Gleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung die <xref:System.Collections.ObjectModel.KeyedCollection%602> umfasst ein Suchwörterbuch, die erstellt wird, wenn das erste Element hinzugefügt wird. Wenn ein Element hinzugefügt wird, um die <xref:System.Collections.ObjectModel.KeyedCollection%602>, der Schlüssel des Elements einmal extrahiert und in das Suchwörterbuch für schnellere Suchvorgänge gespeichert ist. Dieses Verhalten kann überschrieben werden, mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor und einen Wörterbuch Erstellung Schwellenwert angeben.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse ist abstrakt (`MustInherit` in Visual Basic), Sie müssen daraus ableiten, um sie zu verwenden. Im Konstruktor für den abgeleiteten Typ, rufen Sie die entsprechende <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, um Funktionen wie den Gleichheitsvergleich bzw. Wörterbuch erstellen in Ihre Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <param name="dictionaryCreationThreshold">Die Anzahl von Elementen, die die Auflistung enthalten kann, ohne dass ein Suchwörterbuch erstellt wird (bei Angabe von 0 wird bereits beim Hinzufügen des ersten Elements ein Suchwörterbuch erstellt), oder -1, um anzugeben, dass nie ein Suchwörterbuch erstellt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, bei der der angegebene Gleichheitsvergleich verwendet und beim Überschreiten des angegebenen Schwellenwerts ein Suchwörterbuch erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung die <xref:System.Collections.ObjectModel.KeyedCollection%602> umfasst ein Suchwörterbuch, die erstellt wird, wenn das erste Element hinzugefügt wird. Wenn ein Element hinzugefügt wird, um die <xref:System.Collections.ObjectModel.KeyedCollection%602>, der Schlüssel des Elements einmal extrahiert und in das Suchwörterbuch für schnellere Suchvorgänge gespeichert ist. Dieser Konstruktor ermöglicht Ihnen, dieses Verhalten zu überschreiben. Geben Sie 0, um das Wörterbuch zu erstellen, wenn das erste Element hinzugefügt wird, 1, um das Wörterbuch zu erstellen, wenn das zweite Element hinzugefügt wird und So weiter. Bei Angabe von – 1 als der Schwellenwert wird nie das Suchwörterbuch erstellt.  
  
 Bei sehr kleinen Auflistungen möglicherweise die Verbesserung der Abruf Geschwindigkeiten, die durch das Suchwörterbuch nicht zu den zusätzlichen Arbeitsspeicher erforderlich, von dem Wörterbuch. Einen Schwellenwert festzulegen, können Sie entscheiden, wann dieser Nachteil sein.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse ist abstrakt (`MustInherit` in Visual Basic), Sie müssen daraus ableiten, um sie zu verwenden. Im Konstruktor für den abgeleiteten Typ, rufen Sie die entsprechende <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, um Funktionen wie den Gleichheitsvergleich bzw. Wörterbuch erstellen in Ihre Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel verwendet die <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor mit einem Schwellenwert von 0 (null), damit das interne Wörterbuch ein Objekt erstmalig erstellt wird wird der Auflistung hinzugefügt.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dictionaryCreationThreshold" /> ist kleiner als –1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, dessen Schlüssel geändert werden soll.</param>
        <param name="newKey">Der neue Schlüssel für <paramref name="item" />.</param>
        <summary>Ändert den dem angegebenen Element im Suchwörterbuch zugeordneten Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ändert nicht den Schlüssel in eingebetteten `item`; er einfach ersetzt den Schlüssel im Suchwörterbuch gespeichert.  Aus diesem Grund Wenn `newKey` unterscheidet sich von den Schlüssel, der in eingebettete `item`, kann nicht auf `item` mithilfe des Schlüssels, der vom <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Diese Methode bewirkt nichts Wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> verfügt nicht über ein Suchwörterbuch.  
  
 Jeder Schlüssel im einem <xref:System.Collections.ObjectModel.KeyedCollection%602> muss eindeutig sein. Ein Schlüssel kann nicht `null`.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Vor dem Ändern des Schlüssels in einem Element eingebettet werden, müssen Sie diese Methode, um die Aktualisierung des Schlüssels im Suchwörterbuch aufrufen. Wenn der Schwellenwert für die Wörterbuch-Erstellung – 1 ist, ist das Aufrufen dieser Methode nicht erforderlich.  
  
 Machen Sie nicht die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> -Methode, wie eine öffentliche Methode einer abgeleiteten Klasse. Falsche Verwendung dieser Methode setzt das Suchwörterbuch nicht mehr synchron mit den Elementschlüsseln. Den Schlüssel beispielsweise auf festlegen `null` , und klicken Sie dann auf einen anderen Wert festlegen das Suchwörterbuch mehrere Schlüssel für ein Element hinzugefügt. Diese Methode intern, um änderbare Element-Keys können zur Verfügung stellen: Wenn der Schlüssel für ein Element geändert wird, wird diese Methode zum Ändern des Schlüssels im Suchwörterbuch verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> wurde nicht gefunden.  
  
- oder -  
 <paramref name="key" /> ist bereits in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Suchwörterbuch vorhanden ist, wird diese Methode löscht er aber nicht gelöscht.  
  
 Wenn die Anzahl der Elemente der Wörterbuch-erstellen-Schwellenwert überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> wird über ein Suchwörterbuch, diese Funktion bleibt weiterhin ein Suchwörterbuch zu verwenden, auch wenn die Anzahl der Elemente erneut unter dem Schwellenwert liegt.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode zum Bereitstellen von benutzerdefinierten Verhaltens für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> -Methode, geerbt von der <xref:System.Collections.ObjectModel.Collection%601> generische Klasse.  
  
 Rufen Sie die basisklassenimplementierung dieser Methode, die zugrunde liegende Auflistung löschen und deaktivieren Sie das Suchwörterbuch.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, überschreiben die <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> Methode, um benutzerdefiniertes Verhalten bereitzustellen, für das Löschen aller Objekte aus der Auflistung. Im erste Beispiel fügt eine benutzerdefinierte Benachrichtigung-Ereignis hinzu, und die zweite bietet Unterstützung für eine Auflistung von Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den generischen Gleichheitsvergleich ab, der verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</summary>
        <value>Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob die Auflistung ein Element mit dem angegebenen Wert enthält.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> verfügt über ein Suchwörterbuch `key` wird verwendet, um das Wörterbuch zu suchen. Ist kein Wörterbuch für die Suche, der Schlüssel für jedes Element extrahiert mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode verglichen mit dem angegebenen Schlüssel.  
  
 Diese Methode ist ein o(1)-Vorgang aus, wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Suchwörterbuch aufweist; andernfalls handelt es sich um ein O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ab.</summary>
        <value>Das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, sofern vorhanden, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung die <xref:System.Collections.ObjectModel.KeyedCollection%602> umfasst ein Suchwörterbuch, die erstellt wird, wenn das erste Element hinzugefügt wird. Wenn ein Element hinzugefügt wird, um die <xref:System.Collections.ObjectModel.KeyedCollection%602>, der Schlüssel des Elements einmal extrahiert und in das Suchwörterbuch für schnellere Suchvorgänge gespeichert ist. Dieses Verhalten kann überschrieben werden, mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor und einen Wörterbuch Erstellung Schwellenwert angeben.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, aus dem der Schlüssel extrahiert werden soll.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse wird der Schlüssel aus dem angegebenen Element extrahiert.</summary>
        <returns>Der Schlüssel für das angegebene Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel in das Suchwörterbuch aus dem Schlüssel, das im eingebettete unterscheidet `item`, kann nicht zugegriffen werden `item` mithilfe des Schlüssels, der vom <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Sie können diese Methode zurückgibt implementieren `null` für eine Sammlung, die Elemente ohne Schlüssel enthält, in diesem Fall die-Elemente zugegriffen werden kann nur anhand ihres Indexes. Diese Methode ist ein o(1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Sie müssen diese Methode, um das Wörterbuch ein Schlüssel aus den Elementen im Wörterbuch extrahiert Möglichkeit bieten, überschreiben.  
  
 Diese Methode wird intern aufgerufen. Es ist nicht erforderlich, damit er öffentlich sein.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` hinzugefügt wird, an das Ende der <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> wird aufgerufen, indem die <xref:System.Collections.ObjectModel.Collection%601.Add%2A> und <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> Methoden.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode zum Bereitstellen von benutzerdefinierten Verhaltens für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A> und <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> von geerbten Methoden der <xref:System.Collections.ObjectModel.Collection%601> generische Klasse.  
  
 Rufen Sie die basisklassenimplementierung dieser Methode das Element in der zugrunde liegenden Auflistung eingefügt werden soll und das Suchwörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, überschreiben die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode, um benutzerdefiniertes Verhalten bereitzustellen, für das Hinzufügen oder Einfügen von Objekten in der Auflistung. Im erste Beispiel fügt eine benutzerdefinierte Benachrichtigung-Ereignis hinzu, und die zweite bietet Unterstützung für eine Auflistung von Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden Elements.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab.</summary>
        <value>Das Element mit dem angegebenen Schlüssel. Wenn kein Element mit dem angegebenen Schlüssel gefunden wird, wird eine Ausnahme ausgelöst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe der folgenden Syntax: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
> [!NOTE]
>  Diese Eigenschaft unterscheidet sich von der geerbten <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> -Eigenschaft, die ermittelt und definiert Elemente über den numerischen Index. Aber wenn `TKey` ist vom Typ <xref:System.Int32>, diese Eigenschaft maskiert die geerbte Eigenschaft. In diesem Fall können Sie die geerbte Eigenschaft zugreifen, durch das Umwandeln der <xref:System.Collections.ObjectModel.KeyedCollection%602> mit seinem Basistyp. Z. B. `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` in Visual Basic `KeyedCollection<int, MyType^>` in C++) umgewandelt werden kann, um `Collection<MyType>` (`Collection(Of MyType)` in Visual Basic `Collection<MyType^>` in C++).  
  
 Wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> verfügt über ein Suchwörterbuch `key` wird verwendet, um das Element aus dem Wörterbuch abzurufen.  Ist kein Wörterbuch für die Suche, der Schlüssel für jedes Element extrahiert mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode verglichen mit dem angegebenen Schlüssel.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang, wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Suchwörterbuch aufweist; andernfalls handelt es sich um ein O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Das Codebeispiel ruft sowohl die <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die schreibgeschützt ist, und ruft nach Schlüssel ab, und die <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> -Eigenschaft, die festgelegt werden kann, und ruft nach Index ab. Es veranschaulicht, wie die letzte Eigenschaft zugreifen, wenn die Objekte in der abgeleiteten Auflistung nicht von ganzen Zahlen verwendet, für den indizierten Abruf unterschieden ganzzahligen Schlüssel aufweisen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">In der Auflistung ist kein Element mit dem angegebenen Schlüssel vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>
          <see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird aus dem Wörterbuch für die Suche ebenfalls entfernt.  
  
 Wenn die Anzahl der Elemente der Wörterbuch-erstellen-Schwellenwert überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> wird über ein Suchwörterbuch, diese Funktion bleibt weiterhin ein Suchwörterbuch zu verwenden, auch wenn die Anzahl der Elemente erneut unter dem Schwellenwert liegt.  
  
> [!NOTE]
>  Um das Verhalten dieser Methode anzupassen, überschreiben die <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> Methode.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt die minimalen Code erforderlich, leiten Sie eine Auflistungsklasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode und ein öffentlicher Konstruktor bereitgestellt ist, die an einen Basisklassenkonstruktor delegiert. Im Codebeispiel wird außerdem veranschaulicht viele der Eigenschaften und Methoden von geerbten <xref:System.Collections.ObjectModel.KeyedCollection%602> und <xref:System.Collections.ObjectModel.Collection%601> Klassen.  
  
 Im Beispiel wird veranschaulicht <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> Methode geerbt von <xref:System.Collections.ObjectModel.KeyedCollection%602>, das das Element mit einem angegebenen Schlüssel entfernt und die <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> und <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> geerbten Methoden <xref:System.Collections.ObjectModel.Collection%601>, die vom Objekt und anhand des Indexes bzw. entfernen.  
  
 Die `SimpleOrder` Klasse ist eine sehr einfache Bestellliste, enthält `OrderItem` Objekte, von denen jedes einen Eintrag in der Reihenfolge darstellt. Der Schlüssel des `OrderItem` unveränderlich ist, ein wichtiger Aspekt für abgeleitete Klassen <xref:System.Collections.ObjectModel.KeyedCollection%602>. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird aus dem Wörterbuch für die Suche ebenfalls entfernt.  
  
 Wenn die Anzahl der Elemente der Wörterbuch-erstellen-Schwellenwert überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> wird über ein Suchwörterbuch, diese Funktion bleibt weiterhin ein Suchwörterbuch zu verwenden, auch wenn die Anzahl der Elemente erneut unter dem Schwellenwert liegt.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode zum Bereitstellen von benutzerdefinierten Verhaltens für die <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> und <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> von geerbten Methoden der <xref:System.Collections.ObjectModel.Collection%601> generische Klasse erstellen, und die <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> Methode.  
  
 Rufen Sie die basisklassenimplementierung dieser Methode, um das Element aus der zugrunde liegenden Auflistung zu entfernen und das Suchwörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, überschreiben die <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> Methode, um benutzerdefiniertes Verhalten bereitzustellen, für das Entfernen von Objekten aus der Auflistung. Im erste Beispiel fügt eine benutzerdefinierte Benachrichtigung-Ereignis hinzu, und die zweite bietet Unterstützung für eine Auflistung von Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu ersetzenden Elements.</param>
        <param name="item">Das neue Element.</param>
        <summary>Ersetzt das Element im angegebenen Index durch ein angegebenes Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Suchwörterbuch wird entsprechend aktualisiert. D. h. aus das Suchwörterbuch der Schlüssel des Elements, das ersetzt wird entfernt, und der Schlüssel des neuen Elements wird hinzugefügt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode zum Bereitstellen von benutzerdefinierten Verhaltens für das Festlegen der <xref:System.Collections.ObjectModel.Collection%601.Item%2A> Eigenschaft vererbt wird, aus der <xref:System.Collections.ObjectModel.Collection%601> generische Klasse.  
  
> [!NOTE]
>  Diese Methode wirkt sich nicht auf das Verhalten der <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die schreibgeschützt ist.  
  
 Rufen Sie die basisklassenimplementierung dieser Methode das Element in der zugrunde liegenden Auflistung festgelegt und das Suchwörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, überschreiben die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methode zum Bereitstellen von benutzerdefinierten Verhaltens für das Festlegen der <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> Eigenschaft. Im erste Beispiel fügt eine benutzerdefinierte Benachrichtigung-Ereignis hinzu, und die zweite bietet Unterstützung für eine Auflistung von Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um benutzerdefiniertes Verhalten für bereitzustellen der <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden und Festlegen der standardmäßigen <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in c#). In diesem Beispiel bereitgestellte benutzerdefinierte Verhalten wird ein Benachrichtigungsereignis, die mit dem Namen `Changed`, das am Ende der überschriebenen Methoden ausgelöst wird.  
  
 Das Codebeispiel erstellt die `SimpleOrder` -Klasse, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602> und ein einfache Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte sortiert, die Elemente darstellt. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, um die Informationen und eine Enumeration zum Identifizieren des Typs der Änderung enthalten.  
  
 Im Codebeispiel wird veranschaulicht, das benutzerdefinierte Verhalten durch die Eigenschaften und Methoden von der abgeleiteten Klasse in Aufrufen der `Main` Methode der `Demo` Klasse.  
  
 Dieses Codebeispiel verwendet Objekte mit unveränderlichen Schlüsseln. Ein Codebeispiel, die änderbare Schlüssel verwendet, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte überschreiben <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode zur Unterstützung von veränderbare Schlüssel und den geschützten Außerkraftsetzen <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden, um die Integrität der Schlüssel zu gewährleisten und die Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die abgeleitet <xref:System.Collections.ObjectModel.KeyedCollection%602>, und die `MutableKey` Klasse. Die `MutableKey` -Klasse verfügt über eine festlegbare `Key` Eigenschaft. Wenn ein neuer Schlüssel der Eigenschaft zugewiesen wird, ruft der Eigenschaftensetter der `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der Auflistung zu prüfen, ob es sich bei der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt stehen würde. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und den Wert der Eigenschaft wird nicht geändert.  
  
 Um die Verbindung zwischen zu gewährleisten eine `MutableKey` Objekt und die `MutableKeys` Auflistung und zu verhindern, dass ein Objekt eingefügt wird, in zwei Auflistungen, die `MutableKey` -Klasse verfügt über ein `internal` (`Friend` in Visual Basic) `Collection`Feld. Dieses Feld wird von den geschützten Methoden, die benutzerdefiniertes Verhalten bereitstellen, für das Hinzufügen und Entfernen von Elementen aus der Auflistung, z. B. verwaltet die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und gelöscht, wenn das Element entfernt wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="item" Type="TItem" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>