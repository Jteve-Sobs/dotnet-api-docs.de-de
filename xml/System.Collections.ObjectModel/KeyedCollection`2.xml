<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e91f598b6b6c1baa4b3ad266724134e296b516a2" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69539782" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel in der Auflistung.</typeparam>
    <typeparam name="TItem">Der Typ der Elemente in der Auflistung.</typeparam>
    <summary>Stellt die abstrakte Basisklasse für eine Auflistung bereit, deren Schlüssel in die Werte eingebettet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.ObjectModel.KeyedCollection%602> -Klasse stellt sowohl den o (1)-indizierten Abruf als auch den Schlüssel gebundenen Abruf bereit, der o (1) nähert. Es handelt sich um einen abstrakten Typ oder eine präzisere Menge abstrakter Typen, da jeder seiner konstruierten generischen Typen eine abstrakte Basisklasse ist. Leiten Sie <xref:System.Collections.ObjectModel.KeyedCollection%602>den Auflistungstyp von dem entsprechenden konstruierten Typ ab, um zu verwenden.  
  
 Bei <xref:System.Collections.ObjectModel.KeyedCollection%602> der-Klasse handelt es sich um einen Hybrid zwischen <xref:System.Collections.Generic.IList%601> einer Auflistung, die auf der generischen <xref:System.Collections.Generic.IDictionary%602> -Schnittstelle basiert Wie Auflistungen, <xref:System.Collections.Generic.IList%601> die auf der <xref:System.Collections.ObjectModel.KeyedCollection%602> generischen Schnittstelle basieren, ist eine indizierte Liste von Elementen. Ebenso wie Auflistungen <xref:System.Collections.Generic.IDictionary%602> , die auf <xref:System.Collections.ObjectModel.KeyedCollection%602> der generischen-Schnittstelle basieren, verfügt über einen Schlüssel, der jedem  
  
 Anders als bei Wörterbüchern ist <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Element von kein Schlüssel-Wert-Paar; stattdessen ist das gesamte Element der Wert, und der Schlüssel wird in den Wert eingebettet.  Beispielsweise könnte ein Element einer Auflistung, die von `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` in Visual Basic) abgeleitet ist, "John Doe Jr" lauten. Dabei ist der Wert "John Doe Jr". und der Schlüssel ist "Doe". oder eine Auflistung von Mitarbeiterdaten Sätzen, die ganzzahlige Schlüssel `KeyedCollection\<int,Employee>`enthalten, könnte von abgeleitet werden. Die abstrakte <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode extrahiert den Schlüssel aus dem Element.  
  
 Standardmäßig <xref:System.Collections.ObjectModel.KeyedCollection%602> enthält ein Such Wörterbuch, das Sie mit der <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> -Eigenschaft abrufen können.  Wenn ein Element hinzugefügt <xref:System.Collections.ObjectModel.KeyedCollection%602>wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten wird durch Angeben eines Schwellenwerts für die Wörterbuch Erstellung überschrieben <xref:System.Collections.ObjectModel.KeyedCollection%602>, wenn Sie das erstellen. Das Such Wörterbuch wird erstellt, wenn die Anzahl der Elemente den Schwellenwert überschreitet.  Wenn Sie-1 als Schwellenwert angeben, wird das Such Wörterbuch nie erstellt.  
  
> [!NOTE]
>  Wenn das interne Such Wörterbuch verwendet wird, enthält es Verweise auf alle Elemente in der Auflistung, `TItem` wenn ein Verweistyp ist, oder Kopien aller Elemente in der Auflistung, wenn `TItem` ein Werttyp ist. Daher ist es möglicherweise nicht sinnvoll, das Such Wörterbuch zu verwenden, wenn `TItem` ein Werttyp ist.  
  
 Mithilfe der-Eigenschaft können Sie auf ein Element über den Index oder <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> den Schlüssel zugreifen. Sie können Elemente ohne Schlüssel hinzufügen, aber auf diese Elemente kann dann nur über den Index zugegriffen werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt den minimalen Code, der für die <xref:System.Collections.ObjectModel.KeyedCollection%602>Ableitung von erforderlich ist, und zeigt viele der geerbten Methoden. Im zweiten Beispiel wird gezeigt, wie die geschützten Methoden von <xref:System.Collections.ObjectModel.KeyedCollection%602> überschrieben werden, um benutzerdefiniertes Verhalten bereitzustellen.  
  
 **Beispiel 1**  
  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die einen Standardgleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.ObjectModel.KeyedCollection%602> , der mit diesem Konstruktor erstellt wird, verwendet den generischen Standard Gleichheits Vergleich für den Typ des <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>Schlüssels, der aus abgerufen wird. Um einen anderen generischen Gleichheits Vergleich anzugeben, verwenden <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> Sie den-Konstruktor oder den <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> -Konstruktor.  
  
 Standardmäßig enthält das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn ein Element hinzugefügt <xref:System.Collections.ObjectModel.KeyedCollection%602>wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> -Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die den angegebenen Gleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn ein Element hinzugefügt <xref:System.Collections.ObjectModel.KeyedCollection%602>wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> -Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <param name="dictionaryCreationThreshold">Die Anzahl von Elementen, die die Collection enthalten kann, ohne dass ein Suchwörterbuch erstellt wird (bei Angabe von 0 wird bereits beim Hinzufügen des ersten Elements ein Suchwörterbuch erstellt), oder –1, um anzugeben, dass nie ein Suchwörterbuch erstellt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, bei der der angegebene Gleichheitsvergleich verwendet und beim Überschreiten des angegebenen Schwellenwerts ein Suchwörterbuch erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn ein Element hinzugefügt <xref:System.Collections.ObjectModel.KeyedCollection%602>wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Mit diesem Konstruktor können Sie dieses Verhalten überschreiben. Geben Sie 0 an, um das Wörterbuch zu erstellen, wenn das erste Element hinzugefügt wird, und 1, um das Wörterbuch zu erstellen, wenn das zweite Element hinzugefügt wird usw. Wenn Sie-1 als Schwellenwert angeben, wird das Such Wörterbuch nie erstellt.  
  
 Für sehr kleine Auflistungen ist die durch das Such Wörterbuch bereitgestellte Verbesserung der Abruf Geschwindigkeit möglicherweise nicht der zusätzliche Speicherplatz, der für das Wörterbuch erforderlich ist. Durch Festlegen eines Schwellenwerts können Sie entscheiden, wann dieser Kompromiss zu treffen ist.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor mit einem Schwellenwert von 0 verwendet, sodass das interne Wörterbuch erstellt wird, wenn der Auflistung das erste Mal ein Objekt hinzugefügt wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" /> ist kleiner als -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, dessen Schlüssel geändert werden soll.</param>
        <param name="newKey">Der neue Schlüssel für <paramref name="item" />.</param>
        <summary>Ändert den dem angegebenen Element im Suchwörterbuch zugeordneten Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ändert nicht den in `item`eingebetteten Schlüssel; Sie ersetzt einfach den im Such Wörterbuch gespeicherten Schlüssel.  Wenn `newKey` sich daher von dem Schlüssel unterscheidet, der in eingebettet `item`ist, können Sie `item` nicht mit dem von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>zurückgegebenen Schlüssel auf zugreifen.  
  
 Diese Methode führt keine Aktion aus <xref:System.Collections.ObjectModel.KeyedCollection%602> , wenn nicht über ein Such Wörterbuch verfügt.  
  
 Jeder Schlüssel in einem <xref:System.Collections.ObjectModel.KeyedCollection%602> muss eindeutig sein. Ein Schlüssel kann nicht `null`sein.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Bevor Sie den in ein Element eingebetteten Schlüssel ändern, müssen Sie diese Methode zum Aktualisieren des Schlüssels im Nachschlage Wörterbuch aufruft. Wenn der Schwellenwert für die Wörterbuch Erstellung den Wert-1 hat, ist das Aufrufen dieser Methode nicht erforderlich.  
  
 Machen Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> Methode nicht als öffentliche Methode einer abgeleiteten Klasse verfügbar. Durch den Missbrauch dieser Methode wird das Such Wörterbuch nicht mehr mit den Element Schlüsseln synchronisiert. Wenn Sie z. b. den `null` Schlüssel auf festlegen und ihn dann auf einen anderen Wert festlegen, werden dem Such Wörterbuch mehrere Schlüssel für ein Element hinzugefügt. Machen Sie diese Methode intern verfügbar, um änderbare Element Schlüssel zuzulassen: Wenn sich der Schlüssel für ein Element ändert, wird diese Methode verwendet, um den Schlüssel im Such Wörterbuch zu ändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> wurde nicht gefunden.  
  
- oder - 
 <paramref name="key" /> ist bereits in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Such Wörterbuch vorhanden ist, wird es von dieser Methode gelöscht, aber nicht gelöscht.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung <xref:System.Collections.ObjectModel.KeyedCollection%602> überschritten hat und das Such Wörterbuch verwendet, wird weiterhin ein Nachschlage Wörterbuch verwendet, obwohl die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.ObjectModel.Collection%601.Count%2A>dem gleich ist.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten für <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> die <xref:System.Collections.ObjectModel.Collection%601> Methode bereitzustellen, die von der generischen Klasse  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um die zugrunde liegende Auflistung zu löschen und das Such Wörterbuch zu löschen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> wie die-Methode überschrieben wird, um das Löschen aller Objekte aus der Auflistung zu ermöglichen. Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den generischen Gleichheitsvergleich ab, der verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</summary>
        <value>Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob die Auflistung ein Element mit dem angegebenen Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch enthält, `key` wird verwendet, um das Wörterbuch zu durchsuchen. Wenn kein Such Wörterbuch vorhanden ist, wird der Schlüssel der einzelnen Elemente mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode extrahiert und mit dem angegebenen Schlüssel verglichen.  
  
 Bei dieser Methode handelt es sich um einen o (1 <xref:System.Collections.ObjectModel.KeyedCollection%602> )-Vorgang, wenn der über ein Such Wörterbuch verfügt; andernfalls handelt `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>sich um eine o (`n`)-Operation, bei der  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ab.</summary>
        <value>Das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, sofern vorhanden, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn ein Element hinzugefügt <xref:System.Collections.ObjectModel.KeyedCollection%602>wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> -Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, aus dem der Schlüssel extrahiert werden soll.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse wird der Schlüssel aus dem angegebenen Element extrahiert.</summary>
        <returns>Der Schlüssel für das angegebene Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich der Schlüssel im Such Wörterbuch von dem Schlüssel unterscheidet, der in `item`eingebettet ist, können `item` Sie nicht mit dem von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>zurückgegebenen Schlüssel auf zugreifen.  
  
 Sie können diese Methode implementieren, um `null` für eine Auflistung zurückzugeben, die Elemente ohne Schlüssel enthält. in diesem Fall kann nur über ihren Index auf die Elemente zugegriffen werden. Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Sie müssen diese Methode überschreiben, um dem Wörterbuch eine Möglichkeit zur Verfügung zu stellen, um Schlüssel aus Elementen im Wörterbuch zu extrahieren.  
  
 Diese Methode wird intern aufgerufen. Es ist nicht erforderlich, dass es öffentlich ist.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleichist`item`,wird am Ende der <xref:System.Collections.ObjectModel.KeyedCollection%602>hinzugefügt. <xref:System.Collections.ObjectModel.Collection%601.Count%2A>  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.ObjectModel.Collection%601.Count%2A>dem gleich ist.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>wird von der- <xref:System.Collections.ObjectModel.Collection%601.Add%2A> Methode <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> und der-Methode aufgerufen.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A> Methoden und <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> bereitzustellen, die von der <xref:System.Collections.ObjectModel.Collection%601> generischen Klasse  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element in die zugrunde liegende Auflistung einzufügen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> wie die-Methode überschrieben wird, um benutzerdefiniertes Verhalten zum Hinzufügen oder Einfügen von Objekten in die Auflistung Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden Elements.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab.</summary>
        <value>Das Element mit dem angegebenen Schlüssel. Wenn kein Element mit dem angegebenen Schlüssel gefunden wird, wird eine Ausnahme ausgelöst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet die Möglichkeit, auf ein bestimmtes Element in der Auflistung zuzugreifen, indem die folgende Syntax `myCollection[key]` verwendet`myCollection(key)` wird: (in Visual Basic).  
  
> [!NOTE]
>  Diese Eigenschaft unterscheidet sich von der <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> geerbten-Eigenschaft, die Elemente nach dem numerischen Index abruft und festlegt. Wenn `TKey` jedoch vom Typ <xref:System.Int32>ist, maskiert diese Eigenschaft die geerbte Eigenschaft. In diesem Fall können Sie auf die geerbte Eigenschaft zugreifen, indem <xref:System.Collections.ObjectModel.KeyedCollection%602> Sie den in den Basistyp umwandeln. `KeyedCollection<int, MyType>` Beispielsweise kann (`KeyedCollection(Of Integer, MyType)` in Visual Basic `Collection<MyType>` `Collection(Of MyType)` `Collection<MyType^>` in) in umgewandelt werden (in Visual Basic C++). C++ `KeyedCollection<int, MyType^>`  
  
 Wenn das <xref:System.Collections.ObjectModel.KeyedCollection%602> Such Wörterbuch enthält, `key` wird verwendet, um das Element aus dem Wörterbuch abzurufen.  Wenn kein Such Wörterbuch vorhanden ist, wird der Schlüssel der einzelnen Elemente mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> -Methode extrahiert und mit dem angegebenen Schlüssel verglichen.  
  
 Die C# Sprache verwendet das [this](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort, um die Indexer zu definieren, <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> statt die-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> als [Standard Eigenschaft](~/docs/visual-basic/language-reference/modifiers/default.md), die die gleiche Indizierungs Funktionalität bereitstellt.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein o (1)-Vorgang, wenn <xref:System.Collections.ObjectModel.KeyedCollection%602> der ein Such Wörterbuch aufweist; andernfalls ist es ein`n`o ()- `n` Vorgang <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, bei dem gleich ist.

## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Im Codebeispiel wird die- <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> Eigenschaft aufgerufen, die schreibgeschützt ist und nach Schlüssel abgerufen wird, sowie die <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> -Eigenschaft, die festgelegt werden kann und nach Index abgerufen wird. Es zeigt, wie auf die letztere Eigenschaft zugegriffen wird, wenn die Objekte in der abgeleiteten Auflistung ganzzahlige Schlüssel aufweisen, die nicht von den ganzen Zahlen für den indizierten Abruf unterschieden werden können.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">In der Auflistung ist kein Element mit dem angegebenen Schlüssel vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns><see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird auch aus dem Such Wörterbuch entfernt.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung <xref:System.Collections.ObjectModel.KeyedCollection%602> überschritten hat und das Such Wörterbuch verwendet, wird weiterhin ein Nachschlage Wörterbuch verwendet, obwohl die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
> [!NOTE]
>  Um das Verhalten dieser Methode anzupassen, überschreiben Sie <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> die-Methode.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.ObjectModel.Collection%601.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse <xref:System.Collections.ObjectModel.KeyedCollection%602>von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> erforderlich ist: Überschreiben der-Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele der Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> der <xref:System.Collections.ObjectModel.Collection%601> -Klasse und der-Klasse geerbt wurden.  
  
 Das Beispiel veranschaulicht <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> die von <xref:System.Collections.ObjectModel.KeyedCollection%602>geerbte Methode, mit der das Element mit einem angegebenen Schlüssel entfernt wird <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> , <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> sowie <xref:System.Collections.ObjectModel.Collection%601>die-und-Methoden, die von geerbt werden, die nach dem-Objekt bzw. dem Index entfernt werden.  
  
 Die `SimpleOrder` -Klasse ist eine sehr einfache Liste der Anforderungen, `OrderItem` die-Objekte enthält, die jeweils ein Zeilen Element in der Reihenfolge darstellen. Der Schlüssel von `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird auch aus dem Such Wörterbuch entfernt.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung <xref:System.Collections.ObjectModel.KeyedCollection%602> überschritten hat und das Such Wörterbuch verwendet, wird weiterhin ein Nachschlage Wörterbuch verwendet, obwohl die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.ObjectModel.Collection%601.Count%2A>dem gleich ist.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> angepasstes Verhalten für die-und- <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> Methoden bereitzustellen <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> , die von der <xref:System.Collections.ObjectModel.Collection%601> generischen-Klasse geerbt wurden  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element aus der zugrunde liegenden Auflistung zu entfernen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> wie die-Methode überschrieben wird, um benutzerdefiniertes Verhalten zum Entfernen von Objekten aus der Auflistung Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu ersetzenden Elements.</param>
        <param name="item">Das neue Element.</param>
        <summary>Ersetzt das Element im angegebenen Index durch ein angegebenes Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Such Wörterbuch wird entsprechend aktualisiert. Das heißt, der Schlüssel des Elements, das ersetzt wird, wird aus dem Such Wörterbuch entfernt, und der Schlüssel des neuen Elements wird hinzugefügt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um das angepasste Verhalten <xref:System.Collections.ObjectModel.Collection%601.Item%2A> zum Festlegen der von <xref:System.Collections.ObjectModel.Collection%601> der generischen Klasse geerbten Eigenschaft bereitzustellen.  
  
> [!NOTE]
>  Diese Methode wirkt sich nicht auf das Verhalten der <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> -Eigenschaft aus, die schreibgeschützt ist.  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element in der zugrunde liegenden Auflistung festzulegen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> wie die-Methode überschrieben wird, <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> um benutzerdefiniertes Verhalten beim Festlegen der-Eigenschaft Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird gezeigt, wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>Methoden,, und überschrieben werden, um benutzerdefiniertes <xref:System.Collections.ObjectModel.Collection%601.Add%2A>Verhalten <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methoden, und bereitzustellen. Festlegen der Default <xref:System.Collections.ObjectModel.Collection%601.Item%2A> -Eigenschaft (Indexer in C#). Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder` -Klasse erstellt, die <xref:System.Collections.ObjectModel.KeyedCollection%602> von abgeleitet wird und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` -Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in `Main` der-Methode `Demo` der-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>, finden Sie unter.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> geschützte Methode überschreiben, um änderbare Schlüssel zu unterstützen, und <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>wie Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>Methoden,, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und überschreiben, um die Integrität der Schlüssel und die-Auflistung.  
  
 Das Codebeispiel erstellt die `MutableKeys` -Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, `MutableKey` und die-Klasse. Die `MutableKey` -Klasse verfügt über eine `Key` festleg Bare Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` -Methode der-Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey` -Objekt und der `MutableKeys` -Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt `MutableKey` wird, verfügt `internal` die`Friend` -Klasse über einen (in Visual Basic) `Collection`.ein. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> bereitstellen, z. b. die-Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
