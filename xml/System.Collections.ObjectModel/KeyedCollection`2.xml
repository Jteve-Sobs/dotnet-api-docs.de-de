<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f5d50e3b4bf156e2003d7d4ad6e0488de81edc2" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83967711" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.ObjectModel" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.ObjectModel" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel in der Auflistung.</typeparam>
    <typeparam name="TItem">Der Typ der Elemente in der Auflistung.</typeparam>
    <summary>Stellt die abstrakte Basisklasse für eine Auflistung bereit, deren Schlüssel in die Werte eingebettet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.ObjectModel.KeyedCollection%602>-Klasse bietet sowohl den o (1)-indizierten Abruf als auch den Schlüssel gebundenen Abruf, der o (1) angeht. Es handelt sich um einen abstrakten Typ oder eine präzisere Menge abstrakter Typen, da jeder seiner konstruierten generischen Typen eine abstrakte Basisklasse ist. Um <xref:System.Collections.ObjectModel.KeyedCollection%602>zu verwenden, leiten Sie den Auflistungstyp vom entsprechenden konstruierten Typ ab.  
  
 Die <xref:System.Collections.ObjectModel.KeyedCollection%602>-Klasse ist eine Hybride zwischen einer Auflistung, die auf der <xref:System.Collections.Generic.IList%601> generischen Schnittstelle basiert, und einer Auflistung, die auf der <xref:System.Collections.Generic.IDictionary%602> generischen Schnittstelle basiert Wie Auflistungen, die auf der <xref:System.Collections.Generic.IList%601> generischen Schnittstelle basieren, ist <xref:System.Collections.ObjectModel.KeyedCollection%602> eine indizierte Liste von Elementen. Wie Auflistungen, die auf der <xref:System.Collections.Generic.IDictionary%602> generischen Schnittstelle basieren, verfügt <xref:System.Collections.ObjectModel.KeyedCollection%602> über einen Schlüssel, der jedem Element zugeordnet  
  
 Im Gegensatz zu Wörterbüchern ist ein Element von <xref:System.Collections.ObjectModel.KeyedCollection%602> kein Schlüssel/Wert-Paar. Stattdessen ist das gesamte Element der Wert, und der Schlüssel wird in den Wert eingebettet.  Beispielsweise könnte ein Element einer Auflistung, die von `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` in Visual Basic) abgeleitet ist, "John Doe Jr" lauten. Dabei ist der Wert "John Doe Jr". und der Schlüssel ist "Doe". oder eine Auflistung von Mitarbeiterdaten Sätzen, die ganzzahlige Schlüssel enthalten, kann von `KeyedCollection\<int,Employee>`abgeleitet werden. Die abstrakte <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>-Methode extrahiert den Schlüssel aus dem Element.  
  
 Standardmäßig enthält die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch, das Sie mit der <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A>-Eigenschaft abrufen können.  Wenn dem <xref:System.Collections.ObjectModel.KeyedCollection%602>ein Element hinzugefügt wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten wird überschrieben, wenn Sie beim Erstellen des <xref:System.Collections.ObjectModel.KeyedCollection%602>einen Schwellenwert für die Wörterbuch Erstellung angeben. Das Such Wörterbuch wird erstellt, wenn die Anzahl der Elemente den Schwellenwert überschreitet.  Wenn Sie-1 als Schwellenwert angeben, wird das Such Wörterbuch nie erstellt.  
  
> [!NOTE]
>  Wenn das interne Such Wörterbuch verwendet wird, enthält es Verweise auf alle Elemente in der Auflistung, wenn `TItem` ein Referenztyp ist, oder kopiert alle Elemente in der Auflistung, wenn `TItem` ein Werttyp ist. Daher ist es möglicherweise nicht sinnvoll, das Such Wörterbuch zu verwenden, wenn `TItem` ein Werttyp ist.  
  
 Sie können über den Index oder Schlüssel auf ein Element zugreifen, indem Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>-Eigenschaft verwenden. Sie können Elemente ohne Schlüssel hinzufügen, aber auf diese Elemente kann dann nur über den Index zugegriffen werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt den minimalen Code, der zum Ableiten von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist, und zeigt viele der geerbten Methoden. Im zweiten Beispiel wird gezeigt, wie die geschützten Methoden von <xref:System.Collections.ObjectModel.KeyedCollection%602> überschrieben werden, um benutzerdefiniertes Verhalten bereitzustellen.  
  
 **Beispiel 1**  
  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die einen Standardgleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.ObjectModel.KeyedCollection%602>, das mit diesem Konstruktor erstellt wird, verwendet den generischen Standard Gleichheits Vergleich für den Typ des Schlüssels, der von <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>abgerufen wird. Um einen anderen generischen Gleichheits Vergleich anzugeben, verwenden Sie den <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29>-Konstruktor oder den <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>-Konstruktor.  
  
 Standardmäßig enthält die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn dem <xref:System.Collections.ObjectModel.KeyedCollection%602>ein Element hinzugefügt wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>-Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602>-Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, die den angegebenen Gleichheitsvergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn dem <xref:System.Collections.ObjectModel.KeyedCollection%602>ein Element hinzugefügt wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>-Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602>-Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die beim Schlüsselvergleich verwendet werden soll, oder <see langword="null" />, damit der Standardgleichheitsvergleich für den Typ des Schlüssels verwendet wird, der aus dem <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> abgerufen wird.</param>
        <param name="dictionaryCreationThreshold">Die Anzahl von Elementen, die die Collection enthalten kann, ohne dass ein Suchwörterbuch erstellt wird (bei Angabe von 0 wird bereits beim Hinzufügen des ersten Elements ein Suchwörterbuch erstellt), oder –1, um anzugeben, dass nie ein Suchwörterbuch erstellt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />-Klasse, bei der der angegebene Gleichheitsvergleich verwendet und beim Überschreiten des angegebenen Schwellenwerts ein Suchwörterbuch erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn dem <xref:System.Collections.ObjectModel.KeyedCollection%602>ein Element hinzugefügt wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Mit diesem Konstruktor können Sie dieses Verhalten überschreiben. Geben Sie 0 an, um das Wörterbuch zu erstellen, wenn das erste Element hinzugefügt wird, und 1, um das Wörterbuch zu erstellen, wenn das zweite Element hinzugefügt wird usw. Wenn Sie-1 als Schwellenwert angeben, wird das Such Wörterbuch nie erstellt.  
  
 Für sehr kleine Auflistungen ist die durch das Such Wörterbuch bereitgestellte Verbesserung der Abruf Geschwindigkeit möglicherweise nicht der zusätzliche Speicherplatz, der für das Wörterbuch erforderlich ist. Durch Festlegen eines Schwellenwerts können Sie entscheiden, wann dieser Kompromiss zu treffen ist.  
  
> [!NOTE]
>  Da die <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasse abstrakt (`MustInherit` in Visual Basic) ist, müssen Sie von ihr ableiten, damit Sie verwendet werden kann. Nennen Sie im Konstruktor für den abgeleiteten Typ den entsprechenden <xref:System.Collections.ObjectModel.KeyedCollection%602>-Konstruktor. Es ist nicht erforderlich, Funktionen wie den Gleichheits Vergleich oder den Schwellenwert für die Wörterbuch Erstellung in den Konstruktoren verfügbar zu machen.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>-Konstruktor mit einem Schwellenwert von 0 verwendet, sodass das interne Wörterbuch erstellt wird, wenn ein Objekt der Auflistung erstmalig hinzugefügt wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" /> ist kleiner als –1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, dessen Schlüssel geändert werden soll.</param>
        <param name="newKey">Der neue Schlüssel für <paramref name="item" />.</param>
        <summary>Ändert den dem angegebenen Element im Suchwörterbuch zugeordneten Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird der in `item`eingebettete Schlüssel nicht geändert. Es ersetzt einfach den im Such Wörterbuch gespeicherten Schlüssel.  Wenn sich `newKey` von dem in `item`eingebetteten Schlüssel unterscheidet, können Sie daher nicht auf `item` zugreifen, indem Sie den von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>zurückgegebenen Schlüssel verwenden.  
  
 Diese Methode führt keine Aktion aus, wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> nicht über ein Such Wörterbuch verfügt.  
  
 Jeder Schlüssel in einer <xref:System.Collections.ObjectModel.KeyedCollection%602> muss eindeutig sein. Ein Schlüssel kann nicht `null`werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Bevor Sie den in ein Element eingebetteten Schlüssel ändern, müssen Sie diese Methode zum Aktualisieren des Schlüssels im Nachschlage Wörterbuch aufruft. Wenn der Schwellenwert für die Wörterbuch Erstellung den Wert-1 hat, ist das Aufrufen dieser Methode nicht erforderlich.  
  
 Machen Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode nicht als öffentliche Methode einer abgeleiteten Klasse verfügbar. Durch den Missbrauch dieser Methode wird das Such Wörterbuch nicht mehr mit den Element Schlüsseln synchronisiert. Wenn Sie z. b. den Schlüssel auf `null` festlegen und ihn dann auf einen anderen Wert festlegen, werden dem Such Wörterbuch mehrere Schlüssel für ein Element hinzugefügt. Diese Methode intern verfügbar machen, um änderbare Element Schlüssel zuzulassen: Wenn sich der Schlüssel für ein Element ändert, wird diese Methode verwendet, um den Schlüssel im Such Wörterbuch zu ändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="key" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> wurde nicht gefunden.  
  
- oder - 
 <paramref name="key" /> ist bereits in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Such Wörterbuch vorhanden ist, wird es von dieser Methode gelöscht, aber nicht gelöscht.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch verwendet, wird auch dann weiterhin ein Nachschlage Wörterbuch verwendet, wenn die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> Methode bereitzustellen, die von der <xref:System.Collections.ObjectModel.Collection%601> generischen Klasse geerbt  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um die zugrunde liegende Auflistung zu löschen und das Such Wörterbuch zu löschen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, wie die <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-Methode überschrieben wird, um benutzerdefiniertes Verhalten zum Löschen aller Objekte aus der Auflistung bereitzustellen Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den generischen Gleichheitsvergleich ab, der verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</summary>
        <value>Die Implementierung der generischen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Schnittstelle, die verwendet wird, um die Gleichheit von Schlüsseln in der Auflistung zu bestimmen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, der in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> gesucht werden soll.</param>
        <summary>Bestimmt, ob die Auflistung ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein Element mit dem angegebenen Schlüssel enthält; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> über ein Such Wörterbuch verfügt, wird `key` verwendet, um das Wörterbuch zu durchsuchen. Wenn kein Such Wörterbuch vorhanden ist, wird der Schlüssel der einzelnen Elemente mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>-Methode extrahiert und mit dem angegebenen Schlüssel verglichen.  
  
 Bei dieser Methode handelt es sich um einen O (1)-Vorgang, wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch enthält. andernfalls handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ab.</summary>
        <value>Das Suchwörterbuch der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, sofern vorhanden, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch, das beim Hinzufügen des ersten Elements erstellt wird. Wenn dem <xref:System.Collections.ObjectModel.KeyedCollection%602>ein Element hinzugefügt wird, wird der Schlüssel des Elements einmal extrahiert und für schnellere Suchvorgänge im Such Wörterbuch gespeichert. Dieses Verhalten kann überschrieben werden, indem der <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>-Konstruktor verwendet und ein Schwellenwert für die Wörterbuch Erstellung angegeben wird.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, aus dem der Schlüssel extrahiert werden soll.</param>
        <summary>Bei Implementierung in einer abgeleiteten Klasse wird der Schlüssel aus dem angegebenen Element extrahiert.</summary>
        <returns>Der Schlüssel für das angegebene Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich der Schlüssel im Nachschlage Wörterbuch von dem in `item`eingebetteten Schlüssel unterscheidet, können Sie nicht mit dem von <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>zurückgegebenen Schlüssel auf `item` zugreifen.  
  
 Sie können diese Methode implementieren, um `null` für eine Auflistung zurückzugeben, die Elemente ohne Schlüssel enthält. in diesem Fall kann nur über ihren Index auf die Elemente zugegriffen werden. Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Sie müssen diese Methode überschreiben, um dem Wörterbuch eine Möglichkeit zur Verfügung zu stellen, um Schlüssel aus Elementen im Wörterbuch zu extrahieren.  
  
 Diese Methode wird intern aufgerufen. Es ist nicht erforderlich, dass es öffentlich ist.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt.</param>
        <summary>Fügt ein Element am angegebenen Index in die <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist, wird `item` am Ende der <xref:System.Collections.ObjectModel.KeyedCollection%602>hinzugefügt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> wird von den Methoden <xref:System.Collections.ObjectModel.Collection%601.Add%2A> und <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> aufgerufen.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Insert%2A>-Methoden bereitzustellen, die von der generischen <xref:System.Collections.ObjectModel.Collection%601>  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element in die zugrunde liegende Auflistung einzufügen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, wie die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-Methode überschrieben wird, um benutzerdefiniertes Verhalten zum Hinzufügen oder Einfügen von Objekten in die Auflistung Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden Elements.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab.</summary>
        <value>Das Element mit dem angegebenen Schlüssel. Wenn kein Element mit dem angegebenen Schlüssel gefunden wird, wird eine Ausnahme ausgelöst.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe der folgenden Syntax: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
> [!NOTE]
>  Diese Eigenschaft unterscheidet sich von der geerbten <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>-Eigenschaft, die Elemente nach dem numerischen Index abruft und festlegt. Wenn `TKey` jedoch vom Typ <xref:System.Int32>ist, maskiert diese Eigenschaft die geerbte Eigenschaft. In diesem Fall können Sie auf die geerbte Eigenschaft zugreifen, indem Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602> in ihren Basistyp umwandeln. Beispielsweise können `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` in Visual Basic, `KeyedCollection<int, MyType^>` in C++) in `Collection<MyType>` (`Collection(Of MyType)` Visual Basic in C++) umgewandelt werden.`Collection<MyType^>`  
  
 Wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> über ein Such Wörterbuch verfügt, wird `key` verwendet, um das Element aus dem Wörterbuch abzurufen.  Wenn kein Such Wörterbuch vorhanden ist, wird der Schlüssel der einzelnen Elemente mithilfe der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>-Methode extrahiert und mit dem angegebenen Schlüssel verglichen.  
  
 Die C# Sprache verwendet das [this](/dotnet/csharp/language-reference/keywords/this) -Schlüsselwort zum Definieren der Indexer, anstatt die <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> als [Standard Eigenschaft](/dotnet/visual-basic/language-reference/modifiers/default), die die gleiche Indizierungs Funktionalität bereitstellt.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang, wenn die <xref:System.Collections.ObjectModel.KeyedCollection%602> über ein Such Wörterbuch verfügt. andernfalls handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.

## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Im Codebeispiel wird die <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>-Eigenschaft aufgerufen, die schreibgeschützt ist und nach Schlüssel abgerufen wird, sowie die <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>-Eigenschaft, die festgelegt werden kann und nach Index abgerufen wird. Es zeigt, wie auf die letztere Eigenschaft zugegriffen wird, wenn die Objekte in der abgeleiteten Auflistung ganzzahlige Schlüssel aufweisen, die nicht von den ganzen Zahlen für den indizierten Abruf unterschieden werden können.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">In der Auflistung ist kein Element mit dem angegebenen Schlüssel vorhanden.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns><see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht in der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird auch aus dem Such Wörterbuch entfernt.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch verwendet, wird auch dann weiterhin ein Nachschlage Wörterbuch verwendet, wenn die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
> [!NOTE]
>  Um das Verhalten dieser Methode anzupassen, überschreiben Sie die <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-Methode.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.  
  
   
  
## Examples  
 Dieses Codebeispiel zeigt den minimalen Code, der zum Ableiten einer Auflistungs Klasse von <xref:System.Collections.ObjectModel.KeyedCollection%602>erforderlich ist: Überschreiben der <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Methode und Bereitstellen eines öffentlichen Konstruktors, der an einen Basisklassenkonstruktor delegiert. Das Codebeispiel veranschaulicht auch viele Eigenschaften und Methoden, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>-und <xref:System.Collections.ObjectModel.Collection%601>-Klassen geerbt werden.  
  
 Das Beispiel veranschaulicht <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> von <xref:System.Collections.ObjectModel.KeyedCollection%602>geerbte Methode, die das Element mit einem angegebenen Schlüssel entfernt, sowie die von <xref:System.Collections.ObjectModel.Collection%601>geerbten <xref:System.Collections.ObjectModel.Collection%601.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> Methoden, die nach Objekt bzw. Index entfernt werden.  
  
 Die `SimpleOrder`-Klasse ist eine sehr einfache Gespräche-Liste, die `OrderItem`-Objekte enthält, die jeweils ein Zeilen Element in der Bestellung darstellen. Der Schlüssel `OrderItem` ist unveränderlich, ein wichtiger Aspekt bei Klassen, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet werden. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel des Elements wird auch aus dem Such Wörterbuch entfernt.  
  
 Wenn die Anzahl der Elemente den Schwellenwert für die Wörterbuch Erstellung überschritten hat und die <xref:System.Collections.ObjectModel.KeyedCollection%602> ein Such Wörterbuch verwendet, wird auch dann weiterhin ein Nachschlage Wörterbuch verwendet, wenn die Anzahl der Elemente wieder unter dem Schwellenwert liegt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>ist.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29>-und <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> Methoden bereitzustellen, die von der <xref:System.Collections.ObjectModel.Collection%601> generischen Klasse geerbt werden, und die <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29>  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element aus der zugrunde liegenden Auflistung zu entfernen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, wie die <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-Methode überschrieben wird, um ein benutzerdefiniertes Verhalten zum Entfernen von Objekten aus der Auflistung Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu ersetzenden Elements.</param>
        <param name="item">Das neue Element.</param>
        <summary>Ersetzt das Element im angegebenen Index durch ein angegebenes Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Such Wörterbuch wird entsprechend aktualisiert. Das heißt, der Schlüssel des Elements, das ersetzt wird, wird aus dem Such Wörterbuch entfernt, und der Schlüssel des neuen Elements wird hinzugefügt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
## <a name="notes-for-implementers"></a>Hinweise für Implementierer  
 Überschreiben Sie diese Methode, um ein angepasstes Verhalten zum Festlegen der <xref:System.Collections.ObjectModel.Collection%601.Item%2A> Eigenschaft bereitzustellen, die von der <xref:System.Collections.ObjectModel.Collection%601> generischen Klasse  
  
> [!NOTE]
>  Diese Methode wirkt sich nicht auf das Verhalten der <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>-Eigenschaft aus, die schreibgeschützt ist.  
  
 Ruft die Basisklassen Implementierung dieser Methode auf, um das Element in der zugrunde liegenden Auflistung festzulegen und das Such Wörterbuch zu aktualisieren.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele, die veranschaulichen, wie die <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>-Methode überschrieben wird, um benutzerdefiniertes Verhalten zum Festlegen der <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>-Eigenschaft Im ersten Beispiel wird ein benutzerdefiniertes Benachrichtigungs Ereignis hinzugefügt, das zweite unterstützt eine Auflistung von-Objekten mit änderbaren Schlüsseln.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden der geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> überschrieben werden, um benutzerdefiniertes Verhalten für die <xref:System.Collections.ObjectModel.Collection%601.Add%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>-und <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>-Methode bereitzustellen und die standardmäßige <xref:System.Collections.ObjectModel.Collection%601.Item%2A> C#-Eigenschaft (Indexer in) festzulegen. Das in diesem Beispiel bereitgestellte benutzerdefinierte Verhalten ist ein Benachrichtigungs Ereignis namens `Changed`, das am Ende jeder überschriebenen Methode ausgelöst wird.  
  
 Im Codebeispiel wird die `SimpleOrder`-Klasse erstellt, die von <xref:System.Collections.ObjectModel.KeyedCollection%602> abgeleitet ist und ein einfaches Bestellformular darstellt. Das Bestellformular enthält `OrderItem` Objekte, die geordnete Elemente darstellen. Das Codebeispiel erstellt außerdem eine `SimpleOrderChangedEventArgs` Klasse, die die Ereignis Informationen enthält, und eine Enumeration, um den Typ der Änderung zu identifizieren.  
  
 Im Codebeispiel wird das benutzerdefinierte Verhalten veranschaulicht, indem die Eigenschaften und Methoden der abgeleiteten Klasse in der `Main`-Methode der `Demo`-Klasse aufgerufen werden.  
  
 In diesem Codebeispiel werden-Objekte mit unveränderlichen Schlüsseln verwendet. Ein Codebeispiel, in dem änderbare Schlüssel verwendet werden, finden Sie unter <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die geschützte <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>-Methode überschrieben wird, um änderbare Schlüssel zu unterstützen, und wie die geschützten <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>-, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>-und <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> Methoden überschrieben werden, um die Integrität der Schlüssel und der Auflistung aufrechtzuerhalten.  
  
 Das Codebeispiel erstellt die `MutableKeys`-Auflistung, die von <xref:System.Collections.ObjectModel.KeyedCollection%602>abgeleitet ist, und die `MutableKey`-Klasse. Die `MutableKey`-Klasse verfügt über eine festleg Bare `Key`-Eigenschaft. Wenn der Eigenschaft ein neuer Schlüssel zugewiesen wird, ruft der Eigenschaften Setter die `internal` (`Friend` in Visual Basic) `ChangeKey` Methode der Auflistung auf, um zu überprüfen, ob der neue Schlüssel mit einem vorhandenen Schlüssel in Konflikt steht. Wenn dies der Fall ist, wird eine Ausnahme ausgelöst, und der Eigenschafts Wert wird nicht geändert.  
  
 Um die Verbindung zwischen einem `MutableKey`-Objekt und der `MutableKeys` Auflistung beizubehalten und zu verhindern, dass ein Objekt in zwei Auflistungen eingefügt wird, verfügt die `MutableKey`-Klasse über ein `internal` (`Friend` Visual Basic) `Collection` Feld. Dieses Feld wird von den geschützten Methoden verwaltet, die benutzerdefiniertes Verhalten zum Hinzufügen und Entfernen von Elementen aus der Auflistung bereitstellen, z. b. die <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Methode. Das-Feld wird festgelegt, wenn das Element einer Auflistung hinzugefügt und beim Entfernen des Elements gelöscht wird.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key * 'Item -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des Elements, das in der Sammlung gesucht werden soll.</param>
        <param name="item">Wenn diese Methode <see langword="true" /> zurückgibt, das Element aus der Sammlung, das mit dem angegebenen Schlüssel übereinstimmt. Wenn diese Methode <see langword="false" /> zurückgibt, der <see langword="default" />-Wert für den Typ der Sammlung.</param>
        <summary>Versucht, ein Element mit dem angegebenen Schlüssel aus der Sammlung abzurufen.</summary>
        <returns><see langword="true" />, wenn ein Element für den angegebenen Schlüssel in der Sammlung gefunden wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>
