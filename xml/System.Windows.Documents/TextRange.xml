<Type Name="TextRange" FullName="System.Windows.Documents.TextRange">
  <Metadata><Meta Name="ms.openlocfilehash" Value="26862f7b9f8e43f79a89a4b20e4ffa5138cd86ac" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78812678" /></Metadata><TypeSignature Language="C#" Value="public class TextRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextRange" />
  <TypeSignature Language="F#" Value="type TextRange = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Inhaltsauswahl zwischen zwei <see cref="T:System.Windows.Documents.TextPointer" />-Positionen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Documents.TextRange>-Klasse führt die folgende Terminologie ein.  
  
-   **Auswahl** : eine <xref:System.Windows.Documents.TextRange> ist eine Auswahl von Inhalten zwischen zwei von **Text Zeigern**gekennzeichneten Positionen.  Eine dieser Positionen positioniert einen Fixed-Anker in Bezug auf die Auswahl, während die andere Position verschiebbar ist.  Dies ähnelt der Art und Weise, wie sich ein Benutzer mit der Maus oder der Tastatur verhält.  
  
-   **Aktuelle Auswahl** : da ein <xref:System.Windows.Documents.TextRange> immer eine Auswahl im Inhalt anzeigt, ist es sinnvoll, einfach auf die Auswahl zu verweisen, die durch eine <xref:System.Windows.Documents.TextRange> als *aktuelle Auswahl*angegeben wird.  
  
-   **Text Container** : ein *Text Container* ist das Element, das den endgültigen Rahmen für den Flow-Inhalt bildet. die Auswahl, die von einem <xref:System.Windows.Documents.TextRange> angegeben wird, liegt immer innerhalb eines Text Containers.  Derzeit muss ein Text Container entweder eine <xref:System.Windows.Documents.FlowDocument> oder eine <xref:System.Windows.Controls.TextBlock>sein.  
  
-   **Dokument** -der Inhalt, der in einem Text Container Kollektiv enthalten ist, wird als *Dokument*bezeichnet.  
  
 Weitere Informationen zu anderen verwandten Begriffen, wie z. b. *Position*, finden Sie unter <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Windows.Documents.TextRange.Text%2A>-Eigenschaft eines <xref:System.Windows.Documents.TextRange> verwendet wird, um die nur-Text-Darstellung eines angegebenen <xref:System.Windows.Documents.FlowDocument>zurückzugeben.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextRange (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.#ctor(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextRange(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.TextRange : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="new System.Windows.Documents.TextRange (position1, position2)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Eine feste Ankerposition, die ein Ende der Auswahl für den neuen <see cref="T:System.Windows.Documents.TextRange" /> markiert.</param>
        <param name="position2">Eine verschiebbare Ankerposition, die das andere Ende der Auswahl für den neuen <see cref="T:System.Windows.Documents.TextRange" /> markiert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Documents.TextRange" />-Klasse mit zwei angegebenen <see cref="T:System.Windows.Documents.TextPointer" />-Positionen als Anfangs- und Endpositionen für den neuen Bereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Documents.TextRange> wird aus einer Auswahl zwischen zwei Positionen gebildet, die von **Text Zeigern**angegeben werden.  Eine dieser Positionen (angegeben durch `position1`) wird in Bezug auf die Auswahl korrigiert, während die andere Position (angegeben durch `position2`) verschiebbar ist.  Dies ähnelt der Art und Weise, wie sich ein Benutzer mit der Maus oder der Tastatur verhält.  
  
 Die eigentlichen Enden der neuen <xref:System.Windows.Documents.TextRange> können so angepasst werden, dass Sie einer beliebigen Auswahl-Heuristik entsprechen, die auf das Dokument anwendbar ist, das die neue <xref:System.Windows.Documents.TextRange>enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des <xref:System.Windows.Documents.TextRange>-Konstruktors veranschaulicht.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn <paramref name="position1" /> und <paramref name="position2" /> nicht innerhalb desselben Dokuments positioniert sind.</exception>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn <paramref name="position1" /> oder <paramref name="position2" /> den Wert <see langword="null" /> hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyValue">
      <MemberSignature Language="C#" Value="public void ApplyPropertyValue (System.Windows.DependencyProperty formattingProperty, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyValue(class System.Windows.DependencyProperty formattingProperty, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyValue (formattingProperty As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyValue(System::Windows::DependencyProperty ^ formattingProperty, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="textRange.ApplyPropertyValue (formattingProperty, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Eine anzuwendende Formatierungseigenschaft.</param>
        <param name="value">Der Wert der Formatierungseigenschaft.</param>
        <summary>Wendet auf die aktuelle Auswahl eine angegebene Formatierungseigenschaft und einen Wert an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wendet die Formatierung an, indem die entsprechenden <xref:System.Windows.Documents.Inline> Elemente (z. b. <xref:System.Windows.Documents.Bold> und <xref:System.Windows.Documents.Italic>in die Auswahl eingefügt werden, die von diesem <xref:System.Windows.Documents.TextRange>angegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.ApplyPropertyValue%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn <paramref name="formattingProperty" /> keine gültige Formatierungseigenschaft oder <paramref name="value" /> einen ungültigen Wert für <paramref name="formattingProperty" /> angibt.</exception>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn <paramref name="formattingProperty" /> gleich <see langword="null" /> ist.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="CanLoad">
      <MemberSignature Language="C#" Value="public bool CanLoad (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanLoad(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanLoad (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanLoad(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanLoad : string -&gt; bool" Usage="textRange.CanLoad dataFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Ein Datenformat, das Ladekompatibilität mit der aktuellen Auswahl überprüft werden soll.  Eine Liste vordefinierter Datenformate finden Sie unter <see cref="T:System.Windows.DataFormats" />.</param>
        <summary>Überprüft, ob die aktuelle Auswahl mit Inhalt in ein angegebenes Datenformat geladen werden kann.</summary>
        <returns><see langword="true" />, wenn die aktuelle Auswahl mit Inhalt in dass angegebene Datenformat geladen werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die entsprechende <xref:System.Windows.Documents.TextRange.Load%2A>-Methode, um Inhalt tatsächlich in der aktuellen Auswahl in einem angegebenen Datenformat zu laden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.CanLoad%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CanSave">
      <MemberSignature Language="C#" Value="public bool CanSave (string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanSave(string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanSave (dataFormat As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanSave(System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.CanSave : string -&gt; bool" Usage="textRange.CanSave dataFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataFormat">Ein Datenformat, das auf Speicherkompatibilität mit der aktuellen Auswahl überprüft werden soll.  Eine Liste vordefinierter Datenformate finden Sie unter <see cref="T:System.Windows.DataFormats" />.</param>
        <summary>Überprüft, ob die aktuelle Auswahl in einem angegebenen Datenformat gespeichert werden kann.</summary>
        <returns><see langword="true" />, wenn die aktuelle Auswahl im angegebenen Datenformat gespeichert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die entsprechende <xref:System.Windows.Documents.TextRange.Save%2A>-Methode, um die aktuelle Auswahl tatsächlich in einem angegebenen Datenformat zu speichern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.CanSave%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.TextRange.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Changed As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Bereich neu positioniert wurde, um einen neuen Inhaltsbereich abzudecken.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllProperties">
      <MemberSignature Language="C#" Value="public void ClearAllProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAllProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.ClearAllProperties" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAllProperties ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAllProperties();" />
      <MemberSignature Language="F#" Value="member this.ClearAllProperties : unit -&gt; unit" Usage="textRange.ClearAllProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Formatierungseigenschaften (durch <see cref="T:System.Windows.Documents.Inline" />-Elemente dargestellt) aus der aktuellen Auswahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wirkt sich nur auf <xref:System.Windows.Documents.Inline> Formatierungs Elemente aus, z. b. <xref:System.Windows.Documents.Bold> oder <xref:System.Windows.Documents.Italic>. Eigenschaften, die für Absätze und andere einschließende <xref:System.Windows.Documents.Block> Elemente festgelegt werden, werden nicht geändert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Documents.TextPointer textPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Documents.TextPointer textPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Contains(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (textPointer As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Documents::TextPointer ^ textPointer);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Documents.TextPointer -&gt; bool" Usage="textRange.Contains textPointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPointer" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPointer">Eine Position, die daraufhin getestet wird, ob sie in der aktuellen Auswahl enthalten ist.</param>
        <summary>Überprüft, ob sich eine Position (von einem <see cref="T:System.Windows.Documents.TextPointer" /> angegeben) innerhalb der aktuellen Auswahl befindet.</summary>
        <returns><see langword="true" />, wenn sich die angegebene Position innerhalb der aktuellen Auswahl befindet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Positionen an beiden Enden der aktuellen Auswahl (angegeben durch <xref:System.Windows.Documents.TextRange.Start%2A> und <xref:System.Windows.Documents.TextRange.End%2A>) werden als Teil der aktuellen Auswahl betrachtet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.Contains%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn sich *textPointer* nicht in demselben Dokument wie die aktuelle Auswahl befindet.</exception>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer End" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ End { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.End : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.End" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rufen Sie die Position ab, die das Ende der aktuellen Auswahl markiert.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der auf das Ende der aktuellen Auswahl zeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.End%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.Start" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public object GetPropertyValue (System.Windows.DependencyProperty formattingProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPropertyValue(class System.Windows.DependencyProperty formattingProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.GetPropertyValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (formattingProperty As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPropertyValue(System::Windows::DependencyProperty ^ formattingProperty);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : System.Windows.DependencyProperty -&gt; obj" Usage="textRange.GetPropertyValue formattingProperty" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattingProperty" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="formattingProperty">Eine Formatierungseigenschaft, deren Wert bezüglich der aktuellen Auswahl abgerufen werden soll.</param>
        <summary>Gibt den effektiven Wert einer angegebenen Formatierungseigenschaft für die aktuelle Auswahl zurück.</summary>
        <returns>Ein Objekt, das den Wert der angegebenen Formatierungseigenschaft angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um einen Eigenschafts Wert zurückzugeben, muss die gesamte <xref:System.Windows.Documents.TextRange> über Text mit nur einem Wert für die `formattingProperty`erweitert werden. Wenn die <xref:System.Windows.Documents.TextRange> über Text mit zwei oder mehr unterschiedlichen Werten für die `formattingProperty`hinausgeht, wird <xref:System.Windows.DependencyProperty.UnsetValue> zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn <paramref name="formattingProperty" /> keine gültige Formatierungseigenschaft oder <paramref name="value" /> einen ungültigen Wert für <paramref name="formattingProperty" /> angibt.</exception>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn <paramref name="formattingProperty" /> gleich <see langword="null" /> ist.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.ClearAllProperties" />
        <altmember cref="M:System.Windows.Documents.TextRange.ApplyPropertyValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Documents.TextRange.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Auswahl leer ist.</summary>
        <value><see langword="true" />, wenn die aktuelle Auswahl leer ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Documents.TextRange> wird als leer betrachtet, wenn die <xref:System.Windows.Documents.TextRange.Start%2A>-und <xref:System.Windows.Documents.TextRange.End%2A> Positionen gleich sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.IsEmpty%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (stream As Stream, dataFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Load : System.IO.Stream * string -&gt; unit" Usage="textRange.Load (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Ein lesbarer Stream mit Daten, die in die aktuelle Auswahl geladen werden sollen.</param>
        <param name="dataFormat">Das Datenformat, in dem die Daten geladen werden sollen.  Derzeit werden die Datenformate <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> und <see cref="F:System.Windows.DataFormats.XamlPackage" /> unterstützt.</param>
        <summary>Lädt die aktuelle Auswahl aus einem angegebenen Stream in ein angegebenes Datenformat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.CanSeek%2A> für `stream``true` wird, werden die Inhalte vom Anfang des Streams bis zum Ende des Streams geladen.  Andernfalls wird der Inhalt vom aktuellen <xref:System.IO.Stream.Position%2A> bis zum Ende des Streams gelesen.  Wenn diese Methode zurückgegeben wird, wird `stream` Links geöffnet, und die aktuelle Position in `stream` ist nicht definiert.  
  
 Ein Ladevorgang ersetzt die aktuelle Auswahl durch den neu geladenen Inhalt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.Load%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tritt ein, wenn <paramref name="stream" /> oder <paramref name="dataFormat" /> den Wert <see langword="null" /> aufweist.</exception>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn das angegebene Datenformat nicht unterstützt wird.  Wird auch möglicherweise ausgelöst, wenn aus <paramref name="stream" /> geladener Inhalt für das angegebene Datenformat nicht geeignet ist.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert die aktuelle Auswahl in einem angegebenen Stream in einem angegebenen Datenformat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream, dataFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string -&gt; unit" Usage="textRange.Save (stream, dataFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">Ein leerer, schreibbarer Stream, in dem die aktuelle Auswahl gespeichert werden soll.</param>
        <param name="dataFormat">Das Datenformat, in dem die aktuelle Auswahl gespeichert werden soll.  Derzeit werden die Datenformate <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> und <see cref="F:System.Windows.DataFormats.XamlPackage" /> unterstützt.</param>
        <summary>Speichert die aktuelle Auswahl in einem angegebenen Stream in einem angegebenen Datenformat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgegeben wird, wird `stream` Links geöffnet, und die aktuelle Position in `stream` ist nicht definiert.  
  
 Im Rahmen des Speicher Vorgangs kann der Inhalt in der aktuellen Auswahl in das durch `dataFormat`angegebene Datenformat konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.Save%2A>-Methode gezeigt.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_loadsave)]
 [!code-vb[TextPointer_Snippets#_TextRange_LoadSave](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_loadsave)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> oder <paramref name="dataFormat" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das angegebene Datenformat wird nicht unterstützt.  
  
– oder – 
Der aus <paramref name="stream" /> geladene Inhalt entspricht nicht dem angegebenen Datenformat.</exception>
        <altmember cref="M:System.Windows.Documents.TextRange.CanSave(System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.Load(System.IO.Stream,System.String)" />
        <altmember cref="M:System.Windows.Documents.TextRange.CanLoad(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, string dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, string dataFormat, bool preserveTextElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Save(System.IO.Stream,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream, dataFormat As String, preserveTextElements As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::String ^ dataFormat, bool preserveTextElements);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * string * bool -&gt; unit" Usage="textRange.Save (stream, dataFormat, preserveTextElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="dataFormat" Type="System.String" />
        <Parameter Name="preserveTextElements" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Ein leerer, schreibbarer Stream, in dem die aktuelle Auswahl gespeichert werden soll.</param>
        <param name="dataFormat">Das Datenformat, in dem die aktuelle Auswahl gespeichert werden soll.  Derzeit werden die Datenformate <see cref="F:System.Windows.DataFormats.Rtf" />, <see cref="F:System.Windows.DataFormats.Text" />, <see cref="F:System.Windows.DataFormats.Xaml" /> und <see cref="F:System.Windows.DataFormats.XamlPackage" /> unterstützt.</param>
        <param name="preserveTextElements"><see langword="true" />, um benutzerdefinierte <see cref="T:System.Windows.Documents.TextElement" />-Objekte beizubehalten, andernfalls <see langword="false" />.</param>
        <summary>Speichert die aktuelle Auswahl in einem angegebenen Stream in einem angegebenen Datenformat. Optional können benutzerdefinierte <see cref="T:System.Windows.Documents.TextElement" />-Objekte beibehalten werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `preserveTextElements` `false`ist, werden benutzerdefinierte <xref:System.Windows.Documents.TextElement> Objekte als bekannte <xref:System.Windows.Documents.TextElement> Typen gespeichert.  Angenommen, Sie erstellen ein benutzerdefiniertes <xref:System.Windows.Documents.TextElement> namens `Heading1`, das von <xref:System.Windows.Documents.Paragraph>erbt. Wenn Sie diese Methode mit `preserveTextElements` auf `false`festlegen, wird `Heading1` in eine <xref:System.Windows.Documents.Paragraph> konvertiert, wenn die <xref:System.Windows.Documents.TextRange> gespeichert wird.  Wenn Sie diese Methode mit `preserveTextElements` auf `true`festlegen, wird `Heading1` gespeichert, ohne konvertiert zu werden. Um benutzerdefinierte Textelemente beizubehalten, muss `dataFormat` auf <xref:System.Windows.DataFormats.Xaml?displayProperty=nameWithType>festgelegt werden.  
  
 <xref:System.Windows.Documents.TextRange.Save%28System.IO.Stream%2CSystem.String%2CSystem.Boolean%29> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn <paramref name="stream" /> oder <paramref name="dataFormat" /> den Wert <see langword="null" /> hat.</exception>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn das angegebene Datenformat nicht unterstützt wird.  Wird auch möglicherweise ausgelöst, wenn aus <paramref name="stream" /> geladener Inhalt für das angegebene Datenformat nicht geeignet ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Documents.TextPointer position1, System.Windows.Documents.TextPointer position2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Documents.TextPointer position1, class System.Windows.Documents.TextPointer position2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextRange.Select(System.Windows.Documents.TextPointer,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (position1 As TextPointer, position2 As TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Documents::TextPointer ^ position1, System::Windows::Documents::TextPointer ^ position2);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Documents.TextPointer * System.Windows.Documents.TextPointer -&gt; unit" Usage="textRange.Select (position1, position2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position1" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="position2" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position1">Eine feste Ankerposition, die ein Ende der aktualisierten Auswahl markiert.</param>
        <param name="position2">Eine verschiebbare Ankerposition, die das andere Ende der aktualisierten Auswahl markiert.</param>
        <summary>Aktualisiert die aktuelle Auswahl, indem zwei <see cref="T:System.Windows.Documents.TextPointer" />-Positionen zum Angeben der aktualisierten Auswahl verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Documents.TextRange> wird aus einer Auswahl zwischen zwei Positionen gebildet, die von **Text Zeigern**angegeben werden.  Eine dieser Positionen (angegeben durch `position1`) wird in Bezug auf die Auswahl korrigiert, während die andere Position (angegeben durch `position2`) verschiebbar ist.  Dies ähnelt der Art und Weise, wie sich ein Benutzer mit der Maus oder der Tastatur verhält.  
  
 Die eigentlichen Enden der neuen Auswahl können so angepasst werden, dass Sie einer beliebigen Auswahl-Heuristik entsprechen, die auf das Dokument anwendbar ist, das die neue aktuelle Auswahl enthält.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt auf, wenn <paramref name="position1" /> und <paramref name="position2" /> nicht innerhalb desselben Dokuments positioniert sind</exception>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn <paramref name="position1" /> oder <paramref name="position2" /> den Wert <see langword="null" /> hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer Start { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer Start" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Start" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Start As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ Start { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Start : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextRange.Start" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position ab, die den Anfang der aktuellen Auswahl markiert.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der auf den Anfang der aktuellen Auswahl zeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.Start%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_startend)]
 [!code-vb[TextPointer_Snippets#_TextRange_StartEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_startend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextRange.End" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextRange.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Documents.TextRange.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Nur-Text-Inhalt der aktuellen Auswahl ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge, die den Nur-Text-Inhalt der aktuellen Auswahl enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um den nur-Text-Inhalt in der aktuellen Auswahl zu extrahieren, unabhängig von der ggf. vorhandenen Formatierung.  
  
 Neue Zeilenzeichen und Absatz Umbrüche werden in Bezug auf diese Eigenschaft als gleichwertig behandelt.  Alle Typen von Inhalts Umbrüchen, die in der aktuellen Auswahl vorhanden sind, werden in neue Zeilen konvertiert, wenn diese Eigenschaft gelesen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Windows.Documents.TextRange.Text%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textrange_text)]
 [!code-vb[TextPointer_Snippets#_TextRange_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textrange_text)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tritt auf, wenn versucht wird, diese Eigenschaft auf <see langword="null" /> festzulegen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
