<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3952c6422d11625c3e926c21b1f329167434d4b1" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="83948591" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Standardsatz von Befehlen für Bearbeitungen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden die Bearbeitungsbefehle und die zugeordneten Standardschlüssel Gesten (mit Schlüsselnamen aus den <xref:System.Windows.Input.Key> <xref:System.Windows.Input.ModifierKeys> Enumerationen und) angezeigt.  
  
|Bearbeitungs Befehl|Standardmäßige Tastenkombination|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|keine Standardtasten Bewegung|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|keine Standardtasten Bewegung|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Befehle für Caretzeichen und Auswahl aufzunehmenden Befehle verwenden einen gemeinsamen Satz von Standard schlüsselgesten. der allgemeine Unterschied besteht im Hinzufügen des <xref:System.Windows.Input.ModifierKeys.Shift> Schlüssels zum unterscheiden von Auswahl Befehlen von Befehlen der Caretzeichen.  Beispielsweise verfügt der <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> Befehl über eine Standard schlüsselgeste von <xref:System.Windows.Input.Key.Left> , und der entsprechende <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> Befehl hat eine Standard schlüsselgeste von <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left> .  
  
 Im Allgemeinen verwenden die von der-Klasse bereitgestellten Befehlsdefinitionen <xref:System.Windows.Documents.EditingCommands> keine Befehlsparameter (der-Parameter, der `parameter` von der-Methode erwartet wird <xref:System.Windows.Input.ICommand.Execute%2A> ).  
  
 Weitere Informationen zu Befehlen und Befehlen finden Sie unter [Übersicht](/dotnet/framework/wpf/advanced/input-overview)über die Eingabe.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />-Befehl dar, mit dem angefordert wird, dass der aktuelle Absatz oder ausgewählte Absätze zentriert werden.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="E" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf den gesamten Inhalt jedes Absatzes angewendet, der an der Auswahl teilnimmt.  
  
 Die folgende Abbildung zeigt ein Beispiel für einen zentrierten Inhalt.  
  
 ![Bildschirmabbildung: TextAlign-Eigenschaftswert Center](~/add/media/flowdoc-textalign-center.png "Screenshot: TextAlign-Eigenschaftswert Center")  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />-Befehl dar, mit dem angefordert wird, dass der aktuelle Absatz oder ausgewählte Absätze im Blocksatz ausgerichtet werden.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="J" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf alle Absätze in der Auswahl angewendet.  
  
 Wenn der Inhalt gerechtfertigt ist, wird der horizontale Abstand innerhalb jeder Zeile des Inhalts so angepasst, dass die bündig ausgerichteten Zeilen gleich oder nahezu gleich groß sind.  Der Inhalt wird in der Regel zum Erstellen von glatten Kanten auf den Seiten des Inhalts gerechtfertigt.  
  
 Da der Wert oft kürzer ist als der Rest, kann die letzte Zeile in einem Absatz nach dem Aufrufen dieses Befehls nicht gerechtfertigt bleiben.  
  
 Die folgende Abbildung zeigt den unberechtigten Inhalt (linksbündig).  
  
 ![Bildschirmabbildung: Inhalt ist nicht ausgerichtet](~/add/media/content-unjustified.png "Screenshot: Inhalt ist nicht ausgerichtet")  
  
 In der folgenden Abbildung wird derselbe Inhalt angezeigt, nachdem er gerechtfertigt wurde.  
  
 ![Bildschirmabbildung von am Inhalt ausgerichtetem Text](~/add/media/content-justified.png "Screenshot von am Inhalt ausgerichtetem Text")  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />-Befehl dar, mit dem angefordert wird, dass der ausgewählte Inhalt linksbündig ausgerichtet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="L" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf den gesamten Inhalt jedes Absatzes angewendet, der an der Auswahl teilnimmt.  
  
 Die folgende Abbildung zeigt ein Beispiel für linksbündig ausgerichteten Inhalt.  
  
 ![Bildschirmabbildung: TextAlign-Eigenschaftswert Left](~/add/media/flowdoc-textalign-left.png "Screenshot: TextAlign-Eigenschaftswert Left")  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" />-Befehl dar, mit dem angefordert wird, dass der ausgewählte Inhalt rechtsbündig ausgerichtet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="R" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf den gesamten Inhalt jedes Absatzes angewendet, der an der Auswahl teilnimmt.  
  
 Die folgende Abbildung zeigt ein Beispiel für einen rechts ausgerichteten Inhalt.  
  
 ![Bildschirmabbildung: TextAlign-Wert Right](~/add/media/flowdoc-textalign-right.png "Screenshot: TextAlign-Wert Right")  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.Backspace" />-Befehl dar, mit dem angefordert wird, dass an der aktuellen Position oder für die aktuelle Auswahl ein Rücktastenzeichen eingefügt wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Befehl bei einer leeren Auswahl aufgerufen wird, löscht er das Zeichen oder Absatz Trennzeichen direkt vor der Einfügemarke. Wenn der Befehl für eine nicht leere Auswahl aufgerufen wird, wird die Auswahl gelöscht.  
  
 Dieser Befehl behält jede Formatierung aus der gelöschten Auswahl für Inhalt bei, der nach dem Aufrufen dieses Befehls sofort an derselben Position eingefügt wurde.  Vergleichen Sie den- <xref:System.Windows.Documents.EditingCommands.Delete%2A> Befehl, der die vorherige Formatierung nicht beibehält.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />-Befehl dar, mit dem angefordert wird, dass jedes falsch geschriebene Wort an der aktuellen Position korrigiert wird.</summary>
        <value>Der angeforderte Befehl.  Für diesen Befehl gibt es keine Standardtastenkombination.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />-Befehl dar, mit dem angefordert wird, dass die Schriftgröße für die aktuelle Auswahl um 1 Punkt verringert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="OemOpenBrackets" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Befehl bei einer leeren Auswahl aufgerufen wird, bei der sich die Einfügemarke innerhalb eines Worts befindet, wird die Auswahl automatisch erweitert, um den Befehl auf das gesamte Wort anzuwenden.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />-Befehl dar, mit dem angefordert wird, dass der Einzug des aktuellen Absatzes um einen Tabstopp verringert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
> [!IMPORTANT]
>  Dieser Befehl hat keine Auswirkung auf ein Textelement, es sei denn, die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> Eigenschaft des Text-Elements ist auf festgelegt `true` .  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.Delete" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl gelöscht wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl verwirft jede Formatierung aus der gelöschten Auswahl.  Im Gegensatz zum- <xref:System.Windows.Documents.EditingCommands.Backspace%2A> Befehl, der alle Formatierungen aus der gelöschten Auswahl für Inhalt beibehält, der nach dem Aufrufen dieses Befehls sofort an derselben Position eingefügt wird.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />-Befehl dar, mit dem angefordert wird, dass das relativ zur aktuellen Position nächste Wort gelöscht wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Delete" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, wird der Rest des Worts zwischen der aktuellen Position und dem Ende des Worts gelöscht.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />-Befehl dar, mit dem angefordert wird, dass das relativ zur aktuellen Position vorhergehende Wort gelöscht wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Backspace" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, wird der Rest des Worts zwischen der aktuellen Position und dem Anfang des Worts gelöscht.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />-Befehl dar, mit dem angefordert wird, dass ein Zeilenumbruch an der aktuellen Position oder über der aktuellen Auswahl eingefügt wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Enter" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Editoren, die fortlaufenden Inhalt unterstützen (z. b.), <xref:System.Windows.Controls.RichTextBox> bewirkt dieser Befehl, dass ein- <xref:System.Windows.Documents.LineBreak> Element an der aktuellen Position eingefügt wird.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />-Befehl dar, mit dem angefordert wird, dass ein Absatzwechsel an der aktuellen Position oder über der aktuellen Auswahl eingefügt wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl entspricht dem Benutzer, der die EINGABETASTE drückt.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> (wenn die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> Eigenschaft ist `true` ).  
  
> [!IMPORTANT]
>  Dieser Befehl hat keine Auswirkung auf ein Textelement, es sei denn, die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> Eigenschaft des Text-Elements ist auf festgelegt `true` .  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />-Befehl dar, mit dem angefordert wird, dass sämtliche Instanzen falsch geschriebener Wörter an der aktuellen Position oder in der aktuellen Auswahl ignoriert werden.</summary>
        <value>Der angeforderte Befehl.  Für diesen Befehl gibt es keine Standardtastenkombination.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />-Befehl dar, mit dem angefordert wird, dass die Schriftgröße für die aktuelle Auswahl um 1 Punkt erhöht wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="OemCloseBrackets" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Befehl bei einer leeren Auswahl aufgerufen wird, bei der sich die Einfügemarke innerhalb eines Worts befindet, wird die Auswahl so erweitert, dass der Befehl auf das gesamte Wort angewendet wird.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />-Befehl dar, mit dem angefordert wird, dass der Einzug des aktuellen Absatzes um einen Tabstopp vergrößert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="T" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
> [!IMPORTANT]
>  Dieser Befehl hat keine Auswirkung auf ein Textelement, es sei denn, die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> Eigenschaft des Text-Elements ist auf festgelegt `true` .  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um eine Zeile nach unten verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um eine Seite nach unten verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um einen Absatz nach unten verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Down" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl positioniert die Einfügemarke am Anfang des nächsten Absatzes.  
  
 Dieser Befehl verhält sich wie, <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> Wenn in einem aufgerufen wird <xref:System.Windows.Controls.TextBox> .  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um ein Zeichen nach links verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um ein Wort nach links verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Left" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, verschiebt dieser Befehl die Einfügemarke an den Anfang dieses Worts.  Andernfalls verschiebt der Befehl die Einfügemarke an den Anfang des vorherigen Worts.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um ein Zeichen nach rechts verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um ein Wort nach rechts verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Right" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, verschiebt dieser Befehl die Einfügemarke an das Ende dieses Worts.  Andernfalls verschiebt der Befehl die Einfügemarke an den Anfang des nächsten Worts.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke an das Ende des Inhalts verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="End" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *Text Container* ist das Element, das den endgültigen Rahmen für den Inhalt bildet.  <xref:System.Windows.Controls.TextBlock>und <xref:System.Windows.Documents.FlowDocument> sind Beispiele für Text Container.  Der Inhalt, der in einem Text Container Kollektiv enthalten ist, wird als *Dokument*bezeichnet.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke an den Anfang des Inhalts verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Home" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *Text Container* ist das Element, das den endgültigen Rahmen für den Inhalt bildet.  <xref:System.Windows.Controls.TextBlock>und <xref:System.Windows.Documents.FlowDocument> sind Beispiele für Text Container.  Der Inhalt, der in einem Text Container Kollektiv enthalten ist, wird als *Dokument*bezeichnet.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke an das Ende der aktuellen Zeile verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke an den Anfang der aktuellen Zeile verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um eine Zeile nach oben verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um eine Seite nach oben verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />-Befehl dar, mit dem angefordert wird, dass die Einfügemarke um einen Absatz nach oben verschoben wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Up" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl positioniert die Einfügemarke am Anfang des nächsten Absatzes.  
  
 Dieser Befehl verhält sich wie, <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> Wenn in einem aufgerufen wird <xref:System.Windows.Controls.TextBox> .  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> .  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um eine Zeile nach unten erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Down" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um eine Seite nach unten erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="PageDown" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um einen Absatz nach unten erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Befehl wird die Auswahl auf den Anfang des nächsten Absatzes erweitert.  Andernfalls erweitert dieser Befehl die Auswahl bis zum Ende des aktuellen Absatzes.  Die erweiterte Auswahl schließt die Absatz Umbruch ein, die das Ende des Absatzes markiert.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um ein Zeichen nach links erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Left" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um ein Wort nach links erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, erweitert dieser Befehl die Auswahl an den Anfang dieses Worts.  Andernfalls erweitert dieser Befehl die Auswahl an den Anfang des vorherigen Worts.  
  
 Die erweiterte Auswahl schließt das Wort Trennzeichen nicht ein.  <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>Steht im Gegensatz zu, wobei das Wort Trennzeichen in der erweiterten Auswahl enthalten ist.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um ein Zeichen nach rechts erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Right" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um ein Wort nach rechts erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke innerhalb eines Worts befindet, erweitert dieser Befehl die Auswahl bis zum Ende dieses Worts.  Andernfalls erweitert dieser Befehl die Auswahl bis zum Ende des nächsten Worts.  
  
 Die erweiterte Auswahl umfasst das Wort Trennzeichen.  Der Kontrast <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> , bei dem das Wort Trennzeichen in der erweiterten Auswahl nicht enthalten ist.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl bis an das Ende des Inhalts erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *Text Container* ist das Element, das den endgültigen Rahmen für den Inhalt bildet.  <xref:System.Windows.Controls.TextBlock>und <xref:System.Windows.Documents.FlowDocument> sind Beispiele für Text Container.  Der Inhalt, der in einem Text Container Kollektiv enthalten ist, wird als *Dokument*bezeichnet.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl bis an den Anfang des Inhalts erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *Text Container* ist das Element, das den endgültigen Rahmen für den Inhalt bildet.  <xref:System.Windows.Controls.TextBlock>und <xref:System.Windows.Documents.FlowDocument> sind Beispiele für Text Container.  Der Inhalt, der in einem Text Container Kollektiv enthalten ist, wird als *Dokument*bezeichnet.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl bis an das Ende der aktuellen Zeile erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="End" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl bis an den Anfang der aktuellen Zeile erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Home" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um eine Zeile nach oben erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Up" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um eine Seite nach oben erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="PageUp" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />-Befehl dar, mit dem angefordert wird, dass die aktuelle Auswahl um einen Absatz nach oben erweitert wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die Einfügemarke am Anfang eines Absatzes befindet, erweitert dieser Befehl die Auswahl an den Anfang des vorherigen Absatzes.  Andernfalls erweitert dieser Befehl die Auswahl an den Anfang des aktuellen Absatzes.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />-Befehl dar.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Shift" /> + <see langword="Tab" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten für diesen Befehl hängt von der aktuellen Auswahl ab. Wenn die Auswahl nicht leer ist, entspricht dieser Befehl <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A> . Wenn sich die Einfügemarke in einer Tabellenzelle befindet (dargestellt durch das- <xref:System.Windows.Documents.TableCell> Element), verschiebt dieser Befehl die Einfügemarke in die vorherige Zelle. Andernfalls wird ein Tabstopp Zeichen an der aktuellen Position eingefügt.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> (wenn die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> Eigenschaft ist `true` ).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />-Befehl dar.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten für diesen Befehl hängt von der aktuellen Auswahl ab. Wenn die Auswahl nicht leer ist, oder wenn die Auswahl leer ist und die aktuelle Position der Einfügemarke am Anfang eines Absatzes liegt, entspricht dieser Befehl <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A> . Wenn sich die Einfügemarke in einer Tabellenzelle befindet (dargestellt durch das- <xref:System.Windows.Documents.TableCell> Element), verschiebt dieser Befehl die Einfügemarke in die nächste Zelle. Wenn sich die Einfügemarke in der letzten Zelle einer Tabelle befindet, bewirkt dieser Befehl, dass eine neue Zeile an die Tabelle angehängt wird, wobei die Einfügemarke in der ersten Zelle der neuen Zeile positioniert ist.  Andernfalls wird ein Tabstopp Zeichen an der aktuellen Position eingefügt.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> (wenn die- <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> Eigenschaft ist `true` ).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />-Befehl dar, mit dem angefordert wird, dass die <see cref="T:System.Windows.Documents.Bold" />-Formatierung für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="B" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.FontWeight> für die aktuelle Auswahl im Bereich von bis liegt <xref:System.Windows.FontWeights.Thin%2A> <xref:System.Windows.FontWeights.SemiBold%2A> , <xref:System.Windows.FontWeights.Bold%2A> wird auf die aktuelle Auswahl angewendet.  Andernfalls <xref:System.Windows.FontWeights.Normal%2A> wird angewendet.  Eine vergleichende Liste von <xref:System.Windows.FontWeight> Werten finden Sie unter <xref:System.Windows.FontWeights> .  
  
 Wenn die Auswahl leer ist und sich die Einfügemarke innerhalb eines Worts befindet, wird die Auswahl so erweitert, dass Sie das gesamte Wort enthält.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" />-Befehl dar, mit dem angefordert wird, dass die Formatierung als ungeordnete Liste (auch als Aufzählung bezeichnet) für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf den gesamten Inhalt jedes Absatzes angewendet, der an der Auswahl teilnimmt.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" />-Befehl dar, mit dem der Eingabemodus zwischen Einfügen und Überschreiben umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von, und nativ unterstützt <xref:System.Windows.Controls.RichTextBox> <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.PasswordBox> .  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />-Befehl dar, mit dem angefordert wird, dass die <see cref="T:System.Windows.Documents.Italic" />-Formatierung für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="I" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der <xref:System.Windows.FontStyle> für die aktuelle Auswahl ist <xref:System.Windows.FontStyles.Normal%2A> , <xref:System.Windows.FontStyles.Italic%2A> wird auf die aktuelle Auswahl angewendet.  Andernfalls <xref:System.Windows.FontStyles.Normal%2A> wird angewendet.  
  
 Wenn die Auswahl leer ist und sich die Einfügemarke innerhalb eines Worts befindet, wird die Auswahl so erweitert, dass Sie das gesamte Wort enthält.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />-Befehl dar, mit dem angefordert wird, dass die Formatierung als geordnete Liste (auch als nummerierte Liste bezeichnet) für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl wird auf der- <xref:System.Windows.Documents.Paragraph> Ebene angewendet.  Wenn dieser Befehl für eine partielle Auswahl von Inhalt innerhalb eines Absatzes aufgerufen wird (einschließlich einer leeren Auswahl, bei der sich die Einfügemarke innerhalb eines Absatzes befindet), wird der angeforderte Effekt auf den gesamten Absatz angewendet.  Wenn dieser Befehl für eine Auswahl aufgerufen wird, die mehrere Absätze umfasst, wird der Effekt auf den gesamten Inhalt jedes Absatzes angewendet, der an der Auswahl teilnimmt.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />-Befehl dar, mit dem angefordert wird, dass die Formatierung als tiefgestellt für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="OemPlus" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />-Befehl dar, mit dem angefordert wird, dass die Formatierung als hochgestellt für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />-Befehl dar, mit dem angefordert wird, dass die <see cref="T:System.Windows.Documents.Underline" />-Formatierung für die aktuelle Auswahl umgeschaltet wird.</summary>
        <value>Der angeforderte Befehl.  Die standardmäßige Tastenkombination für diesen Befehl ist <see langword="Ctrl" /> + <see langword="U" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auswahl leer ist und sich die Einfügemarke innerhalb eines Worts befindet, wird die Auswahl so erweitert, dass Sie das gesamte Wort enthält.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf diesen Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung, die auf einen Befehl antwortet, die Verantwortung des anwendungswriter.  
  
 Dieser Befehl wird von nativ unterstützt <xref:System.Windows.Controls.RichTextBox> .  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bearbeitungs Befehl für ein Objekt aufgerufen wird, das den Befehl unterstützt.  
  
 In diesem Beispiel <xref:System.Windows.Controls.RichTextBox> fungiert als das Befehls Ziel.  Beachten Sie, dass <xref:System.Windows.Controls.RichTextBox> die <xref:System.Windows.IInputElement> -Schnittstelle implementiert (geerbt von <xref:System.Windows.FrameworkElement> ) und dass Sie systemeigene Unterstützung für viele Bearbeitungsbefehle enthält.  
  
 Das erste Argument für die- <xref:System.Windows.Input.RoutedCommand.Execute%2A> Methode ist ein Befehlsparameter.  Die meisten Bearbeitungsbefehle ignorieren den Befehlsparameter. im Allgemeinen sollte dieser Parameter für die `null` Bearbeitung von Befehlen sein.  
  
 Das zweite Argument gibt das Objekt an, an das der Befehl weitergeleitet wird.  Dieses Objekt muss die <xref:System.Windows.IInputElement> -Schnittstelle implementieren und sollte einen Handler für den angegebenen Befehl enthalten.  Im Allgemeinen wird ein Befehl ignoriert, wenn er für ein Objekt aufgerufen wird, das den Befehl nicht verarbeitet.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>
