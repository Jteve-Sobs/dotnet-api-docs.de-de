<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TextPointer.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d374acbfa59bece9a23ff4841ba74263d0c6fa42.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d374acbfa59bece9a23ff4841ba74263d0c6fa42</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Represents a position within a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.FlowDocument" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Windows.Controls.TextBlock" /&gt;</ph>.</source>
          <target state="translated">Stellt eine Position in einem <ph id="ph1">&lt;see cref="T:System.Windows.Documents.FlowDocument" /&gt;</ph> oder <ph id="ph2">&lt;see cref="T:System.Windows.Controls.TextBlock" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class introduces the following terminology:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Klasse führt die folgende Terminologie:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Position - Inherently, a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always points to a <bpt id="p1">*</bpt>position<ept id="p1">*</ept> in content.</source>
          <target state="translated">Position - grundsätzlich, ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verweist immer auf eine <bpt id="p1">*</bpt>Position<ept id="p1">*</ept> im Inhalt.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Such positions either fall between characters in the content, or between flow content element tags that define structure for the content.</source>
          <target state="translated">Diese Positionen entweder zwischen Zeichen im Inhalt oder Fluss fallen Content-Element-tags definieren die Struktur für den Inhalt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Current Position - Because a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always indicates a position, and because many of the operations that can be performed through a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> are relative to the position currently pointed to by the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>, it makes sense to simply refer to the position indicated by a <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> as the <bpt id="p1">*</bpt>current position<ept id="p1">*</ept>.</source>
          <target state="translated">Aktuelle Position: Da eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> immer gibt eine Position und da viele Vorgänge, die über ausgeführt werden können eine <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> sind relativ zur Position, die derzeit verweist der <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>, es ist sinnvoll, verweisen einfach auf die durch angegebenen Position ein <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> als die <bpt id="p1">*</bpt>aktuelle Position<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Insertion Position - An <bpt id="p1">*</bpt>insertion position<ept id="p1">*</ept> is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Position der Einfügemarke - ein <bpt id="p1">*</bpt>Einfügeposition<ept id="p1">*</ept> ist eine Position, in neuer Inhalte ohne Unterbrechung semantischen Regeln für den zugehörigen Inhalt hinzugefügt werden kann.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">In der Praxis ist eine Einfügeposition an einer beliebigen Stelle im Inhalt, in denen eine Einfügemarke positioniert werden kann.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Ein Beispiel einer gültigen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Position an, die sich nicht um eine Einfügeposition ist, ist die Position zwischen zwei angrenzende <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Tags (d. h. zwischen dem Endtag aus dem vorherigen Absatz und das öffnende Tag eines nächsten Absatz).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Symbol - For the purposes of <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> operations that involve symbols, any of the following is considered to be a <bpt id="p1">*</bpt>symbol<ept id="p1">*</ept>:</source>
          <target state="translated">Symbol: im Rahmen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Vorgänge, die Symbole betreffen, keines der folgenden gilt eine <bpt id="p1">*</bpt>Symbol<ept id="p1">*</ept>:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Start- oder Endtag für ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained within an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> Element innerhalb einer <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Each 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Jedes 16-Bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Text Container - A <bpt id="p1">*</bpt>text container<ept id="p1">*</ept> is the element that forms the ultimate border for the flow content at hand; the position indicated by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> always falls within a text container.</source>
          <target state="translated">Textcontainer – eine <bpt id="p1">*</bpt>Textcontainer<ept id="p1">*</ept> wird das Element, das den äußeren Rahmen der fortlaufenden Inhalts bildet, die vom angegebenen Position ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> liegt immer in einem Textcontainer.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Currently, a text container must be either a <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> or a <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</source>
          <target state="translated">Derzeit ein Textcontainer muss entweder eine <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> oder ein <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Generally speaking, operations between <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances in different text containers are not supported.</source>
          <target state="translated">Im Allgemeinen steigen zwischen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen in anderen Text-Container werden nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Document - The content in a text container is referred to as a <bpt id="p1">*</bpt>document<ept id="p1">*</ept>, as in the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph> properties.</source>
          <target state="translated">Dokument - der Inhalt in einem Textcontainer wird bezeichnet als eine <bpt id="p1">*</bpt>Dokument<ept id="p1">*</ept>, z. B. die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class is intended to facilitate traversal and manipulation of content that is represented by <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> flow content elements; in general, such elements derive from <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Klasse dient zur Vereinfachung Durchlauf und Bearbeitung von Inhalt, der durch dargestellt wird <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> flow Inhaltselemente; in der Regel solche Elemente abgeleitet <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Some of the operations that <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> facilitates include the following:</source>
          <target state="translated">Einige der Vorgänge, die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> erleichtert umfassen Folgendes:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Perform an ordinal comparison of the current position with a second specified position.</source>
          <target state="translated">Führen Sie einen Ordinalvergleich von der aktuellen Position mit einer zweiten angegebenen Position.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> method.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Determine the type of content adjacent to the current position in a specified direction.</source>
          <target state="translated">Die Art des Inhalts an die aktuelle Position in einer angegebenen Richtung angrenzende bestimmt.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> enumeration.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> Methode und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> that scopes or is adjacent to the current position.</source>
          <target state="translated">Abrufen der <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> , die Bereiche oder angrenzend an die aktuelle Position ist.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A&gt;</ph> method.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> und die <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get the text container that scopes the current document.</source>
          <target state="translated">Abrufen des Textcontainers aus, die das aktuelle Dokument Bereiche.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> property.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Get a specified number of characters preceding or following the current position.</source>
          <target state="translated">Abrufen Sie eine angegebene Anzahl von Zeichen, die vor oder nach der aktuellen Position.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> method.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Insert a string of characters at the current position.</source>
          <target state="translated">Fügen Sie eine Zeichenfolge von Zeichen an der aktuellen Position.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A&gt;</ph> method.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Find line boundaries in content.</source>
          <target state="translated">Suchen Sie Zeile Grenzen im Inhalt.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> property.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> Methode und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Translate between <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions and symbol offsets into content.</source>
          <target state="translated">Übersetzt zwischen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Positionen und das Symbol für UTC-offsets in Inhalte.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> methods.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Perform visual hit testing by translating between a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position and a <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> representing relative coordinates.</source>
          <target state="translated">Führen Sie die visuellen Treffertests durch Übersetzen zwischen ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Position und eine <ph id="ph2">&lt;xref:System.Windows.Point&gt;</ph> , relative Koordinaten darstellt.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>Find a nearby insertion position, or check whether the current position is an insertion position.</source>
          <target state="translated">Suchen einer nahe gelegenen Einfügeposition oder Überprüfen Sie, ob die aktuelle Position eine Einfügeposition ist.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>See the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> methods and the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A&gt;</ph> property.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> Methoden und die <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The position and <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> indicated by a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> object are immutable.</source>
          <target state="translated">Die Position und <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> erkennbar ein <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Objekt sind unveränderlich.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>When content is edited or modified, the position indicated by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> does not change relative to the surrounding text; rather the offset of that position from the beginning of content is adjusted correspondingly to reflect the new relative position in content.</source>
          <target state="translated">Wenn Inhalt bearbeitet oder geändert wird, die vom angegebenen Position eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> ändert sich nicht relativ zum umgebenden Textes; stattdessen der Offset der Position vom Anfang des Inhalts entsprechend entsprechend die neue relative Position im angepasst wird Inhalt.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>For example, a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> that indicates a position at the beginning of a given paragraph continues to point to the beginning of that paragraph even when content is inserted or deleted before or after the paragraph.</source>
          <target state="translated">Angenommen, ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> , der angibt, eine Position, an den Anfang eines bestimmten Absatzes, zeigen Sie auf den Anfang des Absatzes, selbst wenn Inhalt eingefügt oder werden, vor oder nach dem Absatz gelöscht wird fortgesetzt.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> class does not provide any public constructors.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Klasse keine öffentlichen Konstruktoren bereit.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>An instance of <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is created by using properties or methods of other objects (including other <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> objects).</source>
          <target state="translated">Eine Instanz von <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> wird erstellt, indem Sie mithilfe der Eigenschaften oder Methoden anderer Objekte (einschließlich anderer <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Objekte).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following list provides a few examples of methods and properties that create and return a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Die folgende Liste enthält einige Beispiele für Methoden und Eigenschaften, erstellen und zurückgeben, einer <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>This list is not exhaustive:</source>
          <target state="translated">Diese Liste ist nicht vollständig:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextRange.Start%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.Documents.TextRange.End%2A&gt;</ph>.</source>
          <target state="translated">Aus einem <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextRange.Start%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Windows.Documents.TextRange.End%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>:  <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement.ContentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextElement.ElementStart%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement.ElementEnd%2A&gt;</ph>.</source>
          <target state="translated">Aus einem <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement.ContentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextElement.ElementStart%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement.ElementEnd%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> (text container): <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.ContentEnd%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A&gt;</ph>.</source>
          <target state="translated">Aus einem <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> (Textcontainer): <ph id="ph2">&lt;xref:System.Windows.Controls.TextBlock.ContentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock.ContentEnd%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From a <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> (text container): <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument.ContentStart%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Documents.FlowDocument.ContentEnd%2A&gt;</ph></source>
          <target state="translated">Aus einem <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> (Textcontainer): <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument.ContentStart%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Windows.Documents.FlowDocument.ContentEnd%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>From an existing <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph>.</source>
          <target state="translated">Aus einer vorhandenen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>: <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.DocumentStart%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.DocumentEnd%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following example demonstrates how to use a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to find a position just inside of the first <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element in a specified text container.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> finden Sie eine Position der ersten <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element in einem Container angegebenen Text.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Documents.TextPointer">
          <source>The following example implements a simplistic find algorithm using <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> facilities.</source>
          <target state="translated">Das folgende Beispiel implementiert eine vereinfachte Suchalgorithmus mit <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Einrichtungen.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to compare to the current position.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, der eine Position angibt, die mit der aktuellen Position verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>Performs an ordinal comparison between the positions specified by the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and a second specified <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Führt einen Ordinalvergleich der angegebenen Positionen des aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> und eines anderen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> aus.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>–1 if the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes <ph id="ph2">&lt;paramref name="position" /&gt;</ph>; 0 if the locations are the same; +1 if the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">–1, wenn der aktuelle <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> vor der <ph id="ph2">&lt;paramref name="position" /&gt;</ph> liegt; 0, wenn die Positionen identisch sind; +1, wenn der aktuelle <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> nach der <ph id="ph4">&lt;paramref name="position" /&gt;</ph> liegt.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of –1 indicates that the position specified by the current <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> precedes the position specified by <ph id="ph2">`position`</ph>.</source>
          <target state="translated">Der Wert-1 gibt an, dass die Position von der aktuellen angegeben <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> steht vor der angegebenen Position <ph id="ph2">`position`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of 0 indicates that the indicated positions are equal.</source>
          <target state="translated">Der Wert 0 gibt an, dass die angegebenen Positionen gleich sind.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>A value of positive +1 indicates that the position specified by the current <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> follows the position specified by <ph id="ph2">`position`</ph>.</source>
          <target state="translated">Ein Wert von + 1 gibt an, dass die Position von der aktuellen angegeben <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> resultiert aus der angegebenen Position <ph id="ph2">`position`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source>In the example, the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> method is used in conjunction with the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> method to test whether a specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> is empty.</source>
          <target state="translated">Im Beispiel die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> Methode dient in Verbindung mit der <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> Methode zu testen, ob ein angegebenes <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> specifies a position outside of the text container associated with the current position.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> gibt eine Position an, die außerhalb des der aktuellen Position zugeordneten Textcontainers liegt.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters to delete, starting at the current position.</source>
          <target state="translated">Die Anzahl der zu löschenden Zeichen ab der aktuellen Position.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Specify a positive value to delete characters that follow the current position; specify a negative value to delete characters that precede the current position.</source>
          <target state="translated">Geben Sie einen positiven Wert an, um Zeichen nach der aktuellen Position zu löschen, bzw. einen negativen Wert, um Zeichen vor der aktuellen Position zu löschen.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Deletes the specified number of characters from the position indicated by the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Löscht die angegebene Anzahl von Zeichen ab der Position, die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> angegeben wird.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters actually deleted.</source>
          <target state="translated">Die Anzahl der tatsächlich gelöschten Zeichen.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>Specify a positive value to delete characters that follow the current position (as in <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>); specify a negative value to delete characters that precede the current position (as in <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Geben Sie einen positiven Wert ein, um Zeichen zu löschen, die vor der aktuellen Position (wie in <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>); Geben Sie einen negativen Wert, um Zeichen zu löschen, die vor der aktuellen Position (wie in <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The number of characters actually deleted may be less than the number specified by <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Die Anzahl der Zeichen, die tatsächlich gelöscht, ist möglicherweise kleiner als die Anzahl von angegebenen <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>This happens in cases where <ph id="ph1">`count`</ph> specifies more characters than exist to be deleted.</source>
          <target state="translated">Dies geschieht in Fällen, in denen <ph id="ph1">`count`</ph> gibt mehr Zeichen als vorhanden sind, gelöscht werden sollen.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)">
          <source>The method is called at a position where text is not allowed.</source>
          <target state="translated">Die Methode wurde an einer Position aufgerufen, an der Text nicht zulässig ist.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the end of content in the text container associated with the current position.</source>
          <target state="translated">Ruft im der aktuellen Position zugeordneten Textcontainer am Ende des Inhalts einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the end of content in the text container associated with the current position.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> am Ende des Inhalts im der aktuellen Position zugeordneten Textcontainer.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentEnd">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> for the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is always a text container (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), rather than a <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> für das zurückgegebene <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> ist immer ein Textcontainer (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> oder <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), anstelle eines <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the beginning of content in the text container associated with the current position.</source>
          <target state="translated">Ruft im der aktuellen Position zugeordneten Textcontainer am Anfang des Inhalts einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> at the beginning of content in the text container associated with the current position.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> am Anfang des Inhalts im der aktuellen Position zugeordneten Textcontainer.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>Use the position returned by this property as a baseline position from which to work with relative offsets to other positions.</source>
          <target state="translated">Verwenden Sie die Position, die von dieser Eigenschaft zurückgegeben wird, als eine Baselineposition aus dem Arbeiten mit relativen Versatz an andere Positionen an.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> methods provide a way to translate between positions and position offsets.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> Methoden bieten eine Möglichkeit zum Konvertieren zwischen Positionen und offsets.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.DocumentStart">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> for the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is always a text container (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), rather than a <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.Parent%2A&gt;</ph> für das zurückgegebene <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> ist immer ein Textcontainer (<ph id="ph3">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> oder <ph id="ph4">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph>), anstelle eines <ph id="ph5">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for an adjacent element.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach einem benachbarten Element erfolgen soll.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>Returns the element, if any, that borders the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Gibt ggf. das Element zurück, das in der angegebenen logischen Richtung an den aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> grenzt.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>The adjacent element in the specified <ph id="ph1">&lt;paramref name="direction" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no adjacent element exists.</source>
          <target state="translated">Das benachbarte Element in der angegebenen <ph id="ph1">&lt;paramref name="direction" /&gt;</ph> oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn kein benachbartes Element vorhanden ist.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>The returned element is typically a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Das zurückgegebene Element ist in der Regel eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> can be returned when the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> indicates a position inside a <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph> element or an <ph id="ph4">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> element.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> können zurückgegeben werden, wenn die <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> gibt eine Position innerhalb einer <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph> Element oder ein <ph id="ph4">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find a content bounding box.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach einem umgebenden Feld für Inhalt erfolgen soll.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Returns a bounding box (<ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph>) for content that borders the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Gibt ein umgebendes Feld (<ph id="ph1">&lt;see cref="T:System.Windows.Rect" /&gt;</ph>) für Inhalt zurück, der in der angegebenen logischen Richtung an den aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> grenzt.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>A bounding box for content that borders the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified direction, or <ph id="ph2">&lt;see cref="P:System.Windows.Rect.Empty" /&gt;</ph> if current, valid layout information is unavailable.</source>
          <target state="translated">Ein umgebendes Feld für Inhalt, der in der angegebenen Richtung an den aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> grenzt, oder <ph id="ph2">&lt;see cref="P:System.Windows.Rect.Empty" /&gt;</ph>, wenn keine aktuellen und gültigen Layoutinformationen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> edges are not considered content for the purposes of this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Ränder werden Inhalt im Rahmen dieser Methode nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is positioned before a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> edge, the return value is a bounding box for the next non-<ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> content in the specified direction.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positioniert ist, bevor Sie eine <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Edge, der Rückgabewert wird ein Begrenzungsrahmen für den nächsten nicht-<ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Inhalte in der angegebenen Richtung.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>If there is no content in the specified direction, a zero-width <ph id="ph1">&lt;xref:System.Windows.Rect&gt;</ph> is returned with a height matching the height of any preceding content.</source>
          <target state="translated">Wenn kein Inhalt vorhanden, in der angegebenen Richtung, eine Breite von NULL ist <ph id="ph1">&lt;xref:System.Windows.Rect&gt;</ph> wird mit einer Höhe entsprechen die Höhe des vorhergehenden Inhalt zurückgegeben.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>The operation performed by this method depends on a valid layout.</source>
          <target state="translated">Eine gültige Layout abhängt, Vorgang, der von dieser Methode ausgeführt.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Diese Methode versucht bei Bedarf automatisch ein gültiges Layout vor dem Fortsetzen des Vorgangs neu generieren.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Erneutes Generieren eines Layouts kann eine relativ aufwändige Operation.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> Eigenschaft, um ein gültiges Layout überprüfen Sie vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the closest insertion position.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach der nächsten Einfügeposition erfolgen soll.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the closest insertion position in the specified logical direction.</source>
          <target state="translated">Gibt in der angegebenen logischen Richtung an der nächsten Einfügeposition einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the closest insertion position in the specified direction.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> an der nächsten Einfügeposition in der angegebenen Richtung.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An insertion position is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Eine Einfügeposition handelt es sich um eine Position, wo neuer Inhalte hinzugefügt werden kann, ohne Unterbrechung semantischen Regeln für den zugehörigen Inhalt.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">In der Praxis ist eine Einfügeposition an einer beliebigen Stelle im Inhalt, in denen eine Einfügemarke positioniert werden kann.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Ein Beispiel einer gültigen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Position an, die sich nicht um eine Einfügeposition ist, ist die Position zwischen zwei angrenzende <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Tags (d. h. zwischen dem Endtag aus dem vorherigen Absatz und das öffnende Tag eines nächsten Absatz).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> already points to a valid insertion position, but the closing tag for a non-empty formatting sequence directly follows that position in the given direction, then the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is adjusted to point to the insertion position just after the close of the formatting sequence.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> bereits verweist auf eine gültige Einfügeposition, aber das Endtag für eine Formatierung nicht leere Sequenz direkt auf diese Position in der angegebenen Richtung folgt die <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> zurückgegeben, die von dieser Methode so angepasst wird, zeigen Sie auf das Einfügen Positionieren Sie einfach nach dem Schließen der Formatierung Sequenz.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>For example, consider the markup sequence <ph id="ph1">`&lt;Bold&gt;a&lt;/Bold&gt;b`</ph>.</source>
          <target state="translated">Betrachten Sie beispielsweise die Markupsequenz <ph id="ph1">`&lt;Bold&gt;a&lt;/Bold&gt;b`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Note that there are two insertion positions between the letters <ph id="ph1">`a`</ph> and <ph id="ph2">`b`</ph> — one that precedes the closing <ph id="ph3">`Bold`</ph> tag, and one directly following the closing <ph id="ph4">`Bold`</ph> tag.</source>
          <target state="translated">Beachten Sie, dass es zwei Einfügepositionen zwischen den Buchstaben gibt <ph id="ph1">`a`</ph> und <ph id="ph2">`b`</ph> – vor der öffnenden <ph id="ph3">`Bold`</ph> -Tag und direkt nach dem schließenden <ph id="ph4">`Bold`</ph> Tag.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> is called on a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to the position directly after the letter <ph id="ph3">`a`</ph> and before of the closing <ph id="ph4">`Bold`</ph> tag, and with a <ph id="ph5">`direction`</ph> of <ph id="ph6">&lt;xref:System.Windows.Documents.LogicalDirection.Forward&gt;</ph>, the returned <ph id="ph7">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is adjusted to point to the position just before the letter <ph id="ph8">`b`</ph>, after the closing <ph id="ph9">`Bold`</ph> tag.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> für aufgerufen wird eine <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> auf die Position direkt hinter dem Buchstaben <ph id="ph3">`a`</ph> und vor des Abschlusses <ph id="ph4">`Bold`</ph> Tag, und mit einer <ph id="ph5">`direction`</ph> von <ph id="ph6">&lt;xref:System.Windows.Documents.LogicalDirection.Forward&gt;</ph>, zurückgegebenen <ph id="ph7">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> wird angepasst, um zu zeigen die die Position unmittelbar vor dem Buchstaben <ph id="ph8">`b`</ph>, nach dem schließenden <ph id="ph9">`Bold`</ph> Tag.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A similar adjustment is made for opening formatting tags when working in the opposite logical direction.</source>
          <target state="translated">Zum Öffnen von Formatierungstags bei der Arbeit in die Gegenrichtung logischen wird eine ähnliche Anpassung vorgenommen.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method is intended to provide a means of disambiguation between insertion positions in similar cases.</source>
          <target state="translated">Diese Methode soll systemverarbeitungsaufwand Mehrdeutigkeit zwischen Positionen der Einfügemarke in ähnlichen Fällen.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method can also be used to be selective about insertion points when a sequence of structural tags is involved.</source>
          <target state="translated">Diese Methode kann auch verwendet werden, selektive Einfügemarken sein, wenn eine Sequenz von Strukturtags beteiligt ist.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>For example, when at a position between closing and opening paragraph tags, the direction parameter can be used to select the closest insertion point at the beginning of the following paragraph (by specifying <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>) or at the end of the preceding paragraph (by specifying <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Z. B. an der Position zwischen schließen und Öffnen von Absatztags, die Richtung-Parameter kann verwendet werden, wählen Sie die nächste Einfügemarke am Anfang des folgenden Absatzes (durch Angabe <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType&gt;</ph>) oder am Ende der vorherigen Absatz ( durch Angabe <ph id="ph2">&lt;xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the pointer is already at insertion position, and there are no adjacent formatting tags in the specified <ph id="ph1">`direction`</ph>, the returned <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to the same position as the calling <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Wenn der Mauszeiger befindet sich bereits an der Position der Einfügemarke, und es keine benachbarten Formatierungstags in der angegebenen gibt <ph id="ph1">`direction`</ph>, das zurückgegebene <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verweist auf derselben Position wie die aufrufende <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>It is possible that no valid insertion position exists relative to the position pointed to by a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Es ist möglich, dass keine gültige Einfügeposition relativ zur Position verweist vorhanden ist eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This can happen if the referenced content is structurally incomplete, as in an empty table or list.</source>
          <target state="translated">Dies kann geschehen, wenn der referenzierte Inhalt strukturell unvollständig sind, wie eine leere Tabelle oder Liste.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In such cases, this method simply returns a <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to the same position as the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> from which this method was called.</source>
          <target state="translated">In solchen Fällen gibt diese Methode einfach eine <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> an derselben Position wie das <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> aus dem diese Methode aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This method always returns a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</source>
          <target state="translated">Diese Methode gibt immer einen gültigen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> method to check whether a specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> is empty of printable content.</source>
          <target state="translated">Dieses Beispiel zeigt, wie die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A&gt;</ph> -Methode überprüft, ob ein angegebener <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> druckbaren Inhalt leer ist.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> angegeben wird.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>The number of start-of-line markers to skip when determining the line for which to return the starting position.</source>
          <target state="translated">Die Anzahl der zu überspringenden Zeilenanfangsmarker beim Festlegen der Zeile, deren Anfangsposition zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</source>
          <target state="translated">Mit negativen Werten werden vorangehende Zeilen angegeben, mit 0 die aktuelle Zeile, mit positiven Werten Folgezeilen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> angegeben wird.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointing to the beginning of the specified line (with the <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), or <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the specified line is out of range or otherwise cannot be located.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, der auf den Anfang der angegebenen Zeile zeigt (wobei die <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> auf <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph> festgelegt ist); bzw. <ph id="ph4">&lt;see langword="null" /&gt;</ph>, wenn die angegebene Zeile außerhalb des Bereichs liegt oder anderweitig nicht gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> is selected as the relative starting line.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verweist auf eine mehrdeutige Position, z. B. zwischen zwei Zeilen, die Zeile in der vom angegebenen Richtung <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> als relative Anfangszeile ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>The operation performed by this method depends on a valid layout.</source>
          <target state="translated">Eine gültige Layout abhängt, Vorgang, der von dieser Methode ausgeführt.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Diese Methode versucht bei Bedarf automatisch ein gültiges Layout vor dem Fortsetzen des Vorgangs neu generieren.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Erneutes Generieren eines Layouts kann eine relativ aufwändige Operation.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> zu prüfen, ob ein gültiges Layout vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>The number of start-of-line markers to skip when determining the line for which to return the starting position.</source>
          <target state="translated">Die Anzahl der zu überspringenden Zeilenanfangsmarker beim Festlegen der Zeile, deren Anfangsposition zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</source>
          <target state="translated">Mit negativen Werten werden vorangehende Zeilen angegeben, mit 0 die aktuelle Zeile, mit positiven Werten Folgezeilen.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>When this method returns, contains the actual number of start-of-line markers that were skipped when determining the line for which to return the starting position.</source>
          <target state="translated">Wenn diese Methode einen Rückgabewert erstellt, enthält dieser die tatsächliche Anzahl der Zeilenanfangsmarker, die beim Festlegen der Zeile übersprungen wurden, deren Anfangsposition zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>This value may be less than <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept> if the beginning or end of content is encountered before the specified number of lines are skipped.</source>
          <target state="translated">Dieser Wert kann kleiner als <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept> sein, wenn der Anfang oder das Ende des Inhalts erreicht ist, bevor die angegebene Anzahl von Zeilen übersprungen wurde.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning of a line that is specified relative to the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, and reports how many lines were skipped.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> angegeben wird, und gibt an, wie viele Zeilen übersprungen wurden.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> pointing to the beginning of the specified line (with the <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph>), or to the beginning of the line closest to the specified line if the specified line is out of range.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, der auf den Anfang der angegebenen Zeile (wobei die <ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> auf <ph id="ph3">&lt;see cref="F:System.Windows.Documents.LogicalDirection.Forward" /&gt;</ph> festgelegt ist) oder auf den Anfang der Zeile zeigt, die der angegebenen Zeile am nächsten ist, wenn die angegebene Zeile außerhalb des Bereichs liegt.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> property is selected as the relative starting line.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verweist auf eine mehrdeutige Position, z. B. zwischen zwei Zeilen, die Zeile in der vom angegebenen Richtung der <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> Eigenschaft als relative Anfangszeile ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the next symbol.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach dem nächsten Symbol erfolgen soll.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a pointer to the next symbol in the specified logical direction.</source>
          <target state="translated">Gibt einen Zeiger auf das nächste Symbol in der angegebenen logischen Richtung zurück.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the next symbol in the requested direction, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> borders the start or end of content.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf das nächste Symbol in der angeforderten Richtung oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der aktuelle <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> an den Anfang oder das Ende des Inhalts grenzt.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Folgendes gilt ein Symbol sein:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Start- oder Endtag für ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> in enthaltenen Elementen ein <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Eine 16-Bit- <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the next symbol is categorized as <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.EmbeddedElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext.ElementStart&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext.ElementEnd&gt;</ph> (as identified by the <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method), then the <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is advanced by exactly one symbol from the current position.</source>
          <target state="translated">Wenn das nächste Symbol als kategorisiert wird <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.EmbeddedElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointerContext.ElementStart&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext.ElementEnd&gt;</ph> (, das durch die <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> Methode), die <ph id="ph5">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> zurückgegeben, die von dieser Methode ist genau ein Primärschlüsselsymbol erweiterten, von der aktuellen Position.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>If the next symbol is categorized as <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>, then the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by this method is advanced past the text to the next non-text symbol (that is, the next position where the <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> is not <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>).</source>
          <target state="translated">Wenn das nächste Symbol als kategorisiert wird <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>, die <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> zurückgegeben, die von dieser Methode wird hinter dem Text vorgerückt, auf das nächste-n Nichttext-Symbol (, also der nächsten position, an der <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointerContext&gt;</ph> ist nicht <ph id="ph4">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The exact symbol count crossed can be calculated in advance by calling the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A&gt;</ph> method.</source>
          <target state="translated">Die genaue Anzahl kann im Voraus berechnet werden, durch Aufrufen der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A&gt;</ph> method in conjunction with the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method to traverse and extract the symbols in a specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A&gt;</ph> Methode in Verbindung mit der <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> Methode durchlaufen und extrahiert die Symbole in einem angegebenen <ph id="ph3">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>While the example can be used to extract a <ph id="ph1">[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</ph> structure for the contents of a given <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>, it is intended for illustrative purposes only, and should not be used in production code.</source>
          <target state="translated">Während das Beispiel kann, zum Extrahieren verwendet werden einer <ph id="ph1">[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]</ph> Struktur für den Inhalt der einer angegebenen <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement&gt;</ph>, es dient nur zur Veranschaulichung und sollte nicht im Produktionscode verwendet werden.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)">
          <source>See the <ph id="ph1">&lt;xref:System.Xml&gt;</ph> namespace for a rich set of types designed for working with and processing XML.</source>
          <target state="translated">Finden Sie unter der <ph id="ph1">&lt;xref:System.Xml&gt;</ph> Namespace-URI für einen umfangreichen Satz von Typen, die zum Arbeiten mit und die XML-Verarbeitung entworfen wurden.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to search for the next insertion position.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach der nächsten Einfügeposition erfolgen soll.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the next insertion position in the specified logical direction.</source>
          <target state="translated">Gibt in der angegebenen logischen Richtung an der nächsten Einfügeposition einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that identifies the next insertion position in the requested direction, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no next insertion position can be found.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, mit dem die nächste Einfügeposition in der angegebenen Richtung gekennzeichnet wird, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn keine nächste Einfügeposition gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An <bpt id="p1">*</bpt>insertion position<ept id="p1">*</ept> is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Ein <bpt id="p1">*</bpt>Einfügeposition<ept id="p1">*</ept> ist eine Position, in neuer Inhalte ohne Unterbrechung semantischen Regeln für den zugehörigen Inhalt hinzugefügt werden kann.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">In der Praxis ist eine Einfügeposition an einer beliebigen Stelle im Inhalt, in denen eine Einfügemarke positioniert werden kann.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Ein Beispiel einer gültigen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Position an, die sich nicht um eine Einfügeposition ist, ist die Position zwischen zwei angrenzende <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Tags (d. h. zwischen dem Endtag aus dem vorherigen Absatz und das öffnende Tag eines nächsten Absatz).</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> method to traverse content element boundaries in order to count the number of <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> elements present between two specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A&gt;</ph> Methode Inhaltselement Grenzen durchlaufen, um die Anzahl der <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Elemente darstellen, zwischen zwei angegebenen <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to find the distance (in symbols) to.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, mit dem eine Position angegeben wird, zu der die Entfernung (in Symbolen) bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Returns the count of symbols between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and a second specified <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Gibt die Anzahl der Symbole zwischen dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> und einem weiteren bestimmten <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The relative number of symbols between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and <ph id="ph2">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">Die relative Anzahl von Symbolen zwischen dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> und der <ph id="ph2">&lt;paramref name="position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A negative value indicates that the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> follows the position specified by <ph id="ph2">&lt;paramref name="position" /&gt;</ph>, 0 indicates that the positions are equal, and a positive value indicates that the current <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes the position specified by <ph id="ph4">&lt;paramref name="position" /&gt;</ph>.</source>
          <target state="translated">Mit einem negativen Wert wird angegeben, dass sich der aktuelle <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> hinter der durch <ph id="ph2">&lt;paramref name="position" /&gt;</ph> angegebenen Position befindet; 0 gibt an, dass die Positionen identisch sind; und mit einem positiven Wert wird angegeben, dass sich der aktuelle <ph id="ph3">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> vor der durch <ph id="ph4">&lt;paramref name="position" /&gt;</ph> angegebenen Position befindet.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Folgendes gilt ein Symbol sein:</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>An opening or closing tag for a <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Start- oder Endtag für ein <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> in enthaltenen Elementen ein <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Eine 16-Bit- <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> method to find the offsets for two <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances, and then uses this information to save and restore the selection in a <ph id="ph3">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> Methode, um die Offsets für zwei ermitteln <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen und verwendet dann diese Informationen speichern und Wiederherstellen der Auswahl in einem <ph id="ph3">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source>The example assumes that the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph> have not changed between a selection save and a selection restore.</source>
          <target state="translated">Das Beispiel setzt voraus, dass der Inhalt des der <ph id="ph1">&lt;xref:System.Windows.Controls.RichTextBox&gt;</ph> zwischen einem speichern und eine Wiederherstellen der Auswahl nicht geändert wurden.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> specifies a position outside of the text container associated with the current position.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> gibt eine Position an, die außerhalb des der aktuellen Position zugeordneten Textcontainers liegt.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to determine the category for adjacent content.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der die Kategorie für den benachbarten Inhalt bestimmt wird.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>Returns a category indicator for the content adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Gibt für den Inhalt neben dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in der angegebenen logischen Richtung einen Kategorieindikator zurück.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointerContext" /&gt;</ph> values that indicates the category for adjacent content in the specified logical direction.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointerContext" /&gt;</ph>-Werte, mit denen die Kategorie für benachbarten Inhalt in der angegebenen logischen Richtung angegeben wird.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> method to implement an algorithm for calculating the balance of opening and closing element tags between two specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> positions.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPointerContext%2A&gt;</ph> Methode für die Implementierung eines Algorithmus zum Berechnen des Saldo der Start- und Endtags Element zwischen zwei angegebenen <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Positionen.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)">
          <source>Each opening element tag is counted as +1, and each closing element tag is counted as –1.</source>
          <target state="translated">Jeder öffnenden Element als + 1, und jeder gezählt wird das Endtag des Elements als – 1 gezählt wird.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of content.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf die Position zurück, die in Symbolen durch den ab dem Anfang des Inhalts bestimmten Offset angegeben wird.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>An offset, in symbols, for which to calculate and return the position.</source>
          <target state="translated">Ein Offset in Symbolen, für den die Position berechnet und zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>If the offset is negative, the position is calculated in the logical direction opposite of that indicated by the <ph id="ph1">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph> property.</source>
          <target state="translated">Wenn der Offset negativ ist, wird die Position in der logischen Richtung berechnet, die der mit der <ph id="ph1">&lt;see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /&gt;</ph>-Eigenschaft angegebenen Richtung entgegengesetzt ist.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf die Position zurück, die in Symbolen durch den ab dem Anfang des aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> bestimmten Offset angegeben wird.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no corresponding position can be found.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf die Position, die von dem bestimmten Offset angegeben wird, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn keine entsprechende Position gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Folgendes gilt ein Symbol sein:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Eine öffnende oder schließende Tag für den <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> in enthaltenen Elementen ein <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Eine 16-Bit- <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> method to implement a pair of methods, one to calculate the offset to a specified position relative to any hosting paragraph, and the other to return a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to a specified offset in a specified paragraph.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A&gt;</ph> Methode für die Implementierung von ein Paar von Methoden, mit einem Methodenpaar an eine angegebene Position relativ zum alle hosting Absatz, und die andere zum Zurückgeben einer <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> an einem angegebenen Offset in einem angegebenen Absatz.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>An offset, in symbols, for which to calculate and return the position.</source>
          <target state="translated">Ein Offset in Symbolen, für den die Position berechnet und zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>If the offset is negative, the returned <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> precedes the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>; otherwise, it follows.</source>
          <target state="translated">Wenn der Offset negativ ist, steht der zurückgegebene <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> vor dem aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, andernfalls danach.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction of the returned <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung des zurückgegebenen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> angegeben wird.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, in symbols, from the beginning of the current <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and in the specified direction.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf die Position zurück, die in Symbolen durch den ab dem Anfang des aktuellen <ph id="ph2">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> bestimmten Offset und in der angegebenen Richtung angegeben wird.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the position indicated by the specified offset, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the offset extends past the end of the content.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf die Position, die durch den bestimmten Offset angegeben wird, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn sich der Offset über das Ende des Inhalts hinaus erstreckt.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Folgendes gilt ein Symbol sein:</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Eine öffnende oder schließende Tag für den <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> in enthaltenen Elementen ein <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Eine 16-Bit- <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Windows.Documents.TextPointer">
          <source>Returns text adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>.</source>
          <target state="translated">Gibt den Text zurück, der sich neben dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> befindet.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find and return any adjacent text.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der benachbarter Text gesucht und zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Returns a string containing any text adjacent to the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> in the specified logical direction.</source>
          <target state="translated">Gibt eine Zeichenfolge zurück, die Text enthält, der sich in der angegebenen logischen Richtung neben dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> befindet.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>A string containing any adjacent text in the specified logical direction, or <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if no adjacent text can be found.</source>
          <target state="translated">Eine Zeichenfolge, die beliebigen benachbarten Text in der angegebenen logischen Richtung enthält, oder <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn kein benachbarter Text gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>This method returns only uninterrupted runs of text.</source>
          <target state="translated">Diese Methode gibt nur ununterbrochene textausführungen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Nothing is returned if any symbol type other than <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> is adjacent to the current <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in the specified direction.</source>
          <target state="translated">Nichts wird zurückgegeben, wenn alle Typ außer symbol <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> wird neben dem aktuellen <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in der angegebenen Richtung.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Similarly, text is returned only up to the next non-text symbol.</source>
          <target state="translated">Auf ähnliche Weise wird der Text nur bis zur nächsten-n Nichttext-Symbol zurückgegeben.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> method to implement a simple text extractor.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetTextInRun%2A&gt;</ph> Methode für die Implementierung von einem einfachen Text extrahieren.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>The method returns a string concatenation of all text between two specified <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances.</source>
          <target state="translated">Die Methode gibt eine zeichenfolgenverkettung aus sämtlichen Text zwischen zwei angegebenen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>While the example can be used to extract any text between two <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances, it is intended for illustrative purposes only, and should not be used in production code.</source>
          <target state="translated">Während das Beispiel kann, zum Extrahieren von Text zwischen zwei verwendet werden <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen, es dient nur zur Veranschaulichung und sollte nicht im Produktionscode verwendet werden.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Verwenden Sie stattdessen die <ph id="ph1">&lt;xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to find and copy any adjacent text.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung angegeben wird, in der benachbarter Text gesucht und kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>A buffer into which any text is copied.</source>
          <target state="translated">Ein Puffer, in den beliebiger Text kopiert wird.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>An index into <bpt id="p1">&lt;c&gt;</bpt>textBuffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing copied text.</source>
          <target state="translated">Ein Index im <bpt id="p1">&lt;c&gt;</bpt>textBuffer<ept id="p1">&lt;/c&gt;</ept>, ab dem mit dem Schreiben von kopiertem Text begonnen wird.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to copy.</source>
          <target state="translated">Die maximale Anzahl der zu kopierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Copies the specified maximum number of characters from any adjacent text in the specified direction into a caller-supplied character array.</source>
          <target state="translated">Kopiert die angegebene maximale Anzahl von Zeichen aus benachbartem Text in der angegebenen Richtung in ein vom Aufrufer bereitgestelltes Zeichenarray.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters actually copied into <ph id="ph1">&lt;paramref name="textBuffer" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der tatsächlich in den <ph id="ph1">&lt;paramref name="textBuffer" /&gt;</ph> kopierten Zeichen.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>This method returns only uninterrupted runs of text.</source>
          <target state="translated">Diese Methode gibt nur ununterbrochene textausführungen.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Nothing is returned if any symbol type other than <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> is adjacent to the current <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in the specified direction.</source>
          <target state="translated">Nichts wird zurückgegeben, wenn alle Typ außer symbol <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointerContext.Text&gt;</ph> wird neben dem aktuellen <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> in der angegebenen Richtung.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>Similarly, text is returned only up to the next non-text symbol.</source>
          <target state="translated">Auf ähnliche Weise wird der Text nur bis zur nächsten-n Nichttext-Symbol zurückgegeben.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 or greater than the <ph id="ph2">&lt;see cref="P:System.Array.Length" /&gt;</ph> property of <ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 oder größer als die <ph id="ph2">&lt;see cref="P:System.Array.Length" /&gt;</ph>-Eigenschaft von <ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0 or greater than the remaining space in <ph id="ph2">&lt;paramref name="textBuffer" /&gt;</ph> (<ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.<ph id="ph4">&lt;see cref="P:System.Array.Length" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0 oder größer als der verbleibende Raum im <ph id="ph2">&lt;paramref name="textBuffer" /&gt;</ph> (<ph id="ph3">&lt;paramref name="textBuffer" /&gt;</ph>.<ph id="ph4">&lt;see cref="P:System.Array.Length" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)">
          <source>minus <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>).</source>
          <target state="translated">minus<ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> values that specifies the logical direction in which to count the number of characters.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Werte, mit denen die logische Richtung für das Zählen der Zeichenanzahl angegeben wird.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Returns the number of Unicode characters between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and the next non-text symbol, in the specified logical direction.</source>
          <target state="translated">Gibt in der angegebenen logischen Richtung die Anzahl der Unicode-Zeichen zwischen dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> und dem nächsten Nicht-Text-Symbol zurück.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>The number of Unicode characters between the current <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> and the next non-text symbol.</source>
          <target state="translated">Die Anzahl der Unicode-Zeichen zwischen dem aktuellen <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> und dem nächsten Nicht-Text-Symbol.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>This number may be 0 if there is no adjacent text.</source>
          <target state="translated">Diese Zahl kann 0 sein, wenn kein benachbarter Text vorhanden ist.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Any of the following is considered to be a symbol:</source>
          <target state="translated">Folgendes gilt ein Symbol sein:</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>An opening or closing tag for the <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> element.</source>
          <target state="translated">Eine öffnende oder schließende Tag für den <ph id="ph1">&lt;xref:System.Windows.Documents.TextElement&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> element contained in an <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> in enthaltenen Elementen ein <ph id="ph2">&lt;xref:System.Windows.Documents.InlineUIContainer&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.Documents.BlockUIContainer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>Note that such a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> is always counted as exactly one symbol; any additional content or elements contained by the <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> are not counted as symbols.</source>
          <target state="translated">Beachten Sie, dass solche eine <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> wird immer als genau ein Symbol ist eine zusätzliche Inhalts- oder Elemente gezählt der <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> werden als Symbole nicht gezählt.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)">
          <source>A 16-bit <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> character inside of a text <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element.</source>
          <target state="translated">Eine 16-Bit- <ph id="ph1">[!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)]</ph> -Zeichen in einem <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Gets a value that indicates whether the text container associated with the current position has a valid (up-to-date) layout.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob der der aktuellen Position zugeordnete Textcontainer über ein gültiges (aktuelles) Layout verfügt.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the layout is current and valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Layout aktuell und gültig ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>When necessary, operations that depend on a valid layout (such as the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> method, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A&gt;</ph> method, and <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> property) attempt to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Bei Bedarf werden Vorgänge, die von einem gültigen Layout abhängen (z. B. die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A&gt;</ph> -Methode, <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A&gt;</ph> -Methode und <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A&gt;</ph> Eigenschaft) versuchen, ein gültiges Layout vor dem Fortsetzen des Vorgangs automatisch erneut zu generieren.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Erneutes Generieren eines Layouts kann eine relativ aufwändige Operation.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>Use this property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft, um ein gültiges Layout überprüfen Sie vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.HasValidLayout">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertLineBreak">
          <source>Inserts a line break at the current position.</source>
          <target state="translated">Fügt an der aktuellen Position einen Zeilenumbruch ein.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertLineBreak">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> positioned immediately after the <ph id="ph2">&lt;see cref="T:System.Windows.Documents.LineBreak" /&gt;</ph> element inserted by this method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, der unmittelbar nach dem von dieser Methode eingefügten <ph id="ph2">&lt;see cref="T:System.Windows.Documents.LineBreak" /&gt;</ph>-Element positioniert wird.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>Inserts a paragraph break at the current position.</source>
          <target state="translated">Fügt an der aktuellen Position einen Absatzwechsel ein.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> to the beginning (<ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextElement.ContentStart" /&gt;</ph>) of the new paragraph.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> auf den Anfang (<ph id="ph2">&lt;see cref="P:System.Windows.Documents.TextElement.ContentStart" /&gt;</ph>) des neuen Absatzes.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called when the current position is inside of an existing <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, the existing paragraph and any content it contains are split into two paragraphs at the current position.</source>
          <target state="translated">Wenn diese Methode aufgerufen wird, wenn die aktuelle Position innerhalb einer vorhandenen ist <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> -Element, den vorhandenen Absatz und alle Inhalte, die es enthält sind an der aktuellen Position in zwei Absätze aufgeteilt.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called when the current position is not inside of an existing paragraph, a new, empty paragraph is inserted.</source>
          <target state="translated">Wenn diese Methode aufgerufen wird, wenn die aktuelle Position nicht in einen vorhandenen Absatz ist, wird ein neuer, leerer Absatz eingefügt.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>If this method is called at a position unsuitable for splitting or inserting a paragraph (for example, if the current position is inside of a <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> element), an exception is thrown.</source>
          <target state="translated">Wenn diese Methode an einer Position für das Aufteilen oder Einfügen eines Absatzes ungeeignet aufgerufen wird (z. B., wenn die aktuelle Position innerhalb des ist ein <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> Element), wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertParagraphBreak">
          <source>This method is called on a position that cannot be split to accommodate a new paragraph, such as in the scope of a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Hyperlink" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Windows.Documents.InlineUIContainer" /&gt;</ph>.</source>
          <target state="translated">Diese Methode wird an einer Position aufgerufen, an der keine Aufteilung für das Einfügen eines neuen Absatzes erfolgen kann, z. B. im Bereich eines <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Hyperlink" /&gt;</ph> oder eines <ph id="ph2">&lt;see cref="T:System.Windows.Documents.InlineUIContainer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>The text to insert.</source>
          <target state="translated">Der einzufügende Text.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>Inserts the specified text into the text <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> at the current position.</source>
          <target state="translated">Fügt den angegebenen Text an der aktuellen Position in den <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> des Texts ein.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is not scoped by a <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> element, a <ph id="ph3">&lt;xref:System.Windows.Documents.Run&gt;</ph> is inserted along with the <ph id="ph4">`textData`</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> nicht beschränkt wird eine <ph id="ph2">&lt;xref:System.Windows.Documents.Run&gt;</ph> Element, eine <ph id="ph3">&lt;xref:System.Windows.Documents.Run&gt;</ph> eingefügt wird, zusammen mit den <ph id="ph4">`textData`</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source>The current position is not within a <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph> element.</source>
          <target state="translated">Die aktuelle Position befindet sich nicht in einem <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Run" /&gt;</ph>-Element.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)">
          <source><ph id="ph1">&lt;paramref name="textData" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="textData" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>Gets a value that indicates whether the current position is an insertion position.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob die aktuelle Position eine Einfügeposition ist.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current position is an insertion position; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die aktuelle Position eine Einfügeposition ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>An insertion position is a position where new content may be added without breaking any semantic rules for the associated content.</source>
          <target state="translated">Eine Einfügeposition handelt es sich um eine Position, wo neuer Inhalte hinzugefügt werden kann, ohne Unterbrechung semantischen Regeln für den zugehörigen Inhalt.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>In practice, an insertion position is anywhere in content where a caret may be positioned.</source>
          <target state="translated">In der Praxis ist eine Einfügeposition an einer beliebigen Stelle im Inhalt, in denen eine Einfügemarke positioniert werden kann.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition">
          <source>An example of a valid <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> position that is not an insertion position is the position between two adjacent <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> tags (that is, between the closing tag of the preceding paragraph and the opening tag of the next paragraph).</source>
          <target state="translated">Ein Beispiel einer gültigen <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Position an, die sich nicht um eine Einfügeposition ist, ist die Position zwischen zwei angrenzende <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> Tags (d. h. zwischen dem Endtag aus dem vorherigen Absatz und das öffnende Tag eines nächsten Absatz).</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Gets a value that indicates whether the current position is at the beginning of a line.</source>
          <target state="translated">Ruft einen Wert ab, mit dem angegeben wird, ob sich die aktuelle Position am Anfang einer Zeile befindet.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current position is at the beginning of a line; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn sich die aktuelle Position am Anfang einer Zeile befindet, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> points to an ambiguous position, for example, between two lines, the line in the direction specified by the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> property is selected as the relative starting line.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> verweist auf eine mehrdeutige Position, z. B. zwischen zwei Zeilen, die Zeile in der vom angegebenen Richtung der <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.LogicalDirection%2A&gt;</ph> Eigenschaft als relative Anfangszeile ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>The operation performed by this property depends on a valid layout.</source>
          <target state="translated">Der Vorgang ausgeführt wird, die von dieser Eigenschaft hängt von einem gültigen Layout ab.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>When necessary, this method attempts to automatically regenerate a valid layout before proceeding with the operation.</source>
          <target state="translated">Diese Methode versucht bei Bedarf automatisch ein gültiges Layout vor dem Fortsetzen des Vorgangs neu generieren.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Regenerating a layout can be a relatively expensive operation.</source>
          <target state="translated">Erneutes Generieren eines Layouts kann eine relativ aufwändige Operation.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> property to check for a valid layout before performing operations that may regenerate the layout.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.HasValidLayout%2A&gt;</ph> Eigenschaft, um ein gültiges Layout überprüfen Sie vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph> that specifies a position to compare to the current position.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Windows.Documents.TextPointer" /&gt;</ph>, der eine Position angibt, die mit der aktuellen Position verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Indicates whether the specified position is in the same text container as the current position.</source>
          <target state="translated">Gibt an, ob sich die angegebene Position im gleichen Textcontainer wie die aktuelle Position befindet.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="textPosition" /&gt;</ph> indicates a position that is in the same text container as the current position; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn mit <ph id="ph2">&lt;paramref name="textPosition" /&gt;</ph> eine Position angegeben wird, die sich im gleichen Textcontainer wie die aktuelle Position befindet, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Most operations that involve multiple <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances are only valid if the instances in question indicate positions that are in the same text container scope.</source>
          <target state="translated">Die meisten Operationen mit mehreren <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen sind nur gültig, wenn die betreffenden Instanzen Positionen anzuzeigen, die im gleichen Textfeld Containerbereich sind.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>For example the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> methods cannot be used with a <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> to a position outside of the text container associated with the current position.</source>
          <target state="translated">Zum Beispiel die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.CompareTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A&gt;</ph> Methoden können nicht verwendet werden, mit einer <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> an eine Position außerhalb der aktuellen Position zugeordneten Textcontainers.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>Use this method to verify that a specified <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is compatible with the current position for such operations.</source>
          <target state="translated">Verwenden Sie diese Methode zum Überprüfen, ob ein angegebenes <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> ist kompatibel mit der aktuellen Position für solche Vorgänge.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>The following example demonstrates a use for this method.</source>
          <target state="translated">Im folgende Beispiel wird eine Verwendung für diese Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> method to check whether a specified <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is positioned between two other specified <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> instances in a situation when there is no guarantee that all three positions belong to the same text container.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A&gt;</ph> -Methode überprüft, ob ein angegebener <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> befindet sich zwischen zwei anderen angegebenen <ph id="ph3">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> Instanzen in eine Situation, besteht keine Garantie, dass alle drei Positionen auf den gleichen Textcontainer gehören.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)">
          <source><ph id="ph1">&lt;paramref name="textPosition" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="textPosition" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>Gets the logical direction associated with the current position which is used to disambiguate content associated with the current position.</source>
          <target state="translated">Ruft die der aktuellen Position zugeordnete logische Richtung ab, mit der der aktuellen Position zugeordneter Inhalt unterschieden werden kann.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph> value that is associated with the current position.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Windows.Documents.LogicalDirection" /&gt;</ph>-Wert, der der aktuellen Position zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>As an example of how this property is used, the <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection&gt;</ph> of the <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> returned by a hit test method gives a hit that is between two characters of text.</source>
          <target state="translated">Als Beispiel dafür, wie diese Eigenschaft verwendet wird die <ph id="ph1">&lt;xref:System.Windows.Documents.LogicalDirection&gt;</ph> von der <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> zurückgegeben von einem Treffertest Methode ergibt einen Treffer zwischen beiden Zeichen des Texts.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.LogicalDirection">
          <source>The logical direction specifies which of the two characters was actually hit—the left or the right.</source>
          <target state="translated">Die logische Richtung gibt an, welche der beiden Zeichen tatsächlich erreicht wurde, links oder rechts.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.Paragraph">
          <source>Gets the paragraph that scopes the current position, if any.</source>
          <target state="translated">Ruft den Absatz ab, mit dem ggf. die aktuelle Position festgelegt wird.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.Paragraph">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Paragraph" /&gt;</ph> that scopes the current position, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no such paragraph exists.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Windows.Documents.Paragraph" /&gt;</ph> , die die aktuelle Position, Bereiche oder <ph id="ph2">&lt;see langword="null" /&gt;</ph> Wenn kein entsprechender Absatz vorhanden ist.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Windows.Documents.TextPointer.Parent">
          <source>Gets the logical parent that scopes the current position.</source>
          <target state="translated">Ruft das logische übergeordnete Element ab, mit dem die aktuelle Position festgelegt wird.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.Documents.TextPointer.Parent">
          <source>The logical parent that scopes the current position.</source>
          <target state="translated">Das logische übergeordnete Element, mit dem die aktuelle Position festgelegt wird.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.ToString">
          <source>This type or member supports the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> infrastructure and is not intended to be used directly from your code.</source>
          <target state="translated">Dieser Typ oder Member unterstützt die <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Windows.Documents.TextPointer.ToString">
          <source>The string that represents the object.</source>
          <target state="translated">Die Zeichenfolge, die das Objekt darstellt.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>