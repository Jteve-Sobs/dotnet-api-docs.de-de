<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80ffc4468fcd8385587be234b88e4272ca043528" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37577928" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents a position within a <see cref="T:System.Windows.Documents.FlowDocument" /> or <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Documents.TextPointer> Klasse führt die folgende Terminologie:  
  
-   Position - grundsätzlich eine <xref:System.Windows.Documents.TextPointer> verweist immer auf einen *Position* im Inhalt.  Solche Positionen, um entweder zwischen Zeichen in den Inhalt oder Flow fallen Content-Element-tags definieren die Struktur für den Inhalt.  
  
-   Aktuelle Position: Da ein <xref:System.Windows.Documents.TextPointer> gibt immer eine Position, an und da viele der Vorgänge, die über ausgeführt werden können eine <xref:System.Windows.Documents.TextPointer> sind relativ zur Position derzeit verweist die <xref:System.Windows.Documents.TextPointer>, ist es sinnvoll, verweisen einfach auf die durch angegebenen Position ein <xref:System.Windows.Documents.TextPointer> als die *aktuelle Position*.  
  
-   Die Einfügeposition - ein *Einfügeposition* ist eine Position, in denen möglicherweise neue Inhalte hinzugefügt werden, ohne alle semantischen Regeln für den zugeordneten Inhalt.  In der Praxis ist eine Einfügeposition überall im Inhalt, in denen eine Einfügemarke positioniert werden kann.  Ein Beispiel einer gültigen <xref:System.Windows.Documents.TextPointer> Position, die keine Einfügeposition ist die Position zwischen zwei angrenzende <xref:System.Windows.Documents.Paragraph> Tags (d. h. zwischen dem schließenden Tag des vorherigen Abschnitt und das öffnende Tag des nächsten Absatz).  
  
-   Symbol - zum Zweck der <xref:System.Windows.Documents.TextPointer> Vorgänge, die Symbole enthalten, eine der folgenden gilt eine *Symbol*:  
  
    -   Eine öffnende oder schließende Tag für eine <xref:System.Windows.Documents.TextElement> Element.  
  
    -   Ein <xref:System.Windows.UIElement> Element innerhalb einer <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
    -   Jeder 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
-   Textcontainer – ein *Textcontainer* ist das Element, das den äußeren Rahmen der fortlaufenden Inhalts bildet, die Position angegeben wird, indem eine <xref:System.Windows.Documents.TextPointer> befindet sich immer in einem Textcontainer.  Derzeit ein Textcontainer muss entweder eine <xref:System.Windows.Documents.FlowDocument> oder <xref:System.Windows.Controls.TextBlock>.  Im Allgemeinen steigen zwischen <xref:System.Windows.Documents.TextPointer> Instanzen in anderen Text-Containern werden nicht unterstützt.  
  
-   Dokument - der Inhalt in einem Textcontainer wird als bezeichnet ein *Dokument*, z. B. die <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> Methode und die <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> und <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> Eigenschaften.  
  
 Die <xref:System.Windows.Documents.TextPointer> Klasse dient zum durchlaufen und Bearbeiten von Inhalt, der durch dargestellt wird vereinfacht [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] fortlaufende Inhaltselemente; in der Regel solche Elemente abgeleitet <xref:System.Windows.Documents.TextElement>.  Einige der Vorgänge, die <xref:System.Windows.Documents.TextPointer> erleichtert umfassen Folgendes:  
  
-   Führen Sie einen Ordinalvergleich von der aktuellen Position mit einer zweiten angegebenen Position ein.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Methode.  
  
-   Bestimmen Sie den Typ des Inhalts grenzt an der aktuellen Position in einer angegebenen Richtung.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode und <xref:System.Windows.Documents.TextPointerContext> Enumeration.  
  
-   Abrufen der <xref:System.Windows.Documents.TextElement> , Bereiche oder neben der aktuellen Position.  Finden Sie unter <xref:System.Windows.Documents.Paragraph> und <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> Methode.  
  
-   Abrufen des Textcontainers aus, die das aktuelle Dokument festlegt.  Siehe <xref:System.Windows.Documents.TextPointer.Parent%2A>-Eigenschaft.  
  
-   Erhalten Sie eine angegebene Anzahl von Zeichen, die vor oder nach der aktuellen Position ein.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> Methode.  
  
-   Fügen Sie eine Zeichenfolge von Zeichen an der aktuellen Position ein.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> Methode.  
  
-   Suchen Sie Zeilengrenzen im Inhalt.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> Methode und <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> Eigenschaft.  
  
-   Übersetzen zwischen <xref:System.Windows.Documents.TextPointer> -Positionen und offsets zum Inhalt.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> und <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methoden.  
  
-   Führen Sie die visuellen Treffertests durch die Konvertierung zwischen einer <xref:System.Windows.Documents.TextPointer> Position und eine <xref:System.Windows.Point> , das relative Koordinaten darstellt.  
  
-   Überprüfen Sie, ob die aktuelle Position eine Einfügeposition ist, oder suchen Sie eine nahe gelegenen Einfügeposition.  Finden Sie unter den <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> und <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> Methoden und die <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> Eigenschaft.  
  
 Die Position und <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> angegeben durch eine <xref:System.Windows.Documents.TextPointer> Objekt sind unveränderlich.  Wenn Inhalt bearbeitet oder geändert wird, die durch angegebene Position eine <xref:System.Windows.Documents.TextPointer> ändert sich nicht relativ zum umgebenden Text; stattdessen der Offset der Position vom Anfang des Inhalts entsprechend entsprechend die neue relative Position in angepasst wird Inhalt.  Z. B. eine <xref:System.Windows.Documents.TextPointer> , der angibt, auf den Anfang des diesem Absatz zeigen Sie auch, wenn der Inhalt eingefügt oder gelöscht werden, vor oder nach dem Absatz wird weiterhin eine Position am Anfang eines Absatzes.  
  
 Die <xref:System.Windows.Documents.TextPointer> Klasse stellt keine öffentlichen Konstruktoren bereit.  Eine Instanz von <xref:System.Windows.Documents.TextPointer> wird erstellt, indem Sie mithilfe von Eigenschaften oder Methoden anderer Objekte (einschließlich anderer <xref:System.Windows.Documents.TextPointer> Objekte). Die folgende Liste enthält einige Beispiele für Methoden und Eigenschaften, die zu erstellen und Zurückgeben einer <xref:System.Windows.Documents.TextPointer>.  Diese Liste ist nicht vollständig:  
  
-   Aus einem <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> und <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Aus einem <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, und <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Aus einem <xref:System.Windows.Controls.TextBlock> (Textcontainer): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, und <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Aus einem <xref:System.Windows.Documents.FlowDocument> (Textcontainer): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, und <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Aus einer vorhandenen <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, und <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine <xref:System.Windows.Documents.TextPointer> finden Sie eine Position innerhalb der ersten nur <xref:System.Windows.Documents.Run> Element in einem Container für angegebenen Text.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Das folgende Beispiel implementiert eine vereinfachte Suchalgorithmus mit <xref:System.Windows.Documents.TextPointer> Einrichtungen.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Performs an ordinal comparison between the positions specified by the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>–1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes <paramref name="position" />; 0 if the locations are the same; +1 if the current <see cref="T:System.Windows.Documents.TextPointer" /> follows <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert-1 gibt an, dass die Position von der aktuellen angegeben <xref:System.Windows.Documents.TextPointer> liegt vor dem vom angegebenen Position `position`.  Der Wert 0 gibt an, dass die angegebenen Positionen gleich sind.  Wert + 1 gibt an, dass die Position von der aktuellen angegeben <xref:System.Windows.Documents.TextPointer> hinter der durch `position`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode.  Im Beispiel die <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Methode wird verwendet, in Verbindung mit der <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> Methode zum Testen, ob ein angegebener <xref:System.Windows.Documents.TextElement> ist leer.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of characters to delete, starting at the current position. Specify a positive value to delete characters that follow the current position; specify a negative value to delete characters that precede the current position.</param>
        <summary>Deletes the specified number of characters from the position indicated by the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The number of characters actually deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie einen positiven Wert ein, um Zeichen zu löschen, die vor der aktuellen Position (wie in <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); einen negativen Wert, um Zeichen zu löschen, die vor der aktuellen Position angeben (wie in <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Die Anzahl der tatsächlich gelöschten Zeichen kann geringer sein als die angegebene Anzahl `count`.  Dies geschieht in Fällen, in denen `count` mehr Zeichen als vorhanden sind, gelöscht werden sollen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The method is called at a position where text is not allowed.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the end of content in the text container associated with the current position.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" /> am Ende des Inhalts in der aktuellen Position zugeordneten Textcontainer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Documents.TextPointer.Parent%2A> für das zurückgegebene <xref:System.Windows.Documents.TextPointer> ist immer ein Textcontainer (<xref:System.Windows.Controls.TextBlock> oder <xref:System.Windows.Documents.FlowDocument>), anstelle eines <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> at the beginning of content in the text container associated with the current position.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" /> am Anfang des Inhalts in der aktuellen Position zugeordneten Textcontainer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die Position, die von dieser Eigenschaft als eine Baselineposition aus der Arbeit mit relativen Versatz an andere Positionen zurückgegeben.  Die <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> und <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methoden bieten eine Möglichkeit zum Übersetzen zwischen Positionen und offsets.  
  
 Die <xref:System.Windows.Documents.TextPointer.Parent%2A> für das zurückgegebene <xref:System.Windows.Documents.TextPointer> ist immer ein Textcontainer (<xref:System.Windows.Controls.TextBlock> oder <xref:System.Windows.Documents.FlowDocument>), anstelle eines <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for an adjacent element.</param>
        <summary>Returns the element, if any, that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>The adjacent element in the specified <paramref name="direction" />, or <see langword="null" /> if no adjacent element exists.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Element ist in der Regel eine <xref:System.Windows.Documents.TextElement>.  Ein <xref:System.Windows.UIElement> zurückgegeben werden kann, wenn die <xref:System.Windows.Documents.TextPointer> gibt eine Position innerhalb einer <xref:System.Windows.Documents.BlockUIContainer> Element oder ein <xref:System.Windows.Documents.InlineUIContainer> Element.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find a content bounding box.</param>
        <summary>Returns a bounding box (<see cref="T:System.Windows.Rect" />) for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A bounding box for content that borders the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified direction, or <see cref="P:System.Windows.Rect.Empty" /> if current, valid layout information is unavailable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> Inhalt für die Zwecke dieser Methode gelten nicht.  Wenn die <xref:System.Windows.Documents.TextPointer> positioniert ist, bevor Sie eine <xref:System.Windows.Documents.TextElement> Edge, der Rückgabewert ist ein umgebendes Feld für den nächsten nicht -<xref:System.Windows.Documents.TextElement> Inhalte in der angegebenen Richtung.  Wenn kein Inhalt vorhanden, in der angegebenen Richtung, die eine Breite von NULL ist <xref:System.Windows.Rect> wird mit einer Höhe des entspricht alle vorherigen Inhalte zurückgegeben.  
  
 Der von dieser Methode ausgeführte Vorgang hängt von einem gültigen Layout ab.  Bei Bedarf, versucht diese Methode, um ein gültiges Layout vor dem Fortsetzen des Vorgangs automatisch erneut zu generieren.  Ein Layout wird erneut generiert, kann ein relativ teurer Vorgang sein.  Verwenden der <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Eigenschaft, um ein gültiges Layout vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.  Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the closest insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the closest insertion position in the specified direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Einfügeposition ist eine Position, in denen neuer Inhalte hinzugefügt werden kann, ohne alle semantischen Regeln für den zugeordneten Inhalt, an.  In der Praxis ist eine Einfügeposition überall im Inhalt, in denen eine Einfügemarke positioniert werden kann.  Ein Beispiel einer gültigen <xref:System.Windows.Documents.TextPointer> Position, die keine Einfügeposition ist die Position zwischen zwei angrenzende <xref:System.Windows.Documents.Paragraph> Tags (d. h. zwischen dem schließenden Tag des vorherigen Abschnitt und das öffnende Tag des nächsten Absatz).  
  
 Wenn die <xref:System.Windows.Documents.TextPointer> bereits verweist auf eine gültige Einfügeposition, aber das schließende Tag für eine nicht leere Formatierung Sequenz direkt auf diese Position in der angegebenen Richtung folgt die <xref:System.Windows.Documents.TextPointer> zurückgegeben, die von dieser Methode wird angepasst, um auf die Einfügemarke zu verweisen die Position direkt hinter das Ende der Formatzeichenfolge. Betrachten Sie beispielsweise die Markupsequenz `<Bold>a</Bold>b`. Beachten Sie, dass zwei Einfügepositionen zwischen den Buchstaben `a` und `b` – vor der öffnenden `Bold` Tag und eine, die direkt nach dem schließenden `Bold` Tag. Wenn <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> aufgerufen wird eine <xref:System.Windows.Documents.TextPointer> an die Position direkt hinter dem Buchstaben `a` und vor dem des Schließvorgangs `Bold` -Tag, und mit einer `direction` von <xref:System.Windows.Documents.LogicalDirection.Forward>, zurückgegebenen <xref:System.Windows.Documents.TextPointer> wird angepasst, um zu zeigen die die Position direkt vor dem Buchstaben `b`, nach dem schließenden `Bold` Tag. Zum Öffnen von Zeichenformatierungstags, bei der Arbeit in die entgegengesetzte Richtung für die logische ist eine ähnliche Anpassung erfolgt. Diese Methode ist vorgesehen, um die Mehrdeutigkeit zwischen Positionen der Einfügemarke in ähnlichen Fällen bereitzustellen.  
  
 Diese Methode kann auch verwendet werden, zum Einfügemarken sein, wenn eine Sequenz von Strukturtags beteiligt ist. Z. B. wenn an einer Position zwischen schließen und öffnen Absatztags, die Direction-Parameter kann verwendet werden, wählen Sie die nächste Einfügemarke am Anfang des folgenden Absatzes (durch Angabe <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) oder am Ende der vorhergehenden Absatz ( durch Angabe <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Wenn der Mauszeiger befindet sich bereits an der Position der Einfügemarke, und es keine benachbarten Formatierungstags in der angegebenen gibt `direction`, zurückgegebenen <xref:System.Windows.Documents.TextPointer> verweist auf der gleichen Position wie das aufrufende <xref:System.Windows.Documents.TextPointer>.  
  
 Es ist möglich, dass keine gültige Einfügeposition relativ zur Position verweist vorhanden ist. eine <xref:System.Windows.Documents.TextPointer>.  Dies kann auftreten, wenn die referenzierten Inhalte wie eine leere Tabelle oder Liste strukturell unvollständig ist.  In solchen Fällen gibt diese Methode einfach eine <xref:System.Windows.Documents.TextPointer> auf der gleichen Position wie der <xref:System.Windows.Documents.TextPointer> aus dem diese Methode aufgerufen wurde.  Diese Methode gibt immer einen gültigen <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Dieses Beispiel zeigt, wie Sie mit der <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> Methode, um zu überprüfen, ob ein angegebener <xref:System.Windows.Documents.TextElement> druckbaren Inhalt leer ist.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or <see langword="null" /> if the specified line is out of range or otherwise cannot be located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Documents.TextPointer> verweist auf eine nicht eindeutige Position, z. B. zwischen zwei Zeilen, die Zeile in der vom angegebenen Richtung <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> als relative Anfangszeile ausgewählt ist.  
  
 Der von dieser Methode ausgeführte Vorgang hängt von einem gültigen Layout ab.  Bei Bedarf, versucht diese Methode, um ein gültiges Layout vor dem Fortsetzen des Vorgangs automatisch erneut zu generieren.  Ein Layout wird erneut generiert, kann ein relativ teurer Vorgang sein.  Verwendung <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> um ein gültiges Layout vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.  Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">The number of start-of-line markers to skip when determining the line for which to return the starting position. Negative values specify preceding lines, 0 specifies the current line, and positive values specify following lines.</param>
        <param name="actualCount">When this method returns, contains the actual number of start-of-line markers that were skipped when determining the line for which to return the starting position.  This value may be less than <c>count</c> if the beginning or end of content is encountered before the specified number of lines are skipped. This parameter is passed uninitialized.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of a line that is specified relative to the current <see cref="T:System.Windows.Documents.TextPointer" />, and reports how many lines were skipped.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> pointing to the beginning of the specified line (with the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> set to <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), or to the beginning of the line closest to the specified line if the specified line is out of range.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Documents.TextPointer> verweist auf eine nicht eindeutige Position, z. B. zwischen zwei Zeilen, die Zeile in die Richtung, die gemäß der <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> -Eigenschaft, die als relative Anfangszeile ausgewählt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next symbol.</param>
        <summary>Returns a pointer to the next symbol in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the next symbol in the requested direction, or <see langword="null" /> if the current <see cref="T:System.Windows.Documents.TextPointer" /> borders the start or end of content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine der folgenden gilt ein Symbol:  
  
-   Eine öffnende oder schließende Tag für eine <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein <xref:System.Windows.UIElement> in enthaltenen Elementen ein <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
-   Eine 16-Bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
 Wenn das nächste Symbol als kategorisiert wird <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, oder <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (, das durch die <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode), und klicken Sie dann die <xref:System.Windows.Documents.TextPointer> zurückgegebene Methode wird von genau ein Symbol aus der aktuellen Position verschoben.  
  
 Wenn das nächste Symbol als kategorisiert wird <xref:System.Windows.Documents.TextPointerContext.Text>, die <xref:System.Windows.Documents.TextPointer> zurückgegebene Methode direkt hinter dem Text erweitert ist, auf das nächste nicht-Text-Symbol (d. h. die nächste position, an die <xref:System.Windows.Documents.TextPointerContext> ist nicht <xref:System.Windows.Documents.TextPointerContext.Text>).  Die genaue Anzahl kann im Voraus berechnet werden, durch den Aufruf der <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode.  Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> -Methode in Verbindung mit der <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode durchlaufen und extrahiert die Symbole in einem angegebenen <xref:System.Windows.Documents.TextElement>.  
  
 Während das Beispiel verwendet werden kann, um zu extrahieren eine [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Struktur für den Inhalt einer angegebenen <xref:System.Windows.Documents.TextElement>, er dient nur zur Veranschaulichung und sollte nicht im Produktionscode verwendet werden.  Finden Sie unter den <xref:System.Xml> Namespace-URI für einen umfangreichen Satz von Typen, die zum Arbeiten mit und die XML-Verarbeitung entworfen wurden.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to search for the next insertion position.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the next insertion position in the specified logical direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> that identifies the next insertion position in the requested direction, or <see langword="null" /> if no next insertion position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *Einfügeposition* ist eine Position, in denen möglicherweise neue Inhalte hinzugefügt werden, ohne alle semantischen Regeln für den zugeordneten Inhalt.  In der Praxis ist eine Einfügeposition überall im Inhalt, in denen eine Einfügemarke positioniert werden kann.  Ein Beispiel einer gültigen <xref:System.Windows.Documents.TextPointer> Position, die keine Einfügeposition ist die Position zwischen zwei angrenzende <xref:System.Windows.Documents.Paragraph> Tags (d. h. zwischen dem schließenden Tag des vorherigen Abschnitt und das öffnende Tag des nächsten Absatz).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> Methode, um die Grenzen der Content-Element zu durchlaufen, um die Anzahl der zählen <xref:System.Windows.Documents.Paragraph> Elemente vorhanden, zwischen zwei angegebenen <xref:System.Windows.Documents.TextPointer> Instanzen.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to find the distance (in symbols) to.</param>
        <summary>Returns the count of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and a second specified <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>The relative number of symbols between the current <see cref="T:System.Windows.Documents.TextPointer" /> and <paramref name="position" />.  A negative value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> follows the position specified by <paramref name="position" />, 0 indicates that the positions are equal, and a positive value indicates that the current <see cref="T:System.Windows.Documents.TextPointer" /> precedes the position specified by <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine der folgenden gilt ein Symbol:  
  
-   Eine öffnende oder schließende Tag für eine <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein <xref:System.Windows.UIElement> in enthaltenen Elementen ein <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
-   Eine 16-Bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> Methode, um die Offsets für zwei ermitteln <xref:System.Windows.Documents.TextPointer> Instanzen und verwendet dann diese Informationen speichern und Wiederherstellen der Auswahl in einem <xref:System.Windows.Controls.RichTextBox>.  Im Beispiel wird vorausgesetzt, die den Inhalt der <xref:System.Windows.Controls.RichTextBox> nicht zwischen einem speichern und ein Wiederherstellen der Auswahl geändert haben.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifies a position outside of the text container associated with the current position.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to determine the category for adjacent content.</param>
        <summary>Returns a category indicator for the content adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>One of the <see cref="T:System.Windows.Documents.TextPointerContext" /> values that indicates the category for adjacent content in the specified logical direction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode zum Implementieren eines Algorithmus zum Berechnen des Saldo mit öffnenden und schließenden Elementtags zwischen zwei angegebenen <xref:System.Windows.Documents.TextPointer> Positionen.  Jeder öffnenden Element zählt als + 1, und jeder endkennung für Element zählt als – 1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of content.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the position is calculated in the logical direction opposite of that indicated by the <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> property.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if no corresponding position can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine der folgenden gilt ein Symbol:  
  
-   Eine öffnende oder schließende Tag für die <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein <xref:System.Windows.UIElement> in enthaltenen Elementen ein <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
-   Eine 16-Bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methode zum Implementieren von ein Paar von Methoden, eine Methodenpaar an eine angegebene Position relativ zum jedem hosting Absatz ist, und die andere zum Zurückgeben einer <xref:System.Windows.Documents.TextPointer> zu einem angegebenen Offset in einem angegebenen Absatz.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">An offset, in symbols, for which to calculate and return the position.  If the offset is negative, the returned <see cref="T:System.Windows.Documents.TextPointer" /> precedes the current <see cref="T:System.Windows.Documents.TextPointer" />; otherwise, it follows.</param>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction of the returned <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, in symbols, from the beginning of the current <see cref="T:System.Windows.Documents.TextPointer" /> and in the specified direction.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the position indicated by the specified offset, or <see langword="null" /> if the offset extends past the end of the content.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine der folgenden gilt ein Symbol:  
  
-   Eine öffnende oder schließende Tag für die <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein <xref:System.Windows.UIElement> in enthaltenen Elementen ein <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
-   Eine 16-Bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and return any adjacent text.</param>
        <summary>Returns a string containing any text adjacent to the current <see cref="T:System.Windows.Documents.TextPointer" /> in the specified logical direction.</summary>
        <returns>A string containing any adjacent text in the specified logical direction, or <see cref="F:System.String.Empty" /> if no adjacent text can be found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur ohne Unterbrechung ausgeführt wird, von Text.  Wenn Sie einen Typ als symbol wird nichts zurückgegeben <xref:System.Windows.Documents.TextPointerContext.Text> wird neben dem aktuellen <xref:System.Windows.Documents.TextPointer> in der angegebenen Richtung.  Auf ähnliche Weise wird der Text nur bis zur nächsten nicht-Text-Symbol zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> Methode zum Implementieren einer einfachen Text extrahieren.  Die-Methode gibt eine zeichenfolgenverkettung aus dem gesamten Text zwischen zwei angegebenen <xref:System.Windows.Documents.TextPointer> Instanzen.  
  
 Während das Beispiel kann, zum Extrahieren von Text zwischen zwei verwendet werden <xref:System.Windows.Documents.TextPointer> Instanzen, er dient nur zur Veranschaulichung und sollte nicht im Produktionscode verwendet werden.  Verwenden Sie stattdessen die <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to find and copy any adjacent text.</param>
        <param name="textBuffer">A buffer into which any text is copied.</param>
        <param name="startIndex">An index into <c>textBuffer</c> at which to begin writing copied text.</param>
        <param name="count">The maximum number of characters to copy.</param>
        <summary>Copies the specified maximum number of characters from any adjacent text in the specified direction into a caller-supplied character array.</summary>
        <returns>The number of characters actually copied into <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur ohne Unterbrechung ausgeführt wird, von Text.  Wenn Sie einen Typ als symbol wird nichts zurückgegeben <xref:System.Windows.Documents.TextPointerContext.Text> wird neben dem aktuellen <xref:System.Windows.Documents.TextPointer> in der angegebenen Richtung.  Auf ähnliche Weise wird der Text nur bis zur nächsten nicht-Text-Symbol zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> is less than 0 or greater than the <see cref="P:System.Array.Length" /> property of <paramref name="textBuffer" />.  -or-  <paramref name="count" /> is less than 0 or greater than the remaining space in <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">One of the <see cref="T:System.Windows.Documents.LogicalDirection" /> values that specifies the logical direction in which to count the number of characters.</param>
        <summary>Returns the number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol, in the specified logical direction.</summary>
        <returns>The number of Unicode characters between the current <see cref="T:System.Windows.Documents.TextPointer" /> and the next non-text symbol.  This number may be 0 if there is no adjacent text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine der folgenden gilt ein Symbol:  
  
-   Eine öffnende oder schließende Tag für die <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein <xref:System.Windows.UIElement> in enthaltenen Elementen ein <xref:System.Windows.Documents.InlineUIContainer> oder <xref:System.Windows.Documents.BlockUIContainer>.  Beachten Sie, dass solche eine <xref:System.Windows.UIElement> immer zählt als genau ein Symbol, eine zusätzliche Inhalts- oder die Elemente der <xref:System.Windows.UIElement> werden als Symbole nicht gezählt.  
  
-   Eine 16-Bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] -Zeichen in einem <xref:System.Windows.Documents.Run> Element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the text container associated with the current position has a valid (up-to-date) layout.</summary>
        <value>
          <see langword="true" /> Wenn das Layout aktuell und gültig ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Bedarf Vorgänge, die eine gültige Datenträgerlayout abhängig sind (z. B. die <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> -Methode, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> -Methode und <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> Eigenschaft) versuchen, ein gültiges Layout vor dem Fortsetzen des Vorgangs automatisch neu zu generieren.  Ein Layout wird erneut generiert, kann ein relativ teurer Vorgang sein.  Verwenden Sie diese Eigenschaft, um ein gültiges Layout vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.  Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a line break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> positioned immediately after the <see cref="T:System.Windows.Documents.LineBreak" /> element inserted by this method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserts a paragraph break at the current position.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) of the new paragraph.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode aufgerufen wird, wenn die aktuelle Position innerhalb einer vorhandenen <xref:System.Windows.Documents.Paragraph> -Element, dem vorhandenen Absatz und alle Inhalte, die es enthält in beiden Absätze tauschen, an der aktuellen Position aufgeteilt sind.  Wenn diese Methode aufgerufen wird, wenn die aktuelle Position nicht in einem vorhandenen Absatz ist, wird eine neue, leere Absatzes eingefügt.  Wenn diese Methode an der Position für das Aufteilen oder Einfügen von Absätzen ungeeignet aufgerufen wird (z. B., wenn die aktuelle Position innerhalb des ist eine <xref:System.Windows.Documents.Hyperlink> Element), wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This method is called on a position that cannot be split to accommodate a new paragraph, such as in the scope of a <see cref="T:System.Windows.Documents.Hyperlink" /> or <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">The text to insert.</param>
        <summary>Inserts the specified text into the text <see cref="T:System.Windows.Documents.Run" /> at the current position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Documents.TextPointer> bezieht sich nicht von einem <xref:System.Windows.Documents.Run> -Element, eine <xref:System.Windows.Documents.Run> eingefügt wird, zusammen mit der `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The current position is not within a <see cref="T:System.Windows.Documents.Run" /> element.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is an insertion position.</summary>
        <value>
          <see langword="true" /> Wenn die aktuelle Position eine Einfügeposition ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Einfügeposition ist eine Position, in denen neuer Inhalte hinzugefügt werden kann, ohne alle semantischen Regeln für den zugeordneten Inhalt, an.  In der Praxis ist eine Einfügeposition überall im Inhalt, in denen eine Einfügemarke positioniert werden kann.  Ein Beispiel einer gültigen <xref:System.Windows.Documents.TextPointer> Position, die keine Einfügeposition ist die Position zwischen zwei angrenzende <xref:System.Windows.Documents.Paragraph> Tags (d. h. zwischen dem schließenden Tag des vorherigen Abschnitt und das öffnende Tag des nächsten Absatz).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current position is at the beginning of a line.</summary>
        <value>
          <see langword="true" /> Wenn die aktuelle Position am Anfang einer Zeile befindet; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Documents.TextPointer> verweist auf eine nicht eindeutige Position, z. B. zwischen zwei Zeilen, die Zeile in die Richtung, die gemäß der <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> -Eigenschaft, die als relative Anfangszeile ausgewählt ist.  
  
 Der Vorgang, der von dieser Eigenschaft hängt von einem gültigen Layout ab.  Bei Bedarf, versucht diese Methode, um ein gültiges Layout vor dem Fortsetzen des Vorgangs automatisch erneut zu generieren.  Ein Layout wird erneut generiert, kann ein relativ teurer Vorgang sein.  Verwenden der <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Eigenschaft, um ein gültiges Layout vor dem Ausführen von Vorgängen, die das Layout erneut generiert werden können.  Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">A <see cref="T:System.Windows.Documents.TextPointer" /> that specifies a position to compare to the current position.</param>
        <summary>Indicates whether the specified position is in the same text container as the current position.</summary>
        <returns>
          <see langword="true" /> if <paramref name="textPosition" /> indicates a position that is in the same text container as the current position; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten Operationen mit mehreren <xref:System.Windows.Documents.TextPointer> Instanzen sind nur gültig, wenn die betreffenden Instanzen Positionen angegeben werden, die sich im gleichen Textcontainerbereich befinden.  Zum Beispiel die <xref:System.Windows.Documents.TextPointer.CompareTo%2A> und <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> Methoden können nicht verwendet werden, mit einer <xref:System.Windows.Documents.TextPointer> an eine Position außerhalb der aktuellen Position zugeordneten Textcontainer.  Verwenden Sie diese Methode zum Überprüfen, ob ein angegebenes <xref:System.Windows.Documents.TextPointer> ist kompatibel mit der aktuellen Position für Vorgänge dieser Art.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Szenario für diese Methode.  Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> Methode, um zu überprüfen, ob ein angegebener <xref:System.Windows.Documents.TextPointer> befindet sich zwischen zwei anderen angegebenen <xref:System.Windows.Documents.TextPointer> -Instanzen in einer Situation, es gibt keine Garantie, dass alle drei Positionen zum gleichen Textcontainer gehören.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical direction associated with the current position which is used to disambiguate content associated with the current position.</summary>
        <value>Die <see cref="T:System.Windows.Documents.LogicalDirection" /> -Wert, der die aktuelle Position zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als Beispiel dafür, wie diese Eigenschaft verwendet wird die <xref:System.Windows.Documents.LogicalDirection> von der <xref:System.Windows.Documents.TextPointer> zurückgegeben, von einem Treffertest-Methode gibt einen Treffer zwischen zwei Zeichen des Texts. Die logische Richtung angegeben, welche der beiden Zeichen tatsächlich erreicht wurde, links oder rechts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the paragraph that scopes the current position, if any.</summary>
        <value>Die <see cref="T:System.Windows.Documents.Paragraph" /> platziert die aktuelle Position oder <see langword="null" /> Wenn kein entsprechender Absatz vorhanden ist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the logical parent that scopes the current position.</summary>
        <value>Das logische übergeordnete Element, das die aktuelle Position festgelegt wird.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This type or member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <returns>The string that represents the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>