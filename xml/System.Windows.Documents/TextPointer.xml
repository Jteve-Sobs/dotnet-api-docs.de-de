<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bdd4b36d2c90eebad620705886b1c30d54b07ca4" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86711219" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Position in einem <see cref="T:System.Windows.Documents.FlowDocument" /> oder <see cref="T:System.Windows.Controls.TextBlock" /> dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der- <xref:System.Windows.Documents.TextPointer> Klasse wird die folgende Terminologie eingeführt:  
  
-   Position: ein <xref:System.Windows.Documents.TextPointer> zeigt immer auf eine *Position* im Inhalt.  Diese Positionen liegen entweder zwischen Zeichen im Inhalt oder zwischen fortlaufenden Inhalts Element-Tags, die die Struktur für den Inhalt definieren.  
  
-   Aktuelle Position-da ein-Wert <xref:System.Windows.Documents.TextPointer> immer eine Position angibt und viele der Vorgänge, die über einen ausgeführt werden können, <xref:System.Windows.Documents.TextPointer> relativ zu der Position sind, auf die derzeit von verwiesen wird <xref:System.Windows.Documents.TextPointer> , ist es sinnvoll, einfach auf die Position zu verweisen, die von einer <xref:System.Windows.Documents.TextPointer> als *aktuelle Position*angegeben wird.  
  
-   Einfügeposition: eine *Einfügeposition* ist eine Position, an der neuer Inhalt hinzugefügt werden kann, ohne dass alle semantischen Regeln für den zugeordneten Inhalt  In der Praxis befindet sich eine Einfügemarke an einer beliebigen Stelle im Inhalt, an der ein Caretzeichen positioniert werden  Ein Beispiel für eine gültige <xref:System.Windows.Documents.TextPointer> Position, bei der es sich nicht um eine Einfügeposition handelt, ist die Position zwischen zwei angrenzenden Tags (d. h. <xref:System.Windows.Documents.Paragraph> zwischen dem schließenden Tag des vorangehenden Absatzes und dem öffnenden Tag des nächsten Absatzes).  
  
-   Symbol <xref:System.Windows.Documents.TextPointer> : bei Vorgängen, die Symbole einschließen, gilt Folgendes als *Symbol*:  
  
    -   Ein öffnendes oder Schließ Endes Tag für ein- <xref:System.Windows.Documents.TextElement> Element.  
  
    -   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
    -   Jedes 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
-   Text Container: ein *Text Container* ist das Element, das den endgültigen Rahmen für den Flow-Inhalt bildet. die von einem gekennzeichnete Position <xref:System.Windows.Documents.TextPointer> liegt immer innerhalb eines Text Containers.  Derzeit muss ein Text Container entweder ein <xref:System.Windows.Documents.FlowDocument> oder ein sein <xref:System.Windows.Controls.TextBlock> .  Im Allgemeinen werden Vorgänge zwischen <xref:System.Windows.Documents.TextPointer> Instanzen in unterschiedlichen Text Containern nicht unterstützt.  
  
-   Document: der Inhalt in einem Text Container wird als *Dokument*bezeichnet, wie in der- <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> Methode und den <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> -und- <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> Eigenschaften.  
  
 Die-Klasse soll das Traversieren <xref:System.Windows.Documents.TextPointer> und manipulieren von Inhalten erleichtern, die durch fortlaufende [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Inhaltselemente dargestellt werden. im Allgemeinen werden solche Elemente von abgeleitet <xref:System.Windows.Documents.TextElement> .  Zu den Vorgängen, die von vereinfacht werden, <xref:System.Windows.Documents.TextPointer> zählen die folgenden:  
  
-   Führt einen Ordinalvergleich der aktuellen Position mit einer zweiten angegebenen Position aus.  Siehe die- <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Methode.  
  
-   Bestimmen Sie den Inhaltstyp, der an der aktuellen Position in einer angegebenen Richtung angrenzt.  Siehe die <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> -Methode und- <xref:System.Windows.Documents.TextPointerContext> Enumeration.  
  
-   Dient zum Beziehen der <xref:System.Windows.Documents.TextElement> Bereiche oder der aktuellen Position.  Siehe <xref:System.Windows.Documents.Paragraph> und die- <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> Methode.  
  
-   Den Text Container zum Gültigkeitsbereich des aktuellen Dokuments.  Weitere Informationen finden Sie unter der <xref:System.Windows.Documents.TextPointer.Parent%2A>-Eigenschaft.  
  
-   Gibt eine angegebene Anzahl von Zeichen an, die der aktuellen Position vorangestellt oder folgt.  Siehe die- <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> Methode.  
  
-   Fügt eine Zeichenfolge an der aktuellen Position ein.  Siehe die- <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> Methode.  
  
-   Zeilen Grenzen im Inhalt suchen.  Siehe die <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> -Methode und die- <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> Eigenschaft.  
  
-   Übersetzt zwischen <xref:System.Windows.Documents.TextPointer> Positionen und Symbol Offsets in den Inhalt.  Siehe die <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methoden und.  
  
-   Ausführen von visuellen Treffer Tests durch übersetzen zwischen einer <xref:System.Windows.Documents.TextPointer> Position und einem, das <xref:System.Windows.Point> relative Koordinaten darstellt.  
  
-   Sucht eine Einfügeposition in der Nähe oder überprüft, ob die aktuelle Position eine Einfügeposition ist.  Siehe die <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> Methoden und und die- <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> Eigenschaft.  
  
 Die Position, die <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> von einem-Objekt angegeben wird, <xref:System.Windows.Documents.TextPointer> ist unveränderlich.  Wenn der Inhalt bearbeitet oder geändert wird, ändert sich die von einem angegebener Position <xref:System.Windows.Documents.TextPointer> nicht relativ zum umgebenden Text; stattdessen wird der Offset dieser Position vom Anfang des Inhalts entsprechend angepasst, um die neue relative Position im Inhalt widerzuspiegeln.  Beispielsweise zeigt ein- <xref:System.Windows.Documents.TextPointer> Wert, der eine Position am Anfang eines bestimmten Absatzes angibt, weiterhin auf den Anfang dieses Absatzes, auch wenn Inhalt vor oder nach dem Absatz eingefügt oder gelöscht wird.  
  
 Die-Klasse stellt keine <xref:System.Windows.Documents.TextPointer> öffentlichen Konstruktoren bereit.  Eine Instanz von <xref:System.Windows.Documents.TextPointer> wird mithilfe von Eigenschaften oder Methoden anderer Objekte (einschließlich anderer <xref:System.Windows.Documents.TextPointer> Objekte) erstellt. Die folgende Liste enthält einige Beispiele für Methoden und Eigenschaften, mit denen ein erstellt und zurückgegeben wird <xref:System.Windows.Documents.TextPointer> .  Diese Liste ist nicht vollständig:  
  
-   Aus einem <xref:System.Windows.Documents.TextRange> : <xref:System.Windows.Documents.TextRange.Start%2A> und <xref:System.Windows.Documents.TextRange.End%2A> .  
  
-   Von einem <xref:System.Windows.Documents.TextElement> :  <xref:System.Windows.Documents.TextElement.ContentStart%2A> , <xref:System.Windows.Documents.TextElement.ContentEnd%2A> , <xref:System.Windows.Documents.TextElement.ElementStart%2A> und <xref:System.Windows.Documents.TextElement.ElementEnd%2A> .  
  
-   Aus einem <xref:System.Windows.Controls.TextBlock> (Text Container): <xref:System.Windows.Controls.TextBlock.ContentStart%2A> , <xref:System.Windows.Controls.TextBlock.ContentEnd%2A> und <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A> .  
  
-   Aus einem <xref:System.Windows.Documents.FlowDocument> (Text Container): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A> , und <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Aus einer vorhandenen <xref:System.Windows.Documents.TextPointer> : <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> , <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> , <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> und <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mit einem eine <xref:System.Windows.Documents.TextPointer> Position direkt innerhalb des ersten <xref:System.Windows.Documents.Run> Elements in einem angegebenen Text Container finden.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Im folgenden Beispiel wird ein einfacher Suchalgorithmus mithilfe von-Funktionen implementiert <xref:System.Windows.Documents.TextPointer> .  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position angibt, die mit der aktuellen Position verglichen werden soll.</param>
        <summary>Führt einen Ordinalvergleich der angegebenen Positionen des aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> und eines anderen <see cref="T:System.Windows.Documents.TextPointer" /> aus.</summary>
        <returns>–1, wenn der aktuelle <see cref="T:System.Windows.Documents.TextPointer" /> vor der <paramref name="position" /> liegt; 0, wenn die Positionen identisch sind; +1, wenn der aktuelle <see cref="T:System.Windows.Documents.TextPointer" /> nach der <paramref name="position" /> liegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert-1 gibt an, dass die vom aktuellen angegebene Position vor <xref:System.Windows.Documents.TextPointer> der durch angegebenen Position liegt `position` .  Der Wert 0 gibt an, dass die genannten Positionen gleich sind.  Der Wert "positiv + 1" gibt an, dass die vom aktuellen angegebene Position <xref:System.Windows.Documents.TextPointer> der durch angegebenen Position folgt `position` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht.  Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.CompareTo%2A> Methode in Verbindung mit der- <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> Methode verwendet, um zu testen, ob ein angegebenes <xref:System.Windows.Documents.TextElement> leer ist.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> gibt eine Position an, die außerhalb des der aktuellen Position zugeordneten Textcontainers liegt.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Die Anzahl der zu löschenden Zeichen ab der aktuellen Position. Geben Sie einen positiven Wert an, um Zeichen nach der aktuellen Position zu löschen, bzw. einen negativen Wert, um Zeichen vor der aktuellen Position zu löschen.</param>
        <summary>Löscht die angegebene Anzahl von Zeichen ab der Position, die vom aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> angegeben wird.</summary>
        <returns>Die Anzahl der tatsächlich gelöschten Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie einen positiven Wert zum Löschen von Zeichen an, die der aktuellen Position folgen (wie in <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType> ). Geben Sie einen negativen Wert zum Löschen von Zeichen an, die der aktuellen Position vorangestellt sind (wie in <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType> ).  
  
 Die Anzahl der tatsächlich gelöschten Zeichen ist möglicherweise kleiner als die Zahl, die durch angegeben wird `count` .  Dies geschieht in Fällen, in denen `count` mehr Zeichen als vorhanden sind, die gelöscht werden sollen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Methode wurde an einer Position aufgerufen, an der Text nicht zulässig ist.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft im der aktuellen Position zugeordneten Textcontainer am Ende des Inhalts einen <see cref="T:System.Windows.Documents.TextPointer" /> ab.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" /> am Ende des Inhalts im der aktuellen Position zugeordneten Textcontainer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Documents.TextPointer.Parent%2A> für die zurückgegebene <xref:System.Windows.Documents.TextPointer> ist immer ein Text Container ( <xref:System.Windows.Controls.TextBlock> oder) und <xref:System.Windows.Documents.FlowDocument> nicht ein <xref:System.Windows.Documents.TextElement> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft im der aktuellen Position zugeordneten Textcontainer am Anfang des Inhalts einen <see cref="T:System.Windows.Documents.TextPointer" /> ab.</summary>
        <value>Ein <see cref="T:System.Windows.Documents.TextPointer" /> am Anfang des Inhalts im der aktuellen Position zugeordneten Textcontainer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die von dieser Eigenschaft zurückgegebene Position als Baselineversion, von der aus relative Offsets zu anderen Positionen verwendet werden.  Die <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> -Methode und die- <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methode bieten eine Möglichkeit, zwischen Positionen und Positions Offsets zu übersetzen.  
  
 Der <xref:System.Windows.Documents.TextPointer.Parent%2A> für die zurückgegebene <xref:System.Windows.Documents.TextPointer> ist immer ein Text Container ( <xref:System.Windows.Controls.TextBlock> oder) und <xref:System.Windows.Documents.FlowDocument> nicht ein <xref:System.Windows.Documents.TextElement> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach einem benachbarten Element erfolgen soll.</param>
        <summary>Gibt ggf. das Element zurück, das in der angegebenen logischen Richtung an den aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> grenzt.</summary>
        <returns>Das benachbarte Element in der angegebenen <paramref name="direction" /> oder <see langword="null" />, wenn kein benachbartes Element vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Element ist in der Regel ein <xref:System.Windows.Documents.TextElement> .  Eine <xref:System.Windows.UIElement> kann zurückgegeben werden, wenn das <xref:System.Windows.Documents.TextPointer> eine Position in einem- <xref:System.Windows.Documents.BlockUIContainer> Element oder einem- <xref:System.Windows.Documents.InlineUIContainer> Element angibt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach einem umgebenden Feld für Inhalt erfolgen soll.</param>
        <summary>Gibt ein umgebendes Feld (<see cref="T:System.Windows.Rect" />) für Inhalt zurück, der in der angegebenen logischen Richtung an den aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> grenzt.</summary>
        <returns>Ein umgebendes Feld für Inhalt, der in der angegebenen Richtung an den aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> grenzt, oder <see cref="P:System.Windows.Rect.Empty" />, wenn keine aktuellen und gültigen Layoutinformationen verfügbar sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> Kanten werden für diese Methode nicht als Inhalt betrachtet.  Wenn das- <xref:System.Windows.Documents.TextPointer> Feld vor einem <xref:System.Windows.Documents.TextElement> Rand positioniert ist, ist der Rückgabewert ein Begrenzungs Rahmen für den nächsten nicht- <xref:System.Windows.Documents.TextElement> Inhalt in der angegebenen Richtung.  Wenn kein Inhalt in der angegebenen Richtung vorhanden ist, wird eine Breite von 0 (null) <xref:System.Windows.Rect> zurückgegeben, wobei eine Höhe mit der Höhe eines vorangehenden Inhalts übereinstimmt.  
  
 Der von dieser Methode ausgeführte Vorgang hängt von einem gültigen Layout ab.  Bei Bedarf versucht diese Methode, ein gültiges Layout automatisch neu zu generieren, bevor der Vorgang fortgesetzt wird.  Das erneute Generieren eines Layouts kann ein relativ kostspieliger Vorgang sein.  Verwenden Sie die- <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Eigenschaft, um ein gültiges Layout zu suchen, bevor Sie Vorgänge ausführen, die das Layout möglicherweise erneut generieren  Weitere Informationen finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach der nächsten Einfügeposition erfolgen soll.</param>
        <summary>Gibt in der angegebenen logischen Richtung an der nächsten Einfügeposition einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" /> an der nächsten Einfügeposition in der angegebenen Richtung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Einfügeposition ist eine Position, an der neuer Inhalt hinzugefügt werden kann, ohne dass alle semantischen Regeln für den zugehörigen Inhalt unterbrochen werden  In der Praxis befindet sich eine Einfügemarke an einer beliebigen Stelle im Inhalt, an der ein Caretzeichen positioniert werden  Ein Beispiel für eine gültige <xref:System.Windows.Documents.TextPointer> Position, bei der es sich nicht um eine Einfügeposition handelt, ist die Position zwischen zwei angrenzenden Tags (d. h. <xref:System.Windows.Documents.Paragraph> zwischen dem schließenden Tag des vorangehenden Absatzes und dem öffnenden Tag des nächsten Absatzes).  
  
 Wenn der <xref:System.Windows.Documents.TextPointer> bereits auf eine gültige Einfügeposition zeigt, aber das Endtag für eine nicht leere Formatierungs Sequenz direkt an diese Position in der angegebenen Richtung folgt, <xref:System.Windows.Documents.TextPointer> wird der von dieser Methode zurückgegebene so angepasst, dass er auf die Einfügeposition unmittelbar nach dem Schließen der Formatierungs Sequenz zeigt. Sehen Sie sich beispielsweise die Markup Sequenz an `<Bold>a</Bold>b` . Beachten Sie, dass es zwei Einfügepositionen zwischen den Buchstaben `a` und `b` -eins gibt, das dem schließenden `Bold` Tag vorangestellt ist, und eines direkt nach dem schließenden `Bold` Tag. Wenn für <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> eine auf <xref:System.Windows.Documents.TextPointer> die Position direkt nach dem Buchstaben `a` und vor dem schließenden `Bold` Tag und mit einem von aufgerufen wird, `direction` <xref:System.Windows.Documents.LogicalDirection.Forward> wird die zurückgegebene <xref:System.Windows.Documents.TextPointer> so angepasst, dass Sie auf die Position unmittelbar vor dem Buchstaben hinter `b` dem schließenden Tag verweist `Bold` . Beim Arbeiten in umgekehrter logischer Richtung wird eine ähnliche Anpassung zum Öffnen von Formatierungs Tags vorgenommen. Diese Methode soll ein Mittel für die Mehrdeutigkeit zwischen Einfügepositionen in ähnlichen Fällen bereitstellen.  
  
 Diese Methode kann auch verwendet werden, um bei einfügepunkten selektiv zu sein, wenn eine Sequenz von strukturellen Tags beteiligt ist. Wenn z. b. an einer Position zwischen schließenden und öffnenden Absatz Tags verwendet wird, kann der Direction-Parameter verwendet werden, um am Anfang des folgenden Absatzes (durch Angabe von <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType> ) oder am Ende des vorangehenden Absatzes (durch Angabe von) den nächstgelegenen Einfügepunkt auszuwählen <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType> .  
  
 Wenn sich der Zeiger bereits an der Einfügemarke befindet und keine angrenzenden Formatierungs Tags in der angegebenen vorhanden sind `direction` , verweist der zurückgegebene <xref:System.Windows.Documents.TextPointer> auf dieselbe Position wie der aufrufende <xref:System.Windows.Documents.TextPointer> .  
  
 Es ist möglich, dass keine gültige Einfügeposition relativ zu der Position vorhanden ist, auf die von verwiesen wird <xref:System.Windows.Documents.TextPointer> .  Dies kann vorkommen, wenn der Inhalt, auf den verwiesen wird, strukturell unvollständig ist, wie in einer leeren Tabelle oder Liste.  In solchen Fällen gibt diese Methode einfach <xref:System.Windows.Documents.TextPointer> an dieselbe Position zurück wie die, <xref:System.Windows.Documents.TextPointer> von der aus diese Methode aufgerufen wurde.  Diese Methode gibt immer einen gültigen zurück <xref:System.Windows.Documents.TextPointer> .  
  
   
  
## Examples  
 In diesem Beispiel wird gezeigt, wie die- <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> Methode verwendet wird, um zu überprüfen, ob ein angegebener <xref:System.Windows.Documents.TextElement> Inhalt leer ist.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> angegeben wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Die Anzahl der zu überspringenden Zeilenanfangsmarker beim Festlegen der Zeile, deren Anfangsposition zurückgegeben werden soll. Mit negativen Werten werden vorangehende Zeilen angegeben, mit 0 die aktuelle Zeile, mit positiven Werten Folgezeilen.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> angegeben wird.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der auf den Anfang der angegebenen Zeile zeigt (wobei die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> auf <see cref="F:System.Windows.Documents.LogicalDirection.Forward" /> festgelegt ist); bzw. <see langword="null" />, wenn die angegebene Zeile außerhalb des Bereichs liegt oder anderweitig nicht gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Documents.TextPointer> auf eine mehrdeutige Position zeigt, z. b. zwischen zwei Zeilen, wird die Zeile in der durch angegebenen Richtung <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> als relative anfangs Linie ausgewählt.  
  
 Der von dieser Methode ausgeführte Vorgang hängt von einem gültigen Layout ab.  Bei Bedarf versucht diese Methode, ein gültiges Layout automatisch neu zu generieren, bevor der Vorgang fortgesetzt wird.  Das erneute Generieren eines Layouts kann ein relativ kostspieliger Vorgang sein.  Verwenden <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Sie, um ein gültiges Layout zu suchen, bevor Sie Vorgänge ausführen, die das Layout neu generieren können.  Weitere Informationen finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int * int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Die Anzahl der zu überspringenden Zeilenanfangsmarker beim Festlegen der Zeile, deren Anfangsposition zurückgegeben werden soll. Mit negativen Werten werden vorangehende Zeilen angegeben, mit 0 die aktuelle Zeile, mit positiven Werten Folgezeilen.</param>
        <param name="actualCount">Wenn diese Methode einen Rückgabewert erstellt, enthält dieser die tatsächliche Anzahl der Zeilenanfangsmarker, die beim Festlegen der Zeile übersprungen wurden, deren Anfangsposition zurückgegeben werden soll.  Dieser Wert kann kleiner als <paramref name="count" /> sein, wenn der Anfang oder das Ende des Inhalts erreicht ist, bevor die angegebene Anzahl von Zeilen übersprungen wurde. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf den Anfang einer Zeile zurück, die relativ zum aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> angegeben wird, und gibt an, wie viele Zeilen übersprungen wurden.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der auf den Anfang der angegebenen Zeile (wobei die <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> auf <see cref="F:System.Windows.Documents.LogicalDirection.Forward" /> festgelegt ist) oder auf den Anfang der Zeile zeigt, die der angegebenen Zeile am nächsten ist, wenn die angegebene Zeile außerhalb des Bereichs liegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Documents.TextPointer> auf eine mehrdeutige Position zeigt, z. b. zwischen zwei Zeilen, wird die Zeile in der durch die-Eigenschaft angegebenen Richtung <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> als relative anfangs Linie ausgewählt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach dem nächsten Symbol erfolgen soll.</param>
        <summary>Gibt einen Zeiger auf das nächste Symbol in der angegebenen logischen Richtung zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" /> auf das nächste Symbol in der angeforderten Richtung oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Windows.Documents.TextPointer" /> an den Anfang oder das Ende des Inhalts grenzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Folgendes gilt als Symbol:  
  
-   Ein öffnendes oder Schließ Endes Tag für ein- <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
-   Ein 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
 Wenn das nächste Symbol als, oder kategorisiert wird <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement> <xref:System.Windows.Documents.TextPointerContext.ElementStart> <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (wie durch die- <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode identifiziert), <xref:System.Windows.Documents.TextPointer> wird der von dieser Methode zurückgegebene von genau einem Symbol von der aktuellen Position aus erweitert.  
  
 Wenn das nächste Symbol als kategorisiert wird <xref:System.Windows.Documents.TextPointerContext.Text> , wird der, der <xref:System.Windows.Documents.TextPointer> von dieser Methode zurückgegeben wird, hinter dem Text bis zum nächsten nicht-Text-Symbol erweitert (d. h. die nächste Position, an der <xref:System.Windows.Documents.TextPointerContext> nicht ist <xref:System.Windows.Documents.TextPointerContext.Text> ).  Die genaue Symbol Anzahl, die überschritten wird, kann im Voraus durch Aufrufen der-Methode berechnet werden <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht.  Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> -Methode in Verbindung mit der- <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode verwendet, um die Symbole in einem angegebenen zu durchlaufen und zu extrahieren <xref:System.Windows.Documents.TextElement> .  
  
 Obwohl das Beispiel zum Extrahieren einer [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] Struktur für den Inhalt einer bestimmten verwendet werden kann <xref:System.Windows.Documents.TextElement> , ist es nur für die Veranschaulichung gedacht und sollte nicht im Produktionscode verwendet werden.  Weitere Informationen zum <xref:System.Xml> Arbeiten mit und Verarbeiten von XML finden Sie im-Namespace.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Suche nach der nächsten Einfügeposition erfolgen soll.</param>
        <summary>Gibt in der angegebenen logischen Richtung an der nächsten Einfügeposition einen <see cref="T:System.Windows.Documents.TextPointer" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, mit dem die nächste Einfügeposition in der angegebenen Richtung gekennzeichnet wird, oder <see langword="null" />, wenn keine nächste Einfügeposition gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine *Einfügeposition* ist eine Position, an der neuer Inhalt hinzugefügt werden kann, ohne dass alle semantischen Regeln für den zugehörigen Inhalt unterbrochen werden  In der Praxis befindet sich eine Einfügemarke an einer beliebigen Stelle im Inhalt, an der ein Caretzeichen positioniert werden  Ein Beispiel für eine gültige <xref:System.Windows.Documents.TextPointer> Position, bei der es sich nicht um eine Einfügeposition handelt, ist die Position zwischen zwei angrenzenden Tags (d. h. <xref:System.Windows.Documents.Paragraph> zwischen dem schließenden Tag des vorangehenden Absatzes und dem öffnenden Tag des nächsten Absatzes).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht. Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> Methode zum Durchlaufen von Inhalts Elementgrenzen verwendet, um die Anzahl der Elemente zu zählen, die <xref:System.Windows.Documents.Paragraph> zwischen zwei angegebenen-Instanzen vorhanden sind <xref:System.Windows.Documents.TextPointer> .  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Ein <see cref="T:System.Windows.Documents.TextPointer" />, mit dem eine Position angegeben wird, zu der die Entfernung (in Symbolen) bestimmt werden soll.</param>
        <summary>Gibt die Anzahl der Symbole zwischen dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> und einem weiteren bestimmten <see cref="T:System.Windows.Documents.TextPointer" /> zurück.</summary>
        <returns>Die relative Anzahl von Symbolen zwischen dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> und der <paramref name="position" />.  Mit einem negativen Wert wird angegeben, dass sich der aktuelle <see cref="T:System.Windows.Documents.TextPointer" /> hinter der durch <paramref name="position" /> angegebenen Position befindet; 0 gibt an, dass die Positionen identisch sind; und mit einem positiven Wert wird angegeben, dass sich der aktuelle <see cref="T:System.Windows.Documents.TextPointer" /> vor der durch <paramref name="position" /> angegebenen Position befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Folgendes gilt als Symbol:  
  
-   Ein öffnendes oder Schließ Endes Tag für ein- <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
-   Ein 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht. Im Beispiel wird die <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> -Methode verwendet, um die Offsets für zwei <xref:System.Windows.Documents.TextPointer> -Instanzen zu suchen. Anschließend werden diese Informationen verwendet, um die Auswahl in einem zu speichern und wiederherzustellen <xref:System.Windows.Controls.RichTextBox> .  Im Beispiel wird davon ausgegangen, dass sich der Inhalt von <xref:System.Windows.Controls.RichTextBox> zwischen dem Speichern einer Auswahl und dem Wiederherstellen einer Auswahl nicht geändert hat.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> gibt eine Position an, die außerhalb des der aktuellen Position zugeordneten Textcontainers liegt.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der die Kategorie für den benachbarten Inhalt bestimmt wird.</param>
        <summary>Gibt für den Inhalt neben dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> in der angegebenen logischen Richtung einen Kategorieindikator zurück.</summary>
        <returns>Einer der <see cref="T:System.Windows.Documents.TextPointerContext" />-Werte, mit denen die Kategorie für benachbarten Inhalt in der angegebenen logischen Richtung angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht. Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> Methode verwendet, um einen Algorithmus zum Berechnen des Ausgleichs von öffnenden und schließenden Element Tags zwischen zwei angegebenen Positionen zu implementieren <xref:System.Windows.Documents.TextPointer> .  Jedes öffnende Elementtag wird als + 1 gezählt, und jedes schließende Elementtag wird als-1 gezählt.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf die Position zurück, die in Symbolen durch den ab dem Anfang des Inhalts bestimmten Offset angegeben wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Ein Offset in Symbolen, für den die Position berechnet und zurückgegeben werden soll.  Wenn der Offset negativ ist, wird die Position in der logischen Richtung berechnet, die der mit der <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />-Eigenschaft angegebenen Richtung entgegengesetzt ist.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf die Position zurück, die in Symbolen durch den ab dem Anfang des aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> bestimmten Offset angegeben wird.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" /> auf die Position, die von dem bestimmten Offset angegeben wird, oder <see langword="null" />, wenn keine entsprechende Position gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Folgendes gilt als Symbol:  
  
-   Ein öffnendes oder Schließ Endes Tag für das <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
-   Ein 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht. Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> Methode verwendet, um ein Methoden paar zu implementieren, eines zum Berechnen des Offsets an eine angegebene Position in Relation zu einem beliebigen hostingabsatz und das andere, um einen <xref:System.Windows.Documents.TextPointer> an einen angegebenen Offset in einem angegebenen Absatz zurückzugeben.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Ein Offset in Symbolen, für den die Position berechnet und zurückgegeben werden soll.  Wenn der Offset negativ ist, steht der zurückgegebene <see cref="T:System.Windows.Documents.TextPointer" /> vor dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" />, andernfalls danach.</param>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung des zurückgegebenen <see cref="T:System.Windows.Documents.TextPointer" /> angegeben wird.</param>
        <summary>Gibt einen <see cref="T:System.Windows.Documents.TextPointer" /> auf die Position zurück, die in Symbolen durch den ab dem Anfang des aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> bestimmten Offset und in der angegebenen Richtung angegeben wird.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" /> auf die Position, die durch den bestimmten Offset angegeben wird, oder <see langword="null" />, wenn sich der Offset über das Ende des Inhalts hinaus erstreckt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Folgendes gilt als Symbol:  
  
-   Ein öffnendes oder Schließ Endes Tag für das <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
-   Ein 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Text zurück, der sich neben dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> befindet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der benachbarter Text gesucht und zurückgegeben werden soll.</param>
        <summary>Gibt eine Zeichenfolge zurück, die Text enthält, der sich in der angegebenen logischen Richtung neben dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> befindet.</summary>
        <returns>Eine Zeichenfolge, die beliebigen benachbarten Text in der angegebenen logischen Richtung enthält, oder <see cref="F:System.String.Empty" />, wenn kein benachbarter Text gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur ununterbrochene Ausführungen von Text zurück.  Es wird nichts zurückgegeben, wenn ein anderer Symboltyp als <xref:System.Windows.Documents.TextPointerContext.Text> an den aktuellen <xref:System.Windows.Documents.TextPointer> in der angegebenen Richtung grenzt.  Auf ähnliche Weise wird Text nur bis zum nächsten nicht-Text-Symbol zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht. Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> Methode verwendet, um einen einfachen textextraktor zu implementieren.  Die-Methode gibt eine Zeichen folgen Verkettung für den gesamten Text zwischen zwei angegebenen- <xref:System.Windows.Documents.TextPointer> Instanzen zurück.  
  
 Obwohl das Beispiel zum Extrahieren von Text zwischen zwei-Instanzen verwendet werden kann <xref:System.Windows.Documents.TextPointer> , ist es nur zu Veranschaulichung gedacht und sollte nicht im Produktionscode verwendet werden.  Verwenden Sie stattdessen die <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung angegeben wird, in der benachbarter Text gesucht und kopiert werden soll.</param>
        <param name="textBuffer">Ein Puffer, in den beliebiger Text kopiert wird.</param>
        <param name="startIndex">Ein Index im <paramref name="textBuffer" />, ab dem mit dem Schreiben von kopiertem Text begonnen wird.</param>
        <param name="count">Die maximale Anzahl der zu kopierenden Zeichen.</param>
        <summary>Kopiert die angegebene maximale Anzahl von Zeichen aus benachbartem Text in der angegebenen Richtung in ein vom Aufrufer bereitgestelltes Zeichenarray.</summary>
        <returns>Die Anzahl der tatsächlich in den <paramref name="textBuffer" /> kopierten Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nur ununterbrochene Ausführungen von Text zurück.  Es wird nichts zurückgegeben, wenn ein anderer Symboltyp als <xref:System.Windows.Documents.TextPointerContext.Text> an den aktuellen <xref:System.Windows.Documents.TextPointer> in der angegebenen Richtung grenzt.  Auf ähnliche Weise wird Text nur bis zum nächsten nicht-Text-Symbol zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" /> ist kleiner als 0 oder größer als die <see cref="P:System.Array.Length" />-Eigenschaft von <paramref name="textBuffer" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0 oder größer als der verbleibende Raum im <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> minus<paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der <see cref="T:System.Windows.Documents.LogicalDirection" />-Werte, mit denen die logische Richtung für das Zählen der Zeichenanzahl angegeben wird.</param>
        <summary>Gibt in der angegebenen logischen Richtung die Anzahl der Unicode-Zeichen zwischen dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> und dem nächsten Nicht-Text-Symbol zurück.</summary>
        <returns>Die Anzahl der Unicode-Zeichen zwischen dem aktuellen <see cref="T:System.Windows.Documents.TextPointer" /> und dem nächsten Nicht-Text-Symbol.  Diese Zahl kann 0 sein, wenn kein benachbarter Text vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Folgendes gilt als Symbol:  
  
-   Ein öffnendes oder Schließ Endes Tag für das <xref:System.Windows.Documents.TextElement> Element.  
  
-   Ein-Element, das <xref:System.Windows.UIElement> in einem oder einem enthalten ist <xref:System.Windows.Documents.InlineUIContainer> <xref:System.Windows.Documents.BlockUIContainer> .  Beachten Sie, dass ein solcher Wert <xref:System.Windows.UIElement> immer als genau ein Symbol gezählt wird; alle zusätzlichen Inhalte oder Elemente, die in der enthalten <xref:System.Windows.UIElement> sind, werden nicht als Symbole gezählt.  
  
-   Ein 16-Bit- [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] Zeichen in einem Text <xref:System.Windows.Documents.Run> Element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob der der aktuellen Position zugeordnete Textcontainer über ein gültiges (aktuelles) Layout verfügt.</summary>
        <value><see langword="true" />, wenn das Layout aktuell und gültig ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Bedarf versuchen Vorgänge, die von einem gültigen Layout (z. b. der <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> Methode, der <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> Methode und der <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> Eigenschaft) abhängen, automatisch ein gültiges Layout erneut zu generieren, bevor Sie den Vorgang fortsetzen.  Das erneute Generieren eines Layouts kann ein relativ kostspieliger Vorgang sein.  Verwenden Sie diese Eigenschaft, um vor der Durchführung von Vorgängen, die das Layout neu generieren können, nach einem gültigen Layout  Weitere Informationen finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt an der aktuellen Position einen Zeilenumbruch ein.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" />, der unmittelbar nach dem von dieser Methode eingefügten <see cref="T:System.Windows.Documents.LineBreak" />-Element positioniert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt an der aktuellen Position einen Absatzwechsel ein.</summary>
        <returns>Ein <see cref="T:System.Windows.Documents.TextPointer" /> auf den Anfang (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) des neuen Absatzes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode aufgerufen wird, wenn sich die aktuelle Position innerhalb eines vorhandenen <xref:System.Windows.Documents.Paragraph> Elements befindet, werden der vorhandene Absatz und der darin enthaltene Inhalt in zwei Absätze an der aktuellen Position aufgeteilt.  Wenn diese Methode aufgerufen wird, wenn die aktuelle Position nicht innerhalb eines vorhandenen Absatzes liegt, wird ein neuer, leerer Absatz eingefügt.  Wenn diese Methode an einer Position aufgerufen wird, die für das Aufteilen oder Einfügen eines Absatzes ungeeignet ist (z. b. wenn sich die aktuelle Position in einem- <xref:System.Windows.Documents.Hyperlink> Element befindet), wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird an einer Position aufgerufen, an der keine Aufteilung für das Einfügen eines neuen Absatzes erfolgen kann, z. B. im Bereich eines <see cref="T:System.Windows.Documents.Hyperlink" /> oder eines <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Der einzufügende Text.</param>
        <summary>Fügt den angegebenen Text an der aktuellen Position in den <see cref="T:System.Windows.Documents.Run" /> des Texts ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der <xref:System.Windows.Documents.TextPointer> nicht durch ein-Element festgelegt ist <xref:System.Windows.Documents.Run> , <xref:System.Windows.Documents.Run> wird eine zusammen mit der eingefügt `textData` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle Position befindet sich nicht in einem <see cref="T:System.Windows.Documents.Run" />-Element.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="textData" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob die aktuelle Position eine Einfügeposition ist.</summary>
        <value><see langword="true" />, wenn die aktuelle Position eine Einfügeposition ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Einfügeposition ist eine Position, an der neuer Inhalt hinzugefügt werden kann, ohne dass alle semantischen Regeln für den zugehörigen Inhalt unterbrochen werden  In der Praxis befindet sich eine Einfügemarke an einer beliebigen Stelle im Inhalt, an der ein Caretzeichen positioniert werden  Ein Beispiel für eine gültige <xref:System.Windows.Documents.TextPointer> Position, bei der es sich nicht um eine Einfügeposition handelt, ist die Position zwischen zwei angrenzenden Tags (d. h. <xref:System.Windows.Documents.Paragraph> zwischen dem schließenden Tag des vorangehenden Absatzes und dem öffnenden Tag des nächsten Absatzes).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob sich die aktuelle Position am Anfang einer Zeile befindet.</summary>
        <value><see langword="true" />, wenn sich die aktuelle Position am Anfang einer Zeile befindet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Documents.TextPointer> auf eine mehrdeutige Position zeigt, z. b. zwischen zwei Zeilen, wird die Zeile in der durch die-Eigenschaft angegebenen Richtung <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> als relative anfangs Linie ausgewählt.  
  
 Der von dieser Eigenschaft ausgeführte Vorgang hängt von einem gültigen Layout ab.  Bei Bedarf versucht diese Methode, ein gültiges Layout automatisch neu zu generieren, bevor der Vorgang fortgesetzt wird.  Das erneute Generieren eines Layouts kann ein relativ kostspieliger Vorgang sein.  Verwenden Sie die- <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> Eigenschaft, um ein gültiges Layout zu suchen, bevor Sie Vorgänge ausführen, die das Layout möglicherweise erneut generieren  Weitere Informationen finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Ein <see cref="T:System.Windows.Documents.TextPointer" />, der eine Position angibt, die mit der aktuellen Position verglichen werden soll.</param>
        <summary>Gibt an, ob sich die angegebene Position im gleichen Textcontainer wie die aktuelle Position befindet.</summary>
        <returns><see langword="true" />, wenn mit <paramref name="textPosition" /> eine Position angegeben wird, die sich im gleichen Textcontainer wie die aktuelle Position befindet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten Vorgänge, die mehrere Instanzen umfassen, <xref:System.Windows.Documents.TextPointer> sind nur gültig, wenn die fraglichen Instanzen Positionen angeben, die sich im gleichen Text Containerbereich befinden.  Beispielsweise <xref:System.Windows.Documents.TextPointer.CompareTo%2A> können die-Methode und die- <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> Methode nicht mit einem <xref:System.Windows.Documents.TextPointer> an eine Position außerhalb des Text Containers, der der aktuellen Position zugeordnet ist, verwendet werden.  Verwenden Sie diese Methode, um zu überprüfen, ob eine angegebene <xref:System.Windows.Documents.TextPointer> mit der aktuellen Position für solche Vorgänge kompatibel ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Verwendung für diese Methode veranschaulicht.  Im Beispiel wird die- <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> Methode verwendet, um zu überprüfen, ob ein angegebenes <xref:System.Windows.Documents.TextPointer> zwischen zwei anderen angegebenen-Instanzen positioniert ist <xref:System.Windows.Documents.TextPointer> , wenn keine Garantie besteht, dass alle drei Positionen zu demselben Text Container gehören.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="textPosition" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die der aktuellen Position zugeordnete logische Richtung ab, mit der der aktuellen Position zugeordneter Inhalt unterschieden werden kann.</summary>
        <value>Der <see cref="T:System.Windows.Documents.LogicalDirection" />-Wert, der der aktuellen Position zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als Beispiel für die Verwendung dieser Eigenschaft gibt der der von <xref:System.Windows.Documents.LogicalDirection> <xref:System.Windows.Documents.TextPointer> einer Treffer Testmethode zurückgegebenen einen Treffer zwischen zwei Textzeichen zurück. Die logische Richtung gibt an, welches der beiden Zeichen tatsächlich auf der linken oder rechten Seite gedrückt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Absatz ab, mit dem ggf. die aktuelle Position festgelegt wird.</summary>
        <value>Die <see cref="T:System.Windows.Documents.Paragraph" /> , die die aktuelle Position eingibt, oder, <see langword="null" /> Wenn kein solcher Absatz vorhanden ist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das logische übergeordnete Element ab, mit dem die aktuelle Position festgelegt wird.</summary>
        <value>Das logische übergeordnete Element, mit dem die aktuelle Position festgelegt wird.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Typ oder Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <returns>Die Zeichenfolge, die das Objekt darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
