<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="098f090025956013bb455121d70f70fe58204a7d" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70415456" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Die abstrakte Basis-Klasse, die die Eigenschaften und Methoden eines Sicherheitstokendiensts (STS) definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen eines STS müssen Sie von der <xref:System.IdentityModel.SecurityTokenService> -Klasse ableiten. In Ihrer benutzerdefinierten Klasse müssen Sie mindestens die-Methode und die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> - <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methode überschreiben. Mit diesen über schreibungen kann der STS, der mit der Standard Implementierung aller anderen in der-Klasse definierten Methoden erstellt wurde, Sicherheits Token als Antwort auf Sicherheitstokenanforderungen (RST) ausgeben. Das heißt, dass die in der WS-Trust-Spezifikation definierte Problem Bindung implementiert wird. Diese Bindung wird in der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> -Methode implementiert. Keine der anderen WS-Trust-Bindungen (erneuern, Abbrechen und validieren) wird im Standardfall implementiert, und ein entsprechender Fehler wird an den Aufrufer zurückgegeben, wenn ein RST gefunden wird, das einer dieser Bindungen entspricht. Natürlich können Sie die entsprechenden Methoden (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>und <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) überschreiben, um diese Bindungen in ihren STS zu implementieren.  
  
> [!IMPORTANT]
>  Das Implementieren eines Produktions bereiten STS erfordert eine sorgfältige Planung und beträchtliche Ressourcen, um die potenziellen Sicherheitsrisiken beim verfügbar machen eines solchen Diensts zu verringern. Die meisten Entwickler, die Windows Identity Foundation (WIF) verwenden, entwickeln Anwendungen, die die Identitätsverwaltung auf einen STS auslagern, anstatt einen STS selbst zu entwickeln. WIF stellt eine Visual Studio-Erweiterung, das Identitäts-und Zugriffs Tool für Visual Studio 2012, bereit, um Entwicklern das Testen von Projektmappen in der Entwicklungsumgebung zu erleichtern. Dieses Tool enthält einen STS, `LocalSTS`, den Sie so konfigurieren können, dass bestimmte Ansprüche an die Anwendung, die Sie entwickeln, verarbeitet werden. Weitere Informationen zum Identitäts-und Zugriffs Tool finden Sie unter [Identitäts-und Zugriffs Tool für Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). In einigen Szenarien `LocalSTS` bietet möglicherweise nicht die erforderliche Funktionalität, um die Anwendung adäquat zu testen, z. b. in einem Szenario, das die Entwicklung eines benutzerdefinierten tokenhandlers zur Verwendung durch eine Anwendung umfasst. In diesen Fällen können Sie von <xref:System.IdentityModel.SecurityTokenService> ableiten, um einen oder mehrere einfache Sicherheitstokendienste zu erstellen, die in Ihrer Entwicklungsumgebung bereitgestellt werden können und die zum Testen solcher Funktionen in Ihrer Anwendung verwendet werden können. Der Rest dieses Abschnitts konzentriert sich auf die Methoden, die von <xref:System.IdentityModel.SecurityTokenService> der-Klasse verfügbar gemacht werden, mit denen Sie einen einfachen STS implementieren und die tokenausstellungspipeline erweitern können.  
  
 Die folgende Liste enthält eine kurze Übersicht über die Methoden der primären Wichtigkeit für den Entwickler, die in einer Test-oder Entwicklungsumgebung verwendet werden können.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> -Methode. Diese Methode gibt ein <xref:System.IdentityModel.Scope> -Objekt zurück, das Informationen über die RP enthält. Dieses Objekt wird im Rest der tokenausstellungpipeline verwendet und enthält Informationen über die Signierungs-und Verschlüsselungs Anmelde Informationen, die in der Antwort verwendet werden sollen `AppliesTo` , `ReplyTo` sowie die Adressen und (falls erforderlich). Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode. Diese Methode gibt ein <xref:System.Security.Claims.ClaimsIdentity> Objekt zurück, das die Ansprüche enthält, die an die RP zurückgegeben werden sollen. Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> -Methode. Diese Methode implementiert die tokenanforderungs-Pipeline, die eine eingehende Sicherheitstokenanforderung (RST) verarbeitet und eine Antwort (RSTR) an den Aufrufer zurückgibt, die ein Token enthält, das zum Authentifizieren mit einem RP verwendet werden kann. Viele der anderen in der <xref:System.IdentityModel.SecurityTokenService> -Klasse definierten Methoden werden von dieser Methode aufgerufen, einschließlich der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> -und- <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methoden. Diese Methode muss nicht außer Kraft gesetzt werden, aber ein Verständnis der von ihr implementierten tokenanforderungs-Pipeline ist möglicherweise hilfreich.  
  
 Ein STS wird durch die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> -Klasse konfiguriert.  
  
   
  
## Examples  
 Die in den <xref:System.IdentityModel.SecurityTokenService> Themen verwendeten Codebeispiele stammen aus dem `Custom Token` Beispiel. In diesem Beispiel werden benutzerdefinierte Klassen bereitstellt, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Sie beinhaltet eine Implementierung eines passiven STS, der ein Swap-Token bereitstellen kann. Ein Beispiel für die Implementierung eines aktiven STS finden Sie im `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und anderen Beispielen, die für WIF verfügbar sind, und zum Herunterladen dieser Beispiele finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code zeigt die Implementierung eines passiven STS mithilfe der <xref:System.IdentityModel.SecurityTokenService> -Klasse.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Der folgende Code zeigt, wie Sie einen benutzerdefinierten passiven STS aufrufen, um eine WS-Verbund Anforderung zu <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> verarbeiten, indem Sie die-Methode `default.aspx.cs` aus dem Code Behind in der-Datei aufrufen.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Sie müssen sowohl die <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> -Methode als auch die <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> -Methode überschreiben.</para></block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">Eine <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />, die die Einstellungen für den STS enthält.</param>
        <summary>Aufgerufen von abgeleiteten Klassen, um die <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse mit der angegebenen Konfigurationseinstellungen zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um den Bereichs Anbieter und das Zertifikat Aussteller Zertifikat zu initialisieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="securityTokenServiceConfiguration" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Schließvorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Abbruchvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Cancel-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Abbruchvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="scope">Der <see cref="T:System.IdentityModel.Scope" />, der Informationen über die abhängige Partei enthält, die der Anforderung zugeordnet ist.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Vorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Vorgang zugeordnet sind.</param>
        <summary>Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />-Methode ein.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" />-Einstellung, die auf den asynchronen Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.NotImplementedException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Vorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Vorgang zugeordnet sind.</param>
        <summary>Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf für die <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Methode ein.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Abbruchvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.NotImplementedException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Herausgabevorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Ausstellungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Issue-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf die asynchrone Herausgabe verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Erneuern-Vorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Erneuerungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Renew-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Erneuerungsvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Validierungsvorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Validierungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Validate-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Validierungs-Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Cancel-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Die eingehende Tokenanforderung.</param>
        <param name="scope">Das von <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> zurückgegebene <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Objekt.</param>
        <summary>Erstellt eine Instanz eines <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>Die <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird während der Tokenausstellung nach <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scope" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Cancel-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />-Methode ab.</summary>
        <returns>Ein <see cref="T:System.Security.Claims.ClaimsIdentity" />, das die Sammlung von Ansprüchen enthält, die in das ausgestellte Sicherheitstoken eingefügt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.NotImplementedException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Scope" />, das die Informationen der vertrauenden Seite (RP) kapselt, die der Anforderung (RST) zugeordnet ist, die im Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode angegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.NotImplementedException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Issue-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Renew-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Validate-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Namen des Sicherheitstokendienst (STS) ab.</summary>
        <returns>Der Ausstellername.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der standardtokenausstellungpipeline aufgerufen <xref:System.IdentityModel.SecurityTokenService.Issue%2A> , die in der-Methode implementiert ist.  
  
 Die Standard Implementierung gibt die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> Eigenschaft aus der Konfiguration zurück, <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> auf die über die-Eigenschaft zugegriffen wird  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="scope">Der <see cref="T:System.IdentityModel.Scope" />, der Informationen über die abhängige Partei enthält, die der Anforderung zugeordnet ist. Dies ist das <see cref="T:System.IdentityModel.Scope" />-Objekt, das von der <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Methode zurückgegeben wurde.</param>
        <summary>Wenn sie in einer abgeleiteten Klasse überschrieben wird, gibt diese Methode eine Auflistung von Ausgabebetreffs zurück, die in das ausgestellte Token eingeschlossen werden sollen.</summary>
        <returns>Ein <see cref="T:System.Security.Claims.ClaimsIdentity" />, das die Sammlung von Ansprüchen enthält, die in das ausgestellte Sicherheitstoken eingefügt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode wird von der tokenausstellungpipeline aufgerufen, die von <xref:System.IdentityModel.SecurityTokenService.Issue%2A> der-Methode implementiert wird. Es gibt einen <xref:System.Security.Claims.ClaimsIdentity> zurück, der die Ansprüche enthält, die in das ausgegebene Sicherheits Token aufgenommen werden sollen, basierend auf dem Anforderer des Tokens (dem `principal` -Parameter `request` ), dem eingehenden RST (dem-Parameter) und der vertrauenden Seite, für die das Token vorgesehen ist ( der `scope` -Parameter). Die Logik in dieser Methode beschäftigt sich hauptsächlich mit der Beantwortung der folgenden Fragen:  
  
-   **Welche Anspruchs Typen sollten in die Antwort eingeschlossen werden, die auf der RP basiert, für die Sie vorgesehen ist?** In der Regel wird dies pro RP aus Listen von Anspruchs Typen, die für die einzelnen RP erforderlich sind, oder pro Anforderung durch Untersuchen der <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> -Eigenschaft der Anforderung festgelegt. Die Logik und die Details zum Bestimmen der Ansprüche, die in die Antwort eingeschlossen werden sollen, sind jedoch vollständig in ihrer Implementierung enthalten.  
  
-   **Welche Anspruchs Werte sollten den Ansprüchen in der Antwort zugewiesen werden?** Bei einem Identitäts Anbieter (IP-STS) bedeutet dies in der Regel, dass ein oder mehrere Ansprüche im Anforderer <xref:System.Security.Claims.ClaimsPrincipal> (durch den `principal` -Parameter bereitgestellt) auf einen Speicher (oder eine andere Entität) zugreifen, um Werte für die erforderlichen Anspruchs Typen zurückzugeben. Bei einem Verbund Anbieter (R-STS) bedeutet dies in der Regel eine Verarbeitung der eingehenden Ansprüche des Anforderers, um die Anforderung zu erfüllen. möglicherweise werden Filter oder Transformationen für einige Ansprüche durchgeführt, die vom Anforderer bereitgestellt werden, während andere Benutzer unverändert übergeben werden. Wie bei der Entscheidung, welche Ansprüche in die Antwort eingeschlossen werden sollen, sind die Details und die Logik zum Bestimmen der Werte dieser Ansprüche natürlich Ihre Implementierung.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema verwendet wird, stammt aus `Custom Token` dem Beispiel. In diesem Beispiel werden benutzerdefinierte Klassen bereitstellt, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Sie beinhaltet eine Implementierung eines passiven STS, der ein Swap-Token bereitstellen kann. Ein Beispiel für die Implementierung eines aktiven STS finden Sie im `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und anderen Beispielen, die für WIF verfügbar sind, und zum Herunterladen dieser Beispiele finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode überschreiben, um Ansprüche für Ihren STS zurückzugeben. In diesem Beispiel wird die Nachricht für das Anforderungs Sicherheits Token (RST) ignoriert, und eine Auflistung von Ansprüchen auf der Grundlage des Benutzers, die auf dem STS authentifiziert ist, wird zurückgegeben.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Tokenanforderung (RST) darstellt.</param>
        <param name="scope">Die <see cref="T:System.IdentityModel.Scope" />-Instanz, die Informationen über die abhängige Partei kapselt.</param>
        <summary>Ruft das Prüftoken ab, das in der Antwort enthalten sein soll (RSTR).</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" />, der den neu erstellten Proof-Deskriptor darstellt. Der Proof-Deskriptor kann ein asymmetrischer oder ein symmetrischer Proof-Deskriptor sein, oder <see langword="null" /> im Falle eines Bearer-Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der standardtokenausstellungpipeline aufgerufen <xref:System.IdentityModel.SecurityTokenService.Issue%2A> , die in der-Methode implementiert ist.  
  
 Die Standard Implementierung gibt einen Nachweis Deskriptor zurück oder löst eine entsprechende Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="scope" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Tokenanforderung (RST) darstellt.</param>
        <summary>Ruft den Beweis der Verschlüsselungsanmeldeinformationen des Anfordernden ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" />-Objekt, das die verschlüsselnden Anmeldeinformationen des Anfordernden darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> -Methode aufgerufen.  
  
 Die Standard Implementierung führt Folgendes aus: Gibt `null` zurück, wenn in der Anforderung kein Verschlüsselungs Token angegeben ist ( <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> die- `null`Eigenschaft ist). Andernfalls werden Anmelde Informationen basierend auf diesem Token zurückgegeben <xref:System.IdentityModel.Tokens.X509SecurityToken>, wenn das Token als zurückgegeben werden kann. Wenn das Token nicht als <xref:System.IdentityModel.Tokens.X509SecurityToken>aufgelöst werden kann, wird eine <xref:System.IdentityModel.RequestFailedException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">Der RST, der die Token-Anforderung enthält.</param>
        <param name="tokenDescriptor">Der Tokendeskriptor, der die zu verwendenden Informationen für das ausgestellte Token enthält.</param>
        <summary>Erstellt die Antwort (RSTR) die das ausgestelltes Token enthält, indem der angegebene Deskriptor der Anforderung (RST) und des Sicherheitstoken verwendet wird.</summary>
        <returns>Die Antwort (RSTR) oder <see langword="null" />, wenn eine Antwort nicht von der angegebenen Anforderungen und dem Tokendeskriptor erstellt werden kann. Die Standardimplementierung gibt <see langword="null" /> zurück, wenn der <paramref name="tokenDescriptor" />-Parameter <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> -Methode wird als letzter Schritt aus der tokenausstellungpipeline aufgerufen, der von der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> -Methode implementiert wird. Sie erstellt die Antwort (RSTR) und gibt Sie zurück, indem Sie die ursprüngliche eingehende Anforderung (RST) und den tokendeskriptor verwendet, der bei den vorherigen Schritten in der tokenausstellungpipeline erstellt wurde.  
  
 Die Standard Implementierung erstellt das RSTR, indem das im Request-Parameter angegebene RST an den <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> -Konstruktor übergeben wird <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> . dabei wird die-Methode für den <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> in übergebenen tokendeskriptor aufgerufen, um die zugehörigen Eigenschaften auf den neuen Erstellen Sie RSTR, legen <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> Sie die-Eigenschaft für die RSTR <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> mithilfe der-Eigenschaft für den tokendeskriptor fest <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> , und legen Sie schließlich die-Eigenschaft für die RSTR gemäß der folgenden Tabelle fest:  
  
|`RST.ReplyTo` -Eigenschaft|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>-Eigenschaft.|`RSTR.ReplyTo` -Eigenschaft|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|Nicht festgelegt|Nicht festgelegt|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Nicht festgelegt|Set|Nicht festgelegt|  
|Nicht festgelegt|Nicht festgelegt|Nicht festgelegt|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, der den Client darstellt, von dem die Anforderung stammt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Anforderung (RST) darstellt.</param>
        <summary>Ruft ein <see cref="T:System.IdentityModel.Scope" />-Objekt ab, das Informationen über die vertrauende Seite enthält, die der angegebenen Anforderung zugeordnet ist. In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Scope" />, die RP-Informationen kapselt, die der Anforderung zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> -Methode wird von der tokenausstellungs-Pipeline <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> nach der-Methode aufgerufen <xref:System.IdentityModel.Scope> und sollte ein für die eingehende Anforderung konfiguriertes-Objekt zurückgeben. (Die tokenausstellungspipeline ist <xref:System.IdentityModel.SecurityTokenService.Issue%2A> in der-Methode implementiert.) Das <xref:System.IdentityModel.Scope> -Objekt kapselt Informationen über den RP, der der Sicherheitstokenanforderung (RST) zugeordnet ist. Dies umfasst Informationen über die Verschlüsselungs-und Signatur Anmelde Informationen, die mit der RP verwendet werden sollen, und ob in der Antwort ausgegebene Token und/oder symmetrische Schlüssel verschlüsselt werden sollen. Einige typische Aufgaben, die in <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> der-Methode ausgeführt werden, sind:  
  
-   Bestimmen Sie, ob die RP, für die das Token vorgesehen ist, ein bekanntes RP ist. Wie dies erreicht wird, hängt von ihrer Implementierung ab. Wenn die beabsichtigte RP keine gültige RP für diesen STS ist, sollte die Methode eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>auslösen.  
  
-   Bestimmen Sie die Signierungs Anmelde Informationen, die in der Antwort (RSTR) verwendet <xref:System.IdentityModel.Scope.SigningCredentials%2A> werden sollen, und legen Sie die Eigenschaft entsprechend fest.  
  
-   Bestimmen Sie, ob die Antwort und/oder alle enthaltenen symmetrischen Schlüssel verschlüsselt und die Anmelde Informationen für die Verschlüsselung verwendet werden sollen. Legen Sie <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>die <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>Eigenschaften, <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> und entsprechend fest.  
  
    > [!IMPORTANT]
    >  Standardmäßig werden die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> Eigenschaften <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> und festgelegt `true` , um zu verhindern, dass STS Token ausgibt, die nicht sicher sind. Es wird empfohlen, diese Eigenschaften in einer Produktionsumgebung `false` nie auf festzulegen.  
  
-   Bestimmen Sie die Adresse, an die die Antwort zurückgegeben werden soll. Legen Sie die <xref:System.IdentityModel.Scope.AppliesToAddress%2A> - <xref:System.IdentityModel.Scope.ReplyToAddress%2A> Eigenschaft oder die-Eigenschaft entsprechend fest.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema verwendet wird, stammt aus `Custom Token` dem Beispiel. In diesem Beispiel werden benutzerdefinierte Klassen bereitstellt, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Sie beinhaltet eine Implementierung eines passiven STS, der ein Swap-Token bereitstellen kann. Ein Beispiel für die Implementierung eines aktiven STS finden Sie im `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und anderen Beispielen, die für WIF verfügbar sind, und zum Herunterladen dieser Beispiele finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 Im folgenden Codebeispiel wird eine Implementierung der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>-Methode veranschaulicht. Mit dieser Implementierung wird überprüft, ob der Dienstanbieter vom STS erkannt wird, die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> Adresse in der Anforderung überprüft und die <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> -Eigenschaft entsprechend festgelegt wird. Außerdem werden die Signierungs-und Verschlüsselungs Anmelde Informationen für die Verwendung mit dem RP basierend auf Zertifikaten festgelegt, die sind in der Datei hart codiert.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Eine Zeichenfolge, die den URI des angeforderten Tokentyps enthält.</param>
        <summary>Ruft den entsprechenden Sicherheitstokenhandler zum Ausgeben eines Sicherheitstoken des angegebenen Typs ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> der den zur Erstellung des ausgegebenen Sicherheitstoken verwendeten Tokenhandler darstellt. Gibt <see langword="null" /> zurück, wenn der angeforderte Tokentyp nicht unterstützt wird (es gibt keinen Handler, die für den angegebenen Tokentyp konfiguriert ist).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standard Implementierung, `requestedTokenType` Wenn `null` oder eine leere Zeichenfolge ist, wird der Standardtokentyp aus der Konfiguration verwendet. Dies wird durch die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> -Eigenschaft des STS-Konfigurations Objekts angegeben, auf das über die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> -Eigenschaft zugegriffen wird.  
  
 Diese Methode wird von der standardtokenausstellungpipeline aufgerufen <xref:System.IdentityModel.SecurityTokenService.Issue%2A> , die in der-Methode implementiert ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />-Element, das die angeforderte Lebensdauer darstellt.</param>
        <summary>Ruft die Lebensdauer für das ausgestellte Token ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />, das die gewährten Lebensdauer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird normalerweise mit der Lebensdauer aufgerufen, die im RST eingetroffen ist. In der Standard Implementierung wird die Tokengültigkeitsdauer entsprechend der folgenden Tabelle berechnet.  
  
|Erstellt (in)|Läuft ab (in)|Erstellt (in)|Läuft ab (ausgehend)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C +<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Diese Methode wird von der standardtokenausstellungpipeline aufgerufen <xref:System.IdentityModel.SecurityTokenService.Issue%2A> , die in der-Methode implementiert ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Erstellt ein Sicherheitstoken.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das ausgestellte Sicherheitstoken enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die in der WS-Trust-Spezifikation definierte Problem Bindung. Die Standard Implementierung <xref:System.IdentityModel.SecurityTokenService.Issue%2A> der-Methode verarbeitet die eingehende Anforderung (RST) über eine Pipeline für die Tokenausstellung (Forderungs Ausstellung) und gibt entweder eine Antwort (RSTR) zurück, die ein Sicherheits Token mit den entsprechenden Ansprüchen zum Authentifizieren von enthält. der Anforderer mit dem RP oder einer entsprechenden Ausnahme. Die tokenausstellungspipeline in der Standard Implementierung besteht aus Aufrufen der folgenden Methoden ( <xref:System.IdentityModel.SecurityTokenService> der-Klasse).  
  
1.  Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode zum Überprüfen der Anforderung (RST).  
  
2.  Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode, um ein <xref:System.IdentityModel.Scope> -Objekt zu erhalten, das Informationen über die vertrauende Seite (RP) enthält, die der Anforderung zugeordnet ist. Sie müssen diese Methode überschreiben. Wenn <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> zurück `null`gibt, <xref:System.InvalidOperationException> wird eine ausgelöst.  
  
3.  Die <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> Methode, mit der ein sicherheitstokendeskriptor basierend auf dem <xref:System.IdentityModel.Scope> RST und dem im vorherigen Schritt zurückgegebenen-Objekt zurückgegeben wird. Der sicherheitstokendeskriptor (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) enthält Informationen über die Anforderung in einem Formular, das von einem Tokenhandler verwendet werden kann. Die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> -Eigenschaft wird auf den Deskriptor festgelegt, der vom-Befehl zurückgegeben wird. Wenn `null` zurückgegeben wird oder die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> -Eigenschaft des Deskriptors ist `null`, wird <xref:System.InvalidOperationException> eine ausgelöst. Die-Ausnahme wird auch ausgelöst, <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> wenn die `true` -Eigenschaft <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> ist, aber die-Eigenschaft im `null`zurückgegebenen Deskriptor ist.  
  
4.  Die <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> Methode, mit der der geeignete Tokenhandler basierend auf der Art des angeforderten Tokens bezogen werden soll. Wenn `null` zurückgegeben wird, <xref:System.NotImplementedException> wird eine ausgelöst.  
  
5.  Die <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> -Methode, um den Aussteller Namen für das Token zu erhalten. Löst eine <xref:System.InvalidOperationException> aus, wenn der `null` Name oder leer ist. andernfalls <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> wird die-Eigenschaft für den Deskriptor festgelegt.  
  
6.  Die <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> -Methode, um die Lebensdauer für das Token zu <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> erhalten, und legt die-Eigenschaft für den Deskriptor fest.  
  
7.  Die <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Methode, mit der das Prüftoken abgerufen wird, das im ausgestellten Token enthalten <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> sein soll, und legt die-Eigenschaft für den Deskriptor fest.  
  
8.  Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methode, mit der die Ansprüche abgerufen werden, die im ausgestellten Token enthalten <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> sein sollen, und legt die-Eigenschaft für den Deskriptor fest. Sie müssen diese Methode überschreiben.  
  
9. Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Methode zum Erstellen einer Antwort (RSTR), die das ausgestellte Token enthält.  
  
 Sie können die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> -Methode überschreiben, um eine benutzerdefinierte tokenausstellungpipeline zu implementieren. Dies ist in der Entwicklungs-und Testumgebung jedoch normalerweise <xref:System.IdentityModel.SecurityTokenService> nicht erforderlich, für die die meisten benutzerdefinierten Implementierungen der-Klasse vorgesehen sind In vielen dieser Fälle überschreiben Sie die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> - <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode und die-Methode <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> und überschreiben optional die-Methode, um einen servicefähigen STS für Ihre Umgebung bereitzustellen. Wenn eine weitere Anpassung notwendig ist, können Sie diese häufig bereitstellen, indem Sie die Methoden überschreiben, die die einzelnen Phasen der oben aufgeführten Standard-tokenausstellungspipeline  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den Prinzipal, der der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, der den aktuellen Prinzipal darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Renew-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt die Sicherheitstokenanforderung (RST), die der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Anforderung enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den Scope, der der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Scope" />, das die Konfiguration für die Anforderung der Tokenausstellung darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" />, der mit der aktuellen Instanz verknüpft ist.</summary>
        <value>Der Sicherheitstokendeskriptor, der der aktuellen Instanz zugeordnet ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die Eigenschaft auf <see langword="null" /> festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Besitzerkonfigurationsinstanz ab.</summary>
        <value>Eine <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />, die die Konfiguration für die aktuelle Instanz enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Validate-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Anforderung darstellt.</param>
        <summary>Überprüft die von dieser Instanz gekapselten Sicherheitstokenanforderungen (RST).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> -Methode wird von der tokenausstellungpipeline <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (der-Methode) aufgerufen, um das eingehende RST zu validieren. Das RST wird anhand der Anforderungen (Richtlinie) des STS überprüft, und es wird eine entsprechende Ausnahme ausgelöst, wenn Sie ungültig ist.  
  
 Die Standard Implementierung <xref:System.IdentityModel.SecurityTokenService> der-Klasse unterstützt nur das RST-RSTR-Muster und nur die Problem Bindung der WS-Trust-Spezifikation <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> (die-Eigenschaft der Anforderung muss auf <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>festgelegt werden). Die Standard Implementierung dieser Methode erzwingt diese Anforderungen (und andere, die im Abschnitt "Ausnahmen" erwähnt werden). Sie können diese Methode überschreiben, wenn Sie unterschiedliche Validierungsanforderungen für Ihren benutzerdefinierten STS erzwingen müssen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" />-Eigenschaft der Anforderung ist nicht auf <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" /> festgeleget.  
  
- oder - 
Die <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" />-Eigenschaft der Anforderung ist weder <see langword="null" /> noch eine der Konstanten, die in der <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />-Klasse definiert sind.  
  
- oder - 
Der <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> der Anforderung ist <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> und das <see langword="KeySize" />-Element ist vorhanden, aber sein Wert ist ungleich 0 (null).</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">Der STS unterstützt den Anforderungstokentyp nicht (auf Grundlage des Werts der <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" />-Eigenschaft der Anforderung).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>
