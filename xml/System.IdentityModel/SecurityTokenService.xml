<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8d93b898d628b70967d33278c8cd9f33a66bf" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36479607" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>The abstract base class that defines the properties and methods of a security token service (STS).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 So erstellen einen STS, leiten Sie von, der <xref:System.IdentityModel.SecurityTokenService> Klasse. In der benutzerdefinierten Klasse müssen mindestens überschreiben Sie die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> und <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methoden. Diese Außerkraftsetzungen der STS erstellt haben, verwenden die standardmäßige Implementierung aller anderen Methoden in der Klasse definiert ist kann Ausstellen von Sicherheitstoken in Reaktion auf Sicherheit tokenanforderungen (RST). D. h. wird in der WS-Trust-Spezifikation definierte Problem Bindung implementiert. Diese Bindung implementiert die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Keine der anderen WS-Trust-Bindungen (erneuern, Abbrechen und überprüfen) im Standardfall implementiert werden, und ein entsprechenden Fehler wird an den Aufrufer zurückgegeben, wenn eine RST, die eine dieser Bindungen entspricht gefunden wird. Sie können natürlich überschreiben Sie die entsprechenden Methoden (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, und <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) diese Bindungen in Ihren STS zu implementieren.  
  
> [!IMPORTANT]
>  Implementieren einen STS produktionsbereite umfasst eine sorgfältige Planung und erhebliche Ressourcen zum Verfügbarmachen von z. B. ein Dienst inhärenten potenzielle Sicherheitsrisiken zu minimieren. Die meisten Entwickler mithilfe von Windows Identity Foundation (WIF) werden werden Anwendungen entwickeln, die identitätsverwaltung zu einem Sicherheitstokendienst auszulagern, anstatt ein STS selbst entwickeln. WIF bietet eine Visual Studio-Erweiterung, die Identitäts- und Zugriffstool für Visual Studio 2012, Entwickler, die Lösungen in der Entwicklungsumgebung testen können. Dieses Tool enthält ein STS `LocalSTS`, die Sie konfigurieren können, um bestimmte Ansprüche an die Anwendung zu fungieren, die Sie entwickeln. Weitere Informationen über das Identitäts- und Zugriffs-Tool finden Sie unter [Identitäts- und Zugriffstool für Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). In einigen Szenarien `LocalSTS` möglicherweise nicht adäquat testen die Anwendung erforderliche Funktionen bieten, z. B., einen benutzerdefinierten token Handler für die Verwendung von einer Anwendung in einem Szenario, bei der, Entwicklung. In diesen Fällen können Sie ableiten von <xref:System.IdentityModel.SecurityTokenService> erstellen eine oder mehrere einfache Sicherheitstokendienste, die bereitgestellt werden kann, in der Entwicklungsumgebung und, die verwendet werden kann, um solche Funktionen in Ihrer Anwendung zu testen. Im restlichen Teil dieses Abschnitts liegt der Schwerpunkt auf die Methoden verfügbar gemacht werden, indem die <xref:System.IdentityModel.SecurityTokenService> Klasse, mit denen Sie zum Implementieren einer einfachen STS und erweitern das token anspruchsausstellungs-Pipeline.  
  
 Die folgende Liste bietet eine kurze Übersicht über die Methoden von zentraler Bedeutung für dem Entwickler für die Verwendung in einer Test- oder Entwicklungsumgebung Umgebung.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>-Methode. Diese Methode gibt ein <xref:System.IdentityModel.Scope> -Objekt, das Informationen über die vertrauende Seite enthält. Dieses Objekt wird in den Rest der Pipeline tokenausstellung verwendet und enthält Informationen über das Signieren und Verschlüsseln von Anmeldeinformationen in der Antwort verwenden, sowie die `AppliesTo` und `ReplyTo` (falls erforderlich) Adressen. Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>-Methode. Diese Methode gibt ein <xref:System.Security.Claims.ClaimsIdentity> Objekt, das die Ansprüche an die vertrauende Seite zurückzugebenden enthält. Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.Issue%2A>-Methode. Diese Methode implementiert, die Anforderung eines Zugriffstokens Pipeline verarbeitet eine eingehende token Security-Anforderung (RST) und gibt eine Antwort (RSTR) an den Aufrufer, der ein Token enthält, die für die Authentifizierung bei einer vertrauenden Seite verwendet werden können. Viele der anderen Methoden definiert, der <xref:System.IdentityModel.SecurityTokenService> Klasse werden von dieser Methode aufgerufen einschließlich der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> und <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methoden. Sie müssen keine diese Methode überschreiben, aber ein Überblick über die Anforderung eines Zugriffstokens Pipeline implementiert kann hilfreich sein.  
  
 STS ist so konfiguriert, über die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> Klasse.  
  
   
  
## Examples  
 Die Codebeispiele, die in verwendet werden die <xref:System.IdentityModel.SecurityTokenService> Themen stammen aus den `Custom Token` Beispiel. In diesem Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) sowie eine Implementierung von passiver STS, die können bedient ein SWT-Token ist. Ein Beispiel dafür, wie ein aktiver STS implementiert, sehen Sie die `Federation Metadata` Beispiel. Informationen über diese Beispiele und weitere Beispiele verfügbar für WIF und dazu, wo Sie sie herunterladen, finden Sie unter [WIF Beispiel Codeindex](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code zeigt die Implementierung der passiver STS mithilfe der <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Der folgende Code zeigt, wie Sie einen benutzerdefinierten passive STS zum Verarbeiten einer WS-Verbund-Anforderung durch den Aufruf Aufrufen der <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> Methode aus der Code-behind in der `default.aspx.cs` Datei.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Sie müssen beide überschreiben die <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> und <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> Methoden.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">A <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> that contains the settings for the STS.</param>
        <summary>Called from derived classes to initialize the <see cref="T:System.IdentityModel.SecurityTokenService" /> class using the specified configuration settings.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um bereichsanbieter und token Herausgeberzertifikat zu initialisieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous cancel operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous cancel operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous WS-Trust Cancel request.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous cancel operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="scope">The <see cref="T:System.IdentityModel.Scope" /> that contains information about the relying party associated with the request.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous call to the <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> method.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous call for the <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> method.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous cancel operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous issue operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous issue operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous WS-Trust Issue request.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous issue operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous renew operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous renew operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous WS-Trust Renew request.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous renew operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate that receives notification of the completion of the asynchronous validate operation.</param>
        <param name="state">An object that contains state information associated with the asynchronous validate operation.</param>
        <summary>When overridden in a derived class, begins an asynchronous WS-Trust Validate request.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that references the asynchronous validate operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <summary>When overridden in a derived class, processes a WS-Trust Cancel request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">The incoming token request.</param>
        <param name="scope">The <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> object returned from <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Creates an instance of a <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>The <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, während der tokenausstellung nach <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> is <see langword="null" />.  -or-  <paramref name="scope" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous WS-Trust Cancel request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> method.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> that contains the collection of claims that will be placed in the issued security token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> that encapsulates the relying party (RP) information associated with the request (RST) specified in the call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous WS-Trust Issue request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous WS-Trust Renew request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">The <see cref="T:System.IAsyncResult" /> that is returned by a call to the <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> method.</param>
        <summary>When overridden in a derived class, completes the asynchronous WS-Trust Validate request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the name of the security token service (STS).</summary>
        <returns>The issuer name.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der Standardeinstellung in token anspruchsausstellungs-Pipeline implementiert die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 Gibt die standardmäßige Implementierung der <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> Eigenschaft aus der Konfiguration erfolgt über die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <param name="scope">The <see cref="T:System.IdentityModel.Scope" /> that contains information about the relying party associated with the request. This is the <see cref="T:System.IdentityModel.Scope" /> object that was returned by the <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> method.</param>
        <summary>When overridden in a derived class, this method returns a collection of output subjects to be included in the issued token.</summary>
        <returns>A <see cref="T:System.Security.Claims.ClaimsIdentity" /> that contains the collection of claims that will be placed in the issued security token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methode wird aufgerufen, aus der tokenausstellung-Pipeline, die durch implementiert wird die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Gibt eine <xref:System.Security.Claims.ClaimsIdentity> , enthält die Ansprüche in das ausgegebene Sicherheitstoken basierend auf der anforderer des Tokens eingeschlossen werden sollen (die `principal` Parameter), eingehender RST (die `request` Parameter), und die vertrauende Seite für die das Token ist dafür vorgesehen, () die `scope` Parameter). Die Logik in dieser Methode wird hauptsächlich die folgenden Fragen beantworten:  
  
-   **Der claim-Typen sollten enthalten sein, in der Antwort basierend auf die vertrauende Seite für den sie bestimmt ist?** Dies ist in der Regel auf Basis pro RP aus Listen von Anspruchstypen, die erforderlich sind, für jede vertrauende Seite oder auf eine Anforderungsbasis sich entschieden, mithilfe der <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> -Eigenschaft der Anforderung. Die Logik und die Details zur Bestimmung der Ansprüche in die Antwort eingeschlossen ist jedoch vollständig bis zu Ihrer Implementierung.  
  
-   **Die Anspruchswerte sollten die Ansprüche in der Antwort zugewiesen werden?** Für Identitätsanbieter (IP-STS) bedeutet dies in der Regel verwenden einen oder mehrere Ansprüche in des anforderers <xref:System.Security.Claims.ClaimsPrincipal> (bereitgestellt von der `principal` Parameter) den Zugriff auf einen Speicher (oder andere Entität) zur Rückgabe von Werten für die erforderlichen Anspruchstypen. Für einen Verbund-Anbieter (R-STS) bedeutet dies in der Regel eine Art von Verarbeitung für eingehende Ansprüche des anforderers, zur Erfüllung der Anforderung ausführen; Ausführen von Filtern oder Transformation möglicherweise für einige Ansprüchen ab, die durch den anforderer beim Übergeben von Dritten über unverändert bereitgestellt. Wie bei der Entscheidung, welche Ansprüche in die Antwort eingeschlossen werden sollen, ist die Details und die Logik der Vorgehensweise zur Bestimmung der Werte dieser Ansprüche natürlich bis zu Ihrer Implementierung.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema dient stammt aus dem `Custom Token` Beispiel. In diesem Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) sowie eine Implementierung von passiver STS, die können bedient ein SWT-Token ist. Ein Beispiel dafür, wie ein aktiver STS implementiert, sehen Sie die `Federation Metadata` Beispiel. Informationen über diese Beispiele und weitere Beispiele verfügbar für WIF und dazu, wo Sie sie herunterladen, finden Sie unter [WIF Beispiel Codeindex](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> für Ihren STS Anspruchsanbieter-Methode, um zurückzugeben. In diesem Beispiel wird die Nachricht anfordern Anforderungssicherheitstoken (RST) ignoriert, und eine Sammlung von Ansprüchen basierend auf dem Benutzer als an den STS authentifiziert wird zurückgegeben.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode in der Implementierung von der <see cref="T:System.IdentityModel.SecurityTokenService" /> Klasse.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the incoming token request (RST).</param>
        <param name="scope">The <see cref="T:System.IdentityModel.Scope" /> instance that encapsulates information about the relying party.</param>
        <summary>Gets the proof token to be included in the response (RSTR).</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> that represents the newly created proof descriptor. The proof descriptor can be an asymmetric proof descriptor, a symmetric proof descriptor, or <see langword="null" /> in the bearer token case.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der Standardeinstellung in token anspruchsausstellungs-Pipeline implementiert die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 Die Standardimplementierung gibt einen Nachweis Deskriptor zurück oder löst eine entsprechende Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> is <see langword="null" />.  -or-  <paramref name="scope" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the incoming token request (RST).</param>
        <summary>Gets the requestor's proof encrypting credentials.</summary>
        <returns>An <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> object that represents the requestor’s encrypting credentials.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, aus der <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Methode.  
  
 Die standardmäßige Implementierung führt Folgendes aus. Gibt `null` , wenn keine Verschlüsselungstoken, die in der Anforderung angegeben ist (die <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> Eigenschaft ist `null`). Wenn das Token als angezeigt werden kann, andernfalls ein <xref:System.IdentityModel.Tokens.X509SecurityToken>, Anmeldeinformationen, die basierend auf dieses Token zurückgegeben. Wenn das Token als nicht auflösen kann ein <xref:System.IdentityModel.Tokens.X509SecurityToken>, eine <xref:System.IdentityModel.RequestFailedException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">The RST that contains the token request.</param>
        <param name="tokenDescriptor">The token descriptor that contains the information to use for the issued token.</param>
        <summary>Creates the response (RSTR) that contains the issued token by using the specified request (RST) and security token descriptor.</summary>
        <returns>The response (RSTR) or <see langword="null" /> if a response cannot be created from the specified request and token descriptor. The default implementation returns <see langword="null" /> if the <paramref name="tokenDescriptor" /> parameter is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Methode wird aufgerufen, als der letzte Schritt aus der tokenausstellung-Pipeline, die durch implementiert wird die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Erstellt und gibt die Antwort (RSTR) mit der ursprünglichen eingehenden Anforderung (RST) und der token Deskriptor, der während des vorherigen Schritts in der Pipeline tokenausstellung aufgebaut wurde.  
  
 Die Standardimplementierung erstellt das RSTR durch Übergeben der RST in der Anforderungsparameter angegeben der <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> -Konstruktor aufrufen der <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> Methode auf dem token Deskriptor übergebenen <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> anzuwendende seine Eigenschaften mit den neu erstellt RSTR, Festlegen der <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> -Eigenschaft für das RSTR mithilfe der <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> Eigenschaft auf dem token Deskriptor und schließlich Festlegen der <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> -Eigenschaft für das RSTR entsprechend der folgenden Tabelle:  
  
|`RST.ReplyTo`-Eigenschaft|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>-Eigenschaft.|`RSTR.ReplyTo`-Eigenschaft|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|Nicht festgelegt|Nicht festgelegt|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Nicht festgelegt|Set|Nicht festgelegt|  
|Nicht festgelegt|Nicht festgelegt|Nicht festgelegt|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the client making the request.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the incoming request (RST).</param>
        <summary>Gets a <see cref="T:System.IdentityModel.Scope" /> object that contains information about the relying party (RP) associated with the specified request (RST). You must override this method in your implementation of the <see cref="T:System.IdentityModel.SecurityTokenService" /> class.</summary>
        <returns>A <see cref="T:System.IdentityModel.Scope" /> that encapsulates the RP information associated with the request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode wird aufgerufen, aus der Pipeline tokenausstellung nach der <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode und zurückgeben sollte ein <xref:System.IdentityModel.Scope> -Objekt für die eingehende Anforderung konfiguriert ist. (Die tokenausstellung Pipeline wird implementiert, der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.) Die <xref:System.IdentityModel.Scope> -Objekt kapselt Informationen über die vertrauende Seite der Security-token-Anforderung (RST) zugeordnet. Dies schließt Informationen zu den Anmeldeinformationen verschlüsselnden und signieren, mit der Anwendung der vertrauenden Seite und ob alle ausgestellten Token und/oder symmetrische Schlüssel in der Antwort verschlüsseln verwendet werden soll. Einige typische Aufgaben, die in der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode sind:  
  
-   Bestimmen Sie, ob die vertrauende Seite für die das Token vorgesehen ist, eine anerkannten RP ist. Wie dies erreicht wird, hängt von der Implementierung ab. Wenn die beabsichtigte vertrauende Seite ist keinem gültigen RP für dieses STS, löst die Methode sollte ein <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Bestimmt die Signierung Anmeldeinformationen in der Antwort (RSTR) verwendet werden, und legen die <xref:System.IdentityModel.Scope.SigningCredentials%2A> Eigenschaft entsprechend.  
  
-   Bestimmen Sie, ob die Antwort- und/oder enthalten symmetrische Schlüssel verschlüsselt werden soll, und die Anmeldeinformationen für die Verschlüsselung verwendet werden. Legen Sie die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, und <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> Eigenschaften entsprechend.  
  
    > [!IMPORTANT]
    >  Wird standardmäßig die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> und <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> Eigenschaften werden festgelegt, `true` um zu verhindern, dass der STS Ausstellen von Token, die nicht sicher sind. Es wird empfohlen, diese Eigenschaften nie festgelegt werden, um `false` in einer produktionsumgebung.  
  
-   Bestimmen Sie die Adresse, zu der die Antwort zurückgegeben werden sollen. Legen Sie entweder die <xref:System.IdentityModel.Scope.AppliesToAddress%2A> oder <xref:System.IdentityModel.Scope.ReplyToAddress%2A> Eigenschaft entsprechend.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema dient stammt aus dem `Custom Token` Beispiel. In diesem Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) sowie eine Implementierung von passiver STS, die können bedient ein SWT-Token ist. Ein Beispiel dafür, wie ein aktiver STS implementiert, sehen Sie die `Federation Metadata` Beispiel. Informationen über diese Beispiele und weitere Beispiele verfügbar für WIF und dazu, wo Sie sie herunterladen, finden Sie unter [WIF Beispiel Codeindex](~/docs/framework/security/wif-code-sample-index.md).  
  
 Im folgenden Codebeispiel wird eine Implementierung der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>-Methode veranschaulicht. Diese Implementierung stellt sicher, dass die Anwendung die vertrauenden Seite das STS erkannt wird überprüft die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> Adresse in der Anforderung und legt die <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> Eigenschaft entsprechend, und legt das Signieren und Verschlüsseln von Anmeldeinformationen für die Verwendung mit der Anwendung der vertrauenden Seite basierend auf Zertifikaten, die in der Datei sind hartcodiert.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode in der Implementierung von der <see cref="T:System.IdentityModel.SecurityTokenService" /> Klasse.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">A string that contains the requested token type URI.</param>
        <summary>Gets the appropriate security token handler for issuing a security token of the specified type.</summary>
        <returns>A <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> that represents the token handler to be used for creating the issued security token. Returns <see langword="null" /> if the requested token type is not supported (there is no handler configured for the specified token type).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardimplementierung Wenn `requestedTokenType` ist `null` oder eine leere Zeichenfolge, die Standardeinstellung Tokentyp aus der Konfiguration verwendet wird. Dadurch wird angegeben, indem die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> Eigenschaft des Konfigurationsobjekts STS erfolgt über die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> Eigenschaft.  
  
 Diese Methode wird aufgerufen, von der Standardeinstellung in token anspruchsausstellungs-Pipeline implementiert die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> that represents the requested lifetime.</param>
        <summary>Gets the lifetime for the issued token.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> that represents the granted lifetime.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird normalerweise mit der Lebensdauer aufgerufen, die in das RST eingetroffen sind. In der Standardimplementierung wird die Lebensdauer des Tokens gemäß der folgenden Tabelle berechnet.  
  
|Erstellt (in)|Läuft ab (in)|Erstellt (in)|(Out) läuft ab|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Diese Methode wird aufgerufen, von der Standardeinstellung in token anspruchsausstellungs-Pipeline implementiert die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <summary>Issues a security token.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that contains the issued security token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die Problem-Bindung, die in der WS-Trust-Spezifikation definiert. Die standardmäßige Implementierung des der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode verarbeitet die eingehende Anforderung (RST) über eine Pipeline für die tokenausstellung (Ansprüche Ausstellung) und entweder eine Antwort zurückgibt (RSTR), die ein Sicherheitstoken mit den entsprechenden Ansprüchen Authentifizierung enthält der der anforderer die vertrauende Seite oder eine entsprechende Ausnahme. In der Standardimplementierung die tokenausstellung-Pipeline besteht aus Aufrufen der folgenden Methoden (von der <xref:System.IdentityModel.SecurityTokenService> Klasse).  
  
1.  Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode zum Überprüfen der Anforderung (RST).  
  
2.  Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode zum Abrufen einer <xref:System.IdentityModel.Scope> -Objekt, das Informationen über die vertrauende (RP) mit der Anforderung verknüpften enthält. Sie müssen diese Methode überschreiben. Wenn <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> gibt `null`, eine <xref:System.InvalidOperationException> ausgelöst wird.  
  
3.  Die <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> Methode, um ein token Sicherheitsbeschreibung zurück auf der Grundlage von RST und die <xref:System.IdentityModel.Scope> Objekt im vorherigen Schritt zurückgegeben. Die Sicherheitsbeschreibung-token (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) enthält Informationen über die Anforderung in ein Formular, das von einem token Handler verwendet werden kann. Die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> auf den Deskriptor, der vom Aufruf zurückgegebene Eigenschaft festgelegt ist. Wenn `null` zurückgegeben oder, wenn die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> -Eigenschaft des Deskriptors ist `null`, wird eine <xref:System.InvalidOperationException> ausgelöst wird. Die Ausnahme wird auch ausgelöst, wenn die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> Eigenschaft `true` aber die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> -Eigenschaft in der zurückgegebenen Deskriptor ist `null`.  
  
4.  Die <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> Methode zum Abrufen des entsprechenden Tokenhandler auf Grundlage der Art des angeforderten Tokens. Wenn `null` zurückgegeben wird, eine <xref:System.NotImplementedException> ausgelöst wird.  
  
5.  Die <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> Methode, um den Ausstellernamen für das Token abzurufen. Löst ein <xref:System.InvalidOperationException> ist der Name `null` oder leer ist; andernfalls die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> Eigenschaft für den Deskriptor.  
  
6.  Die <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> Methode zum Abrufen der Lebensdauer für die Token und stellt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> Eigenschaft für den Deskriptor.  
  
7.  Die <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Methode zum Abrufen des Prüftoken für das ausgestellte Token und legt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> Eigenschaft für den Deskriptor.  
  
8.  Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methode zum Abrufen der Ansprüche für die ausgestellte Token und legt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> Eigenschaft für den Deskriptor. Sie müssen diese Methode überschreiben.  
  
9. Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Methode zum Erstellen einer Antwort (RSTR), die das ausgestellte Token enthält.  
  
 Sie überschreiben können die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode für die Implementierung einer benutzerdefinierten token anspruchsausstellungs-Pipeline; dies in der Regel nicht in der Entwicklungs- und testumgebungen, für welche die meisten benutzerdefinierten Implementierungen der erforderlich ist jedoch der <xref:System.IdentityModel.SecurityTokenService> Klasse vorgesehen sind. In vielen Fällen überschreiben Sie die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> und <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methoden und optional außer Kraft setzen die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode, um eines zu wartenden STS für Ihre Umgebung bereitzustellen. Wenn weitere Anpassung erforderlich ist können Sie häufig bereitstellen durch Außerkraftsetzen der Methoden, die jeder Phase des Standardwerts, die token anspruchsausstellungs-Pipeline implementieren oben aufgelistet sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the principal associated with the current instance.</summary>
        <value>Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" /> , die den aktuellen Prinzipal darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <summary>When overridden in a derived class, processes a WS-Trust Renew request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the security token request (RST) associated with the current instance.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> , die die Anforderung enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the scope associated with the current instance.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Scope" /> , die die Konfiguration für die tokenausstellung Anforderung darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> associated with the current instance.</summary>
        <value>Die token Sicherheitsbeschreibung, die der aktuellen Instanz zugeordnet ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">An attempt to set the property to <see langword="null" /> occurs.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the owner configuration instance.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> , die die Konfiguration für die aktuelle Instanz enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">A <see cref="T:System.Security.Claims.ClaimsPrincipal" /> that represents the identity of the token requestor.</param>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the security token request. This includes the request message as well as other client related information such as authorization context.</param>
        <summary>When overridden in a derived class, processes a WS-Trust Validate request.</summary>
        <returns>A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> that represents the RSTR to return to the caller.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">A <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> that represents the request.</param>
        <summary>Validates the security token request (RST) encapsulated by this instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode wird aufgerufen, aus der Pipeline tokenausstellung (die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode) zum Überprüfen eingehenden RST. Das Anforderungssicherheitstoken anhand der Anforderungen (Richtlinie) des STS überprüft und eine entsprechende Ausnahme wird ausgelöst, wenn er ungültig ist.  
  
 Die standardmäßige Implementierung des der <xref:System.IdentityModel.SecurityTokenService> Klasse unterstützt nur das RST-RSTR-Muster und nur die Bindung Problem der WS-Trust-Spezifikation (die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> Eigenschaft der Anforderung muss festgelegt werden, um <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). Die standardmäßige Implementierung dieser Methode erzwingt diese Anforderungen (und anderen dar, die im Abschnitt für Ausnahmen). Wenn Sie unterschiedliche Prüfungsanforderungen für Ihren benutzerdefinierten STS erzwingen müssen, können Sie diese Methode überschreiben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> is <see langword="null" />.  -or-  The <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> property of the request is not set to <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  -or-  The <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> property of the request is not <see langword="null" /> or one of the constants defined in the <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" /> class.  -or-  The <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> of the request is <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> and the <see langword="KeySize" /> element is present, but its value is not equal to zero.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">The STS does not support the request token type (based on the value of the <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> property of the request).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>