<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49a0ab5f150cc09113681aed718c286d237b6643" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52603581" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Die abstrakte Basis-Klasse, die die Eigenschaften und Methoden eines Sicherheitstokendiensts (STS) definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellen Sie einen STS durch Ableiten von der <xref:System.IdentityModel.SecurityTokenService> Klasse. In Ihre benutzerdefinierte Klasse müssen mindestens überschreiben Sie die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> und <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methoden. Der STS erstellt haben, verwenden die standardmäßige Implementierung von den Methoden in der Klasse definiert wird mit diese überschreibungen auf kann Ausstellen von Sicherheitstoken in Reaktion auf Sicherheitsprobleme tokenanforderungen (RST). Die Issue-Bindung, die in der WS-Trust-Spezifikation definiert wird, also wie folgt implementiert. Diese Bindung wird implementiert, der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Keine der anderen WS-Trust-Bindungen (erneuern, Abbrechen und überprüfen) werden im Standardfall implementiert und ein entsprechenden Fehler wird an den Aufrufer zurückgegeben, wenn eine RST an, die eine dieser Anbindungen entspricht, gefunden wird. Sie können natürlich die entsprechenden Methoden überschreiben (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, und <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) diese Bindungen in Ihr STS zu implementieren.  
  
> [!IMPORTANT]
>  Implementieren eine produktionsbereite STS erfordert eine sorgfältige Planung und beträchtliche Ressourcen zur Verringerung der potenziellen Sicherheitsrisiken, die sich einen solchen Dienst verfügbar zu machen. Die meisten Entwickler, die mit Windows Identity Foundation (WIF) werden Entwickeln von Anwendungen, die identitätsverwaltung zu einem Sicherheitstokendienst auszulagern, anstatt einen STS selbst entwickeln. WIF bietet Visual Studio-Erweiterung, die Identitäts- und Zugriffs-Tool für Visual Studio 2012, Entwickler, die Lösungen in der Entwicklungsumgebung testen können. Dieses Tool enthält einen STS, `LocalSTS`, die Sie konfigurieren können, um bestimmte Ansprüche an die Anwendung zu verarbeiten, die Sie entwickeln. Weitere Informationen zum Identitäts- und Zugriffs-Tool finden Sie unter [Identitäts- und Zugriffstool für Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). In einigen Szenarien `LocalSTS` möglicherweise nicht die erforderlichen Funktionen zur angemessen Testen Ihrer Anwendung bereit, z. B., einen benutzerdefinierten Tokenhandler für die Verwendung von einer Anwendung in einem Szenario, bei der, Entwicklung. In diesen Fällen ist es sind ableitungen von <xref:System.IdentityModel.SecurityTokenService> erstellen Sie eine oder mehrere einfache Sicherheitstokendienste (STS), die in der Entwicklungsumgebung bereitgestellt werden kann und die, die verwendet werden kann, um solche Features in Ihrer Anwendung zu testen. Im restlichen Teil dieses Abschnitts schwerpunktmäßig das vom verfügbar gemachten Methoden der <xref:System.IdentityModel.SecurityTokenService> Klasse, mit denen Sie eine einfache STS implementieren, und erweitern die Pipeline für die Ausstellung von token.  
  
 Die folgende Liste bietet eine kurze Übersicht über die Methoden der primären Bedeutung für dem Entwickler für die Verwendung in einer Test- oder Entwicklungsumgebung-Umgebung.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> -Methode. Diese Methode gibt eine <xref:System.IdentityModel.Scope> -Objekt, das Informationen über die vertrauende Seite enthält. Dieses Objekt wird in der Rest der Pipeline tokenausstellung verwendet und enthält Informationen über das Signieren und Verschlüsseln von Anmeldeinformationen in der Antwort verwenden, sowie die `AppliesTo` und `ReplyTo` (falls erforderlich) Adressen. Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode. Diese Methode gibt ein <xref:System.Security.Claims.ClaimsIdentity> -Objekt, das die Ansprüche an die RP zurückzugebenden enthält. Sie müssen diese Methode überschreiben.  
  
-   Die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> -Methode. Diese Methode implementiert die tokenanforderung-Pipeline, verarbeitet eine eingehende sicherheitstokenanforderung (RST) und gibt eine Antwort (RSTR) an den Aufrufer, der ein Token enthält, die für die Authentifizierung bei einer RP verwendet werden können. Viele der anderen Methoden definiert, der <xref:System.IdentityModel.SecurityTokenService> Klasse von dieser Methode aufgerufen werden einschließlich der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> und <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methoden. Sie müssen keine diese Methode überschreiben, aber ein Überblick über die Anforderung eines Zugriffstokens-Pipeline, die er implementiert, kann hilfreich sein.  
  
 Ein STS wird konfiguriert, über die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> Klasse.  
  
   
  
## Examples  
 Die Codebeispiele, die in verwendet werden die <xref:System.IdentityModel.SecurityTokenService> Themen stammen aus der `Custom Token` Beispiel. Dieses Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen, und enthält eine Implementierung eines passiven STS, die der ein SWT-Token bereitstellen kann. Ein Beispiel für ein aktives STS implementieren, finden Sie unter den `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code zeigt die Implementierung eines passiven STS über die <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Der folgende Code zeigt, wie Sie einen benutzerdefinierten passiven STS zum Verarbeiten einer WS-Verbund-Anforderung durch Aufrufen von Aufrufen der <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> Methode aus der Code-behind in die `default.aspx.cs` Datei.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Sie müssen beide überschreiben die <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> und <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> Methoden.</para></block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">Eine <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />, die die Einstellungen für den STS enthält.</param>
        <summary>Aufgerufen von abgeleiteten Klassen, um die <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse mit der angegebenen Konfigurationseinstellungen zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um bereichsanbieter und Tokenaussteller Zertifikat zu initialisieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="securityTokenServiceConfiguration" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Schließvorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Abbruchvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Cancel-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Abbruchvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="scope">Der <see cref="T:System.IdentityModel.Scope" />, der Informationen über die abhängige Partei enthält, die der Anforderung zugeordnet ist.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Vorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Vorgang zugeordnet sind.</param>
        <summary>Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />-Methode ein.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" />-Einstellung, die auf den asynchronen Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Vorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Vorgang zugeordnet sind.</param>
        <summary>Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf für die <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Methode ein.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Abbruchvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Herausgabevorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Ausstellungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Issue-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf die asynchrone Herausgabe verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung über den Abschluss des asynchronen Erneuern-Vorgangs empfängt.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Erneuerungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Renew-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Erneuerungsvorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat, der die Benachrichtigung erhält, dass der asynchrone Validierungsvorgang abgeschlossen wurde.</param>
        <param name="state">Ein Objekt mit den Zustandsinformationen, die dem asynchronen Validierungsvorgang zugeordnet sind.</param>
        <summary>Beginnt beim Überschreiben in einer abgeleiteten Klasse eine asynchrone WS-Trust-Validate-Anforderung.</summary>
        <returns>Das <see cref="T:System.IAsyncResult" />, das auf den asynchronen Validierungs-Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Cancel-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Die eingehende Tokenanforderung.</param>
        <param name="scope">Das von <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> zurückgegebene <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Objekt.</param>
        <summary>Erstellt eine Instanz eines <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>Die <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, während der tokenausstellung nach <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="scope" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Cancel-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />-Methode ab.</summary>
        <returns>Ein <see cref="T:System.Security.Claims.ClaimsIdentity" />, das die Sammlung von Ansprüchen enthält, die in das ausgestellte Sicherheitstoken eingefügt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Scope" />, das die Informationen der vertrauenden Seite (RP) kapselt, die der Anforderung (RST) zugeordnet ist, die im Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode angegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Issue-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Renew-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Das <see cref="T:System.IAsyncResult" />, das von einem Aufruf der <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />-Methode zurückgegeben wird.</param>
        <summary>Schließt beim Überschreiben in einer abgeleiteten Klasse die asynchrone WS-Trust-Validate-Anforderung ab.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Namen des Sicherheitstokendienst (STS) ab.</summary>
        <returns>Der Ausstellername.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der Standardeinstellung token anspruchsausstellungs-Pipeline implementiert wird, in der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 Die Standardimplementierung gibt das <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> Eigenschaft aus der Konfiguration erfolgt über die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <param name="scope">Der <see cref="T:System.IdentityModel.Scope" />, der Informationen über die abhängige Partei enthält, die der Anforderung zugeordnet ist. Dies ist das <see cref="T:System.IdentityModel.Scope" />-Objekt, das von der <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />-Methode zurückgegeben wurde.</param>
        <summary>Wenn sie in einer abgeleiteten Klasse überschrieben wird, gibt diese Methode eine Auflistung von Ausgabebetreffs zurück, die in das ausgestellte Token eingeschlossen werden sollen.</summary>
        <returns>Ein <see cref="T:System.Security.Claims.ClaimsIdentity" />, das die Sammlung von Ansprüchen enthält, die in das ausgestellte Sicherheitstoken eingefügt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Methode wird aufgerufen, aus der Ausstellung von token-Pipeline, die von implementiert ist die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Gibt eine <xref:System.Security.Claims.ClaimsIdentity> , enthält die Ansprüche in das ausgestellte Sicherheitstoken auf Grundlage der anforderer des Tokens eingeschlossen werden sollen (die `principal` Parameter), eingehender RST (die `request` Parameter), und die vertrauende Seite für die das Token ist für die Verwendung ( die `scope` Parameter). Die Logik in dieser Methode betrifft in erster Linie die folgenden Fragen beantworten:  
  
-   **Die claim-Typen sollten in der Antwort basierend auf die vertrauende Seite für die es bestimmt ist enthalten sein?** Dies ist in der Regel auf einer pro-RP-Basis aus Listen von Anspruchstypen, die für jede vertrauende Seite erforderlich sind oder auf einer Basis pro Anforderung sich entschieden, anhand der <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> Eigenschaft in der Anforderung. Die Logik und die Details zum bestimmen die Ansprüche in der Antwort eingeschlossen ist jedoch vollständig bis zu Ihrer Implementierung.  
  
-   **Die Anspruchswerte sollten die Ansprüche in der Antwort zugewiesen werden?** Für einen Identitätsanbieter (IP-STS) in der Regel bedeutet dies eine oder mehrere Ansprüche in der anfordernden Person verwenden <xref:System.Security.Claims.ClaimsPrincipal> (bereitgestellt von der `principal` Parameter) den Zugriff auf einen Speicher (oder anderen Entitäten) zum Zurückgeben von Werten für die erforderlichen Anspruchstypen. Für einen Verbund-Anbieter (R-STS) bedeutet dies in der Regel eine Art von Verarbeitung ausgeführt, für eingehende Ansprüche des anforderers, zur Verarbeitung der Anforderung; Ausführen von z. B. filtern oder die Transformation für einige Ansprüchen vom anforderer, wobei Sie dritten über unverändert übergeben. Wie bei der Entscheidung, welche Ansprüche in der Antwort enthalten, ist die Details und die Logik der Vorgehensweise: Bestimmen Sie die Werte dieser Ansprüche natürlich bis zu Ihrer Implementierung.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema werden stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen, und enthält eine Implementierung eines passiven STS, die der ein SWT-Token bereitstellen kann. Ein Beispiel für ein aktives STS implementieren, finden Sie unter den `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md). Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode zur Rückgabe von Ansprüchen für Ihren STS. In diesem Beispiel die Request Security Token (RST)-Nachricht wird ignoriert, und eine Sammlung von Ansprüchen basierend auf dem Benutzer, die an den STS authentifiziert wird zurückgegeben.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Tokenanforderung (RST) darstellt.</param>
        <param name="scope">Die <see cref="T:System.IdentityModel.Scope" />-Instanz, die Informationen über die abhängige Partei kapselt.</param>
        <summary>Ruft das Prüftoken ab, das in der Antwort enthalten sein soll (RSTR).</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" />, der den neu erstellten Proof-Deskriptor darstellt. Der Proof-Deskriptor kann ein asymmetrischer oder ein symmetrischer Proof-Deskriptor sein, oder <see langword="null" /> im Falle eines Bearer-Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der Standardeinstellung token anspruchsausstellungs-Pipeline implementiert wird, in der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 Die Standardimplementierung gibt einen Proof-Deskriptor zurück oder löst eine entsprechende Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="scope" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Tokenanforderung (RST) darstellt.</param>
        <summary>Ruft den Beweis der Verschlüsselungsanmeldeinformationen des Anfordernden ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" />-Objekt, das die verschlüsselnden Anmeldeinformationen des Anfordernden darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> Methode.  
  
 Die Standardimplementierung führt Folgendes aus. Gibt `null` es ist keine Verschlüsselungstoken, die in der Anforderung angegeben (der <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> Eigenschaft `null`). Wenn sie das Token als erhalten kann, andernfalls ein <xref:System.IdentityModel.Tokens.X509SecurityToken>, Anmeldeinformationen, die anhand des Token zurückgegeben. Wenn sie das Token als nicht auflösen kann ein <xref:System.IdentityModel.Tokens.X509SecurityToken>, <xref:System.IdentityModel.RequestFailedException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">Der RST, der die Token-Anforderung enthält.</param>
        <param name="tokenDescriptor">Der Tokendeskriptor, der die zu verwendenden Informationen für das ausgestellte Token enthält.</param>
        <summary>Erstellt die Antwort (RSTR) die das ausgestelltes Token enthält, indem der angegebene Deskriptor der Anforderung (RST) und des Sicherheitstoken verwendet wird.</summary>
        <returns>Die Antwort (RSTR) oder <see langword="null" />, wenn eine Antwort nicht von der angegebenen Anforderungen und dem Tokendeskriptor erstellt werden kann. Die Standardimplementierung gibt <see langword="null" /> zurück, wenn der <paramref name="tokenDescriptor" />-Parameter <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Methode als der letzte Schritt aufgerufen wird, aus der Ausstellung von token-Pipeline, die von implementiert ist die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode. Erstellt und gibt die Antwort (RSTR) mithilfe der ursprünglichen eingehende Anforderung (RST) und der Deskriptor des Tokens, der während der vorherigen Schritte in der Pipeline für die tokenausstellung aufgebaut wurde.  
  
 Die Standardimplementierung erstellt das RSTR durch Übergeben des RST angegeben, in dem-Parameter, die <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> -Konstruktor aufrufen der <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> Methode für die token-Deskriptors übergebenen <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> anzuwendende zugehörigen Eigenschaften, um die neu erstellt RSTR, Festlegen der <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> Eigenschaft für das RSTR mithilfe der <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> Eigenschaft der tokendeskriptor, und schließlich die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> Eigenschaft des RSTR gemäß der folgenden Tabelle:  
  
|`RST.ReplyTo` -Eigenschaft|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>-Eigenschaft.|`RSTR.ReplyTo` -Eigenschaft|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|Nicht festgelegt|Nicht festgelegt|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Nicht festgelegt|Set|Nicht festgelegt|  
|Nicht festgelegt|Nicht festgelegt|Nicht festgelegt|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, der den Client darstellt, von dem die Anforderung stammt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die eingehende Anforderung (RST) darstellt.</param>
        <summary>Ruft ein <see cref="T:System.IdentityModel.Scope" />-Objekt ab, das Informationen über die vertrauende Seite enthält, die der angegebenen Anforderung zugeordnet ist. In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Scope" />, die RP-Informationen kapselt, die der Anforderung zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode wird aufgerufen, aus der tokenausstellung Pipeline nach der <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode und zurückgeben sollte eine <xref:System.IdentityModel.Scope> Objekt, das für die eingehende Anforderung konfiguriert. (Die tokenausstellung Pipeline wird implementiert, der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.) Die <xref:System.IdentityModel.Scope> Objekt kapselt Informationen über die vertrauende Seite die sicherheitstokenanforderung (RST) zugeordnet. Dies umfasst Informationen zu den Anmeldeinformationen verschlüsselnden und signieren, die mit der Anwendung der vertrauenden Seite und ob zum Verschlüsseln aller ausgestellten Token und/oder der symmetrische Schlüssel in der Antwort verwendet werden. Einige typische Aufgaben, die in der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methode sind:  
  
-   Bestimmen Sie, ob die vertrauende Seite für den das Token vorgesehen ist, eine anerkannten vertrauenden Seite ist. Wie dies erreicht wird, hängt von Ihrer Implementierung ab. Wenn die beabsichtigte vertrauende Seite keine gültige vertrauende Seite für dieses STS, sollte die Methode Auslösen einer <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Zu bestimmen, die Signatur Anmeldeinformationen zur Verwendung in der Antwort (RSTR) und legen Sie die <xref:System.IdentityModel.Scope.SigningCredentials%2A> Eigenschaft entsprechend.  
  
-   Bestimmen Sie, ob der Antwort- und/oder enthalten symmetrische Schlüssel verschlüsselt werden soll und die Anmeldeinformationen für die Verschlüsselung verwendet werden. Legen Sie die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, und <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> Eigenschaften entsprechend.  
  
    > [!IMPORTANT]
    >  In der Standardeinstellung die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> und <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> Eigenschaften werden festgelegt, `true` um zu verhindern, dass der STS Ausstellen von Token, die nicht sicher sind. Es wird empfohlen, diese Eigenschaften nie festgelegt werden, um `false` in einer produktionsumgebung.  
  
-   Bestimmen Sie die Adresse, zu der die Antwort zurückgegeben werden sollen. Legen Sie entweder die <xref:System.IdentityModel.Scope.AppliesToAddress%2A> oder <xref:System.IdentityModel.Scope.ReplyToAddress%2A> Eigenschaft entsprechend.  
  
   
  
## Examples  
 Das Codebeispiel, das in diesem Thema werden stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen, und enthält eine Implementierung eines passiven STS, die der ein SWT-Token bereitstellen kann. Ein Beispiel für ein aktives STS implementieren, finden Sie unter den `Federation Metadata` Beispiel. Weitere Informationen zu diesen Beispielen und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 Im folgenden Codebeispiel wird eine Implementierung der <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>-Methode veranschaulicht. Diese Implementierung stellt sicher, dass vom STS, die RP erkannt wird, überprüft der <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> Adresse in der Anforderung und legt die <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> Eigenschaft entsprechend, und legt das Signieren und Verschlüsseln von Anmeldeinformationen für die Verwendung mit der Anwendung der vertrauenden Seite basierend auf Zertifikaten, in der Datei sind hartcodiert.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>In Ihrer Implementierung der <see cref="T:System.IdentityModel.SecurityTokenService" />-Klasse müssen Sie diese Methode überschreiben.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Eine Zeichenfolge, die den URI des angeforderten Tokentyps enthält.</param>
        <summary>Ruft den entsprechenden Sicherheitstokenhandler zum Ausgeben eines Sicherheitstoken des angegebenen Typs ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> der den zur Erstellung des ausgegebenen Sicherheitstoken verwendeten Tokenhandler darstellt. Gibt <see langword="null" /> zurück, wenn der angeforderte Tokentyp nicht unterstützt wird (es gibt keinen Handler, die für den angegebenen Tokentyp konfiguriert ist).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardimplementierung Wenn `requestedTokenType` ist `null` oder eine leere Zeichenfolge, die standardmäßig Tokentyp aus der Konfiguration verwendet wird. Dadurch wird angegeben, indem die <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> -Eigenschaft des STS-Konfigurationsobjekts erfolgt über die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> Eigenschaft.  
  
 Diese Methode wird aufgerufen, von der Standardeinstellung token anspruchsausstellungs-Pipeline implementiert wird, in der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />-Element, das die angeforderte Lebensdauer darstellt.</param>
        <summary>Ruft die Lebensdauer für das ausgestellte Token ab.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />, das die gewährten Lebensdauer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird normalerweise mit der Lebensdauer aufgerufen, die in das RST eingetroffen sind. In der Standardimplementierung wird die Lebensdauer des Tokens anhand der folgenden Tabelle berechnet.  
  
|Erstellt (in)|Läuft ab (in)|Erstellt (in)|Läuft ab (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Diese Methode wird aufgerufen, von der Standardeinstellung token anspruchsausstellungs-Pipeline implementiert wird, in der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Erstellt ein Sicherheitstoken.</summary>
        <returns>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das ausgestellte Sicherheitstoken enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die Issue-Bindung, die in der WS-Trust-Spezifikation definiert. Die standardmäßige Implementierung der <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode verarbeitet die eingehende Anforderung (RST) über eine Pipeline für die Ausstellung von token (Ausstellung von Ansprüchen) und gibt entweder eine Antwort (RSTR), die ein Sicherheitstoken mit den entsprechenden Ansprüchen Authentifizierung enthält der der anforderer die vertrauende Seite oder eine entsprechende Ausnahme. Die Ausstellung von token-Pipeline in der Standardimplementierung besteht aus Aufrufe der folgenden Methoden (der die <xref:System.IdentityModel.SecurityTokenService> Klasse).  
  
1.  Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode zum Überprüfen der Anforderung (RST).  
  
2.  Die <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> -Methode zum Abrufen einer <xref:System.IdentityModel.Scope> -Objekt, das Informationen über die abhängige Partei (RP), die mit der Anforderung verknüpften enthält. Sie müssen diese Methode überschreiben. Wenn <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> gibt `null`, <xref:System.InvalidOperationException> ausgelöst.  
  
3.  Die <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> -Methode zur Rückgabe einer Sicherheitsbeschreibung token auf der Grundlage von RST und <xref:System.IdentityModel.Scope> -Objekt, die im vorherigen Schritt zurückgegeben. Der sicherheitstokendeskriptor (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) enthält Informationen über die Anforderung in ein Formular, das von einem token Handler verwendet werden kann. Die <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> -Eigenschaftensatz auf den Deskriptor, der durch den Aufruf zurückgegeben wird. Wenn `null` wird zurückgegeben, oder wenn die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> -Eigenschaft des Deskriptors ist `null`, eine <xref:System.InvalidOperationException> ausgelöst. Die Ausnahme wird auch ausgelöst, wenn die <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> Eigenschaft `true` jedoch <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> -Eigenschaft in der zurückgegebenen Deskriptor ist `null`.  
  
4.  Die <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> -Methode zum Abrufen von des entsprechenden Tokenhandler auf Grundlage der Art des angeforderten Tokens. Wenn `null` zurückgegeben wird, eine <xref:System.NotImplementedException> ausgelöst.  
  
5.  Die <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> Methode, um den Ausstellernamen für das Token abzurufen. Löst ein <xref:System.InvalidOperationException> ist der Name `null` oder leer ist; andernfalls der <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> Eigenschaft für den Deskriptor.  
  
6.  Die <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> -Methode zum Abrufen der Lebensdauer für das Token und legt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> Eigenschaft für den Deskriptor.  
  
7.  Die <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> -Methode zum Abrufen des prüftokens sollen im ausgestellten Token und legt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> Eigenschaft für den Deskriptor.  
  
8.  Die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> -Methode zum Abrufen von Forderungen an den enthalten im ausgestellten Token und legt die <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> Eigenschaft für den Deskriptor. Sie müssen diese Methode überschreiben.  
  
9. Die <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> Methode, um eine Antwort (RSTR) zu erstellen, die das ausgestellte Token enthält.  
  
 Können Sie überschreiben die <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode zum Implementieren einer benutzerdefinierten tokenausstellungs-Pipeline, die in der Regel nicht erforderlich, in der Entwicklungs- und testumgebungen für die meisten benutzerdefinierten Implementierungen des ist jedoch die <xref:System.IdentityModel.SecurityTokenService> Klasse vorgesehen sind. In vielen Fällen überschreiben Sie die <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> und <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Methoden optional außer Kraft setzen, und die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode, um eines zu wartenden STS für Ihre Umgebung bereitzustellen. Wenn die weitere Anpassung erforderlich ist können Sie häufig bereitstellen sie durch Überschreiben der Methoden, die jeder Phase des Standards zu, die token anspruchsausstellungs-Pipeline implementieren oben aufgeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den Prinzipal, der der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, der den aktuellen Prinzipal darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Renew-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt die Sicherheitstokenanforderung (RST), die der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Anforderung enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den Scope, der der aktuellen Instanz zugeordnet ist.</summary>
        <value>Ein <see cref="T:System.IdentityModel.Scope" />, das die Konfiguration für die Anforderung der Tokenausstellung darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Übernimmt oder bestimmt den <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" />, der mit der aktuellen Instanz verknüpft ist.</summary>
        <value>Der Sicherheitstokendeskriptor, der der aktuellen Instanz zugeordnet ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die Eigenschaft auf <see langword="null" /> festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Besitzerkonfigurationsinstanz ab.</summary>
        <value>Eine <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />, die die Konfiguration für die aktuelle Instanz enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Ein <see cref="T:System.Security.Claims.ClaimsPrincipal" />, das die ID des angegebenen Tokenanforderers darstellt.</param>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Sicherheitstokenanforderung darstellt. Dies schließt die Anforderungsnachricht sowie andere Client-Informationen wie den Kontext der Autorisierung ein.</param>
        <summary>Verarbeitet beim Überschreiben in einer abgeleiteten Klasse eine WS-Trust-Validate-Anforderung.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />, das das RSTR darstellt, die an den Aufrufer zurückgegeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode löst eine <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Ein <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />, das die Anforderung darstellt.</param>
        <summary>Überprüft die von dieser Instanz gekapselten Sicherheitstokenanforderungen (RST).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> Methode wird aufgerufen, aus der Pipeline für die Ausstellung von token (das <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Methode) zum Überprüfen eingehenden RST. Das Anforderungssicherheitstoken wird überprüft, auf die Anforderungen der STS (Richtlinie) und eine entsprechende Ausnahme wird ausgelöst, wenn er nicht gültig ist.  
  
 Die standardmäßige Implementierung der <xref:System.IdentityModel.SecurityTokenService> Klasse unterstützt nur das RST-RST-Antwort-Muster und nur die Issue-Bindung der WS-Trust-Spezifikation (die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> Eigenschaft in der Anforderung muss festgelegt werden, um <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). Die Standardimplementierung dieser Methode erzwingt diese Anforderungen (und andere im Abschnitt mit Ausnahmen angegeben). Sie können diese Methode überschreiben, wenn Sie unterschiedliche Prüfungsanforderungen für einen benutzerdefinierten STS erzwingen müssen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException"><paramref name="request" /> ist <see langword="null" />.  
  
- oder -  
Die <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" />-Eigenschaft der Anforderung ist nicht auf <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" /> festgeleget.  
  
- oder -  
Die <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" />-Eigenschaft der Anforderung ist weder <see langword="null" /> noch eine der Konstanten, die in der <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />-Klasse definiert sind.  
  
- oder -  
Der <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> der Anforderung ist <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> und das <see langword="KeySize" />-Element ist vorhanden, aber sein Wert ist ungleich 0 (null).</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">Der STS unterstützt den Anforderungstokentyp nicht (auf Grundlage des Werts der <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" />-Eigenschaft der Anforderung).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>