<Type Name="GCSettings" FullName="System.Runtime.GCSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2d2cde492a3b619d561500efc4faca310b9f333b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37627603" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GCSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GCSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.GCSettings" />
  <TypeSignature Language="VB.NET" Value="Public Class GCSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class GCSettings abstract sealed" />
  <TypeSignature Language="F#" Value="type GCSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Specifies the garbage collection settings for the current process.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.GCSettings.IsServerGC%2A> Eigenschaft, um zu bestimmen, ob die Garbagecollection für Server für den aktuellen Prozess aktiviert ist.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsServerGC">
      <MemberSignature Language="C#" Value="public static bool IsServerGC { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsServerGC" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.IsServerGC" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsServerGC As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsServerGC { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServerGC : bool" Usage="System.Runtime.GCSettings.IsServerGC" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether server garbage collection is enabled.</summary>
        <value>
          <see langword="true" />, wenn die Garbage Collection für Server aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zur Garbagecollection für Server, finden Sie im Abschnitt "Arbeitsstation und Garbage Collection auf dem Server" im [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).  
  
 Wenn der Garbagecollection auf dem Server nicht aktiviert ist, ist die Garbagecollection auf Arbeitsstationen in Kraft (mit oder ohne gleichzeitigen Auflistung). Garbagecollection auf dem Server ist nur auf Computern mit mehreren Prozessoren verfügbar.  
  
 Ein nicht verwalteter Host kann Garbagecollection für Server anfordern, und die Host-Anforderung überschreibt Einstellungen in der Konfigurationsdatei. Wenn der Host nicht den Typ der Garbagecollection angibt, können Sie eine Konfigurationseinstellung für die Datei, an die Garbagecollection auf dem Server. Diese Einstellung gilt nur in der Anwendungskonfigurationsdatei verwendet werden, nicht in der Computerkonfigurationsdatei (finden Sie unter [Konfigurieren von Apps](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)). Das folgende Beispiel zeigt den Inhalt einer Beispiel-Anwendungskonfigurationsdatei, die Garbagecollection auf dem Server ermöglicht.  
  
```  
<configuration>  
  <runtime>  
    <gcServer enabled="true" />  
  </runtime>  
</configuration>  
```  
  
   
  
## Examples  
 Im folgende Beispiel gibt an, ob der Host-Computer auf Server oder Garbagecollection auf Arbeitsstationen verwendet wird.  
  
 [!code-csharp[Environment.IsServerGC#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.IsServerGC/CS/isg.cs#1)]
 [!code-vb[Environment.IsServerGC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.IsServerGC/VB/isg.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LargeObjectHeapCompactionMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargeObjectHeapCompactionMode As GCLargeObjectHeapCompactionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { System::Runtime::GCLargeObjectHeapCompactionMode get(); void set(System::Runtime::GCLargeObjectHeapCompactionMode value); };" />
      <MemberSignature Language="F#" Value="member this.LargeObjectHeapCompactionMode : System.Runtime.GCLargeObjectHeapCompactionMode with get, set" Usage="System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLargeObjectHeapCompactionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supported in the .NET Framework 4.5.1 and later versions]  Gets or sets a value that indicates whether a full blocking garbage collection compacts the large object heap (LOH).</summary>
        <value>Einer der Enumerationswerte, der angibt, ob eine vollständige blockierende Garbage Collection den großen Objektheap komprimiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der große Objektheap dient zur Zuteilung von Arbeitsspeicher für große Objekte (z. B. Arrays), die mehr als 85.000 Byte erfordern. Aufgrund der Auswirkungen auf die Leistung des Kopierens große Speicherblöcke führt ein Sweep der Garbage Collector normalerweise den großen Objektheap, dies erfordert, erstellen eine Liste mit den Speicherorten, die von inaktiven Objekten belegt wurden und die, die wiederverwendet werden kann, um zukünftige Anforderungen zu erfüllen Zuordnung von Arbeitsspeicher für große Objekte. Allerdings in apps, die umfangreiche Verwenden des großen Objektheaps zum Speichern von flüchtigen Objekten, Speicher, dass die Fragmentierung auch negativ auf die Leistung auswirken kann. In diesem Fall ist es möglich, verwenden Sie die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> Eigenschaft anstatt einfach Sweep des großen Objektheaps während einer Garbagecollection komprimiert.  
  
 Der Standardwert der <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> Eigenschaft <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>, was bedeutet, dass der große Objektheap nicht, während der Garbage collection komprimiert wird. Wenn Sie den Wert der Eigenschaft zuweisen <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, während der nächsten vollständigen blockierenden Garbagecollection der großen Objektheap komprimiert wird und auf den Wert der Eigenschaft zurückgesetzt <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Garbage Collections im Hintergrund werden nicht blockiert. Dies bedeutet, dass, wenn Sie festlegen, die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> Eigenschaft <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>alle Hintergrund- Generation 2 Sammlungen, die später auftreten, führen Sie den großen Objektheap nicht komprimiert. Nur die erste blockierende Generation 2 Collection den großen Objektheap komprimiert.  
  
 Nach der <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> -Eigenschaftensatz auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, die nächste vollständige blockierende Garbagecollection (und die Komprimierung des großen Objektheaps) tritt auf, zu einer unbestimmten späteren Zeitpunkt. Sie können sofort den großen Objektheap komprimieren, mithilfe von Code wie folgt:  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.GCLargeObjectHeapCompactionMode" />
      </Docs>
    </Member>
    <Member MemberName="LatencyMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLatencyMode LatencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLatencyMode LatencyMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LatencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LatencyMode As GCLatencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLatencyMode LatencyMode { System::Runtime::GCLatencyMode get(); void set(System::Runtime::GCLatencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.LatencyMode : System.Runtime.GCLatencyMode with get, set" Usage="System.Runtime.GCSettings.LatencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLatencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current latency mode for garbage collection.</summary>
        <value>Einer der Enumerationswerte, der den Latenzmodus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Ebene der Ausmaß der Garbagecollection in Ihrer Anwendung verringern, indem die <xref:System.Runtime.GCLatencyMode> zu <xref:System.Runtime.GCLatencyMode.LowLatency> bei wichtigen Vorgängen. Wenn solche Vorgänge abgeschlossen wurden, zum höheren Latenzmodus zurück, damit mehr Objekte freigegeben werden können, um Arbeitsspeicher zu erhöhen.  
  
 Normalerweise legen Sie den Wert der die <xref:System.Runtime.GCSettings.LatencyMode%2A> Eigenschaft, die der Garbage collection-Latenzmodus definiert. Allerdings nicht den Latenzmodus ohne GC-Region durch Zuweisen von Festlegen der <xref:System.Runtime.GCLatencyMode.NoGCRegion?displayProperty=nameWithType> Enumerationswert, der <xref:System.Runtime.GCSettings.LatencyMode%2A> Eigenschaft. Stattdessen rufen Sie die <xref:System.GC.TryStartNoGCRegion%2A?displayProperty=nameWithType> Methode damit beginnt, den Latenzmodus ohne GC-Region, und Sie rufen die <xref:System.GC.EndNoGCRegion%2A?displayProperty=nameWithType> um ihn zu beenden.  
  
 Finden Sie unter [Latenzmodi](~/docs/standard/garbage-collection/latency.md) eine Erläuterung der Auswirkungen der Common Language Runtime-Konfigurationseinstellungen für die Garbagecollection auf des Standardwerts der <xref:System.Runtime.GCLatencyMode> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property is being set to an invalid value.  -or-  The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property cannot be set to <see cref="F:System.Runtime.GCLatencyMode.NoGCRegion" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>