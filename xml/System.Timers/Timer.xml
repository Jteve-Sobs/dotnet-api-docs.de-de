<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2483b13115f709c891ae64fffbeed30c28faf0e" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56405396" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generiert nach Ablauf eines festgelegten Intervalls ein Ereignis. Bietet auch die Option zum Generieren wiederkehrender Ereignisse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer>-Komponente ist ein serverbasierter Timer, der nach Verstreichen der in der <xref:System.Timers.Timer.Interval%2A>-Eigenschaft angegebenen Zeit (in Millisekunden) ein <xref:System.Timers.Timer.Elapsed>-Ereignis in Ihrer Anwendung auslöst. Sie können das <xref:System.Timers.Timer>-Objekt mit der <xref:System.Timers.Timer.AutoReset%2A>-Eigenschaft so konfigurieren, dass es das Ereignis nur einmal oder wiederholt auslöst. Normalerweise wird ein <xref:System.Timers.Timer>-Objekt so auf Klassenebene deklariert, dass es im Gültigkeitsbereich verbleibt, solange es benötigt wird. Sie können das zugehörige <xref:System.Timers.Timer.Elapsed>-Ereignis dann behandeln, um eine zyklische Verarbeitung zu ermöglichen. Nehmen wir beispielsweise an, Sie haben einen kritischen Server, der rund um die Uhr in Betrieb gehalten werden muss. Hierfür könnten Sie einen Dienst erstellen, der den Server mithilfe eines <xref:System.Timers.Timer>-Objekts in regelmäßigen Abständen periodisch überprüft und sicherstellt, dass das System fehlerfrei ausgeführt wird. Falls das System nicht reagiert, könnte der Dienst versuchen, den Server neu zu starten, oder einen Administrator benachrichtigen.  
  
> [!IMPORTANT]
> Die <xref:System.Timers.Timer>-Klasse ist nicht für alle .NET-Implementierungen und -Versionen verfügbar, beispielsweise nicht für .NET Standard 1.6 und älter.
> In diesen Fällen können Sie stattdessen die <xref:System.Threading.Timer?displayProperty=nameWithType>-Klasse verwenden.
  
 Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Die serverbasierte <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse ist für die Verwendung mit Workerthreads in einer Multithreadumgebung konzipiert. Servertimer können threadübergreifend eingesetzt werden, um das ausgelöste <xref:System.Timers.Timer.Elapsed>-Ereignis zu behandeln. Hierdurch wird eine im Vergleich zu Windows-Timern größere Genauigkeit beim rechtzeitigen Auslösen des Ereignisses erzielt.  
  
 Die <xref:System.Timers.Timer?displayProperty=nameWithType>-Komponente löst basierend auf dem Wert der Eigenschaft <xref:System.Timers.Timer.Interval%2A> (in Millisekunden) das <xref:System.Timers.Timer.Elapsed>-Ereignis aus. Sie können dieses Ereignis behandeln, um die erforderliche Verarbeitung durchzuführen. Angenommen, Sie haben eine Anwendung für den Onlinevertrieb entwickelt, die fortlaufend Kundenaufträge an eine Datenbank sendet. Der Dienst, der die Versandanweisungen zusammenstellt, bearbeitet immer mehrere Aufträge gleichzeitig statt jedes Auftrags einzeln. Mit einem <xref:System.Timers.Timer> könnten Sie die Batchverarbeitung alle 30 Minuten starten.  
  
> [!IMPORTANT]
>  Die System.Timers.Timer-Klasse hat die gleiche Auflösung wie die Systemuhr. Das bedeutet, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis in einem durch die Auflösung der Systemuhr definierten Intervall ausgelöst wird, wenn die <xref:System.Timers.Timer.Interval%2A>-Eigenschaft kleiner als die Systemuhrauflösung ist. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Timers.Timer.Interval%2A>-Eigenschaft.  
  
 Wenn <xref:System.Timers.Timer.AutoReset%2A> auf `false` festgelegt ist, löst ein <xref:System.Timers.Timer?displayProperty=nameWithType>-Objekt das <xref:System.Timers.Timer.Elapsed>-Ereignis nach dem Verstreichen des ersten <xref:System.Timers.Timer.Interval%2A> nur einmalig aus. Damit das <xref:System.Timers.Timer.Elapsed>-Ereignis regelmäßig in dem durch <xref:System.Timers.Timer.Interval%2A> definierten Intervall ausgelöst wird, legen Sie <xref:System.Timers.Timer.AutoReset%2A> auf `true` fest. Dies entspricht auch dem Standardwert.  
  
 Die <xref:System.Timers.Timer>-Komponente fängt alle Ausnahmen, die von Ereignishandlern für das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst werden, ab und unterdrückt sie. Dieses Verhalten kann sich in zukünftigen .NET Framework-Versionen ändern. Beachten Sie jedoch, dass dies nicht für Ereignishandler gilt, die asynchron ausgeführt werden und den Operator `await` (in C#) bzw. `Await` (in Visual Basic) enthalten. Ausnahmen, die in diesen Ereignishandlern ausgelöst werden, werden wie im folgenden Beispiel veranschaulicht an den aufrufenden Thread übermittelt. Weitere Informationen zu Ausnahmen, die in asynchronen Methoden ausgelöst werden, finden Sie unter [Ausnahmebehandlung](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Wenn die <xref:System.Timers.Timer.SynchronizingObject%2A>-Eigenschaft `null` ist, wird das <xref:System.Timers.Timer.Elapsed>-Ereignis für einen <xref:System.Threading.ThreadPool>-Thread ausgelöst. Dauert die Verarbeitung des <xref:System.Timers.Timer.Elapsed>-Ereignisses länger als <xref:System.Timers.Timer.Interval%2A>, dann kann das Ereignis für einen anderen <xref:System.Threading.ThreadPool>-Thread erneut ausgelöst werden. In dieser Situation muss der Ereignishandler eintrittsinvariant sein.  
  
> [!NOTE]
>  Die Ereignisbehandlungsmethode kann für einen Thread zur gleichen Zeit ausgeführt werden, zu der ein anderer Thread die <xref:System.Timers.Timer.Stop%2A>-Methode aufruft oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festlegt. Dies kann dazu führen, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst wird, nachdem der Timer gestoppt wurde. Der Beispielcode für die <xref:System.Timers.Timer.Stop%2A>-Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null` ist, können <xref:System.Timers.Timer.Elapsed>-Ereignisse auftreten, wenn die Methoden <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> aufgerufen wurden oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festgelegt wurde, da das Signal zum Auslösen des <xref:System.Timers.Timer.Elapsed>-Ereignisses für die Ausführung stets in die Warteschlange eines Threadpoolthreads eingereiht wird. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Wenn Sie die <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse mit einem Benutzeroberflächenelement wie etwa einem Formular oder einem Steuerelement verwenden, ohne dafür den Timer festzulegen, weisen Sie der <xref:System.Timers.Timer.SynchronizingObject%2A>-Eigenschaft das Formular oder Steuerelement zu, das den <xref:System.Timers.Timer> enthält, um das Ereignis auf den Benutzeroberflächenthread zu marshallen.  
  
 Eine Liste der Standardeigenschaftenwerte für eine <xref:System.Timers.Timer>-Instanz finden Sie in den Ausführungen zum <xref:System.Timers.Timer.%23ctor%2A>-Konstruktor.  
  
> [!TIP]
>  Beachten Sie, dass .NET vier Klassen mit dem Namen `Timer` enthält, die jeweils unterschiedliche Funktionen erfüllen:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (dieses Thema): Löst in regelmäßigen Abständen ein Ereignis aus. Die Klasse ist für den Einsatz als serverbasierte oder Dienstkomponente in einer Multithreadumgebung vorgesehen. Sie hat keine Benutzeroberfläche und ist zur Laufzeit nicht sichtbar.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: Führt in regelmäßigen Abständen eine einzelne Rückrufmethode für einen Threadpoolthread aus. Die Rückrufmethode wird definiert, wenn der Timer instanziiert wird, und kann nicht geändert werden. Wie die <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse ist diese Klasse für den Einsatz als serverbasierte oder Dienstkomponente in einer Multithreadumgebung vorgesehen. Sie hat keine Benutzeroberfläche und ist zur Laufzeit nicht sichtbar.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (nur .NET Framework): Dies ist eine Windows Forms-Komponente, die in regelmäßigen Abständen ein Ereignis auslöst. Die Komponente besitzt keine Benutzeroberfläche und wurde für die Verwendung in einer Singlethreadumgebung entwickelt.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (nur .NET Framework): Hierbei handelt es sich um eine ASP.NET-Komponente, die in regelmäßigen Abständen asynchrone oder synchrone Webseitenpostbacks durchführt.  

## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer`-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" />-Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse und legt alle Eigenschaften auf die Anfangswerte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Timers.Timer>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 Millisekunden|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Die Zeit zwischen den Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse, wobei die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft auf den angegebenen Wert (in Millisekunden) festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die <xref:System.Timers.Timer.Interval%2A> Eigenschaft der neuen Timer-Instanz, aber nicht den Timer aktiviert ist.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert des <paramref name="interval" />-Parameters muss größer oder gleich 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" /> sein.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal (<see langword="false" />) oder wiederholt (<see langword="true" />) auslösen soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis immer auslösen soll, wenn das Intervall abläuft, <see langword="false" />, wenn das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal nach dem ersten Ablaufen des Intervalls ausgelöst werden soll. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Timers.Timer> ist bereits aktiviert, wenn die <xref:System.Timers.Timer.Start%2A> -Methode aufgerufen wird, das Intervall wird zurückgesetzt. Wenn <xref:System.Timers.Timer.AutoReset%2A> ist `false`, <xref:System.Timers.Timer.Start%2A> -Methode muss aufgerufen werden, um die Anzahl der erneut zu starten.  
  
 Das Zurücksetzen des Intervalls auswirkt, wenn die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden aus und ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft wurde festgelegt, um `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Timers.Timer> , deren <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem 1,5 Sekunden. Der Ereignishandler zeigt "Hello World!" in der Konsole.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Timers.Timer.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Timers.Timer.BeginInit%2A> und <xref:System.Timers.Timer.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Timers.Timer" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer.Close%2A> Methode wiederum ruft die `Dispose` Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von der aktuellen <see cref="T:System.Timers.Timer" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Intervall abläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, wenn die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft ist `true` und das Zeitintervall (in Millisekunden) definiert, durch die <xref:System.Timers.Timer.Interval%2A> Eigenschaft abgelaufen ist. Wenn die <xref:System.Timers.Timer.AutoReset%2A> -Eigenschaft ist `true`, das Ereignis wird in einem Intervall von definierten wiederholt ausgelöst der <xref:System.Timers.Timer.Interval%2A> Eigenschaft; andernfalls wird das Ereignis ausgelöst nur einmal beim ersten die <xref:System.Timers.Timer.Interval%2A> Wert verstrichen ist.  
  
 Wenn <xref:System.Timers.Timer.Interval%2A> wird festgelegt, nachdem die <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Wenn Sie das Intervall auf 5 Sekunden festgelegt, und legen Sie z. B. <xref:System.Timers.Timer.Enabled%2A> zu `true`, die Zählung beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
 Wenn die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft `null`, <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, auf eine <xref:System.Threading.ThreadPool> Thread. Wenn die Verarbeitung der <xref:System.Timers.Timer.Elapsed> Ereignis dauert länger als <xref:System.Timers.Timer.Interval%2A>, das Ereignis möglicherweise erneut ausgelöst werden, auf einem anderen <xref:System.Threading.ThreadPool> Thread. In dieser Situation muss der Ereignishandler eintrittsinvariant sein.  
  
> [!NOTE]
>  Die Ereignisbehandlungsmethode kann für einen Thread zur gleichen Zeit ausgeführt werden, zu der ein anderer Thread die <xref:System.Timers.Timer.Stop%2A>-Methode aufruft oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festlegt. Dies kann dazu führen, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst wird, nachdem der Timer gestoppt wurde. Der Beispielcode für die <xref:System.Timers.Timer.Stop%2A>-Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null` ist, können <xref:System.Timers.Timer.Elapsed>-Ereignisse auftreten, wenn die Methoden <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> aufgerufen wurden oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festgelegt wurde, da das Signal zum Auslösen des <xref:System.Timers.Timer.Elapsed>-Ereignisses für die Ausführung stets in die Warteschlange eines Threadpoolthreads eingereiht wird. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Die <xref:System.Timers.Timer>-Komponente fängt alle Ausnahmen, die von Ereignishandlern für das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst werden, ab und unterdrückt sie. Dieses Verhalten kann sich in zukünftigen .NET Framework-Versionen ändern.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `true` entspricht dem Aufrufen <xref:System.Timers.Timer.Start%2A>, während das Festlegen <xref:System.Timers.Timer.Enabled%2A> zu `false` entspricht dem Aufrufen <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem <xref:System.Threading.ThreadPool> Thread. Dies führt unter Umständen die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaftensatz auf `false`. Im Codebeispiel für die <xref:System.Timers.Timer.Stop%2A> Methode zeigt eine Möglichkeit, diese Racebedingung umgehen.  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> nastaven NA hodnotu `true` und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist.  
  
 Wenn das Intervall festgelegt ist, nach der <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
> [!NOTE]
>  Legen Sie einige visuelle Designer, z. B. in Microsoft Visual Studio die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true` beim Einfügen einer neuen von <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese Eigenschaft kann nicht festgelegt werden, da der Zeitgeber freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft wurde auf einen größeren Wert als <see cref="F:System.Int32.MaxValue" /> festgelegt, bevor der Timer aktiviert wurde.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung, die diese Methode verwendet, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Timers.Timer.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Timers.Timer.BeginInit%2A> und <xref:System.Timers.Timer.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Intervall in Millisekunden ab, in dem das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis ausgelöst wird, oder legt dieses fest.</summary>
        <value>Die Zeit zwischen den <see cref="E:System.Timers.Timer.Elapsed" />-Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein. Der Standardwert ist 100 Millisekunden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden die <xref:System.Timers.Timer.Interval%2A> -Eigenschaft bestimmt die Häufigkeit, mit der <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst. Da die <xref:System.Timers.Timer> Klasse hängt von der Systemuhr, müssen sie die gleiche Auflösung wie der Systemuhr. Das bedeutet, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis in einem durch die Auflösung der Systemuhr definierten Intervall ausgelöst wird, wenn die <xref:System.Timers.Timer.Interval%2A>-Eigenschaft kleiner als die Systemuhrauflösung ist. Im folgenden Beispiel wird die <xref:System.Timers.Timer.Interval%2A> Eigenschaft 5 Millisekunden. Bei Ausführung auf einem [!INCLUDE[win7](~/includes/win7-md.md)] System, dessen Systemuhr eine Auflösung von etwa 15 Millisekunden, die das Ereignis ausgelöst wird, etwa 15 Millisekunden statt alle 5 Millisekunden hat.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Sie können den folgenden Code verwenden, um zu bestimmen, die Auflösung der Systemuhr auf dem aktuellen System:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Wenn Ihre app mehr Auflösung als das Angebot von erfordert die <xref:System.Timers.Timer> Klasse oder die Systemuhr, die mit hoher Auflösung multimedia-Zeitgeber verwenden; Siehe [wie: Verwenden eines Zeitgebers](https://msdn.microsoft.com/library/aa964692.aspx).  
  
 Wenn das Intervall festgelegt ist, nach der <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> nastaven NA hodnotu `true` und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist. <xref:System.Timers.Timer.Enabled%2A> Legen Sie dann auf `false`.  
  
> [!NOTE]
>  Wenn <xref:System.Timers.Timer.Enabled%2A> und <xref:System.Timers.Timer.AutoReset%2A> auf festlegen `false`, und der Timer bereits aktiviert wurde, Festlegen der <xref:System.Timers.Timer.Interval%2A> Eigenschaft bewirkt, dass die <xref:System.Timers.Timer.Elapsed> Ereignis einmal ausgelöst wird wie die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft Wert`true`. Fest, um das Intervall ohne Auslösen des Ereignisses legen Sie vorübergehend die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, legen die <xref:System.Timers.Timer.Interval%2A> Eigenschaft, um den gewünschten Zeitraum aus, und legen Sie dann sofort die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft zurück auf `false`.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Intervall ist kleiner oder gleich 0 (null).  
  
- oder -  
Das Intervall ist größer als <see cref="F:System.Int32.MaxValue" />, und der Zeitgeber ist gegenwärtig aktiviert. (Wenn der Zeitgeber nicht gerade aktiviert ist, wird keine Ausnahme ausgelöst, bis er aktiviert wird.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Site ab, die die <see cref="T:System.Timers.Timer" />-Klasse im Entwurfsmodus an ihren Container bindet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.ComponentModel.ISite" />-Schnittstelle, die die Site darstellt, die das <see cref="T:System.Timers.Timer" />-Objekt an ihren Container bindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites Binden einer <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen ihnen, als auch eine Möglichkeit für den Container zum Verwalten der Komponenten bereitgestellt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt mit dem Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist. Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und <xref:System.Timers.Timer.AutoReset%2A> ist `true`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> Ereignis das erste Mal das Intervall abläuft, und löst das Ereignis im angegebenen Intervall aus.  
  
 Sie können die zeitliche Steuerung auch starten, durch Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `true`.  
  
> [!NOTE]
>  Wenn <xref:System.Timers.Timer.AutoReset%2A> ist `false`, <xref:System.Timers.Timer.Start%2A> -Methode muss aufgerufen werden, um die Anzahl der erneut zu starten.  
  
 Ein Aufruf der <xref:System.Timers.Timer.Start%2A> Methode, wenn der Zeitgeber aktiviert ist, hat keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="T:System.Timers.Timer" /> wird mit einem Intervall erstellt, das größer gleich <see cref="F:System.Int32.MaxValue" /> + 1 ist, oder auf ein Intervall kleiner als 0 (null) festgelegt.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht das Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die zeitliche Steuerung auch beenden, durch Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `false`.  
  
> [!NOTE]
>  Das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf eine <xref:System.Threading.ThreadPool> Threads, damit die Methode zur Verarbeitung von Ereignissen in einem Thread gleichzeitig ausgeführt werden kann, Zeit, die einen Aufruf der <xref:System.Timers.Timer.Stop%2A> Methode, die in einem anderen Thread ausgeführt wird. Dies könnte dazu führen die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem die <xref:System.Timers.Timer.Stop%2A> Methode wird aufgerufen. Das Codebeispiel im nächsten Abschnitt zeigt eine Möglichkeit zum Umgehen dieser Racebedingung.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer`-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an. Wenn der Benutzer die EINGABETASTE drückt, um die Anwendung ruft die <xref:System.Timers.Timer.Stop%2A> Methode vor dem Beenden der Anwendungs.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Das folgende Codebeispiel zeigt eine Möglichkeit, den Thread, der Aufrufe der <xref:System.Timers.Timer.Stop%2A> Methode fortgesetzt wird, bis ein aktuell ausgeführtes <xref:System.Timers.Timer.Elapsed> endet, und um zu verhindern, dass zwei <xref:System.Timers.Timer.Elapsed> Ereignisse aus den Ereignishandler gleichzeitig ausführen Zeit (häufig als Reentranz bezeichnet).  
  
 Im Beispiel werden die 100 Testläufe ausgeführt. Jedes Mal, wenn der Test ausgeführt wird, wird der Zeitgeber mit einem Intervall von 150 Millisekunden gestartet. Der Ereignishandler verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Aufgabe zu simulieren, die Länge von 50 und 200 Millisekunden nach dem Zufallsprinzip variiert. Die Testmethode wird auch einen Steuerelement-Thread, der für eine Sekunde wartet und dann beendet den Timer gestartet. Wenn ein Ereignis verarbeitet wird, wenn der Thread des Steuerelements der Timer wird angehalten, muss die Steuerthread warten, bis das Ereignis, bevor Sie fortfahren abgeschlossen ist.  
  
 Die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Überladung wird verwendet, um Reentranz zu vermeiden und um zu verhindern, dass den Steuerelement-Thread fortsetzen, bis ein ausgeführtes Ereignis beendet. Der Ereignishandler verwendet die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> Methode, um ein Steuerelement festzulegen, Variablen, 1, aber nur, wenn der Wert derzeit NULL ist. Dies ist ein atomischer Vorgang. Wenn der Rückgabewert 0 (null) ist, wird die Steuerelementvariable auf 1 festgelegt wurde, und der Ereignishandler wird fortgesetzt. Wenn der Rückgabewert ungleich NULL ist, wird das Ereignis einfach verworfen, um Reentranz zu vermeiden. (Wäre es erforderlich, führen Sie jedes Ereignis, das <xref:System.Threading.Monitor> Klasse wäre eine bessere Möglichkeit, um die Ereignisse zu synchronisieren.) Wenn der Ereignishandler beendet wird, wird die Steuerelementvariable zurück auf 0 (null). Im Beispiel zeichnet die Gesamtzahl der Ereignisse, die ausgeführt wurden, die aufgrund von Eintrittsinvarianz verworfen wurden, und, aufgetreten ist, nach, der <xref:System.Timers.Timer.Stop%2A> Methode wurde aufgerufen.  
  
 Der Steuerelement-Thread verwendet die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> Methode, um das Steuerelement festzulegen, Variablen,-1 (minus eins), aber nur, wenn der Wert derzeit NULL ist. Wenn der atomare Vorgang ungleich NULL zurückgibt, wird ein Ereignis derzeit ausgeführt. Der Steuerelement-Thread wartet, und versucht es erneut. Im Beispiel zeichnet die Anzahl der Häufigkeit, mit die Steuerthread auf ein Ereignis zum Abschluss warten mussten.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die nach Ablauf eines Intervalls ausgegeben werden, oder legt dieses fest.</summary>
        <value>Die <see cref="T:System.ComponentModel.ISynchronizeInvoke" />-Schnittstelle, die das Objekt zum Marshallen von Ereignishandleraufrufen darstellt, die nach Ablauf eines Intervalls ausgegeben werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Timers.Timer.SynchronizingObject%2A> ist `null`, die Methode, verarbeitet die <xref:System.Timers.Timer.Elapsed> Ereignis für einen Thread aus dem Threadpool des Systems aufgerufen wird. Weitere Informationen zu System-Thread-Pools finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Timers.Timer.Elapsed> Ereignis wird von einer visuellen Windows Forms-Komponente, z. B. eine Schaltfläche, die Zugriff auf die Komponente über den Threadpool des Systems möglicherweise Ergebnis eine Ausnahme ausgelöst oder einfach funktionieren möglicherweise nicht verarbeitet. Vermeiden Sie dies, indem Sie festlegen <xref:System.Timers.Timer.SynchronizingObject%2A> auf eine Komponente von Windows Forms das führt dazu, dass der Methode, verarbeitet die <xref:System.Timers.Timer.Elapsed> Ereignis auf dem gleichen Thread aufgerufen werden, die der Komponente erstellt wurde.  
  
> [!NOTE]
>  Auch wenn die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft ist nicht `null`, <xref:System.Timers.Timer.Elapsed> Ereignisse können nach dem Auftreten der <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> -Methode aufgerufen wurde oder nach der <xref:System.Timers.Timer.Enabled%2A> eingestellt wurde `false`, da das Signal zum Auslösen von die <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem Threadpool-Thread. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Wenn die <xref:System.Timers.Timer> wird in einem Windows Forms-Designer in Visual Studio verwendet <xref:System.Timers.Timer.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement, enthält die <xref:System.Timers.Timer>. Wenn Sie platzieren z. B. eine <xref:System.Timers.Timer> in einem Designer für `Form1` (erbt von <xref:System.Windows.Forms.Form>), wird die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft <xref:System.Timers.Timer> festgelegt ist, mit der Instanz von `Form1`.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Windows Forms-app, die als einen sehr einfachen Text-Datei-Editor dient. Wenn der Text in das Textfeld nicht gespeichert wurde, fordert die app den Benutzer in Intervallen von 1 Minute, ob er den Inhalt des Textfelds speichern möchte.  Zu diesem Zweck die <xref:System.Timers.Timer.Interval%2A> -Eigenschaftensatz auf eine Minute (60000 Millisekunden), und die <xref:System.Timers.Timer.SynchronizingObject%2A> -Eigenschaftensatz auf die <xref:System.Windows.Forms.Form> Objekt.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Das Beispiel erfordert, dass Sie die folgenden Steuerelemente zum Formular hinzufügen:  
  
-   Ein <xref:System.Windows.Forms.TextBox> Steuerelement mit dem Namen `TextBox1` (der Standardname).  
  
-   Ein <xref:System.Windows.Forms.Button> Steuerelement mit dem Namen `Button1` (der Standardname).  
  
-   Ein <xref:System.Windows.Forms.SaveFileDialog> Steuerelement mit dem Namen `SaveSaveFileDialog1` (der Standardname).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>