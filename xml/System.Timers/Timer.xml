<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b182ebe1139bd14d03ded417cddffca78808f4aa" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48747628" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generiert ein Ereignis nach einem festgelegten Intervall, mit der Option zum Generieren wiederkehrender Ereignisse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer> Komponente ist eine serverbasierte Timer, der löst ein <xref:System.Timers.Timer.Elapsed> Ereignis in Ihrer Anwendung nach der Anzahl von Millisekunden für den die <xref:System.Timers.Timer.Interval%2A> Eigenschaft ist abgelaufen. Sie können konfigurieren, die <xref:System.Timers.Timer> Objekt zum Auslösen des Ereignisses, das nur einmal oder wiederholt über die <xref:System.Timers.Timer.AutoReset%2A> Eigenschaft. In der Regel eine <xref:System.Timers.Timer> -Objekt auf Klassenebene deklariert, damit es im Gültigkeitsbereich bleibt, solange sie benötigt wird. Sie können dann behandeln die <xref:System.Timers.Timer.Elapsed> Ereignis, um reguläre Verarbeitung bereitzustellen. Nehmen wir beispielsweise an, Sie haben einen wichtigen Server, die aufbewahrt werden muss, 24 Stunden am Tag, 7 Tage pro Woche ausgeführt. Sie könnten einen Dienst, verwendet erstellen eine <xref:System.Timers.Timer> Objekt, das in regelmäßigen Abständen überprüfen Sie den Server, und stellen Sie sicher, dass das System ausgeführt wird. Wenn das System nicht reagiert wird, versucht der Dienst konnte den Server neu starten oder einen Administrator zu benachrichtigen.  
  
> [!IMPORTANT]
> Die <xref:System.Timers.Timer> Klasse ist nicht für alle .NET-Implementierungen und Versionen, z. B. .NET Standard 1.6 und frühere Versionen verfügbar.
> In diesen Fällen können Sie die <xref:System.Threading.Timer?displayProperty=nameWithType> stattdessen.
  
 Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 Der Server-basierten <xref:System.Timers.Timer?displayProperty=nameWithType> Klasse dient zur Verwendung mit Arbeitsthreads, die in einer Multithreadumgebung. -Servertimer können zwischen Threads verschieben, auf die ausgelöste behandeln <xref:System.Timers.Timer.Elapsed> Ereignis, was zu höherer Genauigkeit als Windows-Zeitgeber in Auslösen des Ereignisses Zeit.  
  
 Die <xref:System.Timers.Timer?displayProperty=nameWithType> Komponente der <xref:System.Timers.Timer.Elapsed> Ereignis basierend auf dem Wert (in Millisekunden), der die <xref:System.Timers.Timer.Interval%2A> Eigenschaft. Sie können dieses Ereignis, um die Verarbeitung auszuführen, benötigen Sie behandeln. Nehmen wir beispielsweise an, dass Sie eine onlineverkaufsanwendung verfügen, die kontinuierlich auf Aufträge mit einer Datenbank sendet. Der Dienst, der die Anweisungen für die Auslieferung kompiliert verarbeitet einen Batch von Bestellungen, anstatt jede Bestellung einzeln zu verarbeiten. Sie können eine <xref:System.Timers.Timer> , die alle 30 Minuten für die Batchverarbeitung zu starten.  
  
> [!IMPORTANT]
>  Die System.Timers.Timer-Klasse verfügt über die gleiche Auflösung wie der Systemuhr. Dies bedeutet, dass die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, in einem Intervall von der Auflösung der Systemuhr definiert werden, wenn die <xref:System.Timers.Timer.Interval%2A> -Eigenschaft ist kleiner als die Auflösung der Systemuhr. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Timers.Timer.Interval%2A>-Eigenschaft.  
  
 Wenn <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer?displayProperty=nameWithType> -Objekt löst die <xref:System.Timers.Timer.Elapsed> Ereignis nur einmal nach dem ersten <xref:System.Timers.Timer.Interval%2A> ist abgelaufen. Die ausgelöst wird die <xref:System.Timers.Timer.Elapsed> Ereignis regelmäßig im Intervall von definiert die <xref:System.Timers.Timer.Interval%2A>legen <xref:System.Timers.Timer.AutoReset%2A> zu `true`, dies ist der Standardwert.  
  
 Die <xref:System.Timers.Timer> Komponente abfängt und unterdrückt alle Ausnahmen, die von Ereignishandlern für die <xref:System.Timers.Timer.Elapsed> Ereignis. Dieses Verhalten ist, kann in zukünftigen Versionen von .NET Framework geändert. Beachten Sie jedoch, dass dies nicht der Ereignishandler "true", die asynchron ausgeführt und enthalten die `await` -Operator (in c#) oder die `Await` -Operator (in Visual Basic). Ausnahmen in diese Ereignishandler werden zurück an den aufrufenden Thread weitergegeben, wie im folgende Beispiel veranschaulicht. Weitere Informationen zu Ausnahmen in asynchronen Methoden, finden Sie unter [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Wenn die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft `null`, <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, auf eine <xref:System.Threading.ThreadPool> Thread. Wenn die Verarbeitung der <xref:System.Timers.Timer.Elapsed> Ereignis dauert länger als <xref:System.Timers.Timer.Interval%2A>, das Ereignis möglicherweise erneut ausgelöst werden, auf einem anderen <xref:System.Threading.ThreadPool> Thread. In diesem Fall sollte der Ereignishandler wiedereintrittsfähig sein.  
  
> [!NOTE]
>  Die Methode zur Verarbeitung von Ereignissen möglicherweise zur gleichen Zeit, die ein anderer Thread in einem einzelnen Thread ausgeführt der <xref:System.Timers.Timer.Stop%2A> -Methode, oder legt ihn fest der <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `false`. Dies führt unter Umständen die <xref:System.Timers.Timer.Elapsed> Ereignis ausgelöst wird, nachdem der Zeitgeber angehalten wurde. Beispielcode für die <xref:System.Timers.Timer.Stop%2A> Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null`, <xref:System.Timers.Timer.Elapsed> Ereignisse können nach dem Auftreten der <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> -Methode aufgerufen wurde oder nach der <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `false`, da das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem Threadpool-Thread. Eine Möglichkeit zum Auflösen dieser Racebedingung ist ein Kennzeichen festgelegt, der angibt, den Ereignishandler für die <xref:System.Timers.Timer.Elapsed> Ereignis ignoriert nachfolgende Ereignisse.  
  
 Bei Verwendung der <xref:System.Timers.Timer?displayProperty=nameWithType> Klasse mit einem Element der Benutzeroberfläche, z. B. eines Formulars oder Steuerelements, ohne dass des Zeitgebers für dieses Element der Benutzeroberfläche, weisen Sie das Formular oder Steuerelement, enthält die <xref:System.Timers.Timer> auf die <xref:System.Timers.Timer.SynchronizingObject%2A> -Eigenschaft, damit das Ereignis ist an den Benutzeroberflächenthread gemarshallt.  
  
 Eine Liste standardmäßiger Eigenschaftswerte für eine Instanz von <xref:System.Timers.Timer>, finden Sie unter den <xref:System.Timers.Timer.%23ctor%2A> Konstruktor.  
  
> [!TIP]
>  Beachten Sie, dass .NET vier Klassen, die mit dem Namen enthält `Timer`, die jeweils von der anderen Funktionen bietet:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (dieses Thema): löst ein Ereignis in regelmäßigen Abständen. Die Klasse dient zur Verwendung als ein serverbasiertes oder Dienstkomponente in einer Multithreadumgebung; Es hat keine Benutzeroberfläche und nicht zur Laufzeit sichtbar ist.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: führt eine Methode für die einzelnen Rückruf auf einem Threadpoolthread in regelmäßigen Abständen. Die Rückrufmethode wird definiert, wenn der Zeitgeber instanziiert wird und kann nicht geändert werden. Wie die <xref:System.Timers.Timer?displayProperty=nameWithType> -Klasse, diese Klasse ist für die Verwendung als Server-basierten oder Service-Komponente in einer Multithreadumgebung vorgesehen, da es keine Benutzeroberfläche hat und nicht zur Laufzeit sichtbar ist.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Nur .NET Framework): eine Windows Forms-Komponente, die in regelmäßigen Abständen ein Ereignis ausgelöst wird. Die Komponente besitzt keine Benutzeroberfläche und wurde für die Verwendung in einer Singlethreadumgebung entwickelt.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Nur .NET Framework): ein ASP.NET-Komponente, die Webseite für asynchrone oder synchrone Postbacks in regelmäßigen Intervallen ausführt.  

## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer` -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2.000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" /> Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse und legt alle Eigenschaften auf die Anfangswerte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Timers.Timer>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 Millisekunden|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Die Zeit zwischen den Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse, wobei die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die <xref:System.Timers.Timer.Interval%2A> Eigenschaft der neuen Timer-Instanz, aber nicht den Timer aktiviert ist.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert des <paramref name="interval" />-Parameters muss größer oder gleich 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" /> sein.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal (<see langword="false" />) oder wiederholt (<see langword="true" />) auslösen soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis immer auslösen soll, wenn das Intervall abläuft, <see langword="false" />, wenn das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal nach dem ersten Ablaufen des Intervalls ausgelöst werden soll. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Timers.Timer> ist bereits aktiviert, wenn die <xref:System.Timers.Timer.Start%2A> -Methode aufgerufen wird, das Intervall wird zurückgesetzt. Wenn <xref:System.Timers.Timer.AutoReset%2A> ist `false`, <xref:System.Timers.Timer.Start%2A> -Methode muss aufgerufen werden, um die Anzahl der erneut zu starten.  
  
 Das Zurücksetzen des Intervalls auswirkt, wenn die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden aus und ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft wurde festgelegt, um `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Timers.Timer> , deren <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem 1,5 Sekunden. Der Ereignishandler zeigt "Hello World!" in der Konsole.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Timers.Timer.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Timers.Timer.BeginInit%2A> und <xref:System.Timers.Timer.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Timers.Timer" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer.Close%2A> Methode wiederum ruft die `Dispose` Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von der aktuellen <see cref="T:System.Timers.Timer" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Intervall abläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, wenn die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft ist `true` und das Zeitintervall (in Millisekunden) definiert, durch die <xref:System.Timers.Timer.Interval%2A> Eigenschaft abgelaufen ist. Wenn die <xref:System.Timers.Timer.AutoReset%2A> -Eigenschaft ist `true`, das Ereignis wird in einem Intervall von definierten wiederholt ausgelöst der <xref:System.Timers.Timer.Interval%2A> Eigenschaft; andernfalls wird das Ereignis ausgelöst nur einmal beim ersten die <xref:System.Timers.Timer.Interval%2A> Wert verstrichen ist.  
  
 Wenn <xref:System.Timers.Timer.Interval%2A> wird festgelegt, nachdem die <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Wenn Sie das Intervall auf 5 Sekunden festgelegt, und legen Sie z. B. <xref:System.Timers.Timer.Enabled%2A> zu `true`, die Zählung beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
 Wenn die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft `null`, <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, auf eine <xref:System.Threading.ThreadPool> Thread. Wenn die Verarbeitung der <xref:System.Timers.Timer.Elapsed> Ereignis dauert länger als <xref:System.Timers.Timer.Interval%2A>, das Ereignis möglicherweise erneut ausgelöst werden, auf einem anderen <xref:System.Threading.ThreadPool> Thread. In diesem Fall sollte der Ereignishandler wiedereintrittsfähig sein.  
  
> [!NOTE]
>  Die Methode zur Verarbeitung von Ereignissen möglicherweise zur gleichen Zeit, die ein anderer Thread in einem einzelnen Thread ausgeführt der <xref:System.Timers.Timer.Stop%2A> -Methode, oder legt ihn fest der <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `false`. Dies führt unter Umständen die <xref:System.Timers.Timer.Elapsed> Ereignis ausgelöst wird, nachdem der Zeitgeber angehalten wurde. Beispielcode für die <xref:System.Timers.Timer.Stop%2A> Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null`, <xref:System.Timers.Timer.Elapsed> Ereignisse können nach dem Auftreten der <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> -Methode aufgerufen wurde oder nach der <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `false`, da das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem Threadpool-Thread. Eine Möglichkeit zum Auflösen dieser Racebedingung ist ein Kennzeichen festgelegt, der angibt, den Ereignishandler für die <xref:System.Timers.Timer.Elapsed> Ereignis ignoriert nachfolgende Ereignisse.  
  
 Die <xref:System.Timers.Timer> Komponente abfängt und unterdrückt alle Ausnahmen, die von Ereignishandlern für die <xref:System.Timers.Timer.Elapsed> Ereignis. Dieses Verhalten ist, kann in zukünftigen Versionen von .NET Framework geändert.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `true` entspricht dem Aufrufen <xref:System.Timers.Timer.Start%2A>, während das Festlegen <xref:System.Timers.Timer.Enabled%2A> zu `false` entspricht dem Aufrufen <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem <xref:System.Threading.ThreadPool> Thread. Dies führt unter Umständen die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaftensatz auf `false`. Im Codebeispiel für die <xref:System.Timers.Timer.Stop%2A> Methode zeigt eine Möglichkeit, diese Racebedingung umgehen.  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> nastaven NA hodnotu `true` und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist.  
  
 Wenn das Intervall festgelegt ist, nach der <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
> [!NOTE]
>  Legen Sie einige visuelle Designer, z. B. in Microsoft Visual Studio die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true` beim Einfügen einer neuen von <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese Eigenschaft kann nicht festgelegt werden, da der Zeitgeber freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft wurde auf einen größeren Wert als <see cref="F:System.Int32.MaxValue" /> festgelegt, bevor der Timer aktiviert wurde.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung, die diese Methode verwendet, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Timers.Timer.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Timers.Timer.BeginInit%2A> und <xref:System.Timers.Timer.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Intervall in Millisekunden ab, in dem das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis ausgelöst wird, oder legt dieses fest.</summary>
        <value>Die Zeit zwischen den <see cref="E:System.Timers.Timer.Elapsed" />-Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein. Der Standardwert ist 100 Millisekunden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden die <xref:System.Timers.Timer.Interval%2A> -Eigenschaft bestimmt die Häufigkeit, mit der <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst. Da die <xref:System.Timers.Timer> Klasse hängt von der Systemuhr, müssen sie die gleiche Auflösung wie der Systemuhr. Dies bedeutet, dass die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, in einem Intervall von der Auflösung der Systemuhr definiert werden, wenn die <xref:System.Timers.Timer.Interval%2A> -Eigenschaft ist kleiner als die Auflösung der Systemuhr. Im folgenden Beispiel wird die <xref:System.Timers.Timer.Interval%2A> Eigenschaft 5 Millisekunden. Bei Ausführung auf einem [!INCLUDE[win7](~/includes/win7-md.md)] System, dessen Systemuhr eine Auflösung von etwa 15 Millisekunden, die das Ereignis ausgelöst wird, etwa 15 Millisekunden statt alle 5 Millisekunden hat.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Sie können den folgenden Code verwenden, um zu bestimmen, die Auflösung der Systemuhr auf dem aktuellen System:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Wenn Ihre app mehr Auflösung als das Angebot von erfordert die <xref:System.Timers.Timer> Klasse oder die Systemuhr, die mit hoher Auflösung multimedia-Zeitgeber verwenden; Siehe [wie: Verwenden Sie den Zeitgeber hochauflösende](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Wenn das Intervall festgelegt ist, nach der <xref:System.Timers.Timer> wurde gestartet, wird die Anzahl der zurückgesetzt. Angenommen, Sie legen Sie das Intervall auf 5 Sekunden, und legen Sie dann die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, die Anzahl die beginnt zu dem Zeitpunkt <xref:System.Timers.Timer.Enabled%2A> festgelegt ist. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden ist, die <xref:System.Timers.Timer.Elapsed> -Ereignisses zum ersten Mal 13 Sekunden nach dem <xref:System.Timers.Timer.Enabled%2A> wurde `true`.  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> nastaven NA hodnotu `true` und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist. <xref:System.Timers.Timer.Enabled%2A> Legen Sie dann auf `false`.  
  
> [!NOTE]
>  Wenn <xref:System.Timers.Timer.Enabled%2A> und <xref:System.Timers.Timer.AutoReset%2A> auf festlegen `false`, und der Timer bereits aktiviert wurde, Festlegen der <xref:System.Timers.Timer.Interval%2A> Eigenschaft bewirkt, dass die <xref:System.Timers.Timer.Elapsed> Ereignis einmal ausgelöst wird wie die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft Wert`true`. Fest, um das Intervall ohne Auslösen des Ereignisses legen Sie vorübergehend die <xref:System.Timers.Timer.Enabled%2A> Eigenschaft `true`, legen die <xref:System.Timers.Timer.Interval%2A> Eigenschaft, um den gewünschten Zeitraum aus, und legen Sie dann sofort die <xref:System.Timers.Timer.Enabled%2A> -Eigenschaft zurück auf `false`.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer> -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Intervall ist kleiner oder gleich 0 (null).  
  
- oder -  
Das Intervall ist größer als <see cref="F:System.Int32.MaxValue" />, und der Zeitgeber ist gegenwärtig aktiviert. (Wenn der Zeitgeber nicht gerade aktiviert ist, wird keine Ausnahme ausgelöst, bis er aktiviert wird.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Site ab, die die <see cref="T:System.Timers.Timer" />-Klasse im Entwurfsmodus an ihren Container bindet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.ComponentModel.ISite" />-Schnittstelle, die die Site darstellt, die das <see cref="T:System.Timers.Timer" />-Objekt an ihren Container bindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites Binden einer <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen ihnen, als auch eine Möglichkeit für den Container zum Verwalten der Komponenten bereitgestellt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt mit dem Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und <xref:System.Timers.Timer.AutoReset%2A> nastaven NA hodnotu `false`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> -Ereignis nur einmal nach dem ersten Ablaufen des Intervalls abgelaufen ist. Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und <xref:System.Timers.Timer.AutoReset%2A> ist `true`, <xref:System.Timers.Timer> löst die <xref:System.Timers.Timer.Elapsed> Ereignis das erste Mal das Intervall abläuft, und löst das Ereignis im angegebenen Intervall aus.  
  
 Sie können die zeitliche Steuerung auch starten, durch Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `true`.  
  
> [!NOTE]
>  Wenn <xref:System.Timers.Timer.AutoReset%2A> ist `false`, <xref:System.Timers.Timer.Start%2A> -Methode muss aufgerufen werden, um die Anzahl der erneut zu starten.  
  
 Ein Aufruf der <xref:System.Timers.Timer.Start%2A> Methode, wenn der Zeitgeber aktiviert ist, hat keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="T:System.Timers.Timer" /> wird mit einem Intervall größer oder gleich <see cref="F:System.Int32.MaxValue" /> + 1 erstellt oder auf ein Intervall kleiner als null festgelegt.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht das Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die zeitliche Steuerung auch beenden, durch Festlegen von <xref:System.Timers.Timer.Enabled%2A> zu `false`.  
  
> [!NOTE]
>  Das Signal zum Auslösen der <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf eine <xref:System.Threading.ThreadPool> Threads, damit die Methode zur Verarbeitung von Ereignissen in einem Thread gleichzeitig ausgeführt werden kann, Zeit, die einen Aufruf der <xref:System.Timers.Timer.Stop%2A> Methode, die in einem anderen Thread ausgeführt wird. Dies könnte dazu führen die <xref:System.Timers.Timer.Elapsed> Ereignis wird ausgelöst, nachdem die <xref:System.Timers.Timer.Stop%2A> Methode wird aufgerufen. Das Codebeispiel im nächsten Abschnitt zeigt eine Möglichkeit zum Umgehen dieser Racebedingung.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer` -Objekt, das ausgelöst wird seine <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2.000 Millisekunden), richtet einen Ereignishandler für das Ereignis und startet den Timer. Der Ereignishandler zeigt den Wert des der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> Eigenschaft jedes Mal, es wird ausgelöst. Wenn der Benutzer die EINGABETASTE drückt, um die Anwendung ruft die <xref:System.Timers.Timer.Stop%2A> Methode vor dem Beenden der Anwendungs.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Das folgende Codebeispiel zeigt eine Möglichkeit, den Thread, der Aufrufe der <xref:System.Timers.Timer.Stop%2A> Methode fortgesetzt wird, bis ein aktuell ausgeführtes <xref:System.Timers.Timer.Elapsed> endet, und um zu verhindern, dass zwei <xref:System.Timers.Timer.Elapsed> Ereignisse aus den Ereignishandler gleichzeitig ausführen Zeit (häufig als Reentranz bezeichnet).  
  
 Im Beispiel werden die 100 Testläufe ausgeführt. Jedes Mal, wenn der Test ausgeführt wird, wird der Zeitgeber mit einem Intervall von 150 Millisekunden gestartet. Der Ereignishandler verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Aufgabe zu simulieren, die Länge von 50 und 200 Millisekunden nach dem Zufallsprinzip variiert. Die Testmethode wird auch einen Steuerelement-Thread, der für eine Sekunde wartet und dann beendet den Timer gestartet. Wenn ein Ereignis verarbeitet wird, wenn der Thread des Steuerelements der Timer wird angehalten, muss die Steuerthread warten, bis das Ereignis, bevor Sie fortfahren abgeschlossen ist.  
  
 Die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Überladung wird verwendet, um Reentranz zu vermeiden und um zu verhindern, dass den Steuerelement-Thread fortsetzen, bis ein ausgeführtes Ereignis beendet. Der Ereignishandler verwendet die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> Methode, um ein Steuerelement festzulegen, Variablen, 1, aber nur, wenn der Wert derzeit NULL ist. Dies ist ein atomischer Vorgang. Wenn der Rückgabewert 0 (null) ist, wird die Steuerelementvariable auf 1 festgelegt wurde, und der Ereignishandler wird fortgesetzt. Wenn der Rückgabewert ungleich NULL ist, wird das Ereignis einfach verworfen, um Reentranz zu vermeiden. (Wäre es erforderlich, führen Sie jedes Ereignis, das <xref:System.Threading.Monitor> Klasse wäre eine bessere Möglichkeit, um die Ereignisse zu synchronisieren.) Wenn der Ereignishandler beendet wird, wird die Steuerelementvariable zurück auf 0 (null). Im Beispiel zeichnet die Gesamtzahl der Ereignisse, die ausgeführt wurden, die aufgrund von Eintrittsinvarianz verworfen wurden, und, aufgetreten ist, nach, der <xref:System.Timers.Timer.Stop%2A> Methode wurde aufgerufen.  
  
 Der Steuerelement-Thread verwendet die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> Methode, um das Steuerelement festzulegen, Variablen,-1 (minus eins), aber nur, wenn der Wert derzeit NULL ist. Wenn der atomare Vorgang ungleich NULL zurückgibt, wird ein Ereignis derzeit ausgeführt. Der Steuerelement-Thread wartet, und versucht es erneut. Im Beispiel zeichnet die Anzahl der Häufigkeit, mit die Steuerthread auf ein Ereignis zum Abschluss warten mussten.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die nach Ablauf eines Intervalls ausgegeben werden, oder legt dieses fest.</summary>
        <value>Die <see cref="T:System.ComponentModel.ISynchronizeInvoke" />-Schnittstelle, die das Objekt zum Marshallen von Ereignishandleraufrufen darstellt, die nach Ablauf eines Intervalls ausgegeben werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Timers.Timer.SynchronizingObject%2A> ist `null`, die Methode, verarbeitet die <xref:System.Timers.Timer.Elapsed> Ereignis für einen Thread aus dem Threadpool des Systems aufgerufen wird. Weitere Informationen zu System-Thread-Pools finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Timers.Timer.Elapsed> Ereignis wird von einer visuellen Windows Forms-Komponente, z. B. eine Schaltfläche, die Zugriff auf die Komponente über den Threadpool des Systems möglicherweise Ergebnis eine Ausnahme ausgelöst oder einfach funktionieren möglicherweise nicht verarbeitet. Vermeiden Sie dies, indem Sie festlegen <xref:System.Timers.Timer.SynchronizingObject%2A> auf eine Komponente von Windows Forms das führt dazu, dass der Methode, verarbeitet die <xref:System.Timers.Timer.Elapsed> Ereignis auf dem gleichen Thread aufgerufen werden, die der Komponente erstellt wurde.  
  
> [!NOTE]
>  Auch wenn die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft ist nicht `null`, <xref:System.Timers.Timer.Elapsed> Ereignisse können nach dem Auftreten der <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> -Methode aufgerufen wurde oder nach der <xref:System.Timers.Timer.Enabled%2A> eingestellt wurde `false`, da das Signal zum Auslösen von die <xref:System.Timers.Timer.Elapsed> Ereignis wird immer in die Warteschlange für die Ausführung auf einem Threadpool-Thread. Eine Möglichkeit zum Auflösen dieser Racebedingung ist ein Kennzeichen festgelegt, der angibt, den Ereignishandler für die <xref:System.Timers.Timer.Elapsed> Ereignis ignoriert nachfolgende Ereignisse.  
  
 Wenn die <xref:System.Timers.Timer> wird in einem Windows Forms-Designer in Visual Studio verwendet <xref:System.Timers.Timer.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement, enthält die <xref:System.Timers.Timer>. Wenn Sie platzieren z. B. eine <xref:System.Timers.Timer> in einem Designer für `Form1` (erbt von <xref:System.Windows.Forms.Form>), wird die <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft <xref:System.Timers.Timer> festgelegt ist, mit der Instanz von `Form1`.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Windows Forms-app, die als einen sehr einfachen Text-Datei-Editor dient. Wenn der Text in das Textfeld nicht gespeichert wurde, fordert die app den Benutzer in Intervallen von 1 Minute, ob er den Inhalt des Textfelds speichern möchte.  Zu diesem Zweck die <xref:System.Timers.Timer.Interval%2A> -Eigenschaftensatz auf eine Minute (60000 Millisekunden), und die <xref:System.Timers.Timer.SynchronizingObject%2A> -Eigenschaftensatz auf die <xref:System.Windows.Forms.Form> Objekt.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Das Beispiel erfordert, dass Sie die folgenden Steuerelemente zum Formular hinzufügen:  
  
-   Ein <xref:System.Windows.Forms.TextBox> Steuerelement mit dem Namen `TextBox1` (der Standardname).  
  
-   Ein <xref:System.Windows.Forms.Button> Steuerelement mit dem Namen `Button1` (der Standardname).  
  
-   Ein <xref:System.Windows.Forms.SaveFileDialog> Steuerelement mit dem Namen `SaveSaveFileDialog1` (der Standardname).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>