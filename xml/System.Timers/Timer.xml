<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="63cebc30b3cf4eec0e33fbfc805b5f63736fb370" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86988870" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.ComponentModel.TypeConverter" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("Elapsed")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("Elapsed")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.DefaultProperty("Interval")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultProperty("Interval")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generiert nach Ablauf eines festgelegten Intervalls ein Ereignis. Bietet auch die Option zum Generieren wiederkehrender Ereignisse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Timers.Timer>-Komponente ist ein serverbasierter Timer, der nach Verstreichen der in der <xref:System.Timers.Timer.Interval%2A>-Eigenschaft angegebenen Zeit (in Millisekunden) ein <xref:System.Timers.Timer.Elapsed>-Ereignis in Ihrer Anwendung auslöst. Sie können das <xref:System.Timers.Timer>-Objekt mit der <xref:System.Timers.Timer.AutoReset%2A>-Eigenschaft so konfigurieren, dass es das Ereignis nur einmal oder wiederholt auslöst. Normalerweise wird ein <xref:System.Timers.Timer>-Objekt so auf Klassenebene deklariert, dass es im Gültigkeitsbereich verbleibt, solange es benötigt wird. Sie können das zugehörige <xref:System.Timers.Timer.Elapsed>-Ereignis dann behandeln, um eine zyklische Verarbeitung zu ermöglichen. Nehmen wir beispielsweise an, Sie haben einen kritischen Server, der rund um die Uhr in Betrieb gehalten werden muss. Hierfür könnten Sie einen Dienst erstellen, der den Server mithilfe eines <xref:System.Timers.Timer>-Objekts in regelmäßigen Abständen periodisch überprüft und sicherstellt, dass das System fehlerfrei ausgeführt wird. Falls das System nicht reagiert, könnte der Dienst versuchen, den Server neu zu starten, oder einen Administrator benachrichtigen.  
  
> [!IMPORTANT]
> Die <xref:System.Timers.Timer>-Klasse ist nicht für alle .NET-Implementierungen und -Versionen verfügbar, beispielsweise nicht für .NET Standard 1.6 und älter.
> In diesen Fällen können Sie stattdessen die <xref:System.Threading.Timer?displayProperty=nameWithType>-Klasse verwenden.
  
 Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Die serverbasierte <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse ist für die Verwendung mit Workerthreads in einer Multithreadumgebung konzipiert. Servertimer können threadübergreifend eingesetzt werden, um das ausgelöste <xref:System.Timers.Timer.Elapsed>-Ereignis zu behandeln. Hierdurch wird eine im Vergleich zu Windows-Timern größere Genauigkeit beim rechtzeitigen Auslösen des Ereignisses erzielt.  
  
 Die <xref:System.Timers.Timer?displayProperty=nameWithType>-Komponente löst basierend auf dem Wert der Eigenschaft <xref:System.Timers.Timer.Interval%2A> (in Millisekunden) das <xref:System.Timers.Timer.Elapsed>-Ereignis aus. Sie können dieses Ereignis behandeln, um die erforderliche Verarbeitung durchzuführen. Angenommen, Sie haben eine Anwendung für den Onlinevertrieb entwickelt, die fortlaufend Kundenaufträge an eine Datenbank sendet. Der Dienst, der die Versandanweisungen zusammenstellt, bearbeitet immer mehrere Aufträge gleichzeitig statt jedes Auftrags einzeln. Mit einem <xref:System.Timers.Timer> könnten Sie die Batchverarbeitung alle 30 Minuten starten.  
  
> [!IMPORTANT]
>  Die System.Timers.Timer-Klasse hat die gleiche Auflösung wie die Systemuhr. Das bedeutet, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis in einem durch die Auflösung der Systemuhr definierten Intervall ausgelöst wird, wenn die <xref:System.Timers.Timer.Interval%2A>-Eigenschaft kleiner als die Systemuhrauflösung ist. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Timers.Timer.Interval%2A>-Eigenschaft.  
  
 Wenn <xref:System.Timers.Timer.AutoReset%2A> auf `false` festgelegt ist, löst ein <xref:System.Timers.Timer?displayProperty=nameWithType>-Objekt das <xref:System.Timers.Timer.Elapsed>-Ereignis nach dem Verstreichen des ersten <xref:System.Timers.Timer.Interval%2A> nur einmalig aus. Damit das <xref:System.Timers.Timer.Elapsed>-Ereignis regelmäßig in dem durch <xref:System.Timers.Timer.Interval%2A> definierten Intervall ausgelöst wird, legen Sie <xref:System.Timers.Timer.AutoReset%2A> auf `true` fest. Dies entspricht auch dem Standardwert.  
  
 Die <xref:System.Timers.Timer>-Komponente fängt alle Ausnahmen, die von Ereignishandlern für das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst werden, ab und unterdrückt sie. Dieses Verhalten kann sich in zukünftigen .NET Framework-Versionen ändern. Beachten Sie jedoch, dass dies nicht für Ereignishandler gilt, die asynchron ausgeführt werden und den Operator `await` (in C#) bzw. `Await` (in Visual Basic) enthalten. Ausnahmen, die in diesen Ereignishandlern ausgelöst werden, werden wie im folgenden Beispiel veranschaulicht an den aufrufenden Thread übermittelt. Weitere Informationen zu Ausnahmen, die in asynchronen Methoden ausgelöst werden, finden Sie unter [Ausnahmebehandlung](/dotnet/standard/parallel-programming/exception-handling-task-parallel-library).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Wenn die <xref:System.Timers.Timer.SynchronizingObject%2A>-Eigenschaft `null` ist, wird das <xref:System.Timers.Timer.Elapsed>-Ereignis für einen <xref:System.Threading.ThreadPool>-Thread ausgelöst. Dauert die Verarbeitung des <xref:System.Timers.Timer.Elapsed>-Ereignisses länger als <xref:System.Timers.Timer.Interval%2A>, dann kann das Ereignis für einen anderen <xref:System.Threading.ThreadPool>-Thread erneut ausgelöst werden. In dieser Situation muss der Ereignishandler eintrittsinvariant sein.  
  
> [!NOTE]
>  Die Ereignisbehandlungsmethode kann für einen Thread zur gleichen Zeit ausgeführt werden, zu der ein anderer Thread die <xref:System.Timers.Timer.Stop%2A>-Methode aufruft oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festlegt. Dies kann dazu führen, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst wird, nachdem der Timer gestoppt wurde. Der Beispielcode für die <xref:System.Timers.Timer.Stop%2A>-Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null` ist, können <xref:System.Timers.Timer.Elapsed>-Ereignisse auftreten, wenn die Methoden <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> aufgerufen wurden oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festgelegt wurde, da das Signal zum Auslösen des <xref:System.Timers.Timer.Elapsed>-Ereignisses für die Ausführung stets in die Warteschlange eines Threadpoolthreads eingereiht wird. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Wenn Sie die <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse mit einem Benutzeroberflächenelement wie etwa einem Formular oder einem Steuerelement verwenden, ohne dafür den Timer festzulegen, weisen Sie der <xref:System.Timers.Timer.SynchronizingObject%2A>-Eigenschaft das Formular oder Steuerelement zu, das den <xref:System.Timers.Timer> enthält, um das Ereignis auf den Benutzeroberflächenthread zu marshallen.  
  
 Eine Liste der Standardeigenschaftenwerte für eine <xref:System.Timers.Timer>-Instanz finden Sie in den Ausführungen zum <xref:System.Timers.Timer.%23ctor%2A>-Konstruktor.  
  
> [!TIP]
>  Beachten Sie, dass .NET vier Klassen mit dem Namen `Timer` enthält, die jeweils unterschiedliche Funktionen erfüllen:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (dieses Thema): Löst in regelmäßigen Abständen ein Ereignis aus. Die Klasse ist für den Einsatz als serverbasierte oder Dienstkomponente in einer Multithreadumgebung vorgesehen. Sie hat keine Benutzeroberfläche und ist zur Laufzeit nicht sichtbar.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: Führt in regelmäßigen Abständen eine einzelne Rückrufmethode für einen Threadpoolthread aus. Die Rückrufmethode wird definiert, wenn der Timer instanziiert wird, und kann nicht geändert werden. Wie die <xref:System.Timers.Timer?displayProperty=nameWithType>-Klasse ist diese Klasse für den Einsatz als serverbasierte oder Dienstkomponente in einer Multithreadumgebung vorgesehen. Sie hat keine Benutzeroberfläche und ist zur Laufzeit nicht sichtbar.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (nur .NET Framework): Dies ist eine Windows Forms-Komponente, die in regelmäßigen Abständen ein Ereignis auslöst. Die Komponente besitzt keine Benutzeroberfläche und wurde für die Verwendung in einer Singlethreadumgebung entwickelt.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (nur .NET Framework): Hierbei handelt es sich um eine ASP.NET-Komponente, die in regelmäßigen Abständen asynchrone oder synchrone Webseitenpostbacks durchführt.  

## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer`-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" />-Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse und legt alle Eigenschaften auf die Anfangswerte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von angezeigt <xref:System.Timers.Timer> .  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 Millisekunden|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Die Zeit zwischen den Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Timers.Timer" />-Klasse, wobei die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft auf den angegebenen Wert (in Millisekunden) festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor legt die- <xref:System.Timers.Timer.Interval%2A> Eigenschaft der neuen Timer-Instanz fest, aktiviert jedoch nicht den Timer.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert des <paramref name="interval" />-Parameters muss größer oder gleich 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" /> sein.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Category("Behavior")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Behavior")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.Timers.TimersDescription("TimerAutoReset")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("TimerAutoReset")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal (<see langword="false" />) oder wiederholt (<see langword="true" />) auslösen soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis immer auslösen soll, wenn das Intervall abläuft, <see langword="false" />, wenn das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis nur einmal nach dem ersten Ablaufen des Intervalls ausgelöst werden soll. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der <xref:System.Timers.Timer> bereits aktiviert ist, wenn die- <xref:System.Timers.Timer.Start%2A> Methode aufgerufen wird, wird das Intervall zurückgesetzt. Wenn den Wert <xref:System.Timers.Timer.AutoReset%2A> `false` hat, muss die- <xref:System.Timers.Timer.Start%2A> Methode aufgerufen werden, um die Anzahl erneut zu starten.  
  
 Das Zurücksetzen des Intervalls wirkt <xref:System.Timers.Timer.Elapsed> sich auf das Ereignis aus. Wenn Sie z. b. das Intervall auf 5 Sekunden festlegen und dann die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festlegen `true` , wird die Anzahl zum Zeitpunkt der <xref:System.Timers.Timer.Enabled%2A> Festlegung von gestartet. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden beträgt, wird das- <xref:System.Timers.Timer.Elapsed> Ereignis zum ersten Mal nach 13 Sekunden ausgelöst, nachdem die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `true` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Ereignis erstellt, <xref:System.Timers.Timer> dessen- <xref:System.Timers.Timer.Elapsed> Ereignis nach 1,5 Sekunden ausgelöst wird. Der zugehörige Ereignishandler zeigt dann "Hallo Welt!" in der Konsole.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die- <xref:System.Timers.Timer.EndInit%2A> Methode beendet die Initialisierung. Die Verwendung der <xref:System.Timers.Timer.BeginInit%2A> -Methode und der- <xref:System.Timers.Timer.EndInit%2A> Methode verhindert, dass das Steuerelement verwendet wird, bevor es vollständig initialisiert  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Timers.Timer" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Timers.Timer.Close%2A> Methode ruft wiederum die- `Dispose` Methode auf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von der aktuellen <see cref="T:System.Timers.Timer" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Category("Behavior")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Behavior")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.Timers.TimersDescription("TimerIntervalElapsed")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("TimerIntervalElapsed")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Timers.TimersDescription("Occurs when the Interval has elapsed.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("Occurs when the Interval has elapsed.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Intervall abläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Timers.Timer.Elapsed> -Ereignis wird ausgelöst, wenn die <xref:System.Timers.Timer.Enabled%2A> `true` -Eigenschaft und das von der-Eigenschaft definierte Zeitintervall (in Millisekunden) <xref:System.Timers.Timer.Interval%2A> abläuft. Wenn die- <xref:System.Timers.Timer.AutoReset%2A> Eigenschaft ist `true` , wird das-Ereignis in einem von der-Eigenschaft definierten Intervall wiederholt ausgelöst <xref:System.Timers.Timer.Interval%2A> . andernfalls wird das-Ereignis nur einmal ausgelöst, wenn der Wert erstmalig <xref:System.Timers.Timer.Interval%2A> abläuft.  
  
 Wenn <xref:System.Timers.Timer.Interval%2A> festgelegt wird <xref:System.Timers.Timer> , nachdem gestartet wurde, wird die Anzahl zurückgesetzt. Wenn Sie z. b. das Intervall auf 5 Sekunden festlegen und dann <xref:System.Timers.Timer.Enabled%2A> auf festlegen `true` , wird die Anzahl zum Zeitpunkt der <xref:System.Timers.Timer.Enabled%2A> Festlegung von gestartet. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden beträgt, wird das- <xref:System.Timers.Timer.Elapsed> Ereignis zum ersten Mal ausgelöst, nachdem <xref:System.Timers.Timer.Enabled%2A> auf festgelegt wurde `true` .  
  
 Wenn die- <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft ist `null` , <xref:System.Timers.Timer.Elapsed> wird das-Ereignis in einem Thread ausgelöst <xref:System.Threading.ThreadPool> . Wenn die Verarbeitung des <xref:System.Timers.Timer.Elapsed> Ereignisses länger als dauert <xref:System.Timers.Timer.Interval%2A> , wird das Ereignis möglicherweise erneut in einem anderen <xref:System.Threading.ThreadPool> Thread ausgelöst. In dieser Situation muss der Ereignishandler eintrittsinvariant sein.  
  
> [!NOTE]
>  Die Ereignisbehandlungsmethode kann für einen Thread zur gleichen Zeit ausgeführt werden, zu der ein anderer Thread die <xref:System.Timers.Timer.Stop%2A>-Methode aufruft oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festlegt. Dies kann dazu führen, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst wird, nachdem der Timer gestoppt wurde. Der Beispielcode für die <xref:System.Timers.Timer.Stop%2A>-Methode zeigt eine Möglichkeit, diese Racebedingung zu vermeiden.  
  
 Auch wenn <xref:System.Timers.Timer.SynchronizingObject%2A> nicht `null` ist, können <xref:System.Timers.Timer.Elapsed>-Ereignisse auftreten, wenn die Methoden <xref:System.Timers.Timer.Dispose%2A> oder <xref:System.Timers.Timer.Stop%2A> aufgerufen wurden oder die <xref:System.Timers.Timer.Enabled%2A>-Eigenschaft auf `false` festgelegt wurde, da das Signal zum Auslösen des <xref:System.Timers.Timer.Elapsed>-Ereignisses für die Ausführung stets in die Warteschlange eines Threadpoolthreads eingereiht wird. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Die <xref:System.Timers.Timer>-Komponente fängt alle Ausnahmen, die von Ereignishandlern für das <xref:System.Timers.Timer.Elapsed>-Ereignis ausgelöst werden, ab und unterdrückt sie. Dieses Verhalten kann in zukünftigen Versionen von .NET Framework geändert werden.
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Category("Behavior")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Behavior")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.Timers.TimersDescription("TimerEnabled")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("TimerEnabled")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Timers.Timer" /> das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis auslösen soll, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer.Enabled%2A>Das Festlegen von auf entspricht `true` dem Aufruf von <xref:System.Timers.Timer.Start%2A> , während <xref:System.Timers.Timer.Enabled%2A> das Festlegen von auf `false` das gleiche ist wie das Aufrufen von <xref:System.Timers.Timer.Stop%2A> .  
  
> [!NOTE]
>  Das Signal zum Erhöhen des <xref:System.Timers.Timer.Elapsed> Ereignisses wird immer zur Ausführung in einem Thread in die Warteschlange eingereiht <xref:System.Threading.ThreadPool> . Dies kann dazu führen, <xref:System.Timers.Timer.Elapsed> dass das-Ereignis ausgelöst wird, nachdem die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `false` . Das Codebeispiel für die- <xref:System.Timers.Timer.Stop%2A> Methode zeigt eine Möglichkeit, diese Racebedingung zu umgehen.  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> auf `true` und <xref:System.Timers.Timer.AutoReset%2A> auf festgelegt ist, löst das- `false` <xref:System.Timers.Timer> <xref:System.Timers.Timer.Elapsed> Ereignis nur einmal aus, wenn das Intervall das erste Mal abläuft.  
  
 Wenn das Intervall festgelegt wird <xref:System.Timers.Timer> , nachdem gestartet wurde, wird die Anzahl zurückgesetzt. Wenn Sie z. b. das Intervall auf 5 Sekunden festlegen und dann die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festlegen `true` , wird die Anzahl zum Zeitpunkt der <xref:System.Timers.Timer.Enabled%2A> Festlegung von gestartet. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden beträgt, wird das- <xref:System.Timers.Timer.Elapsed> Ereignis zum ersten Mal ausgelöst, nachdem <xref:System.Timers.Timer.Enabled%2A> auf festgelegt wurde `true` .  
  
> [!NOTE]
>  Einige visuelle Designer, z. b. die in Microsoft Visual Studio, legen beim <xref:System.Timers.Timer.Enabled%2A> Einfügen eines neuen die-Eigenschaft auf fest `true` <xref:System.Timers.Timer> .
  
## Examples  
 Im folgenden Beispiel wird ein-Objekt instanziiert, das das- <xref:System.Timers.Timer> <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das-Ereignis festlegt und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese Eigenschaft kann nicht festgelegt werden, da der Zeitgeber freigegeben wurde.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Timers.Timer.Interval" />-Eigenschaft wurde auf einen größeren Wert als <see cref="F:System.Int32.MaxValue" /> festgelegt, bevor der Timer aktiviert wurde.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Laufzeitinitialisierung eines <see cref="T:System.Timers.Timer" />, der in einem Formular oder von einer anderen Komponente verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die- <xref:System.Timers.Timer.BeginInit%2A> Methode startet die Initialisierung. Die Verwendung der <xref:System.Timers.Timer.BeginInit%2A> -Methode und der- <xref:System.Timers.Timer.EndInit%2A> Methode verhindert, dass das Steuerelement verwendet wird, bevor es vollständig initialisiert  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Category("Behavior")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Category("Behavior")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(100)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(100)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.Timers.TimersDescription("TimerInterval")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("TimerInterval")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Timers.TimersDescription("The number of milliseconds between timer events.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("The number of milliseconds between timer events.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Intervall in Millisekunden ab, in dem das <see cref="E:System.Timers.Timer.Elapsed" />-Ereignis ausgelöst wird, oder legt dieses fest.</summary>
        <value>Die Zeit zwischen den <see cref="E:System.Timers.Timer.Elapsed" />-Ereignissen in Millisekunden. Der Wert muss größer als 0 (null) und kleiner als oder gleich <see cref="F:System.Int32.MaxValue" /> sein. Der Standardwert ist 100 Millisekunden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der- <xref:System.Timers.Timer.Interval%2A> Eigenschaft können Sie die Häufigkeit ermitteln, mit der das <xref:System.Timers.Timer.Elapsed> Ereignis ausgelöst wird. Da die- <xref:System.Timers.Timer> Klasse von der Systemuhr abhängig ist, hat Sie dieselbe Auflösung wie die Systemuhr. Das bedeutet, dass das <xref:System.Timers.Timer.Elapsed>-Ereignis in einem durch die Auflösung der Systemuhr definierten Intervall ausgelöst wird, wenn die <xref:System.Timers.Timer.Interval%2A>-Eigenschaft kleiner als die Systemuhrauflösung ist. Im folgenden Beispiel wird die- <xref:System.Timers.Timer.Interval%2A> Eigenschaft auf 5 Millisekunden festgelegt. Wenn die Systemzeit auf einem [!INCLUDE[win7](~/includes/win7-md.md)] System mit einer Auflösung von ungefähr 15 Millisekunden ausgeführt wird, wird das Ereignis ungefähr alle 15 Millisekunden anstatt alle fünf Millisekunden ausgelöst.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Sie können den folgenden Code verwenden, um die Auflösung der Systemuhr im aktuellen System zu bestimmen:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Wenn Ihre APP eine größere Auflösung als die von der- <xref:System.Timers.Timer> Klasse oder der Systemuhr angebotene erfordert, verwenden Sie die hochauflösenden multilösungs-Timer. Weitere Informationen finden Sie unter Gewusst [wie: Verwenden des hochauflösenden Timers](https://msdn.microsoft.com/library/aa964692.aspx).  
  
 Wenn das Intervall festgelegt wird <xref:System.Timers.Timer> , nachdem gestartet wurde, wird die Anzahl zurückgesetzt. Wenn Sie z. b. das Intervall auf 5 Sekunden festlegen und dann die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festlegen `true` , wird die Anzahl zum Zeitpunkt der <xref:System.Timers.Timer.Enabled%2A> Festlegung von gestartet. Wenn Sie das Intervall auf 10 Sekunden zurücksetzen, wenn die Anzahl 3 Sekunden beträgt, wird das- <xref:System.Timers.Timer.Elapsed> Ereignis zum ersten Mal ausgelöst, nachdem <xref:System.Timers.Timer.Enabled%2A> auf festgelegt wurde `true` .  
  
 Wenn <xref:System.Timers.Timer.Enabled%2A> auf `true` und <xref:System.Timers.Timer.AutoReset%2A> auf festgelegt ist, löst das- `false` <xref:System.Timers.Timer> <xref:System.Timers.Timer.Elapsed> Ereignis nur einmal aus, wenn das Intervall das erste Mal abläuft. <xref:System.Timers.Timer.Enabled%2A> wird dann auf festgelegt `false` .  
  
> [!NOTE]
>  Wenn <xref:System.Timers.Timer.Enabled%2A> und <xref:System.Timers.Timer.AutoReset%2A> auf festgelegt sind `false` und der Timer zuvor aktiviert wurde, bewirkt das Festlegen der- <xref:System.Timers.Timer.Interval%2A> Eigenschaft, <xref:System.Timers.Timer.Elapsed> dass das-Ereignis einmal ausgelöst wird, als ob die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `true` . Um das Intervall festzulegen, ohne das-Ereignis zu erhöhen, können Sie die-Eigenschaft temporär <xref:System.Timers.Timer.Enabled%2A> auf festlegen `true` , die <xref:System.Timers.Timer.Interval%2A> -Eigenschaft auf das gewünschte Zeitintervall festlegen und die-Eigenschaft dann sofort <xref:System.Timers.Timer.Enabled%2A> wieder auf festlegen `false` .  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Timers.Timer>-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Intervall ist kleiner oder gleich 0 (null).  
  
- oder - 
Das Intervall ist größer als <see cref="F:System.Int32.MaxValue" />, und der Zeitgeber ist gegenwärtig aktiviert. (Wenn der Zeitgeber nicht gerade aktiviert ist, wird keine Ausnahme ausgelöst, bis er aktiviert wird.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Site ab, die die <see cref="T:System.Timers.Timer" />-Klasse im Entwurfsmodus an ihren Container bindet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.ComponentModel.ISite" />-Schnittstelle, die die Site darstellt, die das <see cref="T:System.Timers.Timer" />-Objekt an ihren Container bindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Standorte binden <xref:System.ComponentModel.Component> an einen <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen Ihnen und ermöglichen dem Container die Verwaltung seiner Komponenten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt mit dem Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und <xref:System.Timers.Timer.AutoReset%2A> auf festgelegt ist, löst das- `false` <xref:System.Timers.Timer> <xref:System.Timers.Timer.Elapsed> Ereignis nur einmal aus, wenn das Intervall das erste Mal abläuft. Wenn <xref:System.Timers.Timer.Start%2A> aufgerufen wird und den Wert hat, löst das- <xref:System.Timers.Timer.AutoReset%2A> `true` <xref:System.Timers.Timer> Ereignis aus, wenn <xref:System.Timers.Timer.Elapsed> das Intervall das erste Mal abläuft und das-Ereignis im angegebenen Intervall weiterhin auslöst.  
  
 Sie können auch die zeitliche Steuerung starten <xref:System.Timers.Timer.Enabled%2A> , indem Sie auf festlegen `true` .  
  
> [!NOTE]
>  Wenn den Wert <xref:System.Timers.Timer.AutoReset%2A> `false` hat, muss die- <xref:System.Timers.Timer.Start%2A> Methode aufgerufen werden, um die Anzahl erneut zu starten.  
  
 Ein Aufrufder- <xref:System.Timers.Timer.Start%2A> Methode, wenn der Timer aktiviert ist, hat keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="T:System.Timers.Timer" /> wird mit einem Intervall erstellt, das größer gleich <see cref="F:System.Int32.MaxValue" /> + 1 ist, oder auf ein Intervall kleiner als 0 (null) festgelegt.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht das Auslösen des <see cref="E:System.Timers.Timer.Elapsed" />-Ereignisses durch Festlegen von <see cref="P:System.Timers.Timer.Enabled" /> auf <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die zeitliche Steuerung Abbrechen <xref:System.Timers.Timer.Enabled%2A> , indem Sie auf festlegen `false` .  
  
> [!NOTE]
> Das Signal zum Erhöhen des <xref:System.Timers.Timer.Elapsed> Ereignisses wird immer zur Ausführung in einem Thread in die Warteschlange eingereiht <xref:System.Threading.ThreadPool> , sodass die Ereignis Behandlungsmethode in einem Thread ausgeführt werden kann, wenn ein Aufruf der-Methode in einem <xref:System.Timers.Timer.Stop%2A> anderen Thread ausgeführt wird. Dies kann dazu führen <xref:System.Timers.Timer.Elapsed> , dass das Ereignis ausgelöst wird, nachdem die- <xref:System.Timers.Timer.Stop%2A> Methode aufgerufen wurde. Das zweite Codebeispiel im Abschnitt "Beispiele" zeigt eine Möglichkeit, diese Racebedingung zu umgehen.
  
## Examples  
 Das folgende Beispiel instanziiert ein `System.Timers.Timer`-Objekt, das sein <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>-Ereignis alle zwei Sekunden (2000 Millisekunden) auslöst, einen Ereignishandler für das Ereignis einrichtet und den Timer startet. Der Ereignishandler zeigt den Wert der <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType>-Eigenschaft bei jedem Auslösen an. Wenn der Benutzer die EINGABETASTE drückt, ruft die Anwendung die-Methode auf,  <xref:System.Timers.Timer.Stop%2A> bevor die Anwendung beendet wird.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Im folgenden Codebeispiel wird eine Möglichkeit veranschaulicht, um zu verhindern, dass der Thread, der die- <xref:System.Timers.Timer.Stop%2A> Methode aufruft, fortgesetzt wird, bis ein aktuell ausgeführtes <xref:System.Timers.Timer.Elapsed> Ereignis endet. Außerdem wird verhindert, dass zwei <xref:System.Timers.Timer.Elapsed> Ereignisse gleichzeitig den Ereignishandler ausführen (häufig auch als "wieder eintreten" bezeichnet).  
  
 Im Beispiel werden 100 Testläufe ausgeführt. Jedes Mal, wenn der Test ausgeführt wird, wird der Timer mit einem Intervall von 150 Millisekunden gestartet. Der Ereignishandler verwendet die- <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Aufgabe zu simulieren, die nach dem Zufallsprinzip zwischen 50 und 200 Millisekunden variiert. Die Testmethode startet außerdem einen Steuerungs Thread, der auf eine Sekunde wartet und dann den Timer stoppt. Wenn ein Ereignis behandelt wird, wenn der Steuer Thread den Timer stoppt, muss der Steuerungs Thread warten, bis das Ereignis abgeschlossen ist, bevor der Vorgang fortgesetzt wird.  
  
 Die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> -Methoden Überladung wird verwendet, um einen erneuten eintreten zu vermeiden und zu verhindern, dass der Steuerungs Thread fortgesetzt wird, bis ein Ausführungs Ereignis endet. Der Ereignishandler verwendet die- <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> Methode, um eine Steuerelement Variable auf 1 festzulegen, aber nur, wenn der Wert momentan 0 (null) ist. Dies ist ein atomarer Vorgang. Wenn der Rückgabewert 0 (null) ist, wurde die Steuerungs Variable auf 1 festgelegt, und der Ereignishandler wird fortgesetzt. Wenn der Rückgabewert ungleich 0 (null) ist, wird das Ereignis einfach verworfen, um einen erneuten eintreten zu vermeiden. (Wenn es notwendig wäre, jedes Ereignis auszuführen, <xref:System.Threading.Monitor> wäre die Klasse eine bessere Möglichkeit, die Ereignisse zu synchronisieren.) Wenn der Ereignishandler beendet wird, wird die Steuerelement Variable auf 0 (null) zurückgesetzt. Im Beispiel wird die Gesamtzahl der ausgeführten Ereignisse aufgezeichnet, die aufgrund eines erneuten Eintretens verworfen wurden und nach dem Aufrufen der-Methode aufgetreten sind <xref:System.Timers.Timer.Stop%2A> .  
  
 Der Steuerungs Thread verwendet die <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> -Methode, um die Steuerelement Variable auf-1 (minus 1) festzulegen, aber nur, wenn der Wert momentan 0 (null) ist. Wenn die atomarische Operation einen Wert ungleich 0 (null) zurückgibt, wird zurzeit ein Ereignis ausgeführt. Der Steuerungs Thread wartet und versucht es erneut. Im Beispiel wird aufgezeichnet, wie oft der Steuerungs Thread auf den Abschluss eines Ereignisses warten musste.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.Timers.TimersDescription("TimerSynchronizingObject")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("TimerSynchronizingObject")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die nach Ablauf eines Intervalls ausgegeben werden, oder legt dieses fest.</summary>
        <value>Die <see cref="T:System.ComponentModel.ISynchronizeInvoke" />-Schnittstelle, die das Objekt zum Marshallen von Ereignishandleraufrufen darstellt, die nach Ablauf eines Intervalls ausgegeben werden. Der Standardwert lautet <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn den Wert <xref:System.Timers.Timer.SynchronizingObject%2A> `null` hat, wird die Methode, die das Ereignis behandelt, <xref:System.Timers.Timer.Elapsed> in einem Thread aus dem System Thread Pool aufgerufen. Weitere Informationen zu System Thread Pools finden Sie unter <xref:System.Threading.ThreadPool> .  
  
 Wenn das <xref:System.Timers.Timer.Elapsed> Ereignis von einer Visual Windows Forms-Komponente behandelt wird, z. b. einer Schaltfläche, kann der Zugriff auf die Komponente über den System Thread Pool zu einer Ausnahme führen oder funktioniert nicht. Vermeiden Sie diesen Effekt <xref:System.Timers.Timer.SynchronizingObject%2A> , indem Sie auf eine Windows Forms Komponente festlegen, die bewirkt, dass die Methode, die das Ereignis behandelt, <xref:System.Timers.Timer.Elapsed> für denselben Thread aufgerufen wird, auf dem die Komponente erstellt wurde.  
  
> [!NOTE]
>  Auch wenn die- <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft nicht ist `null` , <xref:System.Timers.Timer.Elapsed> können Ereignisse auftreten, nachdem die-Methode oder die- <xref:System.Timers.Timer.Dispose%2A> <xref:System.Timers.Timer.Stop%2A> Methode aufgerufen wurde, oder nachdem die- <xref:System.Timers.Timer.Enabled%2A> Eigenschaft auf festgelegt wurde `false` , da das Signal zum Aufrufen des <xref:System.Timers.Timer.Elapsed> Ereignisses stets in die Warteschlange für die Ausführung in einem Thread Pool Thread eingereiht wird. Eine Möglichkeit, diese Racebedingung aufzulösen, besteht darin, ein Flag zu setzen, das den Ereignishandler für das <xref:System.Timers.Timer.Elapsed>-Ereignis anweist, nachfolgende Ereignisse zu ignorieren.  
  
 Wenn <xref:System.Timers.Timer> in Visual Studio in einem Windows Forms-Designer verwendet wird, <xref:System.Timers.Timer.SynchronizingObject%2A> wird automatisch auf das Steuerelement festgelegt, das das enthält <xref:System.Timers.Timer> . Wenn Sie z. b. ein- <xref:System.Timers.Timer> Objekt in einem Designer für `Form1` (das von erbt <xref:System.Windows.Forms.Form> ) platzieren, wird die- <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft von <xref:System.Timers.Timer> auf die Instanz von festgelegt `Form1` .  
  
   
  
## Examples  
 Das folgende Beispiel ist eine Windows Forms-APP, die als sehr einfacher Textdatei-Editor fungiert. Wenn der Text im Textfeld nicht gespeichert wurde, wird der Benutzer von der app in Intervallen von einer Minute gefragt, ob er den Inhalt des Textfelds speichern möchte.  Zu diesem <xref:System.Timers.Timer.Interval%2A> Zweck wird die-Eigenschaft auf eine Minute (60.000 Millisekunden) festgelegt, und die- <xref:System.Timers.Timer.SynchronizingObject%2A> Eigenschaft wird auf das-Objekt festgelegt <xref:System.Windows.Forms.Form> .  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Das Beispiel erfordert, dass Sie dem Formular die folgenden Steuerelemente hinzufügen:  
  
-   Ein- <xref:System.Windows.Forms.TextBox> Steuerelement namens `TextBox1` (seinen Standardnamen).  
  
-   Ein- <xref:System.Windows.Forms.Button> Steuerelement namens `Button1` (seinen Standardnamen).  
  
-   Ein- <xref:System.Windows.Forms.SaveFileDialog> Steuerelement namens `SaveSaveFileDialog1` (seinen Standardnamen).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>
