<Type Name="SqlPipe" FullName="Microsoft.SqlServer.Server.SqlPipe">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c591e65fa92805a7a1e5c96fa03d5a45d1f410bb" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30339754" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlPipe" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlPipe extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.SqlServer.Server.SqlPipe" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlPipe" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlPipe sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht es verwalteten gespeicherten Prozeduren, die prozessintern in einer SQL Server-Datenbank ausgeführt werden, Ergebnisse an den Aufrufer zurückzugeben. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz dieser Klasse über verwaltete gespeicherte Prozeduren zur Verfügung gestellt wird die <xref:Microsoft.SqlServer.Server.SqlContext.Pipe%2A> Eigenschaft von der <xref:Microsoft.SqlServer.Server.SqlContext> Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Data.SqlClient.SqlConnection> und <xref:System.Data.SqlClient.SqlCommand> zum Auswählen von Zeilen aus einer Datenquelle in einer gespeicherten Prozedur. Anschließend wird eine <xref:Microsoft.SqlServer.Server.SqlPipe> führen Sie den Befehl und die Ergebnisse zurück an den Client gesendet.  
  
 [!code-csharp[DataWorks SqlPipe#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ExecuteAndSend">
      <MemberSignature Language="C#" Value="public void ExecuteAndSend (System.Data.SqlClient.SqlCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteAndSend(class System.Data.SqlClient.SqlCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.ExecuteAndSend(System.Data.SqlClient.SqlCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteAndSend (command As SqlCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteAndSend(System::Data::SqlClient::SqlCommand ^ command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.SqlClient.SqlCommand" />
      </Parameters>
      <Docs>
        <param name="command">Das auszuführende <see cref="T:System.Data.SqlClient.SqlCommand" />-Objekt.</param>
        <summary>Führt den als Parameter übergebenen Befehl aus und sendet die Ergebnisse an den Client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu den tatsächlichen Ergebnisse werden andere Nachrichten und der Fehler auch direkt an den Client gesendet.  
  
 Output-Parameter und Rückgabewerte werden nicht an den Client gesendet. Diese sind für den Aufrufer über die Parameters-Auflistung, der das Befehlsobjekt verfügbar.  
  
 Wenn der Befehl nicht auf eine prozessinterne Verbindung gebunden ist ein <xref:System.InvalidOperationException> ausgelöst wird. Diese Methode wird nicht bei Befehlen unterstützt, die an prozessexterne Verbindungen gebunden sind.  
  
 Treten Fehler in der <xref:System.Data.SqlClient.SqlCommand> -Objekt, das gesendet wurde, werden Ausnahmen an die Pipe gesendet, aber eine Kopie wird auch den aufrufenden verwalteten Code gesendet,. Wenn der aufrufende Code die Ausnahme nicht abfängt, wird es im Stapel an den Transact-SQL-Code weitergeben und zweimal in der Ausgabe angezeigt. Wenn der aufrufende Code die Ausnahme abfängt, der Pipe-Consumer wird der Fehler weiterhin angezeigt, aber es werden Fehler aufgrund doppelter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Data.SqlClient.SqlConnection> und <xref:System.Data.SqlClient.SqlCommand> zum Auswählen von Zeilen aus einer Datenquelle in einer gespeicherten Prozedur. Anschließend wird eine <xref:Microsoft.SqlServer.Server.SqlPipe> führen Sie den Befehl und die Ergebnisse zurück an den Client gesendet.  
  
 [!code-csharp[DataWorks SqlPipe.ExecuteAndSend#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe.ExecuteAndSend/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe.ExecuteAndSend#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe.ExecuteAndSend/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="command" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wird nicht bei Befehlen unterstützt, die an prozessexterne Verbindungen gebunden sind.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSendingResults">
      <MemberSignature Language="C#" Value="public bool IsSendingResults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSendingResults" />
      <MemberSignature Language="DocId" Value="P:Microsoft.SqlServer.Server.SqlPipe.IsSendingResults" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSendingResults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSendingResults { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Modus der <see cref="T:Microsoft.SqlServer.Server.SqlPipe" /> das Senden einzelner Resultsets zurück an den Client zulässt. Diese Eigenschaft ist schreibgeschützt.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />-Methode aufgerufen wurde und der Modus der <see cref="T:Microsoft.SqlServer.Server.SqlPipe" /> das Senden einzelner Resultsets zurück an den Client zulässt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Ergebnisse direkt an den Client oder den aktuellen Ausgabeconsumer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die **senden** -Methode sendet Daten direkt an den Client oder Aufrufer. Normalerweise ist es dem Client, der die Ausgabe der **Pipe** -Methode, aber im Fall von geschachtelten CLR gespeicherte Prozeduren, die Consumer der Ausgabe auch kann eine gespeicherte Prozedur handeln. Z. B. die prozedur1 ruft <xref:System.Data.SqlClient.SqlCommand.ExecuteReader%2A> mit dem Befehlstext "EXEC Procedure2". Bei Procedure2 handelt es ist auch eine verwaltete gespeicherte Prozedur. Wenn Procedure2 jetzt ruft <xref:Microsoft.SqlServer.Server.SqlPipe.Send%2A>, wird die Zeile an den Reader von Procedure1, nicht an den Client gesendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (Microsoft.SqlServer.Server.SqlDataRecord record);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(class Microsoft.SqlServer.Server.SqlDataRecord record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.Send(Microsoft.SqlServer.Server.SqlDataRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (record As SqlDataRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(Microsoft::SqlServer::Server::SqlDataRecord ^ record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="Microsoft.SqlServer.Server.SqlDataRecord" />
      </Parameters>
      <Docs>
        <param name="record">Das an den Client gesendete einzeilige Resultset: ein <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />-Objekt.</param>
        <summary>Sendet ein Resultset mit einer Zeile direkt an den Client oder aktuellen Ausgabeconsumer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="record" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (System.Data.SqlClient.SqlDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(class System.Data.SqlClient.SqlDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.Send(System.Data.SqlClient.SqlDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (reader As SqlDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Data::SqlClient::SqlDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.SqlClient.SqlDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Das mehrzeilige Resultset, das an den Client gesendet werden soll: ein <see cref="T:System.Data.SqlClient.SqlDataReader" />-Objekt.</param>
        <summary>Sendet ein Resultset mit mehreren Zeilen direkt an den Client oder aktuellen Ausgabeconsumer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Data.SqlClient.SqlDataReader> Objekt übergeben, wie ein Parameter Spalten ausgeblendet wurden, diese Spalten werden nicht weitergegeben, um das Resultset an den Client gesendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.Send(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die an den Client zu sendende Meldungszeichenfolge.</param>
        <summary>Sendet eine Zeichenfolgenmeldung direkt an den Client oder aktuellen Ausgabeconsumer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge wird als eine informative Meldung an dem Client gesendet. Clientanwendungen können Nachrichten durch verschiedene Mechanismen, abhängig von den Data Access-Anwendungsprogrammierschnittstelle (API) überwachen, die sie verwenden. Z. B. wenn der Client ADO.NET verwendet, das Übertragen von Nachrichten über die <xref:System.Data.SqlClient.SqlConnection.InfoMessage> Ereignis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:Microsoft.SqlServer.Server.SqlPipe.Send%2A> Methode, um eine Meldungszeichenfolge direkt an den Client zu senden.  
  
 [!code-csharp[DataWorks SqlPipe.Send#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe.Send/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe.Send#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe.Send/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="message" /> ist länger als 4.000 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendResultsEnd">
      <MemberSignature Language="C#" Value="public void SendResultsEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendResultsEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendResultsEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendResultsEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Markiert das Ende eines Resultsets und setzt die <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />-Instanz auf den Ausgangszustand zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwaltete gespeicherte Prozeduren können Resultsets senden, für Clients, die nicht implementiert sind eine <xref:System.Data.SqlClient.SqlDataReader>. Diese Methode zusammen mit <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> und <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A>, ermöglicht es gespeicherten Prozeduren, benutzerdefinierte Resultsets an den Client zu senden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:Microsoft.SqlServer.Server.SqlDataRecord> und dessen <xref:Microsoft.SqlServer.Server.SqlMetaData>. Im Beispiel wird dann kennzeichnet den Anfang eines Resultsets mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> Methode, sendet die Datensätze mit Beispieldaten zurück an den Client mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> -Methode und markiert das Ende des Resultsets festgelegt, mit der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> Methode.  
  
 [!code-csharp[DataWorks SqlPipe.SendResultsEnd#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsEnd/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe.SendResultsEnd#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsEnd/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />-Methode wurde zuvor nicht aufgerufen.</exception>
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow(Microsoft.SqlServer.Server.SqlDataRecord)" />
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
      </Docs>
    </Member>
    <Member MemberName="SendResultsRow">
      <MemberSignature Language="C#" Value="public void SendResultsRow (Microsoft.SqlServer.Server.SqlDataRecord record);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendResultsRow(class Microsoft.SqlServer.Server.SqlDataRecord record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow(Microsoft.SqlServer.Server.SqlDataRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendResultsRow (record As SqlDataRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendResultsRow(Microsoft::SqlServer::Server::SqlDataRecord ^ record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="Microsoft.SqlServer.Server.SqlDataRecord" />
      </Parameters>
      <Docs>
        <param name="record">Ein <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />-Objekt mit den Spaltenwerten für die Zeile, die an den Client gesendet werden sollen. Das Schema für den Datensatz muss mit dem Schema in den Metadaten des an die <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />-Methode übergebenen <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" /> übereinstimmen.</param>
        <summary>Sendet eine einzelne Datenzeile an den Client zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwaltete gespeicherte Prozeduren können Resultsets senden, für Clients, die nicht implementiert sind eine <xref:System.Data.SqlClient.SqlDataReader>. Diese Methode zusammen mit <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> und <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A>, ermöglicht es gespeicherten Prozeduren, benutzerdefinierte Resultsets an den Client zu senden.  
  
 Die <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> Methode sendet eine einzelne Zeile mit Daten an den Client zurück. Zeilen können anschließend an den Aufrufer zurückgegeben werden, durch den Aufruf <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A>, einmal für jede Zeile, die gesendet werden. Nachdem alle Zeilen gesendet wurden, einen Aufruf der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> Methode ist erforderlich, um das Ende des Resultsets zu markieren.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:Microsoft.SqlServer.Server.SqlDataRecord> und dessen <xref:Microsoft.SqlServer.Server.SqlMetaData>. Im Beispiel wird dann kennzeichnet den Anfang eines Resultsets mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> Methode, sendet die Datensätze mit Beispieldaten zurück an den Client mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> -Methode und markiert das Ende des Resultsets festgelegt, mit der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> Methode.  
  
 [!code-csharp[DataWorks SqlPipe.SendResultsRow#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsRow/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe.SendResultsRow#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsRow/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="record" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />-Methode wurde zuvor nicht aufgerufen.</exception>
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd" />
      </Docs>
    </Member>
    <Member MemberName="SendResultsStart">
      <MemberSignature Language="C#" Value="public void SendResultsStart (Microsoft.SqlServer.Server.SqlDataRecord record);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendResultsStart(class Microsoft.SqlServer.Server.SqlDataRecord record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendResultsStart (record As SqlDataRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendResultsStart(Microsoft::SqlServer::Server::SqlDataRecord ^ record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="Microsoft.SqlServer.Server.SqlDataRecord" />
      </Parameters>
      <Docs>
        <param name="record">Ein <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />-Objekt, aus dem Metadaten extrahiert werden, mit denen das Resultset beschrieben wird.</param>
        <summary>Kennzeichnet den Anfang eines an den Client zurückgesendeten Resultsets und erstellt mit dem Datensatzparameter die Metadaten zur Beschreibung des Resultsets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwaltete gespeicherte Prozeduren können Resultsets senden, für Clients, die nicht implementiert sind eine <xref:System.Data.SqlClient.SqlDataReader>. Diese Methode zusammen mit <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> und <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A>, ermöglicht es gespeicherten Prozeduren, benutzerdefinierte Resultsets an den Client zu senden.  
  
 Die <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> Methode kennzeichnet den Anfang eines Resultsets und verwendet den Datensatz-Parameter, um die Metadaten zu erstellen, die das Resultset beschreibt. Alle nachfolgenden Zeilen, die gesendet, mit der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> -Methode, müssen dieser Metadatendefinition entsprechen.  
  
 Beachten Sie, dass nach der Aufruf <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A>, nur <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> und <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> aufgerufen werden kann. Jede andere Methode in derselben Instanz von <xref:Microsoft.SqlServer.Server.SqlPipe> löst eine <xref:System.InvalidOperationException>. <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> Legt <xref:Microsoft.SqlServer.Server.SqlPipe> zurück an den Ausgangszustand, in dem andere Methoden aufgerufen werden können.  
  
 Nach dem Steuerelement in Transact-SQL-CLR-Ausführung zurückgibt, versuchen Sie nicht, eine statische oder lokale Variable, die mit CLR-Speicher initialisiert verwenden. Beispielsweise nicht speichern, die eine Instanz einer prozessinternen-Klasse, zum Beispiel `SQLDataRecord`, nachdem steuerelementrückgabe aus der CLR verwendet werden wird. Eine Ausnahme ist die `SQLMetaData` in Prozessklasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:Microsoft.SqlServer.Server.SqlDataRecord> und dessen <xref:Microsoft.SqlServer.Server.SqlMetaData>. Im Beispiel wird dann kennzeichnet den Anfang eines Resultsets mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart%2A> Methode, sendet die Datensätze mit Beispieldaten zurück an den Client mithilfe der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow%2A> -Methode und markiert das Ende des Resultsets festgelegt, mit der <xref:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd%2A> Methode.  
  
 [!code-csharp[DataWorks SqlPipe.SendResultsStart#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsStart/CS/source.cs#1)]
 [!code-vb[DataWorks SqlPipe.SendResultsStart#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlPipe.SendResultsStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="record" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="record" /> enthält keine Spalten oder wurde nicht initialisiert.</exception>
        <exception cref="T:System.InvalidOperationException">Eine andere Methode als <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow(Microsoft.SqlServer.Server.SqlDataRecord)" /> oder <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd" /> wurde nach der <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />-Methode aufgerufen.</exception>
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow(Microsoft.SqlServer.Server.SqlDataRecord)" />
        <altmember cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd" />
      </Docs>
    </Member>
  </Members>
</Type>