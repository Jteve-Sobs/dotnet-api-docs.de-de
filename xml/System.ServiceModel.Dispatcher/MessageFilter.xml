<Type Name="MessageFilter" FullName="System.ServiceModel.Dispatcher.MessageFilter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2bf2741f70be9470dce7f44d59502f4b15cf74d9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37615890" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MessageFilter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageFilter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.MessageFilter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageFilter" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageFilter abstract" />
  <TypeSignature Language="F#" Value="type MessageFilter = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.ServiceModel.Dispatcher.MatchNoneMessageFilter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.ServiceModel.Dispatcher.ActionMessageFilter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.ServiceModel.Dispatcher.MatchAllMessageFilter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.ServiceModel.Dispatcher.XPathMessageFilter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="bf3d6-101">
        <see langword="abstract" />-Basisklasse für verschiedene Klassen von Filtern, die verwendet werden, um Nachrichten abzufragen.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bf3d6-101">
          <see langword="abstract" /> base class for different classes of filters used to query messages.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-102"><xref:System.ServiceModel.Dispatcher.MessageFilter> ist eine `abstract`-Klasse, die Entwickler implementieren, um die Kriterien für das Prüfen von Nachrichten anzugeben.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-102"><xref:System.ServiceModel.Dispatcher.MessageFilter> is an `abstract` class that developers implement in order to specify the criteria to use for inspecting messages.</span></span> <span data-ttu-id="bf3d6-103">In der Regel werden Filter durch eine Endpunktanwendung verwendet, um festzulegen, was mit einer Nachricht auf der Basis einer Prüfung eines bestimmten Teils der Nachricht geschehen soll.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-103">Typically, filters are used by an endpoint application to determine what to do with a message based on an examination of some part of the message.</span></span> <span data-ttu-id="bf3d6-104">Ein Warteschlangenprozess kann beispielsweise eine XPath 1.0-Abfrage verwenden, um das Prioritätselement eines bekannten Headers im Hinblick darauf zu prüfen, ob eine Nachricht in der Warteschlange an den Anfang verschoben werden soll.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-104">A queuing process, for example, can use an XPath 1.0 query to check the priority element of a known header to determine whether to move a message to the front of the queue.</span></span>  
  
 <span data-ttu-id="bf3d6-105">Filter werden in einer Filtertabelle gespeichert, die <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> implementiert.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-105">Filters are stored in a filter table that implements <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>.</span></span> <span data-ttu-id="bf3d6-106">Jeder Filter in der Tabelle wird angegebenen Filterdaten zugeordnet, die verwendet werden können, um die Aktionen festzulegen, die vorgenommen werden, wenn eine Nachricht mit dem Filter übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-106">Each filter in the table is associated with specified filter data that can be used to indicate what actions to take if a message matches the filter.</span></span> <span data-ttu-id="bf3d6-107">Mit den <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A>-Methoden wird ermittelt, ob eine Nachricht zu einem Filter passt.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-107">The <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A> methods are used to determine if a message satisfies a filter.</span></span>  
  
 <span data-ttu-id="bf3d6-108">Die von einem Filter verwendeten Kriterien können nach der Konstruktion des Filters nicht mehr geändert werden, da die Filtertabellen keine Möglichkeit haben, eine Änderung zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-108">The criteria used by a filter cannot be changed once the filter is constructed because the filter tables have no way to detect a change.</span></span> <span data-ttu-id="bf3d6-109">Die einzige Möglichkeit, die Kriterien eines Filters zu ändern, besteht darin, einen neuen Filter zu konstruieren und den vorhandenen Filter zu löschen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-109">The only way to modify the criteria of a filter is to construct a new one and delete the existing filter.</span></span>  
  
 <span data-ttu-id="bf3d6-110">Die folgenden Klassen implementieren die `abstract`<xref:System.ServiceModel.Dispatcher.MessageFilter>-Klasse:</span><span class="sxs-lookup"><span data-stu-id="bf3d6-110">The following classes implement the `abstract`<xref:System.ServiceModel.Dispatcher.MessageFilter> class:</span></span>  
  
-   <span data-ttu-id="bf3d6-111"><xref:System.ServiceModel.Dispatcher.XPathMessageFilter> verwendet einen XPath 1.0-Ausdruck, um die Kriterien für eine Übereinstimmung anzugeben.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-111"><xref:System.ServiceModel.Dispatcher.XPathMessageFilter> uses an XPath 1.0 expression to specify the criteria for a match.</span></span>  
  
-   <span data-ttu-id="bf3d6-112"><xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter> liefert eine Übereinstimmung mit allen Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-112"><xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter> matches all messages.</span></span>  
  
-   <span data-ttu-id="bf3d6-113"><xref:System.ServiceModel.Dispatcher.MatchNoneMessageFilter> stimmt mit keiner der Nachrichten überein.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-113"><xref:System.ServiceModel.Dispatcher.MatchNoneMessageFilter> matches none of the messages.</span></span>  
  
-   <span data-ttu-id="bf3d6-114"><xref:System.ServiceModel.Dispatcher.ActionMessageFilter> testet, ob die Aktion einer Nachricht einem angegebenen Satz von Aktionen entspricht.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-114"><xref:System.ServiceModel.Dispatcher.ActionMessageFilter> tests whether the action of a message is one of a specified set of actions.</span></span>  
  
-   <span data-ttu-id="bf3d6-115"><xref:System.ServiceModel.Dispatcher.EndpointAddressMessageFilter> testet, ob eine Nachricht eine Übereinstimmung mit einer angegebenen Endpunktadresse aufweist.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-115"><xref:System.ServiceModel.Dispatcher.EndpointAddressMessageFilter> tests whether a message satisfies a specified endpoint address.</span></span>  
  
 <span data-ttu-id="bf3d6-116"><xref:System.ServiceModel.Channels.ChannelListenerBase%601> ist eine `abstract`-Basisklasse, die Sie verwenden können, um Listener ohne Warteschlagen zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-116"><xref:System.ServiceModel.Channels.ChannelListenerBase%601> is an `abstract` base class that you can use for writing non-queuing listeners.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageFilter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bf3d6-117">Initialisiert beim Aufruf in einer abgeleiteten Klasse eine neue Instanz der <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-117">When called in a derived class, initializes a new instance of the <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-118">Der Konstruktor ist geschützt, sodass nur Filter, die von <xref:System.ServiceModel.Dispatcher.MessageFilter> abgeleitet werden, instanziiert werden können.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-118">The constructor is protected so that only filters that derive from <xref:System.ServiceModel.Dispatcher.MessageFilter> can be instantiated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFilterTable&lt;FilterData&gt;">
      <MemberSignature Language="C#" Value="protected internal virtual System.ServiceModel.Dispatcher.IMessageFilterTable&lt;FilterData&gt; CreateFilterTable&lt;FilterData&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ServiceModel.Dispatcher.IMessageFilterTable`1&lt;!!FilterData&gt; CreateFilterTable&lt;FilterData&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateFilterTable(Of FilterData) () As IMessageFilterTable(Of FilterData)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename FilterData&gt;&#xA; virtual System::ServiceModel::Dispatcher::IMessageFilterTable&lt;FilterData&gt; ^ CreateFilterTable();" />
      <MemberSignature Language="F#" Value="abstract member CreateFilterTable : unit -&gt; System.ServiceModel.Dispatcher.IMessageFilterTable&lt;'FilterData&gt;&#xA;override this.CreateFilterTable : unit -&gt; System.ServiceModel.Dispatcher.IMessageFilterTable&lt;'FilterData&gt;" Usage="messageFilter.CreateFilterTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IMessageFilterTable&lt;FilterData&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="FilterData" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="FilterData">
          <span data-ttu-id="bf3d6-119">Den Filtern in der Tabelle zugeordnete Daten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-119">Data associated with the filters in the table.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="bf3d6-120">Erstellt eine Filtertabelle für einen Filter, der einen angegebenen Typ von ihm zugeordneten Daten hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-120">Creates a filter table for a filter that has a specified type of data associated with it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bf3d6-121">Ein <see cref="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" />-Objekt, dem <paramref name="FilterData" /> zugeordnete Filter hinzugefügt werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-121">An <see cref="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" /> object to which filters associated with <paramref name="FilterData" /> can be added.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-122">Diese Methode ist für das Aufrufen durch <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-122">This method is intended to be called by <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>.</span></span> <span data-ttu-id="bf3d6-123">Benutzer sollten eine Filtertabelle erstellen, indem sie einen Konstruktor für die Filtertabelle aufrufen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-123">Users should create a filter table by calling a constructor for the filter table.</span></span> <span data-ttu-id="bf3d6-124">Die Standardimplementierung für diese Methode gibt eine Filtertabelle zurück, die die <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A>-Methode für jeden Filter sequenziell aufruft.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-124">The default implementation of this method returns a filter table that calls the <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A> method of each filter sequentially.</span></span> <span data-ttu-id="bf3d6-125">Überschreiben Sie diese Methode, um eine benutzerdefinierte Filtertabelle zuzuordnen, wenn Sie einen Filter implementieren.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-125">Override this method to associate a custom filter table when implementing a filter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bf3d6-126">Wenn dies in einer abgeleiteten Klasse überschrieben wird, wird getestet, ob eine Nachricht oder eine gepufferte Nachricht die Kriterien eines Filters erfüllt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-126">When overridden in a derived class, tests whether a message or a buffered message satisfies the criteria of a filter.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-127">Der Unterschied zwischen den zwei Überladungen besteht darin, dass eine Überladung einen <xref:System.ServiceModel.Channels.Message>-Parameter entgegennimmt und den Nachrichtentext nicht überprüfen darf.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-127">The difference between the two overloads is that one takes a <xref:System.ServiceModel.Channels.Message> parameter and is not permitted to examine the body.</span></span> <span data-ttu-id="bf3d6-128">Die andere Überladung nimmt einen <xref:System.ServiceModel.Channels.MessageBuffer>-Parameter entgegen und kann jeden Teil der Nachricht überprüfen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-128">The other takes a <xref:System.ServiceModel.Channels.MessageBuffer> parameter and can examine any part of the message.</span></span> <span data-ttu-id="bf3d6-129">Nachrichtenheader werden automatisch gepuffert und können durch einen Filter geprüft werden, ohne verwendet zu werden.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-129">Message headers are automatically buffered and can be inspected by a filter without being consumed.</span></span> <span data-ttu-id="bf3d6-130">Wenn jedoch der Nachrichtentext durch einen Filter überprüft werden soll, muss die gesamte Nachricht gepuffert werden, da eine nicht gepufferte Nachricht durch eine Abfrage verwendet werden kann, wodurch ihr Inhalt zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-130">But if the body is to be inspected by a filter, then the entire message must be buffered because an unbuffered message body can be consumed by a query and its contents destroyed.</span></span>  
  
 <span data-ttu-id="bf3d6-131">Verwenden Sie <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A>, wenn die Prüfung des Nachrichtentexts nicht erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-131">Use <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A> if examination of the body is not required.</span></span> <span data-ttu-id="bf3d6-132">Verwenden Sie <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A>, wenn die Prüfung des Nachrichtentexts erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-132">Use <xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A> if examination of the message body is required.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="bf3d6-133">
            <para>
              <see langword="Null" /> -Nachrichten sind ungültig und sollten bewirken, dass ein <see cref="T:System.ArgumentNullException" /> ausgelöst wird.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-133">
              <para>
                <see langword="Null" /> messages are invalid, and should cause an <see cref="T:System.ArgumentNullException" /> to be thrown.</para>
            </span>
          </span>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public abstract bool Match (System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Match(class System.ServiceModel.Channels.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Match(System::ServiceModel::Channels::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Match : System.ServiceModel.Channels.Message -&gt; bool" Usage="messageFilter.Match message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="bf3d6-134">Das zu überprüfende <see cref="T:System.ServiceModel.Channels.Message" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-134">The <see cref="T:System.ServiceModel.Channels.Message" /> object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bf3d6-135">Wenn dies in einer abgeleiteten Klasse überschrieben wird, wird getestet, ob eine Nachricht die Filterkriterien erfüllt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-135">When overridden in a derived class, tests whether a message satisfies the filter criteria.</span>
          </span>
          <span data-ttu-id="bf3d6-136">Der Text kann nicht überprüft werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-136">The body cannot be examined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bf3d6-137">
            <see langword="true" />, wenn das <see cref="T:System.ServiceModel.Channels.Message" />-Objekt die Filterkriterien erfüllt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-137">
              <see langword="true" /> if the <see cref="T:System.ServiceModel.Channels.Message" /> object satisfies the filter criteria; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-138">Diese Methode kann den Inhalt des Nachrichtentexts nicht überprüfen.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-138">This method cannot inspect the contents of the message body.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="bf3d6-139">
            <para>Wenn der Filter versucht, den Text einer nicht gepufferten Nachricht zu überprüfen, und klicken Sie dann der Filter muss Auslösen einer <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" />. Es sollten keine zurückgeben <see langword="false" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-139">
              <para>If the filter attempts to examine the body of an unbuffered message, then the filter must throw an <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" />. It should not return <see langword="false" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public abstract bool Match (System.ServiceModel.Channels.MessageBuffer buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Match(class System.ServiceModel.Channels.MessageBuffer buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Match (buffer As MessageBuffer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Match(System::ServiceModel::Channels::MessageBuffer ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member Match : System.ServiceModel.Channels.MessageBuffer -&gt; bool" Usage="messageFilter.Match buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bf3d6-140">Das zu überprüfende <see cref="T:System.ServiceModel.Channels.MessageBuffer" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-140">The <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bf3d6-141">Wenn dies in einer abgeleiteten Klasse überschrieben wird, wird getestet, ob eine gepufferte Nachricht die Kriterien eines Filters erfüllt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-141">When overridden in a derived class, tests whether a buffered message satisfies the criteria of a filter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bf3d6-142">
            <see langword="true" />, wenn das <see cref="T:System.ServiceModel.Channels.MessageBuffer" />-Objekt die Filterkriterien erfüllt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bf3d6-142">
              <see langword="true" /> if the <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> object satisfies the filter criteria; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf3d6-143">Die Nachricht muss vollständig gepuffert werden, wenn der Text vom Filter überprüft werden soll.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-143">The message must be fully buffered if the body is to be inspected by the filter.</span></span> <span data-ttu-id="bf3d6-144">Der Text von <xref:System.ServiceModel.Channels.MessageBuffer> wird vollständig gepuffert und kann deshalb von einem Filter überprüft werden.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-144">The body of the <xref:System.ServiceModel.Channels.MessageBuffer> is fully buffered and therefore can be inspected by a filter.</span></span> <span data-ttu-id="bf3d6-145">Der Text einer <xref:System.ServiceModel.Channels.Message>, die nicht vollständig gepuffert wurde, kann durch die Filterprüfung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-145">The body of a <xref:System.ServiceModel.Channels.Message> that has not been fully buffered may be consumed by the filter inspection.</span></span> <span data-ttu-id="bf3d6-146">Das Headerelement einer <xref:System.ServiceModel.Channels.Message> wird automatisch gepuffert und kann deshalb überprüft werden, ohne verwendet zu werden.</span><span class="sxs-lookup"><span data-stu-id="bf3d6-146">The header element of a <xref:System.ServiceModel.Channels.Message> is automatically buffered and therefore can be inspected without being consumed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>