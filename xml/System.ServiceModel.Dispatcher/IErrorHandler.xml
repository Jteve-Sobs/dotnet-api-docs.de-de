<Type Name="IErrorHandler" FullName="System.ServiceModel.Dispatcher.IErrorHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a2285d06910f16471e7937c8b9a352ed5e89fdf3" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70600301" /></Metadata><TypeSignature Language="C#" Value="public interface IErrorHandler" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IErrorHandler" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.IErrorHandler" />
  <TypeSignature Language="VB.NET" Value="Public Interface IErrorHandler" />
  <TypeSignature Language="C++ CLI" Value="public interface class IErrorHandler" />
  <TypeSignature Language="F#" Value="type IErrorHandler = interface" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht bei der Implementierung die Steuerung der Fehlermeldung, die an den Aufrufer zurückgegeben wird, und optional die Durchführung von benutzerdefinierter Verarbeitung, wie z. B. Protokollierung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Verhalten der Anwendung explizit zu steuern, wenn eine Ausnahme ausgelöst wird, implementieren <xref:System.ServiceModel.Dispatcher.IErrorHandler> Sie die-Schnittstelle und <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>fügen <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A> Sie der-Eigenschaft des-Objekts hinzu. <xref:System.ServiceModel.Dispatcher.IErrorHandler> ermöglicht es Ihnen, explizit zu steuern, welcher SOAP-Fehler generiert wird, und zu entscheiden, ob der Fehler zurück zum Client geschickt und zugehörige Aufgaben ausgeführt werden sollen, z. B. Protokollieren. Fehlerhandler werden in der gleichen Reihenfolge aufgerufen, in der sie der <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A>-Eigenschaft hinzugefügt wurden.  
  
 Implementieren Sie die <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Methode, um die Fehlermeldung zu steuern, die dem Client zurückgegeben wird.  
  
 Implementieren Sie die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode, um fehlerbezogenes Verhalten, wie die Fehlerprotokollierung, die Sicherstellung eines Failfast, das Beenden der Anwendung und Ähnliches, zu ermöglichen.  
  
> [!NOTE]
>  Da die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode von vielen verschiedenen Quellen aus aufgerufen werden kann, kann nicht garantiert werden, über welchen Thread die Methode aufgerufen wird. Verlassen Sie sich nicht darauf, dass die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode vom Vorgangsthread aufgerufen wird.  
  
 Alle <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Implementierungen werden schon vor dem Senden einer Antwortnachricht aufgerufen. Wenn alle <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Implementierungen aufgerufen und zurückgegeben wurden und wenn `fault` nicht `null` ist, wird sie gemäß dem Vorgangsvertrag an den Client zurückgesendet. Wenn `fault``null` ist, nachdem alle Implementierungen aufgerufen wurden, wird die Antwortnachricht vom <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>-Eigenschaftswert gesteuert.  
  
> [!NOTE]
>  Ausnahmen können auftreten, nachdem alle <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Implementierungen aufgerufen wurden und eine Antwortnachricht an den Kanal weitergegeben wurde. Wenn eine Kanal Ausnahme auftritt (z. b. Schwierigkeiten beim Serialisieren der <xref:System.ServiceModel.Dispatcher.IErrorHandler> Nachricht), werden Objekte benachrichtigt. In diesem Fall sollten Sie dennoch sicherstellen, dass Ihre Entwicklungsumgebung solche Ausnahmen abfängt und anzeigt oder die Ablauf Verfolgung verwendet, um das Problem zu ermitteln. Weitere Informationen zur Ablauf Verfolgung finden Sie unter [Verwenden der Ablauf Verfolgung zum Beheben von Problemen mit Ihrer Anwendung](~/docs/framework/wcf/diagnostics/tracing/using-tracing-to-troubleshoot-your-application.md).  
  
 Nachdem die Antwortnachricht gesendet wurde, werden alle <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Implementierungen in der gleichen Reihenfolge aufgerufen.  
  
 In der Regel wird eine <xref:System.ServiceModel.Dispatcher.IErrorHandler>-Implementierung der <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A>-Eigenschaft für den Dienst hinzugefügt (und im Fall von Duplexkommunikation für den Client).  
  
 Sie können <xref:System.ServiceModel.Dispatcher.IErrorHandler> der Laufzeit hinzufügen, indem Sie Verhalten implementieren (entweder ein <xref:System.ServiceModel.Description.IServiceBehavior?displayProperty=nameWithType>-Objekt, ein <xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType>-Objekt, ein <xref:System.ServiceModel.Description.IContractBehavior?displayProperty=nameWithType>-Objekt oder ein <xref:System.ServiceModel.Description.IOperationBehavior?displayProperty=nameWithType>-Objekt) und das Verhalten programmgesteuert, von einer Konfigurationsdatei oder mit einem benutzerdefinierten Attribut zum Anfügen von <xref:System.ServiceModel.Dispatcher.IErrorHandler> verwenden.  
  
 Weitere Informationen zum Verwenden von Verhaltensweisen zum Ändern der Laufzeit finden Sie unter [Konfigurieren und Erweitern der Laufzeit mit Verhalten](~/docs/framework/wcf/extending/configuring-and-extending-the-runtime-with-behaviors.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen Dienst, der <xref:System.ServiceModel.Dispatcher.IErrorHandler> implementiert, wodurch nur <xref:System.ServiceModel.FaultException%601> des Typs `GreetingFault` zurückgegeben wird, wenn eine Dienstmethode eine verwaltete Ausnahme auslöst.  
  
 [!code-csharp[IErrorHandler#6](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#6)]
 [!code-vb[IErrorHandler#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#6)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Dienstverhalten verwendet wird, um die <xref:System.ServiceModel.Dispatcher.IErrorHandler>-Implementierung zur <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A>-Eigenschaft hinzuzufügen.  
  
 [!code-csharp[IErrorHandler#7](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#7)]
 [!code-vb[IErrorHandler#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#7)]  
  
 Im folgenden Codebeispiel wird die Konfiguration des Diensts zum Laden des Dienstverhaltens mit der Anwendungskonfigurationsdatei veranschaulicht. Weitere Informationen zur Verfügbarmachung eines Dienstverhaltens in einer Konfigurationsdatei finden Sie unter <xref:System.ServiceModel.Description.IServiceBehavior>.  

 [!code-xml[IErrorHandler#4](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/hostapplication.exe.config#4)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="HandleError">
      <MemberSignature Language="C#" Value="public bool HandleError (Exception error);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HandleError(class System.Exception error) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function HandleError (error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HandleError(Exception ^ error);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public bool HandleError (Exception exception);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HandleError(class System.Exception exception) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HandleError(Exception ^ exception);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IErrorHandler.HandleError(System.Exception)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member HandleError : Exception -&gt; bool" Usage="iErrorHandler.HandleError exception" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IErrorHandler.HandleError(System.Exception)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member HandleError : Exception -&gt; bool" Usage="iErrorHandler.HandleError exception" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.Exception" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="error">Die während der Verarbeitung ausgelöste Ausnahme.</param>
        <param name="exception">Die während der Verarbeitung ausgelöste Ausnahme.</param>
        <summary>Aktiviert fehlerbezogene Verarbeitung und gibt einen Wert zurück, der angibt, ob der Verteiler die Sitzung und den Instanzkontext in bestimmten Fällen abbricht.</summary>
        <returns><see langword="true" />, falls Windows Communication Foundation (WCF) die Sitzung (sofern vorhanden) und den Instanzkontext nicht abbrechen soll, falls der Instanzkontext nicht <see cref="F:System.ServiceModel.InstanceContextMode.Single" /> lautet; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode zum Implementieren von fehlerbezogenem Verhalten wie Fehlerprotokollierung, Systembenachrichtigungen, Herunterfahren der Anwendung und Ähnliches, und geben Sie einen Wert zurück, der angibt, ob die Ausnahme ordnungsgemäß behandelt wurde.  
  
> [!NOTE]
>  Da die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode von vielen verschiedenen Quellen aus aufgerufen werden kann, kann nicht garantiert werden, über welchen Thread die Methode aufgerufen wird. Verlassen Sie sich nicht darauf, dass die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode vom Vorgangsthread aufgerufen wird.  
  
 Alle <xref:System.ServiceModel.Dispatcher.IErrorHandler>-Implementierungen werden aufgerufen. Standardmäßig (wenn der Rückgabewert `false` lautet) bricht der Verteiler bei Ausnahmen alle Sitzungen ab und bricht auch den <xref:System.ServiceModel.InstanceContext> ab, falls der <xref:System.ServiceModel.InstanceContextMode><xref:System.ServiceModel.InstanceContextMode.Single> nicht entspricht.  Die Ausnahme gilt in diesem Fall als nicht behandelt, alle Zustände gelten als beschädigt.  
  
 Geben Sie `true` von <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A> zurück, um dieses Standardverhalten zu verhindern. Wenn ein Fehlerhandler zurück `true` gegeben wird, weist WCF an, dass es sicher ist, den mit der fehlgeschlagenen Anforderung verknüpften Status weiterhin zu verwenden.  
  
 Falls kein Fehlerhandler `true` für die <xref:System.ServiceModel.Dispatcher.IErrorHandler.HandleError%2A>-Methode zurückgibt, gilt die Ausnahme als nicht behandelt. Die Standardantwort wird übernommen, was bei der Kommunikation über einen Sitzungskanal oder wenn die <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType>-Eigenschaft nicht auf <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> festgelegt ist, möglicherweise zu einem abgebrochenen <xref:System.ServiceModel.InstanceContextMode.Single?displayProperty=nameWithType> und Channel führt.  
  
 Der `error`-Parameter ist nie `null` und enthält das Ausnahmeobjekt, das ausgelöst wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen Dienst, der <xref:System.ServiceModel.Dispatcher.IErrorHandler> implementiert, wodurch nur <xref:System.ServiceModel.FaultException%601> des Typs `GreetingFault` zurückgegeben wird, wenn eine Dienstmethode eine verwaltete Ausnahme auslöst.  
  
 [!code-csharp[IErrorHandler#6](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#6)]
 [!code-vb[IErrorHandler#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#6)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Dienstverhalten verwendet wird, um die <xref:System.ServiceModel.Dispatcher.IErrorHandler>-Implementierung zur <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A>-Eigenschaft hinzuzufügen.  
  
 [!code-csharp[IErrorHandler#7](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#7)]
 [!code-vb[IErrorHandler#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#7)]  
  
 Im folgenden Codebeispiel wird die Konfiguration des Diensts zum Laden des Dienstverhaltens mit der Anwendungskonfigurationsdatei veranschaulicht. Weitere Informationen zur Verfügbarmachung eines Dienstverhaltens in einer Konfigurationsdatei finden Sie unter <xref:System.ServiceModel.Description.IServiceBehavior>.  
  
 [!code-xml[IErrorHandler#4](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/hostapplication.exe.config#4)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideFault">
      <MemberSignature Language="C#" Value="public void ProvideFault (Exception error, System.ServiceModel.Channels.MessageVersion version, ref System.ServiceModel.Channels.Message fault);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProvideFault(class System.Exception error, class System.ServiceModel.Channels.MessageVersion version, class System.ServiceModel.Channels.Message&amp; fault) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProvideFault (error As Exception, version As MessageVersion, ByRef fault As Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProvideFault(Exception ^ error, System::ServiceModel::Channels::MessageVersion ^ version, System::ServiceModel::Channels::Message ^ % fault);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void ProvideFault (Exception exception, System.ServiceModel.Channels.MessageVersion version, ref System.ServiceModel.Channels.Message fault);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProvideFault(class System.Exception exception, class System.ServiceModel.Channels.MessageVersion version, class System.ServiceModel.Channels.Message&amp; fault) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProvideFault(Exception ^ exception, System::ServiceModel::Channels::MessageVersion ^ version, System::ServiceModel::Channels::Message ^ % fault);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault(System.Exception,System.ServiceModel.Channels.MessageVersion,System.ServiceModel.Channels.Message@)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member ProvideFault : Exception * System.ServiceModel.Channels.MessageVersion *  -&gt; unit" Usage="iErrorHandler.ProvideFault (exception, version, fault)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault(System.Exception,System.ServiceModel.Channels.MessageVersion,System.ServiceModel.Channels.Message@)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ProvideFault : Exception * System.ServiceModel.Channels.MessageVersion *  -&gt; unit" Usage="iErrorHandler.ProvideFault (exception, version, fault)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.Exception" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="version" Type="System.ServiceModel.Channels.MessageVersion" Index="1" />
        <Parameter Name="fault" Type="System.ServiceModel.Channels.Message" RefType="ref" Index="2" />
      </Parameters>
      <Docs>
        <param name="error">Das im Verlauf des Dienstvorgangs ausgelöste <see cref="T:System.Exception" />-Objekt.</param>
        <param name="exception">Das im Verlauf des Dienstvorgangs ausgelöste <see cref="T:System.Exception" />-Objekt.</param>
        <param name="version">Die SOAP-Version der Nachricht.</param>
        <param name="fault">Das <see cref="T:System.ServiceModel.Channels.Message" />-Objekt, das dem Client oder bei Duplexkommunikation dem Dienst zurückgegeben wird.</param>
        <summary>Aktiviert die Erstellung einer benutzerdefinierten <see cref="T:System.ServiceModel.FaultException`1" />, die während einer Dienstmethode von einer Ausnahme zurückgegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementieren Sie die <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Methode, um eine benutzerdefinierte Fehlermeldung zu erstellen, die dem Client zurückgegeben wird.  Die <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A> -Methode wird immer für Ausnahmen aufgerufen, die Vorgänge verlassen, es sei denn, die WCF-Laufzeit erkennt die Ausnahme als besonders schwerwiegend und löst die Ausnahme selbst erneut aus. Wenn alle <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Implementierungen aufgerufen wurden, wird die Fehlermeldung zurück an den Client gesendet (sofern `fault` nicht `null` ist). Wenn der `fault` -Parameter `null` ist, wird der Standardfehler an den Client gesendet.  
  
> [!NOTE]
>  Die eingehende Nachricht, die den Verarbeitungsfehler verursacht hat, ist während dieser Methode über die <xref:System.ServiceModel.OperationContext.RequestContext%2A?displayProperty=nameWithType>-Eigenschaft verfügbar.  
  
> [!NOTE]
>  Da die <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Methode von vielen verschiedenen Quellen aus aufgerufen werden kann, kann nicht garantiert werden, über welchen Thread die Methode aufgerufen wird. Verlassen Sie sich nicht darauf, dass die <xref:System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault%2A>-Methode vom Vorgangsthread aufgerufen wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen Dienst, der <xref:System.ServiceModel.Dispatcher.IErrorHandler> implementiert, wodurch nur <xref:System.ServiceModel.FaultException%601> des Typs `GreetingFault` zurückgegeben wird, wenn eine Dienstmethode eine verwaltete Ausnahme auslöst.  
  
 [!code-csharp[IErrorHandler#6](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#6)]
 [!code-vb[IErrorHandler#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#6)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Dienstverhalten verwendet wird, um die <xref:System.ServiceModel.Dispatcher.IErrorHandler>-Implementierung zur <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A>-Eigenschaft hinzuzufügen.  
  
 [!code-csharp[IErrorHandler#7](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/ierrorhandler.cs#7)]
 [!code-vb[IErrorHandler#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/ierrorhandler/vb/ierrorhandler.vb#7)]  
  
 Im folgenden Codebeispiel wird die Konfiguration des Diensts zum Laden des Dienstverhaltens mit der Anwendungskonfigurationsdatei veranschaulicht. Weitere Informationen zur Verfügbarmachung eines Dienstverhaltens in einer Konfigurationsdatei finden Sie unter <xref:System.ServiceModel.Description.IServiceBehavior>.  
  
 [!code-xml[IErrorHandler#4](~/samples/snippets/csharp/VS_Snippets_CFX/ierrorhandler/cs/hostapplication.exe.config#4)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
