<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aafb963db3ad1d2c7bc939adda5b3530efaeedd7" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51307998" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Auflistung.</typeparam>
    <summary>Stellt Sperr- und Begrenzungsfunktionen für threadsichere Auflistungen bereit, die <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> implementieren.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> ist eine threadsichere Auflistungsklasse, die Folgendes bereitstellt:  
  
-   Eine Implementierung des Producer/Consumer-Musters, andernfalls <xref:System.Collections.Concurrent.BlockingCollection%601> ist ein Wrapper für die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> Schnittstelle.  
  
-   Gleichzeitige hinzufügen und Entfernen von Elementen aus mehreren Threads mit der <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> und <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> Methoden.  
  
-   Einer begrenzten Auflistung, die blockiert <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> und <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> Vorgänge, wenn die Auflistung full oder empty ist.  
  
-   Abbruch <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> oder <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> -Vorgänge durch ein <xref:System.Threading.CancellationToken> -Objekt in der <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> oder <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> Methode.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema. Beachten Sie außerdem, dass die <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> Methode ist nicht threadsicher. Alle anderen öffentlichen und geschützten Member der <xref:System.Collections.Concurrent.BlockingCollection%601> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> Stellt eine Auflistung, die Thread-sichere hinzufügen und Entfernen von Daten ermöglicht. <xref:System.Collections.Concurrent.BlockingCollection%601> Dient als Wrapper für ein <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> Instanz, und ermöglicht die Entfernung Versuche aus der Auflistung blockiert, bis Daten entfernt werden soll, verfügbar sind. Auf ähnliche Weise können Sie erstellen eine <xref:System.Collections.Concurrent.BlockingCollection%601> zum Erzwingen der obere Grenze hinsichtlich der Anzahl von Datenelementen, die innerhalb der <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; außerdem versucht, auf die Auflistung blockieren können dann, bis der Speicherplatz zum Speichern von die hinzugefügten Elemente verfügbar ist. Auf diese Weise <xref:System.Collections.Concurrent.BlockingCollection%601> ähnelt einem herkömmlichen blockierende Warteschlange-Datenstruktur, mit der Ausnahme, dass der zugrunde liegenden Speichermechanismus für die Daten sofort als abstrahiert werden ein <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> unterstützt das Begrenzen und Blockieren. Begrenzen bedeutet, dass an, dass Sie die maximale Kapazität der Auflistung festlegen können. Begrenzen ist in bestimmten Szenarien wichtig, da Sie die maximale Größe der Auflistung im Arbeitsspeicher steuern können, und es wird verhindert, dass die erzeugenden Threads zu weit vor die verbrauchenden Threads verschieben. Mehrere Threads oder Tasks können Elemente hinzufügen, die der Auflistung gleichzeitig aus, und wenn die Auflistung die angegebene maximale Kapazität erreicht, werden die erzeugenden Threads blockiert, bis ein Element entfernt wird. Mehrere Consumer können gleichzeitig Elemente entfernen, und wenn die Sammlung leer ist, werden die verbrauchenden Threads blockiert, bis ein Producer ein Element hinzufügt. Ein Producer-Thread aufrufen, kann die <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> Methode, um anzugeben, dass keine weiteren Elemente mehr hinzugefügt werden. Consumer überwachen die <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A>-Eigenschaft, um zu erkennen, wann die Sammlung leer ist und keine Elemente mehr hinzugefügt werden.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> und <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> Vorgänge in der Regel in einer Schleife ausgeführt werden. Sie können eine Schleife durch die Übergabe Abbrechen ein <xref:System.Threading.CancellationToken> -Objekt der <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> oder <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> -Methode, und klicken Sie dann den Wert der des Tokens überprüfen <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> Eigenschaft bei jeder Iteration. Wenn der Wert ist `true`, es liegt bei Ihnen die abbruchanforderung durch Bereinigen aller Ressourcen und Beenden der Schleife zu reagieren.  
  
 Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie angeben, nicht nur die begrenzte Kapazität sondern auch der Typ der Auflistung verwendet. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Ändern Sie die zugrunde liegende Auflistung nicht direkt. Verwendung <xref:System.Collections.Concurrent.BlockingCollection%601> Methoden zum Hinzufügen oder Entfernen von Elementen. Die <xref:System.Collections.Concurrent.BlockingCollection%601> Objekt kann beschädigt werden, wenn Sie die zugrunde liegende Auflistung direkt ändern.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Hinzufügen und gleichzeitig aus einer blockierungsauflistung:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Die Dispose-Methode ist nicht threadsicher. Alle anderen öffentlichen und geschützten Member der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
    <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
    <related type="Article" href="http://msdn.microsoft.com/library/4c2492de-3876-4873-b5a1-000bb404d770">Vorgehensweise: Hinzufügen von Begrenzungs- und Blockadefunktionen zu einer Auflistungsklasse</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse ohne obere Grenze.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse ohne obere Grenze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zugrunde liegende Auflistung ist eine <xref:System.Collections.Concurrent.ConcurrentQueue%601> -Objekt, das zuerst in, out (FIFO) erste Verhalten bietet.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, die als zugrunde liegender Datenspeicher verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse ohne obere Grenze und unter Verwendung der angegebenen <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> als zugrunde liegenden Datenspeicher.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collection" />-Argument ist null.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">Die begrenzte Größe der Auflistung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse mit der angegebenen oberen Grenze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zugrunde liegende Auflistung ist eine <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="boundedCapacity" /> ist kein positiver Wert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, die als zugrunde liegender Datenspeicher verwendet werden soll.</param>
        <param name="boundedCapacity">Die begrenzte Größe der Auflistung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse mit der angegebenen oberen Grenze und unter Verwendung der angegebenen <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> als zugrunde liegenden Datenspeicher.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collection" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="boundedCapacity" /> ist kein positiver Wert.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="collection" /> enthält mehr Werte als von <paramref name="boundedCapacity" /> erlaubt.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt das Element der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> hinzu.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll. Der Wert kann ein NULL-Verweis sein.</param>
        <summary>Fügt das Element der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine begrenzte Kapazität angegeben wurde bei der diese Instanz von <xref:System.Collections.Concurrent.BlockingCollection%601> wurde initialisiert, ein Aufruf von Add möglicherweise blockiert, bis Speicherplatz zum Speichern des angegebenen Elements verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll. Der Wert kann ein NULL-Verweis sein.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Fügt das Element der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine begrenzte Kapazität angegeben wurde bei der diese Instanz von <xref:System.Collections.Concurrent.BlockingCollection%601> initialisiert wurde, einen Aufruf von <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> möglicherweise blockiert, bis Speicherplatz zum Speichern des angegebenen Elements verfügbar ist.  
  
 Diese Methode kann mit einem frühen Zeitpunkt Zurückgeben einer <xref:System.OperationCanceledException> Wenn die `cancellationToken` abgebrochen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde freigegeben, oder die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> besitzt, wurde freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt das angegebene Element einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <summary>Fügt das angegebene Element einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen hinzu.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine begrenzte Kapazität angegeben wurde bei der alle der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanzen initialisiert wurden, ein Aufruf von AddToAny möglicherweise blockiert, bis der Speicherplatz in einer der Sammlungen zum Speichern des angegebenen Elements verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Fügt das angegebene Element einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen hinzu.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine begrenzte Kapazität angegeben wurde bei der alle der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanzen initialisiert wurden, ein Aufruf von AddToAny möglicherweise blockiert, bis der Speicherplatz in einer der Sammlungen zum Speichern des angegebenen Elements verfügbar ist. Dieser Methode kann zurückgegeben werden, bevor das Element an eine beliebige Auflistung hinzugefügt wird, wenn die `cancellationToken` abgebrochen wird, bevor Speicherplatz verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen oder die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die begrenzte Kapazität dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz ab.</summary>
        <value>Die begrenzte Kapazität dieser Auflistung oder int.MaxValue, wenn keine Begrenzung angegeben wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Markiert die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen als Instanzen, die keine weiteren Hinzufügungen annehmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem Sie eine Sammlung für das Hinzufügen als abgeschlossen markiert wurde, wird der Auflistung hinzugefügt ist nicht zulässig, und versucht, aus der Auflistung entfernt werden nicht gewartet wird, wenn die Auflistung leer ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das als Ziel der aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz kopierten Elemente fungiert. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <summary>Kopiert alle Elemente in der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz in ein kompatibles eindimensionales Array, wobei am angegebenen Index des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo-Vorgang stellt eine Momentaufnahme der Auflistung, an einem bestimmten Zeitpunkt dar. Wenn andere Threads hinzufügen oder Entfernen von Elementen während CopyTo-Vorgang ausgeführt wird, können der von CopyTo-Vorgang zurückgegebenen Elemente nicht den Zustand der Sammlung darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="array" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="index" />-Argument ist weniger als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="index" />-Argument ist gleich  oder größer als die Länge des <paramref name="array" />.  
  
Das Zielarray ist zu klein, um alle BlockingCcollection-Elemente aufzunehmen.  
  
Der Arrayrang stimmt nicht überein.  
  
Der Arraytyp ist mit dem Typ der BlockingCollection-Elemente nicht kompatibel.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente in <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ab.</summary>
        <value>Die Anzahl der Elemente in der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Methode in BlockingCollection ausgeführt wird, während die Count-Eigenschaft zugegriffen wird, ist der Rückgabewert ungefähre. Anzahl der dienstsynchronisierung vorliegen einer Zahl, die entweder größer oder kleiner als die tatsächliche Anzahl der Elemente in der BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dispose` Methode ist nicht threadsicher.  
  
 Rufen Sie `Dispose` auf, wenn Sie <xref:System.Collections.Concurrent.BlockingCollection%601> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Collections.Concurrent.BlockingCollection%601> nicht mehr verwendet werden kann. Nach dem Aufruf `Dispose`, Sie müssen alle Verweise auf Freigeben der <xref:System.Collections.Concurrent.BlockingCollection%601> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Collections.Concurrent.BlockingCollection%601> belegt wurde.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Collections.Concurrent.BlockingCollection%601> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Collections.Concurrent.BlockingCollection%601>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ob explizit verworfen (true) oder wegen eines Finalizers (false).</param>
        <summary>Gibt von der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt ein verwendetes <see cref="T:System.Collections.Generic.IEnumerator`1" /> für Elemente in der Auflistung bereit.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt ein verwendetes <see cref="T:System.Collections.Generic.IEnumerator`1" /> für Elemente in der Auflistung bereit.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Auflistung entfernt und zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> Methode:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__2))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__68))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Stellt ein verwendetes <see cref="T:System.Collections.Generic.IEnumerable`1" /> für Elemente in der Auflistung bereit.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Auflistung entfernt und zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht Clientcode, um Elemente aus der Auflistung entfernt werden, mithilfe einer Foreach-Schleife (für jede in Visual Basic), oder <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oder einer PLINQ-Abfrage. Der Enumerator stellt Elemente bereit (sofern vorhanden) weiterhin, bis <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> gibt true zurück, und wenn <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> wird "false" der Schleife blockiert, bis ein Element verfügbar ist oder bis die <xref:System.Threading.CancellationToken> wird abgebrochen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde freigegeben, oder die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob diese <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zum Hinzufügen als vollständig markiert wurde.</summary>
        <value>Ob diese Auflistung zum Hinzufügen als vollständig markiert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob diese <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zum Hinzufügen als vollständig markiert wurde und leer ist.</summary>
        <value>Ob diese Auflistung zum Hinzufügen als vollständig markiert wurde und leer ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt einen <see cref="T:System.Collections.Generic.IEnumerator`1" /> für Elemente in der Auflistung bereit.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" /> für die Elemente in der Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> gibt einen Standardenumerator, die die zugrunde liegende Auflistung nicht ändert. Wenn andere Threads hinzufügen oder Entfernen von Elementen gleichzeitig verwendet werden, wenn "GetEnumerator" aufgerufen wird, können die Elemente, die vom Enumerator zurückgegebenes nicht den aktuellen Zustand der Auflistung darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das als Ziel der aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz kopierten Elemente fungiert. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <summary>Kopiert alle Elemente in der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz in ein kompatibles eindimensionales Array, wobei am angegebenen Index des Zielarrays begonnen wird.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="array" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das <paramref name="index" />-Argument ist weniger als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="index" />-Argument ist gleich oder größer als die Länge des <paramref name="array" />, das Array ist mehrdimensional, oder der Typparameter für die Auflistung kann in den Typ des Zielarrays nicht automatisch umgewandelt werden.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert ist.</summary>
        <value>Gibt immer false zurück.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann. Diese Eigenschaft wird nicht unterstützt.</summary>
        <value>Gibt NULL zurück.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Die SyncRoot-Eigenschaft wird nicht unterstützt.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt einen <see cref="T:System.Collections.IEnumerator" /> für Elemente in der Auflistung bereit.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die Elemente in der Auflistung.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt ein Element aus <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt ein Element aus <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Das aus der Auflistung entfernte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> möglicherweise blockiert, bis ein Element zum Entfernen verfügbar ist.  
  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert, oder die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ist leer, und die Auflistung wurde zum Hinzufügen als vollständig markiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Objekt, mit dem der Take-Vorgang abgebrochen werden kann.</param>
        <summary>Entfernt ein Element aus <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Das aus der Auflistung entfernte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist, oder das Token abgebrochen wird.  
  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <see cref="T:System.Threading.CancellationToken" /> wird abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde freigegeben, oder die <see cref="T:System.Threading.CancellationTokenSource" />, die das Token erstellt hat, wurde abgebrochen.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert, die BlockingCollection ist zum Hinzufügen als vollständig markiert, oder die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ist leer.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verwendet ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <summary>Verwendet ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein Array der Länge 0 oder enthält ein NULL-Element oder <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> wurde für die Auflistung aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Verwendet ein Element aus einer angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz und berücksichtigt das angegebene Abbruchtoken.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist. Die Methode wird mit einer OperationCanceledException früh zurückgegeben, wenn das Token abgebrochen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein Array der Länge 0 oder enthält ein NULL-Element oder <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> wurde für die Auflistung aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Elemente aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz in ein neues Array.</summary>
        <returns>Ein Array, das Kopien der Elemente aus der Auflistung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der kopierten Elemente werden nicht aus der Auflistung entfernt werden.  
  
 Wenn eine Methode in BlockingCollection ausgeführt wird, während die ToArray-Methode ausgeführt wird, ist der Rückgabewert ungefähre. ToArray möglicherweise enthalten Elemente, die bereits entfernt wurden, oder Ausschließen von Elementen, die bereits eingefügt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> das angegebene Element hinzuzufügen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll.</param>
        <summary>Versucht, der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> das angegebene Element hinzuzufügen.</summary>
        <returns>True, wenn <paramref name="item" /> hinzugefügt werden konnte; andernfalls False. Wenn das Element ein Duplikat ist und die zugrunde liegende Auflistung keine Duplikate zulässt, wird eine <see cref="T:System.InvalidOperationException" /> ausgelöst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auflistung eine begrenzte Sammlung ist und voll ist, gibt diese Methode sofort ohne Hinzufügen des Elements "false".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Versucht, das angegebene Element im angegebenen Zeitraum der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> hinzuzufügen.</summary>
        <returns>True, wenn der Auflistung innerhalb der angegebenen Zeit das <paramref name="item" /> hinzugefügt werden konnte, andernfalls false. Wenn das Element ein Duplikat ist und die zugrunde liegende Auflistung keine Duplikate zulässt, wird eine <see cref="T:System.InvalidOperationException" /> ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Versucht, der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> das angegebene Element hinzuzufügen.</summary>
        <returns>TRUE, wenn der Auflistung innerhalb des angegebenen Zeitraums <paramref name="item" /> hinzugefügt werden konnte, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das der Auflistung hinzugefügt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Versucht, das angegebene Element unter Berücksichtigung des Abbruchtokens im angegebenen Zeitraum der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> hinzuzufügen.</summary>
        <returns>True, wenn der Auflistung innerhalb der angegebenen Zeit das <paramref name="item" /> hinzugefügt werden konnte, andernfalls false. Wenn das Element ein Duplikat ist und die zugrunde liegende Auflistung keine Duplikate zulässt, wird eine <see cref="T:System.InvalidOperationException" /> ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde entfernt, oder die zugrundeliegende <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde hinsichtlich Hinzufügungen als vollständig markiert.  
  
- oder -  
Das Element wurde von der zugrunde liegenden Auflistung nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen das angegebene Element hinzuzufügen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <summary>Versucht, einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen das angegebene Element hinzuzufügen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde, oder -1, wenn das Element nicht hinzugefügt werden konnte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Versucht, einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen das angegebene Element hinzuzufügen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde, oder -1, wenn das Element nicht hinzugefügt werden konnte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt. 
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Versucht, das angegebene Element einer angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz hinzuzufügen und berücksichtigt das angegebene Abbruchtoken.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde, oder -1, wenn das Element nicht hinzugefügt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann einem frühen Zeitpunkt zurückgeben, wenn das CancellationToken abgebrochen wird, bevor der Speicherplatz für die der Vorgang zum Hinzufügen verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen oder die <see cref="T:System.Threading.CancellationTokenSource" />, die <paramref name="cancellationToken" /> erstellt hat, wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.  
  
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das einer der Auflistungen hinzugefügt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Versucht, einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen das angegebene Element hinzuzufügen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, dem das Element hinzugefügt wurde, oder -1, wenn das Element nicht hinzugefügt werden konnte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine zugrunde liegende Auflistung hat das Element nicht akzeptiert.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt. 
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element, oder mindestens eine Auflistungen wurde für Hinzufügungen als vollständig markiert.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, ein Element aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zu entfernen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>-Methode gezeigt.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das aus der Auflistung entfernt werden soll.</param>
        <summary>Versucht, ein Element aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zu entfernen.</summary>
        <returns>
          <see langword="true" />, wenn ein Element entfernt werden konnte; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auflistung leer ist, gibt diese Methode sofort "false" zurück.  
  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das aus der Auflistung entfernt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Versucht, ein Element im angegebenen Zeitraum aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zu entfernen.</summary>
        <returns>
          <see langword="true" />, wenn ein Element innerhalb der angegebenen Zeit aus der Auflistung entfernt werden konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601>, können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das aus der Auflistung entfernt werden soll.</param>
        <param name="timeout">Ein Objekt, dass die Anzahl der zu wartenden Millisekunden angibt, oder ein Objekt, das -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Versucht, ein Element im angegebenen Zeitraum aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zu entfernen.</summary>
        <returns>
          <see langword="true" />, wenn ein Element innerhalb der angegebenen Zeit aus der Auflistung entfernt werden konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich -1 Millisekunden, die ein unendliches Timeout darstellt. 
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das aus der Auflistung entfernt werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Versucht, ein Element unter Berücksichtigung des Abbruchtokens im angegebenen Zeitraum aus der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> zu entfernen.</summary>
        <returns>
          <see langword="true" />, wenn ein Element innerhalb der angegebenen Zeit aus der Auflistung entfernt werden konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge, in dem ein Element entfernt wird, hängt der Typ der Auflistung, die zum Erstellen der <xref:System.Collections.Concurrent.BlockingCollection%601> Instanz. Bei der Erstellung einer <xref:System.Collections.Concurrent.BlockingCollection%601> -Objekt können Sie den Typ des zu verwendenden angeben. Beispielsweise können Sie angeben einer <xref:System.Collections.Concurrent.ConcurrentQueue%601> Objekt für das First-in, out (FIFO) erste Verhalten, oder ein <xref:System.Collections.Concurrent.ConcurrentStack%601> -Objekt für die letzte, erste LIFO-Verhalten. Sie können jede Sammlungsklasse verwenden, die die <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Schnittstelle implementiert. Der standardmäßige Sammlungstyp für <xref:System.Collections.Concurrent.BlockingCollection%601> ist <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Das <see cref="T:System.Threading.CancellationToken" /> wurde abgebrochen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> wurde entfernt, oder die zugrundeliegende <see cref="T:System.Threading.CancellationTokenSource" /> wurde verworfen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die zugrundeliegende Auflistung wurde außerhalb dieser <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <summary>Versucht, ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen zu entfernen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde, oder -1, wenn ein Element nicht entfernt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TryTakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> Methode:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <summary>Versucht, ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen zu entfernen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde, oder -1, wenn ein Element nicht entfernt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TryTakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt. 
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />-Struktur, die die Anzahl der zu wartenden Millisekunden angibt, oder eine <see cref="T:System.TimeSpan" />-Struktur, die -1 Millisekunden zum unendlichen Warten angibt.</param>
        <summary>Versucht, ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen zu entfernen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde, oder -1, wenn ein Element nicht entfernt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TryTakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> ist eine negative Zahl ungleich  -1 Millisekunden, die ein unendliches Timeout darstellt, - oder - Timeout ist größer als <see cref="F:System.Int32.MaxValue" />.  
  
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Das Array von Auflistungen.</param>
        <param name="item">Das Element, das aus einer der Auflistungen entfernt wurde.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, oder <see cref="F:System.Threading.Timeout.Infinite" /> (-1) für Warten ohne Timeout.</param>
        <param name="cancellationToken">Ein Abbruchtoken, das überwacht werden soll.</param>
        <summary>Versucht, ein Element aus einer der angegebenen <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen zu entfernen.</summary>
        <returns>Der Index der Auflistung im <paramref name="collections" />-Array, aus dem das Element entfernt wurde, oder -1, wenn ein Element nicht entfernt werden konnte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf von TryTakeFromAny möglicherweise blockiert, bis ein Element entfernt werden soll, verfügbar ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Wenn <see cref="T:System.Threading.CancellationToken" /> abgebrochen ist.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens eine der zugrunde liegenden Auflistungen wurde außerhalb seiner <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanz geändert.</exception>
        <exception cref="T:System.ArgumentNullException">Das <paramref name="collections" />-Argument ist null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt. 
- oder -  
Die Anzahl von <paramref name="collections" /> ist größer als die maximale Größe von 62 für STA und 63 für MTA.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="collections" />-Argument ist ein 0-Länge-Array oder enthält ein NULL-Element.</exception>
        <exception cref="T:System.ObjectDisposedException">Mindestens eine der <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />-Instanzen wurde freigegeben.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Threadsichere Auflistungen</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Übersicht über BlockingCollections</related>
      </Docs>
    </Member>
  </Members>
</Type>