<Type Name="Partitioner&lt;TSource&gt;" FullName="System.Collections.Concurrent.Partitioner&lt;TSource&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="673e728ff564749ab12475be86a0b04bca4b76ad" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51926498" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Partitioner&lt;TSource&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Partitioner`1&lt;TSource&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.Partitioner`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Partitioner(Of TSource)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSource&gt;&#xA;public ref class Partitioner abstract" />
  <TypeSignature Language="F#" Value="type Partitioner&lt;'Source&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSource" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TSource">Typ der Elemente in der Auflistung.</typeparam>
    <summary>Stellt eine bestimmte Methode dar, mit der eine Datenquelle in mehrere Partitionen aufgeteilt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Partitionierer implementieren, der ein einzelnes Element zu einem Zeitpunkt zurückgibt:  
  
 [!code-csharp[System.Collections.Concurrent.Partitioner#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.partitioner/cs/partitioner.cs#1)]
 [!code-vb[System.Collections.Concurrent.Partitioner#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.partitioner/vb/partitioner.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Die statischen Methoden <see cref="T:System.Collections.Concurrent.Partitioner`1" /> sind alle threadsicher und können von mehreren Threads gleichzeitig verwendet werden. Allerdings während ein erstellter Partitionierer verwendet wird, sollte die zugrunde liegenden Datenquelle nicht geändert werden, ob aus dem gleichen Thread, der einen Partitionierer verwendet oder von einem separaten Thread ist.</threadsafe>
    <altmember cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />
    <altmember cref="T:System.Collections.Concurrent.Partitioner" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Partitioner ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.Partitioner`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Partitioner();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Partitioniererinstanz.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />
        <altmember cref="T:System.Collections.Concurrent.Partitioner" />
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">Benutzerdefinierte Partitionierer für PLINQ und TPL</related>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicPartitions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;TSource&gt; GetDynamicPartitions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;!TSource&gt; GetDynamicPartitions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicPartitions () As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ GetDynamicPartitions();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicPartitions : unit -&gt; seq&lt;'Source&gt;&#xA;override this.GetDynamicPartitions : unit -&gt; seq&lt;'Source&gt;" Usage="partitioner.GetDynamicPartitions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Objekt, das die zugrunde liegende Auflistung in eine variable Anzahl von Partitionen partitionieren kann.</summary>
        <returns>Ein Objekt, das Partitionen über der zugrunde liegenden Datenquelle erstellen kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Objekt implementiert die <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> Schnittstelle. Aufrufen von <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> erstellt Sie eine andere Partition für das Objekt über die Sequenz.  
  
 Die <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> Methode wird nur unterstützt, wenn die <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> -Eigenschaft gibt "true" zurück. Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dynamische Partitionierung wird nicht von der Basisklasse unterstützt. Sie müssen dies in einer abgeleiteten Klasse implementieren.</exception>
        <altmember cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />
        <altmember cref="T:System.Collections.Concurrent.Partitioner" />
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">Benutzerdefinierte Partitionierer für PLINQ und TPL</related>
      </Docs>
    </Member>
    <Member MemberName="GetPartitions">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt; GetPartitions (int partitionCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Collections.Generic.IEnumerator`1&lt;!TSource&gt;&gt; GetPartitions(int32 partitionCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetPartitions (partitionCount As Integer) As IList(Of IEnumerator(Of TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;System::Collections::Generic::IEnumerator&lt;TSource&gt; ^&gt; ^ GetPartitions(int partitionCount);" />
      <MemberSignature Language="F#" Value="abstract member GetPartitions : int -&gt; System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;'Source&gt;&gt;" Usage="partitioner.GetPartitions partitionCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="partitionCount">Die Anzahl der zu erstellenden Partitionen.</param>
        <summary>Partitioniert die zugrunde liegende Auflistung in die angegebene Anzahl von Partitionen.</summary>
        <returns>Eine Liste, die <paramref name="partitionCount" />-Enumeratoren enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Klasse, die diese Methode implementiert wird erwartet, um genau die Anzahl der Partitionen zurückzugeben, die im angegebenen `partitionCount`. Wenn eine Partition keine Elemente enthält, müssen Sie dann einen leeren Enumerator anstelle von Null (Nothing in Visual Basic) zurückgeben. Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />
        <altmember cref="T:System.Collections.Concurrent.Partitioner" />
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">Benutzerdefinierte Partitionierer für PLINQ und TPL</related>
      </Docs>
    </Member>
    <Member MemberName="SupportsDynamicPartitions">
      <MemberSignature Language="C#" Value="public virtual bool SupportsDynamicPartitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsDynamicPartitions" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsDynamicPartitions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsDynamicPartitions { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsDynamicPartitions : bool" Usage="System.Collections.Concurrent.Partitioner&lt;'Source&gt;.SupportsDynamicPartitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob zusätzliche Partitionen dynamisch erstellt werden können.</summary>
        <value>True, wenn der <see cref="T:System.Collections.Concurrent.Partitioner`1" /> Partitionen wie angefordert dynamisch erstellen kann, false, wenn der <see cref="T:System.Collections.Concurrent.Partitioner`1" /> Partitionen nur statisch zuordnen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine abgeleitete Klasse, nicht überschreiben und implementieren Sie <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> sollte "false" zurückgegeben. Der Wert des <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> sollten während der Lebensdauer dieser Instanz nicht unterscheiden. Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />
        <altmember cref="T:System.Collections.Concurrent.Partitioner" />
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">Benutzerdefinierte Partitionierer für PLINQ und TPL</related>
      </Docs>
    </Member>
  </Members>
</Type>