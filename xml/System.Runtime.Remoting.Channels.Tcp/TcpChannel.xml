<Type Name="TcpChannel" FullName="System.Runtime.Remoting.Channels.Tcp.TcpChannel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9803a52baa82d8f6d463904ed2fc1d6876954f50" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73354071" /></Metadata><TypeSignature Language="C#" Value="public class TcpChannel : System.Runtime.Remoting.Channels.IChannelReceiver, System.Runtime.Remoting.Channels.IChannelSender, System.Runtime.Remoting.Channels.ISecurableChannel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpChannel extends System.Object implements class System.Runtime.Remoting.Channels.IChannel, class System.Runtime.Remoting.Channels.IChannelReceiver, class System.Runtime.Remoting.Channels.IChannelSender, class System.Runtime.Remoting.Channels.ISecurableChannel" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpChannel&#xA;Implements IChannelReceiver, IChannelSender, ISecurableChannel" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpChannel : System::Runtime::Remoting::Channels::IChannelReceiver, System::Runtime::Remoting::Channels::IChannelSender, System::Runtime::Remoting::Channels::ISecurableChannel" />
  <TypeSignature Language="F#" Value="type TcpChannel = class&#xA;    interface IChannelReceiver&#xA;    interface IChannel&#xA;    interface IChannelSender&#xA;    interface ISecurableChannel" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Remoting</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannel</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannelReceiver</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.IChannelSender</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Channels.ISecurableChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Channelimplementierung bereit, die zum Übertragen von Meldungen das TCP-Protokoll verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Kanäle transportieren Nachrichten über Remote Grenzen hinweg (z. b. zwischen Computern in Anwendungs Domänen). Die <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel>-Klasse ist eine Hilfsklasse, die die Funktionalität der-Klasse <xref:System.Runtime.Remoting.Channels.Tcp.TcpClientChannel> und der-Klasse <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> kombiniert.  
  
 Kanäle werden von der .NET Framework Remoting-Infrastruktur zum Transportieren von Remote Aufrufen verwendet. Wenn ein Client ein Remote Objekt aufruft, wird der-Befehl in eine Nachricht serialisiert, die von einem Clientchannel gesendet und von einem Serverchannel empfangen wird. Anschließend wird Sie deserialisiert und verarbeitet. Alle zurückgegebenen Werte werden vom Serverchannel übertragen und vom Clientchannel empfangen.  
  
 Um eine zusätzliche Verarbeitung der Nachrichten durchzuführen, können Sie Implementierungen der <xref:System.Runtime.Remoting.Channels.IClientChannelSinkProvider> und <xref:System.Runtime.Remoting.Channels.IServerChannelSinkProvider> angeben, über die alle vom <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> verarbeiteten Nachrichten weitergegeben werden.  
  
 Einem <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel>-Objekt sind Konfigurations Eigenschaften zugeordnet, die zur Laufzeit entweder in einer Konfigurationsdatei (durch Aufrufen der statischen <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%2A?displayProperty=nameWithType>-Methode) oder Programm gesteuert (durch Übergabe einer <xref:System.Collections.IDictionary>-Auflistung an den <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.%23ctor%2A>-Konstruktor) festgelegt werden können. Weitere Informationen zu kanalkonfigurations Eigenschaften finden Sie unter [Kanal-und formatierungserkonfigurations-Eigenschaften](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kw7c6kwc(v=vs.100)).  
  
> [!NOTE]
>  Wenn auf dem Server Computer Windows 95/98/Me ausgeführt wird, kann der Server <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> nicht als sicher angegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> zum Einrichten eines Remote Servers und dessen Clients verwendet wird. Das Beispiel enthält drei Teile: einen Server, einen Client und ein Remote Objekt, das vom Server und vom Client verwendet wird.  
  
 Das folgende Codebeispiel zeigt einen Server:  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#1)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#1)]  
  
 Das folgende Codebeispiel zeigt einen Client für diesen Server:  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#10)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#10)]  
  
 Das folgende Codebeispiel zeigt das Remote Objekt, das vom Server und dem Client verwendet wird:  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#20](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/common.cpp#20)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#20](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/common.cs#20)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />-Klasse, wobei lediglich ein Clientchannel und kein Serverchannel aktiviert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Parameter lose Konstruktor initialisiert alle Felder mit ihren Standardwerten. Wenn der Parameter lose Konstruktor verwendet wird, funktioniert der Kanal nur als Clientchannel und lauscht nicht an Ports.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#11](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#11)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#11](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel(int port);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Remoting.Channels.Tcp.TcpChannel : int -&gt; System.Runtime.Remoting.Channels.Tcp.TcpChannel" Usage="new System.Runtime.Remoting.Channels.Tcp.TcpChannel port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Der Port, den der Serverchannel überwacht.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />-Klasse mit einem Serverchannel, die den angegebenen Anschluss überwacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um anzufordern, dass das Remote System einen geöffneten Port in Ihrem Namen auswählen soll, geben Sie Port 0 (null) an. Dadurch wird eine <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> Instanz erstellt, um Anforderungen an den dynamisch zugewiesenen Port zu überwachen. Dies erfolgt in der Regel auf dem Client, um sicherzustellen, dass eine <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel> auf Rückruf Methoden lauscht.  
  
 Wenn 0 an den Konstruktor übergeben wird, wird der <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> für die Verwendung eines freien Ports instanziiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht. Um anzufordern, dass ein verfügbarer Port dynamisch zugewiesen werden soll, legen Sie den `port`-Parameter auf NULL fest.  
  
 [!code-cpp[RemotingConfiguration.ServerActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation/VB/server.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpChannel (System.Collections.IDictionary properties, System.Runtime.Remoting.Channels.IClientChannelSinkProvider clientSinkProvider, System.Runtime.Remoting.Channels.IServerChannelSinkProvider serverSinkProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary properties, class System.Runtime.Remoting.Channels.IClientChannelSinkProvider clientSinkProvider, class System.Runtime.Remoting.Channels.IServerChannelSinkProvider serverSinkProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.#ctor(System.Collections.IDictionary,System.Runtime.Remoting.Channels.IClientChannelSinkProvider,System.Runtime.Remoting.Channels.IServerChannelSinkProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (properties As IDictionary, clientSinkProvider As IClientChannelSinkProvider, serverSinkProvider As IServerChannelSinkProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpChannel(System::Collections::IDictionary ^ properties, System::Runtime::Remoting::Channels::IClientChannelSinkProvider ^ clientSinkProvider, System::Runtime::Remoting::Channels::IServerChannelSinkProvider ^ serverSinkProvider);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Remoting.Channels.Tcp.TcpChannel : System.Collections.IDictionary * System.Runtime.Remoting.Channels.IClientChannelSinkProvider * System.Runtime.Remoting.Channels.IServerChannelSinkProvider -&gt; System.Runtime.Remoting.Channels.Tcp.TcpChannel" Usage="new System.Runtime.Remoting.Channels.Tcp.TcpChannel (properties, clientSinkProvider, serverSinkProvider)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.IDictionary" />
        <Parameter Name="clientSinkProvider" Type="System.Runtime.Remoting.Channels.IClientChannelSinkProvider" />
        <Parameter Name="serverSinkProvider" Type="System.Runtime.Remoting.Channels.IServerChannelSinkProvider" />
      </Parameters>
      <Docs>
        <param name="properties">Eine <see cref="T:System.Collections.IDictionary" />-Auflistung, die Werte für Konfigurationseigenschaften angibt, die vom Client- und Serverchannel verwendet werden sollen.</param>
        <param name="clientSinkProvider">Die <see cref="T:System.Runtime.Remoting.Channels.IClientChannelSinkProvider" />-Implementierung, die vom Clientchannel verwendet werden soll.</param>
        <param name="serverSinkProvider">Die <see cref="T:System.Runtime.Remoting.Channels.IServerChannelSinkProvider" />-Implementierung, die vom Serverchannel verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" />-Klasse mit den angegebenen Konfigurationseigenschaften und Konfigurationssenken.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu kanalkonfigurations Eigenschaften finden Sie unter [Kanal-und formatierungserkonfigurations-Eigenschaften](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kw7c6kwc(v=vs.100)).  
  
> [!NOTE]
>  Wenn auf dem Server Computer Windows 95/98/Me ausgeführt wird, kann der Server <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel> nicht als sicher angegeben werden.  
  
 Channelsenken bieten einen Plug-in-Punkt, der den Zugriff auf die zugrunde liegenden Nachrichten ermöglicht, die über den Kanal geleitet werden, sowie über den Stream, der vom Transportmechanismus zum Senden von Nachrichten an ein Remote Objekt verwendet wird. Channelsenken sind auch für den Transport von Nachrichten zwischen dem Client und dem Server zuständig. Channelsenken werden in einer Kette miteinander verknüpft, und alle Kanalnachrichten werden durch diese Kette von senken geleitet, bevor die Nachricht schließlich serialisiert und transportiert wird. Wenn Sie keine Senkenfunktionalität benötigen, legen Sie die Parameter `clientSinkProvider` und `serverSinkProvider` auf `null`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel2/CPP/server.cpp#1)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel2/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Eine bereitgestellte Channeleigenschaft ist falsch formatiert.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kw7c6kwc(v=vs.100)">Kanal- und Formatierungskonfigurationseigenschaften</related>
      </Docs>
    </Member>
    <Member MemberName="ChannelData">
      <MemberSignature Language="C#" Value="public object ChannelData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ChannelData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelData As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ChannelData { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelData : obj" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Channels.IChannelReceiver.ChannelData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die channelspezifischen Daten ab.</summary>
        <value>Eine <see cref="T:System.Runtime.Remoting.Channels.ChannelDataStore" />-Instanz mit channelspezifischen Daten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl als Instanz von <xref:System.Object?displayProperty=nameWithType>zurückgegeben wird, kann der Wert dieser Eigenschaft in eine Instanz von umgewandelt werden <xref:System.Runtime.Remoting.Channels.ChannelDataStore> der den Kanal beschreibt, auf den das <xref:System.Runtime.Remoting.Channels.Http.HttpServerChannel>-Objekt lauscht.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie diese Eigenschaft verwendet wird.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#5)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelName">
      <MemberSignature Language="C#" Value="public string ChannelName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ChannelName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ChannelName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelName : string" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Channels.IChannel.ChannelName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des aktuellen Channels ab.</summary>
        <value>Ein <see cref="T:System.String" />, der den Namen des Channels enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder registrierte Channel hat einen eindeutigen Namen. Der Name wird zum Abrufen eines bestimmten Kanals verwendet, wenn <xref:System.Runtime.Remoting.Channels.ChannelServices.GetChannel%2A> aufgerufen wird. Um die <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelName%2A>-Eigenschaft festzulegen, weisen Sie den Wert der indizierten Eigenschaft "Name" im Wörterbuch zu, das an den <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.%23ctor%28System.Collections.IDictionary%2CSystem.Runtime.Remoting.Channels.IClientChannelSinkProvider%2CSystem.Runtime.Remoting.Channels.IServerChannelSinkProvider%29>-Konstruktor übergeben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie diese Eigenschaft verwendet wird.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#3)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelPriority">
      <MemberSignature Language="C#" Value="public int ChannelPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChannelPriority" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChannelPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelPriority : int" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.ChannelPriority" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Channels.IChannel.ChannelPriority</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Priorität des aktuellen Channels ab.</summary>
        <value>Eine ganze Zahl, die die Priorität des Channels darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt, wie diese Eigenschaft verwendet wird.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#4)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMessageSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink (string url, object remoteChannelData, out string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object remoteChannelData, [out] string&amp; objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.CreateMessageSink(System.String,System.Object,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateMessageSink (url As String, remoteChannelData As Object, ByRef objectURI As String) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageSink ^ CreateMessageSink(System::String ^ url, System::Object ^ remoteChannelData, [Runtime::InteropServices::Out] System::String ^ % objectURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateMessageSink : string * obj * string -&gt; System.Runtime.Remoting.Messaging.IMessageSink&#xA;override this.CreateMessageSink : string * obj * string -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="tcpChannel.CreateMessageSink (url, remoteChannelData, objectURI)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink(System.String,System.Object,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="remoteChannelData" Type="System.Object" />
        <Parameter Name="objectURI" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="url">Die URL, an die die neue Senke Nachrichten übermitteln soll. Kann <see langword="null" /> sein.</param>
        <param name="remoteChannelData">Das Channeldatenobjekt des Remotehosts, an das die neue Senke Nachrichten übermitteln soll. Kann <see langword="null" /> sein.</param>
        <param name="objectURI">Enthält bei der Rückgabe dieser Methode einen URI der neuen Channelnachrichtensenke, die Meldungen an die angegebene URL oder an das angegebene Channeldatenobjekt übermittelt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Gibt eine Channelnachrichtensenke zurück, die Meldungen an die angegebene URL oder das angegebene Channeldatenobjekt übermittelt.</summary>
        <returns>Eine Channelnachrichtensenke, die Meldungen an die angegebene URL oder das angegebene Channeldatenobjekt übermittelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Channels.Tcp.TcpChannel.CreateMessageSink%2A>-Methode gibt eine Channelnachrichtensenke zurück, die Nachrichten an die angegebene URL oder das angegebene Channeldatenobjekt übermittelt. Wenn der `uri`-Parameter `null` ist, wird `remoteChannelData` als Ziel für die Senke verwendet. Der Parameter "`url`" oder "`remoteChannelData`" kann `null` sein, aber nicht beides.  
  
 Channelsenken bieten einen Plug-in-Punkt, der den Zugriff auf die zugrunde liegenden Nachrichten ermöglicht, die über den Kanal geleitet werden, sowie über den Stream, der vom Transportmechanismus zum Senden von Nachrichten an ein Remote Objekt verwendet wird. Channelsenken werden in einer Kette von `ChannelSinkProviders` miteinander verknüpft, und alle Kanalnachrichten werden durch diese Kette von senken geleitet, bevor die Nachricht schließlich serialisiert und transportiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#12](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/client.cpp#12)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#12](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/client.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUrlsForUri">
      <MemberSignature Language="C#" Value="public string[] GetUrlsForUri (string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetUrlsForUri(string objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.GetUrlsForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUrlsForUri (objectURI As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetUrlsForUri(System::String ^ objectURI);" />
      <MemberSignature Language="F#" Value="abstract member GetUrlsForUri : string -&gt; string[]&#xA;override this.GetUrlsForUri : string -&gt; string[]" Usage="tcpChannel.GetUrlsForUri objectURI" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Channels.IChannelReceiver.GetUrlsForUri(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="objectURI">Der URI des Objekts, für das URLs erforderlich sind.</param>
        <summary>Gibt ein Array sämtlicher URLs für ein Objekt mit dem angegebenen URI zurück, für das der aktuelle <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> als Host fungiert.</summary>
        <returns>Ein Array der URLs für ein Objekt mit dem angegebenen URI, für das der aktuelle <see cref="T:System.Runtime.Remoting.Channels.Tcp.TcpChannel" /> als Host fungiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von <xref:System.Runtime.Remoting.Channels.ChannelServices.GetUrlsForObject%2A?displayProperty=nameWithType>verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[TcpChannel.GetUrlsForUri#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/CPP/class1.cpp#1)]
 [!code-csharp[TcpChannel.GetUrlsForUri#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/CS/class1.cs#1)]
 [!code-vb[TcpChannel.GetUrlsForUri#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpChannel.GetUrlsForUri/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecured">
      <MemberSignature Language="C#" Value="public bool IsSecured { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecured" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.Tcp.TcpChannel.IsSecured" />
      <MemberSignature Language="VB.NET" Value="Public Property IsSecured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecured { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsSecured : bool with get, set" Usage="System.Runtime.Remoting.Channels.Tcp.TcpChannel.IsSecured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Channels.ISecurableChannel.IsSecured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der aktuelle Channel sicher ist, oder legt diesen fest.</summary>
        <value>Ein boolescher Wert, der angibt, ob die aktuelle Instanz sicher ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft muss nicht explizit festgelegt werden, da es ausreichend ist, den ensureSecurity-Parameter von <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>festzulegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public string Parse (string url, out string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Parse(string url, [out] string&amp; objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.Parse(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Parse (url As String, ByRef objectURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Parse(System::String ^ url, [Runtime::InteropServices::Out] System::String ^ % objectURI);" />
      <MemberSignature Language="F#" Value="abstract member Parse : string * string -&gt; string&#xA;override this.Parse : string * string -&gt; string" Usage="tcpChannel.Parse (url, objectURI)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Channels.IChannel.Parse(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="objectURI" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="url">Die URL, aus der der URI des bekannten Remoteobjekts extrahiert werden soll.</param>
        <param name="objectURI">Enthält nach Beenden der Methode eine <see cref="T:System.String" /> mit dem URI des bekannten Remoteobjekts. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Extrahiert aus der angegebenen URL den Channel-URI und den URI des bekannten Remoteobjekts.</summary>
        <returns>Der URI des aktuellen Channels.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein URI eines Objekts ist ein Wert, der eine bestimmte Objektinstanz eindeutig identifiziert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CPP/server.cpp#6)]
 [!code-csharp[System.Runtime.Remoting.Channels.Tcp.TcpChannel#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.Channels.Tcp.TcpChannel/CS/server.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="public void StartListening (object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartListening(object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartListening (data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StartListening(System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit&#xA;override this.StartListening : obj -&gt; unit" Usage="tcpChannel.StartListening data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Channels.IChannelReceiver.StartListening(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Optionale Initialisierungsinformationen.</param>
        <summary>Weist den aktuellen Channel an, mit der Überwachung von Anforderungen zu beginnen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht erforderlich, diese Methode aufzurufen, um mit dem lauschen an einem neu initialisierten Kanal zu beginnen.  
  
 Verwenden Sie diese Methode, um das lauschen an einem Kanal erneut zu starten, nachdem die <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel.StopListening%2A>-Methode aufgerufen wurde.  
  
 Wenn Ihr Kanal eine dynamisch zugewiesene Portnummer verwendet, ändert sich die Portnummer möglicherweise, wenn Sie die Überwachung neu starten.  
  
 Der `data`-Parameter kann verwendet werden, um einen bestimmten Initialisierungs Status an den Kanal zu übergeben. Wenn Sie keinen bestimmten Zustand an den Kanal übergeben möchten, legen Sie `data` auf `null`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="public void StopListening (object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopListening(object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.Tcp.TcpChannel.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopListening (data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StopListening(System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit&#xA;override this.StopListening : obj -&gt; unit" Usage="tcpChannel.StopListening data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Channels.IChannelReceiver.StopListening(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Remoting</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Optionale Zustandsinformationen für den Channel.</param>
        <summary>Weist den aktuellen Channel an, die Überwachung von Anforderungen zu beenden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um das lauschen an einem Kanal anzuhalten. Verwenden Sie die <xref:System.Runtime.Remoting.Channels.Tcp.TcpServerChannel.StartListening%2A>-Methode, um das lauschen erneut zu starten.  
  
 Wenn Ihr Kanal eine dynamisch zugewiesene Portnummer verwendet, ändert sich die Portnummer möglicherweise, wenn Sie die Überwachung neu starten.  
  
 Der `data`-Parameter kann verwendet werden, um einen bestimmten Initialisierungs Status an den Kanal zu übergeben. Wenn Sie keinen bestimmten Zustand an den Kanal übergeben möchten, legen Sie `data` auf `null`fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
