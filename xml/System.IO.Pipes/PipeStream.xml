<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d02dbb6c87366fa6ff28a0e5e7eefd17206dde7b" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77225394" /></Metadata><TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PipeStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeStream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PipeStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeStream abstract : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type PipeStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="fb3e9-101">Macht ein <see cref="T:System.IO.Stream" />-Objekt um eine Pipe verfügbar, das sowohl anonyme als auch benannte Pipes unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-101">Exposes a <see cref="T:System.IO.Stream" /> object around a pipe, which supports both anonymous and named pipes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-102">Die <xref:System.IO.Pipes.PipeStream>-Klasse stellt die Basisklasse für benannte und Anonyme Pipes-Vorgänge in der .NET Framework bereit.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-102">The <xref:System.IO.Pipes.PipeStream> class provides the base class for named and anonymous pipes operations in the .NET Framework.</span></span> <span data-ttu-id="fb3e9-103">Verwenden Sie die Klassen <xref:System.IO.Pipes.NamedPipeServerStream> und <xref:System.IO.Pipes.NamedPipeClientStream> für Named Pipe Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-103">Use the <xref:System.IO.Pipes.NamedPipeServerStream> and <xref:System.IO.Pipes.NamedPipeClientStream> classes for named pipe operations.</span></span> <span data-ttu-id="fb3e9-104">Verwenden Sie die Klassen <xref:System.IO.Pipes.AnonymousPipeServerStream> und <xref:System.IO.Pipes.AnonymousPipeClientStream> für anonyme Pipe-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-104">Use the <xref:System.IO.Pipes.AnonymousPipeServerStream> and <xref:System.IO.Pipes.AnonymousPipeClientStream> classes for anonymous pipe operations.</span></span>  
  
 <span data-ttu-id="fb3e9-105">Weitere Informationen zu Pipes finden Sie unter [Pipes](~/docs/standard/io/pipe-operations.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-105">For more information about pipes, see [Pipes](~/docs/standard/io/pipe-operations.md).</span></span> <span data-ttu-id="fb3e9-106">Ein Beispiel für anonyme Pipes finden Sie unter Gewusst [wie: Verwenden von anonymen Pipes für die lokale prozessübergreifende Kommunikation](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-106">For an example of anonymous pipes, see [How to: Use Anonymous Pipes for Local Interprocess Communication](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).</span></span> <span data-ttu-id="fb3e9-107">Ein Beispiel für Named Pipes finden Sie unter Gewusst [wie: Verwenden von Named Pipes für die Kommunikation zwischen Netzwerk Prozessen](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-107">For an example of named pipes, see [How to: Use Named Pipes for Network Interprocess Communication](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fb3e9-108">Initialisiert eine neue Instanz der Klasse <see cref="T:System.IO.Pipes.PipeStream" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-108">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="fb3e9-109">Einer der <see cref="T:System.IO.Pipes.PipeDirection" /> -Werte, die die Richtung des Pipeobjekts angeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-109">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="fb3e9-110">Ein positiver <see cref="T:System.Int32" /> -Wert größer oder gleich 0, der die Puffergröße angibt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-110">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="fb3e9-111">Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.PipeStream" /> -Klasse unter Verwendung des angegebenen <see cref="T:System.IO.Pipes.PipeDirection" /> -Werts und der angegebenen Puffergröße.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-111">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-112">Dieser Konstruktor verwendet den Pipe-Übertragungsmodus <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-112">This constructor uses a pipe transmission mode of <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-113"><paramref name="direction" /> ist kein gültiger <see cref="T:System.IO.Pipes.PipeDirection" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-113"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="fb3e9-114">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-114">-or-</span></span> 
 <span data-ttu-id="fb3e9-115"><paramref name="bufferSize" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-115"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeTransmissionMode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, transmissionMode As PipeTransmissionMode, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * System.IO.Pipes.PipeTransmissionMode * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, transmissionMode, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="fb3e9-116">Einer der <see cref="T:System.IO.Pipes.PipeDirection" /> -Werte, die die Richtung des Pipeobjekts angeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-116">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="transmissionMode"><span data-ttu-id="fb3e9-117">Einer der <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> -Werte, die den Übertragungsmodus des Pipeobjekts angeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-117">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</span></span></param>
        <param name="outBufferSize"><span data-ttu-id="fb3e9-118">Ein positiver <see cref="T:System.Int32" /> -Wert größer oder gleich 0, der die Puffergröße angibt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-118">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="fb3e9-119">Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.PipeStream" /> -Klasse mit der angegebenen <see cref="T:System.IO.Pipes.PipeDirection" />, dem angegebenen <see cref="T:System.IO.Pipes.PipeTransmissionMode" />und der angegebenen Puffergröße.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-119">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-120"><paramref name="direction" /> ist kein gültiger <see cref="T:System.IO.Pipes.PipeDirection" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-120"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="fb3e9-121">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-121">-or-</span></span> 
 <span data-ttu-id="fb3e9-122"><paramref name="transmissionMode" /> ist kein gültiger <see cref="T:System.IO.Pipes.PipeTransmissionMode" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-122"><paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span>  
  
<span data-ttu-id="fb3e9-123">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-123">-or-</span></span> 
 <span data-ttu-id="fb3e9-124"><paramref name="bufferSize" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-124"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-125">Der Puffer, in den Daten gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-125">The buffer to read data into.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-126">Der Byteoffset im <paramref name="buffer" />, ab dem gelesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-126">The byte offset in <paramref name="buffer" /> at which to begin reading.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-127">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-127">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="fb3e9-128">Die Methode, die aufgerufen wird, wenn der asynchrone Lesevorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-128">The method to call when the asynchronous read operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="fb3e9-129">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Leseanforderung und anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-129">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="fb3e9-130">Startet einen asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-130">Begins an asynchronous read operation.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-131">Ein <see cref="T:System.IAsyncResult" /> -Objekt, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-131">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-132">Übergeben Sie das zurückgegebene <xref:System.IAsyncResult> Objekt an die <xref:System.IO.Pipes.PipeStream.EndRead%2A>-Methode, um zu bestimmen, wie viele Bytes gelesen wurden, und um die zum Lesen verwendeten Betriebssystemressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-132">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="fb3e9-133"><xref:System.IO.Pipes.PipeStream.EndRead%2A> müssen für jeden Aufruf von <xref:System.IO.Pipes.PipeStream.BeginRead%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-133"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="fb3e9-134">Dies kann entweder im gleichen Code erfolgen, der <xref:System.IO.Pipes.PipeStream.BeginRead%2A> aufgerufen hat, oder in einem Rückruf, der an <xref:System.IO.Pipes.PipeStream.BeginRead%2A>übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-134">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="fb3e9-135">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-135">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="fb3e9-136">Wenn die Pipe geschlossen ist oder ein ungültiges Argument an <xref:System.IO.Pipes.PipeStream.BeginRead%2A>übergeben wird, werden sofort die entsprechenden Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-136">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="fb3e9-137">Fehler, die bei einer asynchronen Lese Anforderung auftreten, treten in dem Thread Pool Thread auf, der die Anforderung ausführt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-137">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="fb3e9-138">Die Ausnahmen werden ausgelöst, wenn der Code die <xref:System.IO.Pipes.PipeStream.EndRead%2A>-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-138">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-139"><paramref name="buffer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-139"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-140"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-140"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="fb3e9-141">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-141">-or-</span></span> 
 <span data-ttu-id="fb3e9-142"><paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-142"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-143"><paramref name="count" /> ist größer als die Anzahl der im <paramref name="buffer" /> verfügbaren Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-143"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-144">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-144">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-145">Die Pipe unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-145">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-146">Die Verbindung der Pipe ist getrennt, die Pipe wartet auf eine Verbindung, oder das Handle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-146">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-147">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-147">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-148">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-148">The buffer that contains the data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-149">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-149">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-150">Die maximal zu schreibende Anzahl von Byte.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-150">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="fb3e9-151">Die Methode, die aufgerufen wird, wenn der asynchrone Schreibvorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-151">The method to call when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="fb3e9-152">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Schreibanforderung und anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-152">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="fb3e9-153">Startet einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-153">Begins an asynchronous write operation.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-154">Ein <see cref="T:System.IAsyncResult" /> -Objekt, das auf den asynchronen Schreibvorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-154">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-155"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> müssen für jeden Aufruf von <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-155"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="fb3e9-156">Dies kann entweder im gleichen Code erfolgen, der <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> aufgerufen hat, oder in einem Rückruf, der an <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-156">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="fb3e9-157">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanWrite%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-157">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="fb3e9-158">Wenn die Pipe geschlossen ist oder ein ungültiges Argument an <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>übergeben wird, werden sofort die entsprechenden Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-158">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="fb3e9-159">Fehler, die bei einer asynchronen Schreib Anforderung auftreten, treten in dem Thread Pool Thread auf, der die Anforderung ausführt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-159">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="fb3e9-160">Die Ausnahmen werden ausgelöst, wenn der Code die <xref:System.IO.Pipes.PipeStream.EndWrite%2A>-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-160">The exceptions are raised when the code calls the  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-161"><paramref name="buffer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-161"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-162"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-162"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="fb3e9-163">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-163">-or-</span></span> 
 <span data-ttu-id="fb3e9-164"><paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-164"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-165"><paramref name="count" /> ist größer als die Anzahl der im <paramref name="buffer" /> verfügbaren Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-165"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-166">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-166">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-167">Die Pipe unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-167">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-168">Die Verbindung der Pipe ist getrennt, die Pipe wartet auf eine Verbindung, oder das Handle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-168">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-169">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-169">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Pipes.PipeStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-170">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-170">Gets a value indicating whether the current stream supports read operations.</span></span></summary>
        <value><span data-ttu-id="fb3e9-171"><see langword="true" />, wenn der Stream Lesevorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-171"><see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-172">Wenn das <xref:System.IO.Pipes.PipeStream> Objekt geschlossen wird, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-172">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Pipes.PipeStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-173">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-173">Gets a value indicating whether the current stream supports seek operations.</span></span></summary>
        <value><span data-ttu-id="fb3e9-174"><see langword="false" /> in allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-174"><see langword="false" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-175">Wenn das <xref:System.IO.Pipes.PipeStream> Objekt geschlossen wird, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-175">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Pipes.PipeStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-176">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-176">Gets a value indicating whether the current stream supports write operations.</span></span></summary>
        <value><span data-ttu-id="fb3e9-177"><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-177"><see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-178">Wenn das <xref:System.IO.Pipes.PipeStream> Objekt geschlossen wird, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-178">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CheckPipePropertyOperations();" />
      <MemberSignature Language="F#" Value="abstract member CheckPipePropertyOperations : unit -&gt; unit&#xA;override this.CheckPipePropertyOperations : unit -&gt; unit" Usage="pipeStream.CheckPipePropertyOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-179">Überprüft, ob sich die Pipe in einem ordnungsgemäßen Zustand zum Abrufen oder Festlegen von Eigenschaften befindet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-179">Verifies that the pipe is in a proper state for getting or setting properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckReadOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckReadOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckReadOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckReadOperations : unit -&gt; unit" Usage="pipeStream.CheckReadOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-180">Überprüft, ob die Pipe verbunden ist, um Lesevorgänge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-180">Verifies that the pipe is in a connected state for read operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckWriteOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckWriteOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckWriteOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckWriteOperations : unit -&gt; unit" Usage="pipeStream.CheckWriteOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-181">Überprüft, ob die Pipe verbunden ist, um Schreibvorgänge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-181">Verifies that the pipe is in a connected state for write operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="pipeStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="fb3e9-182"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-182"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="fb3e9-183">Gibt die von der <see cref="T:System.IO.Pipes.PipeStream" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-183">Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-184">Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-184">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="fb3e9-185"><xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.Pipes.PipeStream.Dispose%2A> Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-185"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Pipes.PipeStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="fb3e9-186"><xref:System.Object.Finalize%2A> ruft <xref:System.IO.Pipes.PipeStream.Dispose%2A> auf, bei dem `disposing` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-186"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Pipes.PipeStream.Dispose%2A> with `disposing` set to `false`.</span></span> <span data-ttu-id="fb3e9-187">Wenn der disposing-Parameter `true`ist, gibt diese Methode alle Ressourcen frei, die von verwalteten Objekten aufbewahrt werden, auf die diese <xref:System.IO.Pipes.PipeStream> Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-187">When the disposing parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Pipes.PipeStream> object references.</span></span> <span data-ttu-id="fb3e9-188">Diese Methode ruft die <xref:System.IO.Pipes.PipeStream.Dispose%2A>-Methode jedes referenzierten Objekts auf.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-188">This method invokes the <xref:System.IO.Pipes.PipeStream.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="fb3e9-189">Fügen Sie in abgeleiteten Klassen alle <see cref="T:System.IO.Stream" /> Bereinigungs Logik in die <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />-Methode ein.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-189">In derived classes, put all <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="fb3e9-190"><see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-190"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="fb3e9-191">Beim Überschreiben von <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see cref="M:System.ComponentModel.Component.Dispose" /> freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-191">When overriding <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="fb3e9-192">Weitere Informationen zum Implementieren von <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-192">For more information about how to implement <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="fb3e9-193">Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-193">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="pipeStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="fb3e9-194">Der Verweis auf die ausstehende asynchrone Anforderung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-194">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="fb3e9-195">Beendet eine ausstehende asynchrone Leseanforderung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-195">Ends a pending asynchronous read request.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-196">Die Anzahl von Bytes, die gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-196">The number of bytes that were read.</span></span> <span data-ttu-id="fb3e9-197">Der Rückgabewert 0 (null) gibt das Ende des Streams an (d. h., die Pipe wurde geschlossen).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-197">A return value of 0 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-198">Diese Methode gibt die Anzahl der Bytes zurück, die in das Bytearray gelesen werden, das durch den früheren <xref:System.IO.Pipes.PipeStream.BeginRead%2A>aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-198">This method returns the number of bytes read into the byte array specified by the earlier call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="fb3e9-199">Übergeben Sie das zurückgegebene <xref:System.IAsyncResult> Objekt an die <xref:System.IO.Pipes.PipeStream.EndRead%2A>-Methode, um zu bestimmen, wie viele Bytes gelesen wurden, und um die zum Lesen verwendeten Betriebssystemressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-199">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="fb3e9-200"><xref:System.IO.Pipes.PipeStream.EndRead%2A> müssen für jeden Aufruf von <xref:System.IO.Pipes.PipeStream.BeginRead%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-200"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="fb3e9-201">Dies kann entweder im gleichen Code erfolgen, der <xref:System.IO.Pipes.PipeStream.BeginRead%2A> aufgerufen hat, oder in einem Rückruf, der an <xref:System.IO.Pipes.PipeStream.BeginRead%2A>übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-201">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="fb3e9-202">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-202">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="fb3e9-203">Wenn die Pipe geschlossen ist oder ein ungültiges Argument an <xref:System.IO.Pipes.PipeStream.BeginRead%2A>übergeben wird, werden sofort die entsprechenden Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-203">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="fb3e9-204">Fehler, die bei einer asynchronen Lese Anforderung auftreten, treten in dem Thread Pool Thread auf, der die Anforderung ausführt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-204">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="fb3e9-205">Die Ausnahmen werden ausgelöst, wenn der Code die <xref:System.IO.Pipes.PipeStream.EndRead%2A>-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-205">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-206"><paramref name="asyncResult" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-206"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-207"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-207"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-208">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-208">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="pipeStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="fb3e9-209">Der Verweis auf die ausstehende asynchrone Anforderung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-209">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="fb3e9-210">Beendet eine ausstehende asynchrone Schreibanforderung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-210">Ends a pending asynchronous write request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-211"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> müssen für jeden Aufruf von <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-211"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="fb3e9-212">Dies kann entweder im gleichen Code erfolgen, der <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> aufgerufen hat, oder in einem Rückruf, der an <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-212">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="fb3e9-213">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanWrite%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-213">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="fb3e9-214">Wenn die Pipe geschlossen ist oder ein ungültiges Argument an <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>übergeben wird, werden sofort die entsprechenden Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-214">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="fb3e9-215">Fehler, die bei einer asynchronen Schreib Anforderung auftreten, treten in dem Thread Pool Thread auf, der die Anforderung ausführt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-215">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="fb3e9-216">Die Ausnahmen werden ausgelöst, wenn der Code, der aufruft, <xref:System.IO.Pipes.PipeStream.EndWrite%2A>-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-216">The exceptions are raised when the code the calls <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-217"><paramref name="asyncResult" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-217"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-218"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-218"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-219">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-219">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="pipeStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-220">Löscht den Puffer für den aktuellen Stream und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-220">Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-221">Die <xref:System.IO.Pipes.PipeStream.Flush%2A>-Methode wird in der <xref:System.IO.Pipes.PipeStream>-Klasse nicht unterstützt und führt keine Aktion aus, wenn Sie aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-221">The <xref:System.IO.Pipes.PipeStream.Flush%2A> method is not supported in the <xref:System.IO.Pipes.PipeStream> class and does nothing when it is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-222">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-222">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-223">Die Pipe unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-223">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-224">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-224">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As PipeSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Pipes::PipeSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.Pipes.PipeSecurity" Usage="pipeStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-225">Ruft ein <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt ab, das die Einträge in der Zugriffssteuerungsliste für die Pipe kapselt, die vom aktuellen <see cref="T:System.IO.Pipes.PipeStream" />-Objekt beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-225">Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-226">Ein <see cref="T:System.IO.Pipes.PipeSecurity" /> -Objekt, das die Einträge in der Zugriffssteuerungsliste für die Pipe kapselt, die vom aktuellen <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-226">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-227">Eine Zugriffs Steuerungs Liste (Access Control List, ACL) beschreibt Personen und/oder Gruppen, die bzw. die keine Rechte haben, bestimmte Aktionen für eine bestimmte Datei auszuführen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-227">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="fb3e9-228">Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-228">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-229">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-229">The pipe is closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="fb3e9-230">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-230">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-231">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-231">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-232">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-232">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InBufferSize : int" Usage="System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-233">Ruft die Größe des Eingangspuffers für eine Pipe in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-233">Gets the size, in bytes, of the inbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="fb3e9-234">Ein Ganzzahlwert, der die Größe des Eingangspuffers in Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-234">An integer value that represents the inbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-235">Wenn <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> 0 ist, wird die Puffergröße nach Bedarf zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-235">If <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-236">Der Datenstrom ist nicht lesbar.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-236">The stream is unreadable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-237">Die Pipe wartet auf eine Verbindung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-237">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-238">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-238">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeHandle (handle As SafePipeHandle, isExposed As Boolean, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeHandle(Microsoft::Win32::SafeHandles::SafePipeHandle ^ handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="F#" Value="member this.InitializeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle * bool * bool -&gt; unit" Usage="pipeStream.InitializeHandle (handle, isExposed, isAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="isExposed" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="fb3e9-239">Das <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> -Objekt der zu initialisierenden Pipe.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-239">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</span></span></param>
        <param name="isExposed"><span data-ttu-id="fb3e9-240"><see langword="true" />, um das Handle verfügbar zu machen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-240"><see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</span></span></param>
        <param name="isAsync"><span data-ttu-id="fb3e9-241"><see langword="true" />, um anzugeben, dass das Handle asynchron geöffnet wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-241"><see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-242">Initialisiert ein <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt aus dem angegebenen <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> -Objekt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-242">Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-243">Wenn sich die Pipe in einem verbundenen Zustand befindet, legt diese Methode auch die <xref:System.IO.Pipes.PipeStream.IsConnected%2A>-Eigenschaft auf `true`fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-243">If the pipe is in a connected state, this method also sets the <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-244">Ein Handle kann nicht an die Pipe gebunden werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-244">A handle cannot be bound to the pipe.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.Pipes.PipeStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-245">Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt asynchron oder synchron geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-245">Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</span></span></summary>
        <value><span data-ttu-id="fb3e9-246"><see langword="true" />, wenn das <see cref="T:System.IO.Pipes.PipeStream" />-Objekt asynchron geöffnet wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-246"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-247">Diese Eigenschaft ermöglicht dem Code, die <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A>-Eigenschaft ordnungsgemäß zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-247">This property enables your code to use the <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> property correctly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Property IsConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsConnected {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsConnected : bool with get, set" Usage="System.IO.Pipes.PipeStream.IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-248">Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt verbunden ist, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-248">Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</span></span></summary>
        <value><span data-ttu-id="fb3e9-249"><see langword="true" /> wenn das <see cref="T:System.IO.Pipes.PipeStream" />-Objekt verbunden ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-249"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-250">Die <xref:System.IO.Pipes.PipeStream.IsConnected%2A>-Eigenschaft gibt `true` nur dann zurück, wenn das <xref:System.IO.Pipes.PipeStream> Objekt verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-250">The <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property returns `true` only if the <xref:System.IO.Pipes.PipeStream> object is connected.</span></span> <span data-ttu-id="fb3e9-251">Wenn diese Eigenschaft `false`zurückgibt, wartet die Pipe möglicherweise darauf, eine Verbindung herzustellen, oder Sie kann getrennt, geschlossen oder unterbrochen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-251">If this property returns `false`, the pipe may be waiting to connect, or may be disconnected, closed, or broken.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsHandleExposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsHandleExposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleExposed : bool" Usage="System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-252">Ruft einen Wert ab, der angibt, ob ein Handle für ein <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt verfügbar gemacht wurde.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-252">Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</span></span></summary>
        <value><span data-ttu-id="fb3e9-253"><see langword="true" />, wenn ein Handle für das <see cref="T:System.IO.Pipes.PipeStream" />-Objekt verfügbar gemacht wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-253"><see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-254">Der Wert dieser Eigenschaft wird festgelegt, wenn ein Handle für die Pipe erhalten wird, das vom aktuellen <xref:System.IO.Pipes.PipeStream> Objekt gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-254">The value of this property is set when obtaining a handle to the pipe that is encapsulated by the current <xref:System.IO.Pipes.PipeStream> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMessageComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMessageComplete { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMessageComplete : bool" Usage="System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-255">Ruft einen Wert ab, der angibt, ob in der vom letzten Lesevorgang zurückgegebenen Meldung weitere Daten vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-255">Gets a value indicating whether there is more data in the message returned from the most recent read operation.</span></span></summary>
        <value><span data-ttu-id="fb3e9-256"><see langword="true" /> , wenn in der Meldung keine weiteren zu lesenden Zeichen vorhanden sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-256"><see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-257">Diese Eigenschaft ist relevant, wenn die <xref:System.IO.Pipes.PipeStream.ReadMode%2A>-Eigenschaft der Pipe auf <xref:System.IO.Pipes.PipeTransmissionMode.Message> durch den letzten <xref:System.IO.Pipes.PipeStream.Read%2A>-oder <xref:System.IO.Pipes.PipeStream.EndRead%2A>-Aufrufsatz festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-257">This property is relevant if the pipe's <xref:System.IO.Pipes.PipeStream.ReadMode%2A> property was set to <xref:System.IO.Pipes.PipeTransmissionMode.Message> by the most recent call to <xref:System.IO.Pipes.PipeStream.Read%2A> or <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-258">Die Pipe ist nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-258">The pipe is not connected.</span></span>  
  
<span data-ttu-id="fb3e9-259">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-259">-or-</span></span> 
<span data-ttu-id="fb3e9-260">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-260">The pipe handle has not been set.</span></span>  
  
<span data-ttu-id="fb3e9-261">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-261">-or-</span></span> 
<span data-ttu-id="fb3e9-262">Der <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> -Eigenschaftswert der Pipe ist nicht <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-262">The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-263">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-263">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Pipes.PipeStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-264">Ruft die Länge eines Streams in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-264">Gets the length of a stream, in bytes.</span></span></summary>
        <value><span data-ttu-id="fb3e9-265">0 in allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-265">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-266">Die <xref:System.IO.Pipes.PipeStream>-Klasse unterstützt die <xref:System.IO.Pipes.PipeStream.Length%2A>-Eigenschaft nicht.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-266">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Length%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-267">Wird immer ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-267">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutBufferSize : int" Usage="System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-268">Ruft die Größe des Ausgangspuffers für eine Pipe in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-268">Gets the size, in bytes, of the outbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="fb3e9-269">Die Größe des Ausgangspuffers in Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-269">The outbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-270">Wenn <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> 0 ist, wird die Puffergröße nach Bedarf zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-270">If <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-271">Der Stream ist nicht schreibbar.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-271">The stream is unwriteable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-272">Die Pipe wartet auf eine Verbindung.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-272">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-273">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-273">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Pipes.PipeStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-274">Ruft die aktuelle Position des aktuellen Streams ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-274">Gets or sets the current position of the current stream.</span></span></summary>
        <value><span data-ttu-id="fb3e9-275">0 in allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-275">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-276">Die <xref:System.IO.Pipes.PipeStream>-Klasse unterstützt die <xref:System.IO.Pipes.PipeStream.Position%2A>-Eigenschaft nicht.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-276">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Position%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-277">Wird immer ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-277">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="pipeStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-278">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-278">A region of memory.</span></span> <span data-ttu-id="fb3e9-279">Bei der Rückgabe dieser Methode werden die Inhalte dieses Bereichs durch die aus der aktuellen Quelle gelesenen Bytes ersetzt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-279">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="fb3e9-280">Liest eine Folge von Bytes aus dem aktuellen Stream, schreibt sie in ein Bytearray und erhöht die Position innerhalb des Streams um die Anzahl der gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-280">Reads a sequence of bytes from the current stream, writes them to a byte array, and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-281">Die Anzahl der insgesamt in den <paramref name="buffer" /> gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-281">The total number of bytes read into the <paramref name="buffer" />.</span></span> <span data-ttu-id="fb3e9-282">Dies kann weniger als die Anzahl der in <paramref name="buffer" /> zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-282">This can be less than the number of bytes allocated in <paramref name="buffer" /> if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="fb3e9-283">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-283">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>

<span data-ttu-id="fb3e9-284">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.ReadAsync%2A>-Methode, um asynchron aus dem aktuellen Stream zu lesen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-284">Use the <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="fb3e9-285">Diese Methode liest maximal `buffer.Length` Bytes aus dem aktuellen Stream und speichert Sie in `buffer`.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-285">This method reads a maximum of `buffer.Length` bytes from the current stream and stores them in `buffer`.</span></span> <span data-ttu-id="fb3e9-286">Die aktuelle Position innerhalb des Streams wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-286">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span>

<span data-ttu-id="fb3e9-287">Diese Methode wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-287">This method will block until at least one byte of data can be read, in the event that no data is available.</span></span>

<span data-ttu-id="fb3e9-288">Diese Methode gibt 0 (null) nur dann zurück, wenn keine weiteren Daten im Stream vorhanden sind und nicht mehr erwartet wird (z. b. ein geschlossener Socket oder ein Dateiende).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-288">This method returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span>

<span data-ttu-id="fb3e9-289">Diese Methode kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-289">This method is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="fb3e9-290">Verwenden Sie `BinaryReader` zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-290">Use `BinaryReader` for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-291">Die Anzahl der gelesenen Bytes war länger als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-291">The number of bytes read was longer than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-292">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-292">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-293">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-293">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-294">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-294">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-295">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-295">-or-</span></span>

<span data-ttu-id="fb3e9-296">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-296">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-297">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-297">-or-</span></span>

<span data-ttu-id="fb3e9-298">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-298">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-299">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-299">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="pipeStream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([in]unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-300">Enthält nach dem Beenden dieser Methode das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1) die durch die aus der aktuellen Quelle gelesenen Bytes ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-300">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-301">Das Byteoffset im <paramref name="buffer" />-Array, an dem die gelesenen Bytes platziert werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-301">The byte offset in the <paramref name="buffer" /> array at which the bytes that are read will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-302">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-302">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="fb3e9-303">Liest einen Block von Bytes aus einem Stream und schreibt die Daten ab einer angegebenen Position für eine angegebene Länge in einen angegebenen Puffer.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-303">Reads a block of bytes from a stream and writes the data to a specified buffer starting at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-304">Die Gesamtanzahl der in den <paramref name="buffer" /> gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-304">The total number of bytes that are read into <paramref name="buffer" />.</span></span> <span data-ttu-id="fb3e9-305">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-305">This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-306">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-306">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="fb3e9-307">Der Aufruf der <xref:System.IO.Pipes.PipeStream.Read%2A>-Methode blockiert, bis `count` Bytes gelesen oder das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-307">Calling the <xref:System.IO.Pipes.PipeStream.Read%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="fb3e9-308">Informationen zu asynchronen Lesevorgängen finden Sie unter <xref:System.IO.Pipes.PipeStream.BeginRead%2A> und <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-308">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginRead%2A> and <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fb3e9-309">Im folgenden Beispiel werden ein anonymer Pipe-Client und ein Pipe-Server erstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-309">The following example creates an anonymous pipe client and pipe server.</span></span> <span data-ttu-id="fb3e9-310">Der Pipeserver verwendet die <xref:System.IO.Pipes.PipeStream.Read%2A>-Methode, um eine Reihe von Bytes aus dem Pipe-Client als Validierungscode zu lesen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-310">The pipe server uses the <xref:System.IO.Pipes.PipeStream.Read%2A> method to read a series of bytes from the pipe client as a validation code.</span></span> <span data-ttu-id="fb3e9-311">Sowohl der Pipe-Client als auch der Pipe-Server sind Teil desselben Beispiels.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-311">Both the pipe client and the pipe server are part of the same example.</span></span> <span data-ttu-id="fb3e9-312">Der Serverteil des Beispiels erstellt einen Client Prozess und übergibt ihm ein anonymes Pipehandle als Argument.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-312">The server portion of the example creates a client process and passes it an anonymous pipe handle as an argument.</span></span>  
  
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cpp/sample.cpp#1)]
 [!code-csharp[System.IO.Pipes.PipeStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cs/sample.cs#1)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.pipes.pipestream/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-313"><paramref name="buffer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-313"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-314"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-314"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="fb3e9-315">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-315">-or-</span></span> 
 <span data-ttu-id="fb3e9-316"><paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-316"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-317"><paramref name="count" /> ist größer als die Anzahl der im <paramref name="buffer" /> verfügbaren Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-317"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-318">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-318">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-319">Die Pipe unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-319">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-320">Die Verbindung der Pipe ist getrennt, die Pipe wartet auf eine Verbindung, oder das Handle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-320">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-321">Es ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-321">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-322">Der Bereich im Arbeitsspeicher, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-322">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="fb3e9-323">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-323">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="fb3e9-324">Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-324">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-325">Liest eine Folge von Bytes asynchron aus dem aktuellen Stream, schreibt diese in einen Bytespeicherbereich, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-325">Asynchronously reads a sequence of bytes from the current stream, writes them to a byte memory range, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-326">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-326">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="fb3e9-327">Der Wert seiner <see cref="P:System.Threading.Tasks.ValueTask`1.Result" />-Eigenschaft enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-327">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="fb3e9-328">Der Ergebniswert kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder er kann 0 (null) sein, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-328">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="fb3e9-329">Die <xref:System.IO.Pipes.PipeStream.ReadAsync%2A>-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-329">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="fb3e9-330">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-330">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="fb3e9-331">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-331">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="fb3e9-332">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="fb3e9-332">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  

<span data-ttu-id="fb3e9-333">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-333">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-334">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-334">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-335">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-335">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-336">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-336">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-337">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-337">-or-</span></span>

<span data-ttu-id="fb3e9-338">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-338">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-339">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-339">-or-</span></span>

<span data-ttu-id="fb3e9-340">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-340">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-341">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-341">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-342">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-342">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-343">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-343">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-344">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-344">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="fb3e9-345">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-345">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="fb3e9-346">Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-346">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-347">Liest eine Folge von Bytes asynchron aus dem aktuellen Stream in ein Bytearray an die angegebene Position für eine angegebene Anzahl von Bytes, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-347">Asynchronously reads a sequence of bytes from the current stream to a byte array starting at a specified position for a specified number of bytes, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-348">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-348">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="fb3e9-349">Der Wert seiner <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-349">The value of its <see cref="P:System.Threading.Tasks.Task`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="fb3e9-350">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-350">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="fb3e9-351">Die <xref:System.IO.Pipes.PipeStream.ReadAsync%2A>-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-351">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="fb3e9-352">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-352">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="fb3e9-353">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-353">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="fb3e9-354">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="fb3e9-354">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="fb3e9-355">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-355">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-356">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-356">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-357">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-357">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-358">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-358">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-359">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-359">-or-</span></span>

<span data-ttu-id="fb3e9-360">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-360">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-361">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-361">-or-</span></span>

<span data-ttu-id="fb3e9-362">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-362">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-363">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-363">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="pipeStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-364">Liest ein Byte aus einer Pipe.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-364">Reads a byte from a pipe.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-365">Das in <see cref="T:System.Int32" />umgewandelte Byte oder -1, wenn das Ende des Streams erreicht wurde (die Pipe wurde geschlossen).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-365">The byte, cast to <see cref="T:System.Int32" />, or -1 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-366">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-366">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-367">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-367">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-368">Die Pipe unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-368">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-369">Die Verbindung der Pipe ist getrennt, die Pipe wartet auf eine Verbindung, oder das Handle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-369">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-370">Es ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-370">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode { System::IO::Pipes::PipeTransmissionMode get(); void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ReadMode : System.IO.Pipes.PipeTransmissionMode with get, set" Usage="System.IO.Pipes.PipeStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-371">Ruft den Lesemodus für ein <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-371">Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <value><span data-ttu-id="fb3e9-372">Einer der <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> -Werte, die angeben, wie das <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt aus der Pipe liest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-372">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-373">Die Nachrichtenübertragung im <xref:System.IO.Pipes.PipeTransmissionMode.Message> Modus wird von anonymen Pipes nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-373">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  

 <span data-ttu-id="fb3e9-374">Um eine <xref:System.InvalidOperationException> auf `ReadMode`zu vermeiden, können <xref:System.IO.Pipes.PipeStream.IsConnected> verwendet werden, um zu überprüfen, ob die Pipe verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-374">To avoid an <xref:System.InvalidOperationException> accessing `ReadMode`, <xref:System.IO.Pipes.PipeStream.IsConnected> can be used to verify the pipe is connected.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-375">Der bereitgestellte Wert ist kein gültiger <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> -Wert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-375">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-376">Der bereitgestellte Wert ist kein unterstützter <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> -Wert für diesen Pipestream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-376">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-377">Das Handle wurde noch nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-377">The handle has not been set.</span></span>  
  
 <span data-ttu-id="fb3e9-378">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-378">-or-</span></span>  
  
 <span data-ttu-id="fb3e9-379">Die Pipe wartet auf die Verbindung mit einem benannten Client.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-379">The pipe is waiting to connect with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-380">Die Pipe wurde unterbrochen, oder mit einem benannten Client ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-380">The pipe is broken or an I/O error occurred with a named client.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ SafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafePipeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle" Usage="System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-381">Ruft das sichere Handle für das lokale Ende der Pipe ab, die vom aktuellen <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-381">Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="fb3e9-382">Ein <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> -Objekt für die Pipe, die vom aktuellen <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-382">A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-383">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-383">The pipe handle has not been set.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-384">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-384">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="pipeStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="fb3e9-385">Der Punkt relativ zu <paramref name="origin" />, ab dem gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-385">The point, relative to <paramref name="origin" />, to begin seeking from.</span></span></param>
        <param name="origin"><span data-ttu-id="fb3e9-386">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <paramref name="offset" /> unter Verwendung eines Werts vom Typ <see cref="T:System.IO.SeekOrigin" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-386">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-387">Legt die aktuelle Position des aktuellen Streams auf den angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-387">Sets the current position of the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-388">Die neue Position im Stream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-388">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-389">Die <xref:System.IO.Pipes.PipeStream.Seek%2A>-Methode wird in Pipes nicht unterstützt, und es wird eine <xref:System.NotSupportedException> ausgelöst, wenn Sie aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-389">The <xref:System.IO.Pipes.PipeStream.Seek%2A> method is not supported in pipes and raises a <xref:System.NotSupportedException> when it is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetAccessControl(System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.Pipes.PipeSecurity -&gt; unit" Usage="pipeStream.SetAccessControl pipeSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity"><span data-ttu-id="fb3e9-390">Ein <see cref="T:System.IO.Pipes.PipeSecurity" /> -Objekt, das einen Eintrag in einer Zugriffssteuerungsliste angibt, der auf die aktuelle Pipe angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-390">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</span></span></param>
        <summary><span data-ttu-id="fb3e9-391">Wendet von einem <see cref="T:System.IO.Pipes.PipeSecurity" /> -Objekt angegebene Einträge in Zugriffssteuerungslisten auf die vom aktuellen <see cref="T:System.IO.Pipes.PipeStream" /> -Objekt angegebene Pipe an.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-391">Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-392">Eine Zugriffs Steuerungs Liste (Access Control List, ACL) beschreibt Personen und/oder Gruppen, die bzw. die keine Rechte haben, bestimmte Aktionen für eine bestimmte Datei auszuführen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-392">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="fb3e9-393">Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span><span class="sxs-lookup"><span data-stu-id="fb3e9-393">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-394">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-394">The pipe is closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-395"><paramref name="pipeSecurity" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-395"><paramref name="pipeSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="fb3e9-396">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-396">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-397">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-397">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-398">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-398">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="pipeStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="fb3e9-399">Die neue Länge des Streams.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-399">The new length of the stream.</span></span></param>
        <summary><span data-ttu-id="fb3e9-400">Legt die Länge des aktuellen Streams auf den angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-400">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-401">Die <xref:System.IO.Pipes.PipeStream>-Klasse unterstützt die <xref:System.IO.Pipes.PipeStream.SetLength%2A>-Methode nicht.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-401">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.SetLength%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberSignature Language="F#" Value="member this.TransmissionMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fb3e9-402">Ruft den von der aktuellen Pipe unterstützten Pipeübertragungsmodus ab.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-402">Gets the pipe transmission mode supported by the current pipe.</span></span></summary>
        <value><span data-ttu-id="fb3e9-403">Einer der <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> -Werte, die den von der aktuellen Pipe unterstützten Übertragungsmodus angeben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-403">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-404">Die Nachrichtenübertragung im <xref:System.IO.Pipes.PipeTransmissionMode.Message> Modus wird von anonymen Pipes nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-404">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-405">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-405">The pipe is closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-406">Das Handle wurde noch nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-406">The handle has not been set.</span></span>  
  
 <span data-ttu-id="fb3e9-407">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-407">-or-</span></span>  
  
 <span data-ttu-id="fb3e9-408">Die Pipe wartet auf die Verbindung in einem anonymen Client/Server-Vorgang oder mit einem benannten Client.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-408">The pipe is waiting to connect in an anonymous client/server operation or with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-409">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-409">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WaitForPipeDrain" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForPipeDrain ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForPipeDrain();" />
      <MemberSignature Language="F#" Value="member this.WaitForPipeDrain : unit -&gt; unit" Usage="pipeStream.WaitForPipeDrain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fb3e9-410">Wartet, bis das andere Ende der Pipe alle gesendeten Bytes gelesen hat.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-410">Waits for the other end of the pipe to read all sent bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-411">Die <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A>-Methode blockiert, bis das andere Ende der Pipe alle gesendeten Bytes gelesen hat.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-411">The <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> method blocks until the other end of the pipe has read all sent bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-412">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-412">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-413">Die Pipe unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-413">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-414">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-414">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="pipeStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-415">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-415">A region of memory.</span></span> <span data-ttu-id="fb3e9-416">Diese Methode kopiert den Inhalt dieses Bereichs in den aktuellen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-416">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="fb3e9-417">Schreibt eine Bytesequenz in den aktuellen Stream und setzt die aktuelle Position in diesem Stream um die Anzahl der geschriebenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-417">Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="fb3e9-418">Verwenden Sie die Eigenschaft <xref:System.IO.Pipes.PipeStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-418">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="fb3e9-419">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.WriteAsync%2A>-Methode, um asynchron in den aktuellen Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-419">Use the <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  

<span data-ttu-id="fb3e9-420">Wenn der Schreibvorgang erfolgreich ist, wird die Position im Stream um die Anzahl der geschriebenen Bytes fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-420">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="fb3e9-421">Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-421">If an exception occurs, the position within the stream remains unchanged.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-422">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-422">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-423">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-423">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-424">Die Pipe ist unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-424">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-425">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-425">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-426">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-426">-or-</span></span>

<span data-ttu-id="fb3e9-427">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-427">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-428">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-428">-or-</span></span>

<span data-ttu-id="fb3e9-429">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-429">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-430">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-430">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="pipeStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-431">Der Puffer, der Daten enthält, die in die Pipe geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-431">The buffer that contains data to write to the pipe.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-432">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-432">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-433">Die maximale Anzahl an Bytes, die in den aktuellen Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-433">The maximum number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="fb3e9-434">Schreibt einen Byteblock mit den Daten aus einem Puffer in den aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-434">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-435">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanWrite%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-435">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="fb3e9-436">Der Aufruf der <xref:System.IO.Pipes.PipeStream.Write%2A>-Methode blockiert, bis `count` Bytes gelesen oder das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-436">Calling the <xref:System.IO.Pipes.PipeStream.Write%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="fb3e9-437">Informationen zu asynchronen Lesevorgängen finden Sie unter <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> und <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-437">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> and <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-438"><paramref name="buffer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-438"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-439"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-439"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="fb3e9-440">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-440">-or-</span></span> 
 <span data-ttu-id="fb3e9-441"><paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-441"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-442"><paramref name="count" /> ist größer als die Anzahl der im <paramref name="buffer" /> verfügbaren Bytes.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-442"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-443">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-443">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-444">Die Pipe unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-444">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-445">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-445">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="pipeStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-446">Die Region im Arbeitsspeicher, aus der die Daten für das Schreiben gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-446">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="fb3e9-447">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-447">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="fb3e9-448">Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-448">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-449">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-449">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-450">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-450">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="fb3e9-451">Die <xref:System.IO.Pipes.PipeStream.WriteAsync%2A>-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-451">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="fb3e9-452">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-452">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="fb3e9-453">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-453">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="fb3e9-454">Verwenden Sie die Eigenschaft <xref:System.IO.Pipes.PipeStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-454">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="fb3e9-455">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-455">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-456">Der Stream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-456">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-457">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-457">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-458">Die Pipe ist unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-458">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-459">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-459">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-460">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-460">-or-</span></span>

<span data-ttu-id="fb3e9-461">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-461">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-462">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-462">-or-</span></span>

<span data-ttu-id="fb3e9-463">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-463">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-464">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-464">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="pipeStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="fb3e9-465">Der Puffer, aus dem die Daten geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-465">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="fb3e9-466">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-466">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="fb3e9-467">Die maximal zu schreibende Anzahl von Byte.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-467">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="fb3e9-468">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-468">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="fb3e9-469">Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-469">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="fb3e9-470">Schreibt eine angegebene Anzahl von Bytes aus einem Bytearray ab einer angegebenen Position, erhöht die aktuelle Position in diesem Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-470">Asynchronously writes a specified number of bytes from a byte array starting at a specified position, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="fb3e9-471">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-471">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="fb3e9-472">Die <xref:System.IO.Pipes.PipeStream.WriteAsync%2A>-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-472">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="fb3e9-473">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-473">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="fb3e9-474">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-474">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="fb3e9-475">Verwenden Sie die Eigenschaft <xref:System.IO.Pipes.PipeStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-475">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="fb3e9-476">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-476">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fb3e9-477"><paramref name="buffer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="fb3e9-477"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="fb3e9-478"><paramref name="offset" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-478">The <paramref name="offset" /> is negative.</span></span>

<span data-ttu-id="fb3e9-479">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-479">-or-</span></span>

<span data-ttu-id="fb3e9-480"><paramref name="count" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-480">The <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fb3e9-481"><paramref name="buffer" />. Länge - <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-481"><paramref name="buffer" />.Length - <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-482">Der Stream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-482">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-483">Auf eine geschlossene Pipe kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-483">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-484">Die Pipe ist unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-484">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-485">Die Pipe ist noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-485">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="fb3e9-486">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-486">-or-</span></span>

<span data-ttu-id="fb3e9-487">Die Pipe befindet sich in einem nicht verbundenen Zustand.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-487">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="fb3e9-488">Oder</span><span class="sxs-lookup"><span data-stu-id="fb3e9-488">-or-</span></span>

<span data-ttu-id="fb3e9-489">Das Pipehandle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-489">The pipe handle has not been set.</span></span> <span data-ttu-id="fb3e9-490">(Hat Ihre <see cref="T:System.IO.Pipes.PipeStream" />-Implementierung <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" /> aufgerufen?</span><span class="sxs-lookup"><span data-stu-id="fb3e9-490">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="pipeStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="fb3e9-491">Das Byte, das in den Stream geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-491">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="fb3e9-492">Schreibt ein Byte in den aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-492">Writes a byte to the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fb3e9-493">Verwenden Sie die <xref:System.IO.Pipes.PipeStream.CanWrite%2A>-Eigenschaft, um zu bestimmen, ob das aktuelle <xref:System.IO.Pipes.PipeStream>-Objekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-493">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="fb3e9-494">Die Pipe ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-494">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="fb3e9-495">Die Pipe unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-495">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fb3e9-496">Die Verbindung der Pipe ist getrennt, die Pipe wartet auf eine Verbindung, oder das Handle wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-496">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="fb3e9-497">Die Pipe wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb3e9-497">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
