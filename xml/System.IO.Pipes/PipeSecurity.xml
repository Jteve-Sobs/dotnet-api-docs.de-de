<Type Name="PipeSecurity" FullName="System.IO.Pipes.PipeSecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f83e93652dca9ab07afc67400edbc69b6fed905" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294381" /></Metadata><TypeSignature Language="C#" Value="public class PipeSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PipeSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeSecurity" />
  <TypeSignature Language="VB.NET" Value="Public Class PipeSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeSecurity : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type PipeSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt die Zugriffssteuerung und die Überwachungssicherheit für eine Pipe dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity> Klasse gibt an, die Zugriffsrechte für eine Pipe und wie Zugriffsversuche überwacht werden.  Diese Klasse stellt Zugriff und Überwachungsrichtlinie als eine Reihe von Regeln dar. Jede Regel für den Anwendungszugriff durch dargestellt wird ein <xref:System.IO.Pipes.PipeAccessRule> Objekt, und jede Überwachungsregel durch dargestellt eine <xref:System.IO.Pipes.PipeAuditRule> Objekt.  
  
 Die <xref:System.IO.Pipes.PipeSecurity> Klasse ist eine Abstraktion der zugrunde liegenden Microsoft Windows Security Dateisystem. In diesem System verwendet hat jede Pipe, eine discretionary Access Control List, Zugriffssteuerungsliste (DACL), die steuert, den Zugriff auf die Pipe und einer System-Zugriffssteuerungsliste (SACL), versucht die Access-Steuerelement an, die überwacht werden.  Die <xref:System.IO.Pipes.PipeAccessRule> und <xref:System.IO.Pipes.PipeAuditRule> Klassen, sind Abstraktionen die Zugriffssteuerungseinträge (ACEs), die DACLs und SACLs zu bilden.  
  
 Die <xref:System.IO.Pipes.PipeSecurity> Klasse verbirgt viele der Details von DACLs und SACLs; Sie müssen sich nicht um ACE Sortierung oder null-DACLS kümmern.  
  
 Verwenden der <xref:System.IO.Pipes.PipeSecurity> Klasse abrufen, hinzufügen oder ändern die Zugriffsregeln, die DACL und einer SACL einer Pipe darstellen.  
  
 Verwenden, um neue oder geänderte Zugriffs- oder Überwachungsregeln für eine Pipe, die <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> Methode. Mit der <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>-Methode können Zugriffs- oder Überwachungsregeln aus einer vorhandenen Datei abgerufen werden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PipeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PipeSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.PipeSecurity" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein leeres <xref:System.IO.Pipes.PipeSecurity> -Objekt, das nicht auf einer vorhandenen Pipe basiert. Sie können anschließend füllen Sie das Objekt mit Informationen zur Zugriffssteuerung und in eine Pipe angewendet.  
  
 Sie können Zugriff hinzufügen oder Überwachungsregeln für die <xref:System.IO.Pipes.PipeSecurity> -Objekt unter Verwendung der <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode. Entfernen Sie den Zugriff oder Überwachungsregeln, die mit der <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> Methode.  
  
 Verwenden, um neue oder geänderte Zugriffs- oder Überwachungsregeln für eine Pipe, die <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> Methode. Mit der <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>-Methode können Zugriffs- oder Überwachungsregeln aus einer vorhandenen Datei abgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> des sicherungsfähigen Objekts ab, das dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <value>Der Typ des sicherungsfähigen Objekts, das dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> Klasse außer Kraft setzen der <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> Eigenschaft und die Rückgabewerte der Typ, die sie verwenden, um Zugriffsrechte darstellt. Bei der Arbeit mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="pipeSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Die Identität, für die die Zugriffsregel gilt. Dabei muss es sich um ein Objekt handeln, das in ein <see cref="T:System.Security.Principal.SecurityIdentifier" />-Objekt umgewandelt werden kann.</param>
        <param name="accessMask">Die Zugriffsmaske dieser Regel. Die Zugriffsmaske ist eine 32-Bit-Auflistung anonymer Bits, deren Bedeutung von den einzelnen Integratoren definiert wird.</param>
        <param name="isInherited"><see langword="true" />, wenn diese Regel von einem übergeordneten Container geerbt wird, andernfalls false.</param>
        <param name="inheritanceFlags">Einer der <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Werte, der die Vererbungseigenschaften der Zugriffsregel angibt.</param>
        <param name="propagationFlags">Einer der <see cref="T:System.Security.AccessControl.PropagationFlags" />-Werte, die angeben, ob geerbte Zugriffsregeln automatisch weitergegeben werden. Die Weitergabeflags werden ignoriert, wenn <paramref name="inheritanceFlags" /> auf <see cref="F:System.Security.AccessControl.InheritanceFlags.None" /> festgelegt ist.</param>
        <param name="type">Gibt den gültigen Zugriffssteuerungstyp an.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.AccessRule" />-Klasse mit den angegebenen Werten.</summary>
        <returns>Das von dieser Methode erstellte <see cref="T:System.Security.AccessControl.AccessRule" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Zugriffssteuerungsregeln wird mithilfe der Konstruktoren, der die <xref:System.IO.Pipes.PipeAccessRule> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> oder <paramref name="type" /> ist ein ungültiger Wert angegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="accessMask" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie etwa <see cref="T:System.Security.Principal.NTAccount" />, der in den Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> des Objekts ab, das den Zugriffsregeln des aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekts zugeordnet ist.</summary>
        <value>Der Typ des Objekts, das den Zugriffsregeln des aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekts zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> Klasse außer Kraft setzen der <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> Eigenschaft und die Rückgabewerte der Typ, die sie verwenden, um Zugriffsrechte darstellt. Bei der Arbeit mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Zugriffsregel.</param>
        <summary>Fügt der freigegebenen Zugriffssteuerungsliste (DACL - Discretionary Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist, eine Zugriffsregel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode fügt eine neue Regel, um die Liste der Regeln, die eine <xref:System.IO.Pipes.PipeSecurity> Objekt enthält. Wenn bereits eine Zugriffssteuerungsliste (ACL) für die angegebene Regel vorhanden ist die <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode wird die Regel mit einer Ausnahme weiterhin hinzufügen: eine <xref:System.IO.Pipes.PipeAccessRule> -Objekt, das erstellt wird, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert Vorrang vor, ein Objekt, das mit der erstelltwird<xref:System.Security.AccessControl.AccessControlType.Allow> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Überwachungsregel.</param>
        <summary>Fügt der Systemzugriffssteuerungsliste (SACL - System Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist, eine Überwachungsregel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> Methode fügt eine neue Überwachungsregel, um die Liste der Regeln, die eine <xref:System.IO.Pipes.PipeSecurity> Objekt enthält.  
  
 Wenn Sie eine Überwachungsregel für die angegebene Regel bereits vorhanden ist die <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> Methode wird immer noch die Regel hinzuzufügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override sealed System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="pipeSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Die Identität, für die die Zugriffsregel gilt. Dabei muss es sich um ein Objekt handeln, das in ein <see cref="T:System.Security.Principal.SecurityIdentifier" />-Objekt umgewandelt werden kann.</param>
        <param name="accessMask">Die Zugriffsmaske dieser Regel. Die Zugriffsmaske ist eine 32-Bit-Auflistung anonymer Bits, deren Bedeutung von den einzelnen Integratoren definiert wird.</param>
        <param name="isInherited"><see langword="true" />, wenn diese Regel von einem übergeordneten Container geerbt wird, andernfalls FALSE.</param>
        <param name="inheritanceFlags">Einer der <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Werte, der die Vererbungseigenschaften der Zugriffsregel angibt.</param>
        <param name="propagationFlags">Einer der <see cref="T:System.Security.AccessControl.PropagationFlags" />-Werte, die angeben, ob geerbte Zugriffsregeln automatisch weitergegeben werden. Die Weitergabeflags werden ignoriert, wenn <paramref name="inheritanceFlags" /> auf <see cref="F:System.Security.AccessControl.InheritanceFlags.None" /> festgelegt ist.</param>
        <param name="flags">Einer der <see cref="T:System.Security.AccessControl.AuditFlags" />-Werte, der den gültigen Zugriffssteuerungstyp angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.AuditRule" />-Klasse mit den angegebenen Werten.</summary>
        <returns>Das von dieser Methode erstellte <see cref="T:System.Security.AccessControl.AuditRule" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Überwachungsregeln ist die Verwendung von den Konstruktoren der <xref:System.IO.Pipes.PipeAuditRule> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Eigenschaften <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> und <paramref name="flags" /> geben einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="identityReference" />-Eigenschaft ist <see langword="null" />.  
  
- oder -  
Der Wert der <paramref name="accessMask" />-Eigenschaft ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="identityReference" />-Eigenschaft ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie <see cref="T:System.Security.Principal.NTAccount" />, der in den Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt ab, das den Überwachungsregeln des aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekts zugeordnet ist.</summary>
        <value>Der Typ des Objekts, das den Überwachungsregeln des aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekts zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> Klasse außer Kraft setzen der <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> Eigenschaft und die Rückgabewerte der Typ, die sie verwenden, um Zugriffsrechte darstellt. Bei der Arbeit mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine dauerhafte Speicherung der angegebenen Abschnitte der Sicherheitsbeschreibung aus, die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (System.Runtime.InteropServices.SafeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(class System.Runtime.InteropServices.SafeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (handle As SafeHandle)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::Runtime::InteropServices::SafeHandle ^ handle);" />
      <MemberSignature Language="F#" Value="member this.Persist : System.Runtime.InteropServices.SafeHandle -&gt; unit" Usage="pipeSecurity.Persist handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle des sicherungsfähigen Objekts, dem das aktuelle <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</param>
        <summary>Führt eine dauerhafte Speicherung der angegebenen Abschnitte der Sicherheitsbeschreibung aus, die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Persist : string -&gt; unit" Usage="pipeSecurity.Persist name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des sicherungsfähigen Objekts, dem das aktuelle <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</param>
        <summary>Führt eine dauerhafte Speicherung der angegebenen Abschnitte der Sicherheitsbeschreibung aus, die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As PipeAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.IO.Pipes.PipeAccessRule -&gt; bool" Usage="pipeSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die zu entfernende Zugriffsregel.</param>
        <summary>Entfernt eine Zugriffsregel aus der freigegebenen Zugriffssteuerungsliste (DACL - Discretionary Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Zugriffsregeln aus der aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt. Beispielsweise können Sie diese Methode verwenden, so entfernen Sie alle <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln für einen Benutzer durch übergeben eine <xref:System.IO.Pipes.PipeAccessRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und ein Benutzerkonto. Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle verweigern-Regeln, die angeben, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert oder die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRuleSpecific(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die zu entfernende Zugriffsregel.</param>
        <summary>Entfernt die angegebene Zugriffsregel aus der freigegebenen Zugriffssteuerungsliste (DACL - Discretionary Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Zugriffsregeln aus der aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt. Beispielsweise können Sie diese Methode verwenden, so entfernen Sie alle <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln für einen Benutzer durch übergeben eine <xref:System.IO.Pipes.PipeAccessRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und ein Benutzerkonto. Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle verweigern-Regeln, die angeben, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert oder die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As PipeAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.IO.Pipes.PipeAuditRule -&gt; bool" Usage="pipeSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die zu entfernende Überwachungsregel.</param>
        <summary>Entfernt eine Überwachungsregel aus der Systemzugriffssteuerungsliste (SACL - System Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <returns><see langword="true" />, wenn die Überwachungsregel entfernt wurde, andernfalls <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Überwachungsregeln aus der aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt.  Beispielsweise können Sie diese Methode verwenden, so entfernen Sie alle <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregeln für einen Benutzer durch übergeben eine <xref:System.Security.AccessControl.FileSystemAuditRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.Security.AccessControl.AuditFlags.Failure> Wert und ein Benutzerkonto.  Wenn Sie dies tun, die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> -Methode entfernt alle verweigern-Regeln, die angeben, die <xref:System.Security.AccessControl.AuditFlags.Failure> Wert oder die <xref:System.Security.AccessControl.AuditFlags.Success> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die zu entfernende Überwachungsregel.</param>
        <summary>Entfernt alle Überwachungsregeln, die dieselbe Sicherheits-ID wie die angegebene Überwachungsregel enthalten, aus der Systemzugriffssteuerungsliste (SACL - System Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll%2A> Methode entfernt alle Überwachungsregeln für den angegebenen Benutzer.  Es ignoriert alle Werte in der <xref:System.IO.Pipes.PipeAuditRule> Objekt, mit Ausnahme des Benutzerkontos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die zu entfernende Überwachungsregel.</param>
        <summary>Entfernt die angegebene Überwachungsregel aus der Systemzugriffssteuerungsliste (SACL - System Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> Methode entfernt die angegebene entsprechende <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachung, Regel oder die angegebene entsprechende <xref:System.Security.AccessControl.AccessControlType.Allow> Überwachungsregel aus der aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt.  Z. B. können Sie diese Methode verwenden, entfernen Sie eine angegebene <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregel für einen Benutzer durch Übergeben einer <xref:System.Security.AccessControl.FileSystemAuditRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.Security.AccessControl.AuditFlags.Failure> Wert und ein Benutzerkonto.  Wenn Sie dies tun, die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> Methode entfernt nur eine Deny-Regel, der angibt, die <xref:System.Security.AccessControl.AuditFlags.Failure> Wert.  Es entfernt nicht die Deny-Regeln, die angeben, die <xref:System.Security.AccessControl.AuditFlags.Success> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.ResetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Zugriffsregel.</param>
        <summary>Entfernt alle Zugriffsregeln in der freigegebenen Zugriffssteuerungsliste (DACL - Discretionary Access Control List), die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist, und fügt dann die angegebene Zugriffsregel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode fügt die angegebene Regel Zugriffssteuerungsliste (ACL), oder überschreibt alle identischen ACL-Regeln, die entsprechen den `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an, eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird auch überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die festzulegende Regel.</param>
        <summary>Legt eine Zugriffsregel in der freigegebenen Zugriffssteuerungsliste (DACL - Discretionary Access Control List) fest, die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode fügt die angegebene Regel Zugriffssteuerungsliste (ACL), oder überschreibt alle identischen ACL-Regeln, die entsprechen der <xref:System.IO.Pipes.PipeAccessRights> Wert der `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an, eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird nicht überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die festzulegende Regel.</param>
        <summary>Legt eine Überwachungsregel in der Systemzugriffssteuerungsliste (SACL - System Access Control List) fest, die dem aktuellen <see cref="T:System.IO.Pipes.PipeSecurity" />-Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode fügt die angegebene Überwachungsregel hinzu oder überschreibt alle identischen Überwachungsregeln, die mit übereinstimmen, der die <xref:System.IO.Pipes.PipeAccessRights> Wert der `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an, eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode findet eine identische Überwachungsregel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode findet eine identische Überwachungsregel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird nicht überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="rule" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>