<Type Name="PipeSecurity" FullName="System.IO.Pipes.PipeSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="29e98cc2a13259ec8e838f8ef32da2cdc8db4e72" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36561224" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PipeSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PipeSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeSecurity" />
  <TypeSignature Language="VB.NET" Value="Public Class PipeSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeSecurity : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type PipeSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Represents the access control and audit security for a pipe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity> Klasse gibt die Zugriffsrechte für eine Pipe und wie Zugriffsversuche überwacht werden.  Diese Klasse stellt Zugriffs- und Überwachungsrichtlinien Rechte als ein Satz von Regeln dar. Jede Zugriffsregel dargestellte eine <xref:System.IO.Pipes.PipeAccessRule> -Objekt, während jede Überwachungsregel entspricht ein <xref:System.IO.Pipes.PipeAuditRule> Objekt.  
  
 Die <xref:System.IO.Pipes.PipeSecurity> -Klasse ist eine Abstraktion der zugrunde liegenden Microsoft Windows Security-Dateisystem. In diesem System verfügt jede Pipe über einen besitzerverwaltete Zugriffssteuerungsliste (DACL), die steuert, den Zugriff auf die Pipe und einer System-Zugriffssteuerungsliste (SACL), das Steuerelement Zugriffsversuchen gibt an, die überwacht werden.  Die <xref:System.IO.Pipes.PipeAccessRule> und <xref:System.IO.Pipes.PipeAuditRule> Klassen stellen Abstraktionen von die Zugriffssteuerungseinträge (ACEs), die DACLs und SACLs bilden.  
  
 Die <xref:System.IO.Pipes.PipeSecurity> -Klasse blendet viele Details der DACLs und SACLs; Sie müssen keine ACE Sortier- oder null-DACLS kümmern.  
  
 Verwenden der <xref:System.IO.Pipes.PipeSecurity> -Klasse abrufen, hinzufügen oder ändern die Zugriffsregeln, die die DACL und SACL einer Pipe darstellen.  
  
 Um neue oder geänderte Zugriffs- oder Überwachungsregeln für eine Pipe, verwenden die <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> Methode. Mit der <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>-Methode können Zugriffs- oder Überwachungsregeln aus einer vorhandenen Datei abgerufen werden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PipeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PipeSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeSecurity" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein leeres <xref:System.IO.Pipes.PipeSecurity> -Objekt, das nicht auf einer vorhandenen Pipe basiert. Sie können das-Objekt mit Informationen aufgefüllt und wenden Sie es mit einer Pipe.  
  
 Zugriff hinzufügen können, oder Überwachungsregeln für die <xref:System.IO.Pipes.PipeSecurity> -Objekt unter Verwendung der <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode. Können Sie den Zugriff entfernen oder Überwachungsregeln, die mithilfe der <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> Methode.  
  
 Um neue oder geänderte Zugriffs- oder Überwachungsregeln für eine Pipe, verwenden die <xref:System.IO.Pipes.PipeStream.SetAccessControl%2A> Methode. Mit der <xref:System.IO.Pipes.PipeStream.GetAccessControl%2A>-Methode können Zugriffs- oder Überwachungsregeln aus einer vorhandenen Datei abgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Type" /> of the securable object that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <value>Der Typ des sicherungsfähigen Objekts, die mit dem aktuellen anfallen <see cref="T:System.IO.Pipes.PipeSecurity" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> -Eigenschaft und der Rückgabewert den Typ, die sie verwenden, um die Darstellung von Zugriffsrechten. Beim Arbeiten mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="pipeSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" /> object.</param>
        <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
        <param name="isInherited">
          <see langword="true" /> if this rule is inherited from a parent container; otherwise false.</param>
        <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values that specifies the inheritance properties of the access rule.</param>
        <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <c>inheritanceFlags</c> is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Specifies the valid access control type.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AccessRule" /> class with the specified values.</summary>
        <returns>The <see cref="T:System.Security.AccessControl.AccessRule" /> object that this method creates.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Zugriffssteuerungsregeln ist die Verwendung von den Konstruktoren für die <xref:System.IO.Pipes.PipeAccessRule> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="type" /> specifies an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> is <see langword="null" />.  -or-  <paramref name="accessMask" /> is zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />, that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Type" /> of the object that is associated with the access rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <value>Der Typ des Objekts, das den Zugriffsregeln des aktuellen zugeordnet ist <see cref="T:System.IO.Pipes.PipeSecurity" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> -Eigenschaft und der Rückgabewert den Typ, die sie verwenden, um die Darstellung von Zugriffsrechten. Beim Arbeiten mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">The access rule to add.</param>
        <summary>Adds an access rule to the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode fügt eine neue Regel, um die Liste der Regeln, die eine <xref:System.IO.Pipes.PipeSecurity> Objekt enthält. Wenn eine Zugriffssteuerungsliste (ACL) für die angegebene Regel ist bereits vorhanden der <xref:System.IO.Pipes.PipeSecurity.AddAccessRule%2A> Methode wird immer noch die Regel mit einer Ausnahme hinzugefügt: ein <xref:System.IO.Pipes.PipeAccessRule> -Objekt, das erstellt wird, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert Vorrang vor, ein Objekt, das mit der erstelltwird<xref:System.Security.AccessControl.AccessControlType.Allow> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AddAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">The audit rule to add.</param>
        <summary>Adds an audit rule to the System Access Control List (SACL)that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> Methode fügt eine neue Überwachungsregel zur Liste der Regeln, die eine <xref:System.IO.Pipes.PipeSecurity> Objekt enthält.  
  
 Wenn eine Überwachungsregel für die angegebene Regel bereits die <xref:System.IO.Pipes.PipeSecurity.AddAuditRule%2A> Methode wird immer noch die Regel hinzuzufügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override sealed System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="pipeSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" /> object.</param>
        <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
        <param name="isInherited">
          <see langword="true" /> if this rule is inherited from a parent container; otherwise, false..</param>
        <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values that specifies the inheritance properties of the access rule.</param>
        <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <c>inheritanceFlags</c> is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" /> values that specifies the valid access control type.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AuditRule" /> class with the specified values.</summary>
        <returns>The <see cref="T:System.Security.AccessControl.AuditRule" /> object that this method creates.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Überwachungsregeln ist die Verwendung von den Konstruktoren für die <xref:System.IO.Pipes.PipeAuditRule> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="flags" /> properties specify an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="identityReference" /> property is <see langword="null" />.  -or-  The <paramref name="accessMask" /> property is zero.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="identityReference" /> property is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />, that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.IO.Pipes.PipeSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Type" /> object associated with the audit rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <value>Der Typ des Objekts, das den Überwachungsregeln des aktuellen zugeordnet ist <see cref="T:System.IO.Pipes.PipeSecurity" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> -Eigenschaft und der Rückgabewert den Typ, die sie verwenden, um die Darstellung von Zugriffsrechten. Beim Arbeiten mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Saves the specified sections of the security descriptor that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object to permanent storage.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (System.Runtime.InteropServices.SafeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(class System.Runtime.InteropServices.SafeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (handle As SafeHandle)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::Runtime::InteropServices::SafeHandle ^ handle);" />
      <MemberSignature Language="F#" Value="member this.Persist : System.Runtime.InteropServices.SafeHandle -&gt; unit" Usage="pipeSecurity.Persist handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The handle of the securable object that the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object is associated with.</param>
        <summary>Saves the specified sections of the security descriptor that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object to permanent storage.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="protected internal void Persist (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Persist(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.Persist(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Persist (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Persist(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Persist : string -&gt; unit" Usage="pipeSecurity.Persist name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the securable object that the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object is associated with.</param>
        <summary>Saves the specified sections of the security descriptor that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object to permanent storage.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As PipeAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.IO.Pipes.PipeAccessRule -&gt; bool" Usage="pipeSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">The access rule to remove.</param>
        <summary>Removes an access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Zugriffsregeln aus dem aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt. Angenommen, Sie können diese Methode alle entfernen <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln für einen Benutzer durch Übergeben einer <xref:System.IO.Pipes.PipeAccessRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und ein Benutzerkonto. Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle Deny-Regeln, die angeben, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert oder die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAccessRuleSpecific(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">The access rule to remove.</param>
        <summary>Removes the specified access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Zugriffsregeln aus dem aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt. Angenommen, Sie können diese Methode alle entfernen <xref:System.Security.AccessControl.AccessControlType.Deny> Zugriffsregeln für einen Benutzer durch Übergeben einer <xref:System.IO.Pipes.PipeAccessRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und ein Benutzerkonto. Die <xref:System.IO.Pipes.PipeSecurity.RemoveAccessRule%2A> -Methode entfernt alle Deny-Regeln, die angeben, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert oder die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As PipeAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.IO.Pipes.PipeAuditRule -&gt; bool" Usage="pipeSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">The audit rule to remove.</param>
        <summary>Removes an audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <returns>
          <see langword="true" /> if the audit rule was removed; otherwise, <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> -Methode entfernt alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregeln bzw. alle entsprechenden <xref:System.Security.AccessControl.AccessControlType.Allow> Überwachungsregeln aus dem aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt.  Angenommen, Sie können diese Methode alle entfernen <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregeln für einen Benutzer durch Übergeben einer <xref:System.Security.AccessControl.FileSystemAuditRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.Security.AccessControl.AuditFlags.Failure> Wert und ein Benutzerkonto.  Wenn Sie dies tun, die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRule%2A> -Methode entfernt alle Deny-Regeln, die angeben der <xref:System.Security.AccessControl.AuditFlags.Failure> Wert oder die <xref:System.Security.AccessControl.AuditFlags.Success> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">The audit rule to remove.</param>
        <summary>Removes all audit rules that have the same security identifier as the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleAll%2A> -Methode entfernt alle Überwachungsregeln für den angegebenen Benutzer.  Es ignoriert alle Werte in der <xref:System.IO.Pipes.PipeAuditRule> Objekt, mit Ausnahme des Benutzerkontos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">The audit rule to remove.</param>
        <summary>Removes the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> Methode entfernt die angegebene entsprechende <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachung, Regel oder die angegebene entsprechende <xref:System.Security.AccessControl.AccessControlType.Allow> Überwachungsregel aus dem aktuellen <xref:System.IO.Pipes.PipeSecurity> Objekt.  Angenommen, Sie können diese Methode ein angegebenes entfernen <xref:System.Security.AccessControl.AccessControlType.Deny> Überwachungsregel für einen Benutzer durch Übergeben einer <xref:System.Security.AccessControl.FileSystemAuditRule> Objekt erstellt, mit der <xref:System.Security.AccessControl.AccessControlType.Deny> Wert, der <xref:System.Security.AccessControl.AuditFlags.Failure> Wert und ein Benutzerkonto.  Wenn Sie dies tun, die <xref:System.IO.Pipes.PipeSecurity.RemoveAuditRuleSpecific%2A> -Methode entfernt nur auf eine Verweigerungsregel, der angibt, die <xref:System.Security.AccessControl.AuditFlags.Failure> Wert.  Keine Deny-Regeln, die angeben, entfernt die <xref:System.Security.AccessControl.AuditFlags.Success> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.ResetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">The access rule to add.</param>
        <summary>Removes all access rules in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object and then adds the specified access rule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode fügt die angegebene Zugriffssteuerungslisten (ACL)-Regel hinzu oder überschreibt alle identischen ACL-Regeln, die entsprechen den `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.ResetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird auch überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.IO.Pipes.PipeAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.IO.Pipes.PipeAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAccessRule(System.IO.Pipes.PipeAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As PipeAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::IO::Pipes::PipeAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.IO.Pipes.PipeAccessRule -&gt; unit" Usage="pipeSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">The rule to set.</param>
        <summary>Sets an access rule in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode fügt die angegebene Zugriffssteuerungslisten (ACL)-Regel hinzu oder überschreibt alle identischen ACL-Regeln, die entsprechen der <xref:System.IO.Pipes.PipeAccessRights> Wert der `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.SetAccessRule%2A> Methode sucht nach einer identischen ACL-Regel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird nicht überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.IO.Pipes.PipeAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.IO.Pipes.PipeAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeSecurity.SetAuditRule(System.IO.Pipes.PipeAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As PipeAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::IO::Pipes::PipeAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.IO.Pipes.PipeAuditRule -&gt; unit" Usage="pipeSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.IO.Pipes.PipeAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">The rule to set.</param>
        <summary>Sets an audit rule in the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode fügt die angegebene Überwachungsregel hinzu oder überschreibt alle identischen Überwachungsregeln, die entsprechen der <xref:System.IO.Pipes.PipeAccessRights> Wert, der die `rule` Parameter.  Z. B. wenn die `rule` Parameter gibt an eine <xref:System.IO.Pipes.PipeAccessRights.Read> Wert und die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode findet eine identische Überwachungsregel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Read> Wert, der identische Regel wird überschrieben werden.  Wenn die <xref:System.IO.Pipes.PipeSecurity.SetAuditRule%2A> Methode findet eine identische Überwachungsregel, der angibt, die <xref:System.IO.Pipes.PipeAccessRights.Write> Wert, der identische Regel wird nicht überschrieben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>