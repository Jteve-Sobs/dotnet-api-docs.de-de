<Type Name="AnonymousPipeServerStream" FullName="System.IO.Pipes.AnonymousPipeServerStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18d0708437ab6c6f1fec334b0f9decc4b21bc722" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52222892" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AnonymousPipeServerStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AnonymousPipeServerStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.AnonymousPipeServerStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AnonymousPipeServerStream&#xA;Inherits PipeStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class AnonymousPipeServerStream sealed : System::IO::Pipes::PipeStream" />
  <TypeSignature Language="F#" Value="type AnonymousPipeServerStream = class&#xA;    inherit PipeStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Macht einen Stream um eine anonyme Pipe verfügbar, der synchrone und asynchrone Lese- und Schreibvorgänge unterstützt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes tragen zur sicheren prozessübergreifende Kommunikation zwischen untergeordneten und übergeordneten Prozessen. Die <xref:System.IO.Pipes.AnonymousPipeServerStream> Klasse ermöglicht es einen übergeordneten Prozess zum Senden oder Empfangen von Informationen aus einem untergeordneten Prozess.  
  
 Anonyme Pipes sind unbenannte, unidirektionale Pipes, die Daten in der Regel zwischen übergeordneten und untergeordneten Prozessen zu übertragen. Anonyme Pipes sind immer lokal. Sie können nicht über ein Netzwerk verwendet werden. Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> Modi zu lesen.  
  
 Die Clientseite einer anonymen Pipe muss erstellt werden, über ein Pipehandle, die von der Serverseite bereitgestellt durch Aufrufen der <xref:System.IO.Pipes.AnonymousPipeServerStream.GetClientHandleAsString%2A> Methode. Die Zeichenfolge wird als Parameter übergeben, wenn den Clientprozess zu erstellen. Vom Client-Prozess, wird es dann zum Übergeben der <xref:System.IO.Pipes.AnonymousPipeClientStream> Konstruktor als die `pipeHandleAsString` Parameter.  
  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt freigeben muss, die Client-Handle mithilfe der <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> Methode, um benachrichtigt zu werden, wenn der Client beendet wird.  
  
> [!NOTE]
>  Für [!INCLUDE[winxppro](~/includes/winxppro-md.md)] und [!INCLUDE[win2kserver](~/includes/win2kserver-md.md)], maximal 10 Pipes kann gleichzeitig eine Verbindung herstellen über das Netzwerk.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie eine Zeichenfolge mithilfe von anonymen Pipes von einem übergeordneten Prozess an einen untergeordneten Prozess gesendet werden kann. In diesem Beispiel wird ein <xref:System.IO.Pipes.AnonymousPipeServerStream>-Objekt in einem übergeordneten Prozess mit dem <xref:System.IO.Pipes.PipeDirection>-Wert <xref:System.IO.Pipes.PipeDirection.Out> erstellt. Erstellt auch eine <xref:System.IO.Pipes.AnonymousPipeClientStream> Objekt in einem untergeordneten Prozess mit einem <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.In>. Der übergeordnete Prozess sendet daraufhin eine vom Benutzer bereitgestellte Zeichenfolge an den untergeordneten Prozess. Die Zeichenfolge wird in der Konsole angezeigt.  
  
 In diesem Beispiel wird für den Serverprozess, der verwendet die <xref:System.IO.Pipes.AnonymousPipeServerStream> Klasse. Das gesamte Codebeispiel an, einschließlich des Codes für die Pipe-Client und Server, finden Sie unter [Vorgehensweise: Verwenden von anonymen Pipes zur lokalen prozessübergreifenden Kommunikation](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für <xref:System.IO.Pipes.AnonymousPipeServerStream> Konstruktoren ohne eine <xref:System.IO.Pipes.PipeDirection> Parameter, der die standardrichtung ist <xref:System.IO.Pipes.PipeDirection.Out>. Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardgröße des Puffers, ohne pipesicherheit hat und ein <xref:System.IO.HandleInheritability> Wert <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (direction As PipeDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream(System::IO::Pipes::PipeDirection direction);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.AnonymousPipeServerStream : System.IO.Pipes.PipeDirection -&gt; System.IO.Pipes.AnonymousPipeServerStream" Usage="new System.IO.Pipes.AnonymousPipeServerStream direction" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
Anonyme Pipes dürfen nur eine Richtung aufweisen, daher kann <paramref name="direction" /> nicht auf <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse mit der angegebenen Piperichtung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardgröße des Puffers, ohne pipesicherheit hat und ein <xref:System.IO.HandleInheritability> Wert <xref:System.IO.HandleInheritability.None>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (direction As PipeDirection, inheritability As HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream(System::IO::Pipes::PipeDirection direction, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.AnonymousPipeServerStream : System.IO.Pipes.PipeDirection * System.IO.HandleInheritability -&gt; System.IO.Pipes.AnonymousPipeServerStream" Usage="new System.IO.Pipes.AnonymousPipeServerStream (direction, inheritability)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
Anonyme Pipes dürfen nur eine Richtung aufweisen, daher kann <paramref name="direction" /> nicht auf <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt werden.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann. Muss entweder auf <see cref="F:System.IO.HandleInheritability.None" /> oder auf <see cref="F:System.IO.HandleInheritability.Inheritable" /> festgelegt sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse mit der angegebenen Piperichtung und dem angegebenen Vererbbarkeitsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt, das die Standardpuffergröße und keine pipesicherheit verfügt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Methode, um eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess mithilfe von anonymen Pipes zu senden. In diesem Beispiel ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt wird erstellt, in einem übergeordneten Prozess mit einem <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" /> ist nicht auf <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, Microsoft.Win32.SafeHandles.SafePipeHandle serverSafePipeHandle, Microsoft.Win32.SafeHandles.SafePipeHandle clientSafePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, class Microsoft.Win32.SafeHandles.SafePipeHandle serverSafePipeHandle, class Microsoft.Win32.SafeHandles.SafePipeHandle clientSafePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,Microsoft.Win32.SafeHandles.SafePipeHandle,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (direction As PipeDirection, serverSafePipeHandle As SafePipeHandle, clientSafePipeHandle As SafePipeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream(System::IO::Pipes::PipeDirection direction, Microsoft::Win32::SafeHandles::SafePipeHandle ^ serverSafePipeHandle, Microsoft::Win32::SafeHandles::SafePipeHandle ^ clientSafePipeHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.AnonymousPipeServerStream : System.IO.Pipes.PipeDirection * Microsoft.Win32.SafeHandles.SafePipeHandle * Microsoft.Win32.SafeHandles.SafePipeHandle -&gt; System.IO.Pipes.AnonymousPipeServerStream" Usage="new System.IO.Pipes.AnonymousPipeServerStream (direction, serverSafePipeHandle, clientSafePipeHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="serverSafePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
        <Parameter Name="clientSafePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
Anonyme Pipes dürfen nur eine Richtung aufweisen, daher kann <paramref name="direction" /> nicht auf <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt werden.</param>
        <param name="serverSafePipeHandle">Ein sicheres Handle für die Pipe, die von diesem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt gekapselt wird.</param>
        <param name="clientSafePipeHandle">Ein sicheres Handle für das <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse aus den angegebenen Pipehandles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="serverSafePipeHandle" /> oder <paramref name="clientSafePipeHandle" /> ist ein ungültiges Handle.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverSafePipeHandle" /> oder <paramref name="clientSafePipeHandle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise ein Datenträgerfehler.  
  
- oder -  
Der Stream wurde geschlossen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (direction As PipeDirection, inheritability As HandleInheritability, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream(System::IO::Pipes::PipeDirection direction, System::IO::HandleInheritability inheritability, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.AnonymousPipeServerStream : System.IO.Pipes.PipeDirection * System.IO.HandleInheritability * int -&gt; System.IO.Pipes.AnonymousPipeServerStream" Usage="new System.IO.Pipes.AnonymousPipeServerStream (direction, inheritability, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
Anonyme Pipes dürfen nur eine Richtung aufweisen, daher kann <paramref name="direction" /> nicht auf <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt werden.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann. Muss entweder auf <see cref="F:System.IO.HandleInheritability.None" /> oder auf <see cref="F:System.IO.HandleInheritability.Inheritable" /> festgelegt sein.</param>
        <param name="bufferSize">Die Größe des Puffers. Dieser Wert muss größer oder gleich 0 sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse mit der angegebenen Piperichtung, dem angegebenen Vererbbarkeitsmodus und der angegebenen Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 Dieser Konstruktor erstellt ein <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt ohne pipesicherheit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" /> ist nicht auf <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" /> festgelegt.  
  
- oder -  
 <paramref name="bufferSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.NotSupportedException">Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AnonymousPipeServerStream (System.IO.Pipes.PipeDirection direction, System.IO.HandleInheritability inheritability, int bufferSize, System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.HandleInheritability inheritability, int32 bufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability,System.Int32,System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AnonymousPipeServerStream(System::IO::Pipes::PipeDirection direction, System::IO::HandleInheritability inheritability, int bufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.AnonymousPipeServerStream : System.IO.Pipes.PipeDirection * System.IO.HandleInheritability * int * System.IO.Pipes.PipeSecurity -&gt; System.IO.Pipes.AnonymousPipeServerStream" Usage="new System.IO.Pipes.AnonymousPipeServerStream (direction, inheritability, bufferSize, pipeSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="direction">Einer der Enumerationswerte, der die Richtung der Pipe bestimmt.  
  
Anonyme Pipes dürfen nur eine Richtung aufweisen, daher kann <paramref name="direction" /> nicht auf <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt werden.</param>
        <param name="inheritability">Einer der Enumerationswerte, der bestimmt, ob das zugrunde liegende Handle von untergeordneten Prozessen geerbt werden kann.</param>
        <param name="bufferSize">Die Größe des Puffers. Dieser Wert muss größer oder gleich 0 sein.</param>
        <param name="pipeSecurity">Ein Objekt, das die Zugriffssteuerung und die Überwachungssicherheit für die Pipe bestimmt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Klasse mit der angegebenen Piperichtung, dem angegebenen Vererbbarkeitsmodus, der angegebenen Puffergröße und der angegebenen Pipesicherheit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.InOut> wird nicht unterstützt werden, da anonyme Pipes unidirektionale definiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="inheritability" /> ist nicht auf <see cref="F:System.IO.HandleInheritability.None" /> oder <see cref="F:System.IO.HandleInheritability.Inheritable" /> festgelegt.  
  
- oder -  
 <paramref name="bufferSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.NotSupportedException">Für <paramref name="direction" /> ist <see cref="F:System.IO.Pipes.PipeDirection.InOut" /> festgelegt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ClientSafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle ClientSafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle ClientSafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.ClientSafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientSafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ ClientSafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientSafePipeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle" Usage="System.IO.Pipes.AnonymousPipeServerStream.ClientSafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das sichere Handle für das <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekt ab, das gegenwärtig mit dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt verbunden ist.</summary>
        <value>Ein Handle für das <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekt, das derzeit mit dem <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt verbunden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> -Methode aufgerufen werden soll, nachdem ein Clienthandle an einen Clientprozess übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="anonymousPipeServerStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeLocalCopyOfClientHandle">
      <MemberSignature Language="C#" Value="public void DisposeLocalCopyOfClientHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisposeLocalCopyOfClientHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisposeLocalCopyOfClientHandle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisposeLocalCopyOfClientHandle();" />
      <MemberSignature Language="F#" Value="member this.DisposeLocalCopyOfClientHandle : unit -&gt; unit" Usage="anonymousPipeServerStream.DisposeLocalCopyOfClientHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die lokale Kopie des Handles für das <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> -Methode aufgerufen werden soll, nachdem der Clienthandle an den Client übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Möglichkeit, eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt wird erstellt, in einem übergeordneten Prozess mit einem <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~AnonymousPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!AnonymousPipeServerStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="anonymousPipeServerStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt nicht verwaltete Ressourcen frei, und führt andere Bereinigungsvorgänge durch, bevor die <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Instanz von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetClientHandleAsString">
      <MemberSignature Language="C#" Value="public string GetClientHandleAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetClientHandleAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.AnonymousPipeServerStream.GetClientHandleAsString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientHandleAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetClientHandleAsString();" />
      <MemberSignature Language="F#" Value="member this.GetClientHandleAsString : unit -&gt; string" Usage="anonymousPipeServerStream.GetClientHandleAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Handle des verbundenen <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekts als Zeichenfolge ab.</summary>
        <returns>Eine Zeichenfolge, die das Handle des verbundenen <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />-Objekts darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle%2A> -Methode aufgerufen werden soll, nachdem ein Clienthandle an einen Clientprozess übergeben wurde. Wenn diese Methode nicht aufgerufen wird, die <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt erhalten keine Benachrichtigung, wenn der Client freigibt, dessen <xref:System.IO.Pipes.PipeStream> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Möglichkeit, eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel ein <xref:System.IO.Pipes.AnonymousPipeServerStream> -Objekt wird erstellt, in einem übergeordneten Prozess mit einem <xref:System.IO.Pipes.PipeDirection> Wert <xref:System.IO.Pipes.PipeDirection.Out>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public override System.IO.Pipes.PipeTransmissionMode ReadMode { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode {  void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ReadMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.AnonymousPipeServerStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Lesemodus für das <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt fest. Für anonyme Pipes muss der Übertragungsmodus <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" /> sein.</summary>
        <value>Der Lesemodus für das <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> im Lesemodus befindet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Möglichkeit, eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel die <xref:System.NotSupportedException> abgefangen, wenn die <xref:System.IO.Pipes.AnonymousPipeServerStream.ReadMode%2A> -Eigenschaftensatz auf <xref:System.IO.Pipes.PipeTransmissionMode.Message>.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Übertragungsmodus ist nicht gültig. Bei anonymen Pipes wird nur <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" /> unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">Die Eigenschaft ist auf <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" /> festgelegt. Dies wird für anonyme Pipes nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">Die Verbindung wurde unterbrochen, oder es ist ein anderer E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Pipe ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public override System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.AnonymousPipeServerStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberSignature Language="F#" Value="member this.TransmissionMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.AnonymousPipeServerStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von der aktuellen Pipe unterstützten Pipeübertragungsmodus ab.</summary>
        <value>Die <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, die von der aktuellen Pipe unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anonyme Pipes unterstützen keine <xref:System.IO.Pipes.PipeTransmissionMode.Message> im Lesemodus befindet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Möglichkeit, eine Zeichenfolge von einem übergeordneten Prozess an einen untergeordneten Prozess zu senden, indem Sie mithilfe von anonymen Pipes. In diesem Beispiel ein <xref:System.IO.Pipes.AnonymousPipeServerStream> Objekt wird in einem übergeordneten Prozess erstellt und die <xref:System.IO.Pipes.AnonymousPipeServerStream.TransmissionMode%2A> Eigenschaft wird in der Konsole angezeigt.  
  
 [!code-cpp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.AnonymousPipeServerStream_Sample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.AnonymousPipeServerStream_Sample/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>