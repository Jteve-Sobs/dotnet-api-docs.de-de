<Type Name="GeoCoordinate" FullName="System.Device.Location.GeoCoordinate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c06b1f703044283a51029efd8efeec2fe8255e5c" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63889029" /></Metadata><TypeSignature Language="C#" Value="public class GeoCoordinate : IEquatable&lt;System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GeoCoordinate extends System.Object implements class System.IEquatable`1&lt;class System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Device.Location.GeoCoordinate" />
  <TypeSignature Language="VB.NET" Value="Public Class GeoCoordinate&#xA;Implements IEquatable(Of GeoCoordinate)" />
  <TypeSignature Language="C++ CLI" Value="public ref class GeoCoordinate : IEquatable&lt;System::Device::Location::GeoCoordinate ^&gt;" />
  <TypeSignature Language="F#" Value="type GeoCoordinate = class&#xA;    interface IEquatable&lt;GeoCoordinate&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Device</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Device.Location.GeoCoordinate&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine durch Breiten- und Längenkoordinaten bestimmte geografische Position dar. Kann auch Informationen zur Höhe, Genauigkeit. Geschwindigkeit und Kurs enthalten.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Device.Location.GeoCoordinate." />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Device.Location.GeoCoordinate" /> ohne festgelegte Datenfelder.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Datenfelder werden festgelegt, um <xref:System.Double.NaN>.  Die neue Instanz der <xref:System.Device.Location.GeoCoordinate> entspricht <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
 Dieser Konstruktor sollte für die Serialisierung verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Die Breitenkoordinate der Position. Der Wert kann zwischen -90,0 und 90,0 liegen.</param>
        <param name="longitude">Die Längenkoordinate der Position. Der Wert kann zwischen –180,0 und 180,0 liegen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Device.Location.GeoCoordinate" />-Klasse aus Breiten- und Längendaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte für Breiten- und Längengrad müssen einem tatsächlichen Speicherort auf der ganzen Welt entsprechen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Breite oder Länge liegt außerhalb des Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Die Breitenkoordinate. Der Wert kann zwischen -90,0 und 90,0 liegen.</param>
        <param name="longitude">Die Längenkoordinate. Der Wert kann zwischen -180,0 und 180,0 liegen.</param>
        <param name="altitude">Die Höhe in Meter. Dieser Wert kann negativ, 0, positiv oder <see cref="F:System.Double.NaN" /> sein, falls nicht bekannt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Device.Location.GeoCoordinate" />-Klasse aus Breiten-, Längen- und Höhendaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte für Breiten- und Längengrad müssen einem tatsächlichen Speicherort auf der ganzen Welt entsprechen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" /> oder <paramref name="altitude" /> liegt außerhalb des Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude, float64 horizontalAccuracy, float64 verticalAccuracy, float64 speed, float64 course) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double, horizontalAccuracy As Double, verticalAccuracy As Double, speed As Double, course As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double * double * double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy, speed, course)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
        <Parameter Name="horizontalAccuracy" Type="System.Double" />
        <Parameter Name="verticalAccuracy" Type="System.Double" />
        <Parameter Name="speed" Type="System.Double" />
        <Parameter Name="course" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Die Breitenkoordinate der Position. Der Wert kann zwischen -90,0 und 90,0 liegen.</param>
        <param name="longitude">Die Längenkoordinate der Position. Der Wert kann zwischen –180,0 und 180,0 liegen.</param>
        <param name="altitude">Die Höhe in Meter. Dieser Wert kann negativ, 0, positiv oder <see cref="F:System.Double.NaN" /> sein, falls nicht bekannt.</param>
        <param name="horizontalAccuracy">Die Genauigkeit der Breiten- und Längenkoordinaten in Meter. Muss mindestens 0 sein. Wenn für diesen Konstruktor der Wert 0 (null) angegeben ist, wird die <see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" />-Eigenschaft auf <see cref="F:System.Double.NaN" /> festgelegt.</param>
        <param name="verticalAccuracy">Die Genauigkeit der Höhe in Meter. Muss mindestens 0 sein. Wenn für diesen Konstruktor der Wert 0 (null) angegeben ist, wird die <see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" />-Eigenschaft auf <see cref="F:System.Double.NaN" /> festgelegt.</param>
        <param name="speed">Die Geschwindigkeit in Meter pro Sekunde. Dieser Wert kann negativ, 0, positiv oder <see cref="F:System.Double.NaN" /> sein, falls nicht bekannt.  Eine negative Geschwindigkeit kann eine Rückwärtsbewegung angeben.</param>
        <param name="course">Die Fahrtrichtung anstelle der Ausrichtung. Dieser Parameter wird in Grad in Bezug auf die echte Nordrichtung gemessen. Muss zwischen 0 und 360,0 liegen oder <see cref="F:System.Double.NaN" /> sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Device.Location.GeoCoordinate" />-Klasse aus Breite, Länge, Höhe, horizontaler Genauigkeit, vertikaler Genauigkeit, Geschwindigkeit und Kurs.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" />, <paramref name="horizontalAccuracy" />, <paramref name="verticalAccuracy," /> oder <paramref name="course" /> liegt außerhalb des Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="Altitude">
      <MemberSignature Language="C#" Value="public double Altitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Altitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Altitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Altitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Altitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Altitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Altitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des <see cref="T:System.Device.Location.GeoCoordinate" />-Objekts in Meter ab.</summary>
        <value>Die Höhe in Meter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Höhe wird relativ zum Sea-Ebene zugewiesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Course">
      <MemberSignature Language="C#" Value="public double Course { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Course" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Course" />
      <MemberSignature Language="VB.NET" Value="Public Property Course As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Course { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Course : double with get, set" Usage="System.Device.Location.GeoCoordinate.Course" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Überschrift in Grad in Bezug auf die echte Nordrichtung ab oder legt diese fest.</summary>
        <value>Die Überschrift in Grad in Bezug auf die echte Nordrichtung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der gültige Bereich enthält die Werte zwischen 0,0 und 360,0 und `Double.NaN` , wenn die Überschrift nicht definiert ist.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Device.Location.GeoCoordinate.Course%2A> und <xref:System.Device.Location.GeoCoordinate.Speed%2A> Eigenschaften der aktuellen Position <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Course" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte einander entsprechen. Grundlage dabei sind ausschließlich Breite und Länge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Device.Location.GeoCoordinate -&gt; bool" Usage="geoCoordinate.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other">Das <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt, das mit dem aufrufenden Objekt verglichen werden soll.</param>
        <summary>Stellt fest, ob das <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt dem Parameter entspricht. Grundlage dabei sind ausschließlich Breite und Länge.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entsprechende <xref:System.Device.Location.GeoCoordinate> Objekte verfügen über denselben <xref:System.Device.Location.GeoCoordinate.Latitude%2A> und <xref:System.Device.Location.GeoCoordinate.Longitude%2A> Eigenschaften. Die <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, und <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> Eigenschaften werden nicht zum Bestimmen der Äquivalenz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="geoCoordinate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, mit dem das <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt verglichen werden soll.</param>
        <summary>Stellt fest, ob eine angegebene <see cref="T:System.Device.Location.GeoCoordinate" /> gleich der aktuellen <see cref="T:System.Device.Location.GeoCoordinate" /> ist. Grundlage dabei sind ausschließlich Breite und Länge.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entsprechende <xref:System.Device.Location.GeoCoordinate> Objekte verfügen über denselben <xref:System.Device.Location.GeoCoordinate.Latitude%2A> und <xref:System.Device.Location.GeoCoordinate.Longitude%2A> Eigenschaften. Die <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, und <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> Eigenschaften werden nicht zum Bestimmen der Äquivalenz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDistanceTo">
      <MemberSignature Language="C#" Value="public double GetDistanceTo (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDistanceTo(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetDistanceTo(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDistanceTo (other As GeoCoordinate) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDistanceTo(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="member this.GetDistanceTo : System.Device.Location.GeoCoordinate -&gt; double" Usage="geoCoordinate.GetDistanceTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other">Das <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt für die Position, für die die Entfernung berechnet werden soll.</param>
        <summary>Gibt die Entfernung zwischen den Breiten- und Längenkoordinaten zurück, die von dieser <see cref="T:System.Device.Location.GeoCoordinate" /> und einer anderen angegebenen <see cref="T:System.Device.Location.GeoCoordinate" /> angegeben werden.</summary>
        <returns>Die Entfernung zwischen den zwei Koordinaten in Meter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Haversine-Formel wird verwendet, um den Abstand zu berechnen.  Die Haversine-Formel Konten für die Krümmung der Erde dar, sondern setzt voraus, eine Ellipsoid, anstatt eine sphärische Erde. Für die lange Strecken führt die Haversine-Formel einen Fehler, der kleiner als 0,1 %.  
  
 Höhe wird nicht verwendet, um die Entfernung zu berechnen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="geoCoordinate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fungiert als eine Hashfunktion für die <see cref="T:System.Device.Location.GeoCoordinate" />-Struktur.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Device.Location.GeoCoordinate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Device.Location.GeoCoordinate> Objekte, die äquivalent sind, haben den gleichen Hashcode. Entsprechende <xref:System.Device.Location.GeoCoordinate> Objekte verfügen über denselben <xref:System.Device.Location.GeoCoordinate.Latitude%2A> und <xref:System.Device.Location.GeoCoordinate.Longitude%2A> Eigenschaften. Die <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, und <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> Eigenschaften werden nicht zum Bestimmen der Äquivalenz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAccuracy">
      <MemberSignature Language="C#" Value="public double HorizontalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Genauigkeit der Breiten- und Längenkoordinaten der <see cref="T:System.Device.Location.GeoCoordinate" /> in Meter ab oder legt diese fest.</summary>
        <value>Die Genauigkeit der Breiten- und Längenkoordinaten in Meter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Genauigkeit kann der Radius der Längen- und Breitengrad Daten angesehen werden.  Einer runden Fläche, die mit der Genauigkeit als RADIUS- und die Breiten-und Längengrad gebildet wird, wie der Mitte den tatsächlichen Speicherort befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Device.Location.GeoCoordinate" /> keine Breiten- oder Längendaten enthält.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Device.Location.GeoCoordinate" /> keine Breiten- oder Längendaten enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Device.Location.GeoCoordinate> enthält, die keine Breite oder Längengrad ist gleich <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Device.Location.GeoCoordinate> , die an einem Speicherort entspricht ist <xref:System.Device.Location.GeoCoordinate.Unknown> vor dem Drucken des breiten-und Längengrad.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Latitude">
      <MemberSignature Language="C#" Value="public double Latitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Latitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Latitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Latitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Latitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Latitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Latitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breitenkoordinate der <see cref="T:System.Device.Location.GeoCoordinate" /> ab oder legt diese fest.</summary>
        <value>Die Breitenkoordinaten der Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Breitengrad kann zwischen-90,0 und 90,0 liegen. Breitengrad wird in Grad nördlich bzw. südlich vom Äquator gemessen. Positive Werte nördlich vom Äquator und negative Werte sind südlich des Äquators.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die Breiten- und Längengrad-Werte, die aus abgerufen werden eine <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Latitude" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="Longitude">
      <MemberSignature Language="C#" Value="public double Longitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Longitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Longitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Longitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Longitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Longitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Longitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Längekoordinate der <see cref="T:System.Device.Location.GeoCoordinate" /> ab oder legt diese fest.</summary>
        <value>Die Längenkoordinaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge kann zwischen-180,0 und 180,0 liegen. Längengrad wird in Grad OST oder westlicher Richtung gemessen wird dem Nullmeridian gemessen. Negative Werte sind westlicher Richtung gemessen wird dem Nullmeridian und östlich vom Nullmeridian positive Werte.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die Breiten- und Längengrad-Werte, die aus abgerufen werden eine <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Longitude" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Equality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte auf die gleiche Position verweisen.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entsprechende <xref:System.Device.Location.GeoCoordinate> Objekte verfügen über denselben <xref:System.Device.Location.GeoCoordinate.Latitude%2A> und <xref:System.Device.Location.GeoCoordinate.Longitude%2A> Eigenschaften. Die <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, und <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> Eigenschaften werden nicht zum Bestimmen der Äquivalenz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Inequality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="System.Device.Location.GeoCoordinate.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte anderen Positionen entsprechen.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Device.Location.GeoCoordinate" />-Objekte unterschiedlich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entsprechende <xref:System.Device.Location.GeoCoordinate> Objekte verfügen über denselben <xref:System.Device.Location.GeoCoordinate.Latitude%2A> und <xref:System.Device.Location.GeoCoordinate.Longitude%2A> Eigenschaften. Die <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, und <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> Eigenschaften werden nicht zum Bestimmen der Äquivalenz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Speed">
      <MemberSignature Language="C#" Value="public double Speed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Speed" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Speed" />
      <MemberSignature Language="VB.NET" Value="Public Property Speed As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Speed { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Speed : double with get, set" Usage="System.Device.Location.GeoCoordinate.Speed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Geschwindigkeit in Meter pro Sekunde ab oder legt sie fest.</summary>
        <value>Die Geschwindigkeit in Meter pro Sekunde. Die Geschwindigkeit muss größer als oder gleich 0 (null) sein, oder <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Device.Location.GeoCoordinate.Course%2A> und <xref:System.Device.Location.GeoCoordinate.Speed%2A> Eigenschaften der aktuellen Position <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Speed" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="geoCoordinate.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die die Breiten- und Längenkoordinaten enthält.</summary>
        <returns>Eine Zeichenfolge, die die Breiten- und Längenkoordinaten enthält (durch Trennzeichen getrennt).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolgendarstellung von dieser Methode zurückgegebene dient nur zum Debuggen verwenden. Diese Methode ist keine gebietsschemaspezifischen Formatierung für Breiten- und Längengrad zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unknown">
      <MemberSignature Language="C#" Value="public static readonly System.Device.Location.GeoCoordinate Unknown;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Device.Location.GeoCoordinate Unknown" />
      <MemberSignature Language="DocId" Value="F:System.Device.Location.GeoCoordinate.Unknown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unknown As GeoCoordinate " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Device::Location::GeoCoordinate ^ Unknown;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unknown : System.Device.Location.GeoCoordinate" Usage="System.Device.Location.GeoCoordinate.Unknown" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Device.Location.GeoCoordinate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt mit unbekannten Breiten- und Längenfeldern dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Device.Location.GeoCoordinate.IsUnknown%2A> Eigenschaft kann verwendet werden, um zu überprüfen, ob eine <xref:System.Device.Location.GeoCoordinate> enthält keine Daten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Device.Location.GeoCoordinate> , die an einem Speicherort entspricht ist <xref:System.Device.Location.GeoCoordinate.Unknown> vor dem Drucken des breiten-und Längengrad.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAccuracy">
      <MemberSignature Language="C#" Value="public double VerticalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Genauigkeit der vom <see cref="T:System.Device.Location.GeoCoordinate" />-Objekt angegebenen Höhenkoordinate in Meter ab oder legt diese fest.</summary>
        <value>Die Genauigkeit der Höhe in Meter.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" /> liegt außerhalb des gültigen Bereichs.</exception>
      </Docs>
    </Member>
  </Members>
</Type>