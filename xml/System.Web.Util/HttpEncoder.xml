<Type Name="HttpEncoder" FullName="System.Web.Util.HttpEncoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d4bac60268ba6ef9b0edfa417efcbd211763d938" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36575150" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpEncoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi HttpEncoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Util.HttpEncoder" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpEncoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpEncoder" />
  <TypeSignature Language="F#" Value="type HttpEncoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Services</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Codierungs- und Decodierungslogik bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Klasse enthält, die Codierung und Decodierung von Logik, die durch Methoden von Klassen, z. B. verwendet wird <xref:System.Web.HttpUtility>, <xref:System.Web.HttpServerUtility>, und <xref:System.Net.HttpResponseHeader>.  
  
 Sie können die erben von der <xref:System.Web.Util.HttpEncoder> Klasse, und überschreiben Sie dessen Verhalten, um die Codierung und Decodierung von ASP.NET Verhalten anpassen. Legen Sie Sie dann die <xref:System.Web.Configuration.HttpRuntimeSection.EncoderType%2A> Eigenschaft von der <xref:System.Web.Configuration.HttpRuntimeSection> Klasse, um die benutzerdefinierte Klasse zu konfigurieren.  
  
 Eine benutzerdefinierte Klasse für Codierung und Decodierung von leitet sich von <xref:System.Web.Util.HttpEncoder> können die integrierten ASP.NET codieren und Decodieren von Verhalten überschreiben oder Änderung nur ausgewählte Aspekte des Zertifikats.  
  
 Sie können den benutzerdefinierten Codierungstyp für in ASP.NET ersetzen oder ergänzen Codierung Folgendes konfigurieren:  
  
-   HTML-Codierung  
  
-   HTML-attributcodierung  
  
-   URL-Codierung  
  
-   URL-Pfad Codierung  
  
-   HTTP-Headernamen und headercodierung Wert  
  
 Standardmäßig werden ASP.NET-Anwendungen Verwendung konfiguriert die <xref:System.Web.Security.AntiXss.AntiXssEncoder> Geben Sie für alle Codierung ausgegeben.  
  
 Im folgenden Beispiel aus auf Anwendungsebene Datei "Web.config" zeigt wie die <xref:System.Web.Security.AntiXss.AntiXssEncoder> Typ für eine ASP.NET-Anwendung festgelegt ist:  
  
 `<httpRuntime requestValidationMode="4.5" encoderType="System.Web.Security.AntiXss.AntiXssEncoder, System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>`  
  
 Die Konfigurationseinstellung im im Beispiel wird die <xref:System.Web.Security.AntiXss.AntiXssEncoder> Klasse alle durchführen Ausgabe Codierung in der Anwendung. Weitere Informationen finden Sie unter der <xref:System.Web.Security.AntiXss.AntiXssEncoder> -Klassenübersicht.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Beim Erstellen einer benutzerdefinierten Encoder-Klasse und die grundlegenden Methoden der Basisklasse überschreiben, kann der abgeleitete Encoder eine Ausnahme von jeder der überschriebenen Methoden ausgelöst. Jedoch in den folgenden Fällen eine Ausnahme auslösen könnte führen zu einem unerwarteten Verhalten in ASP.NET:-Wenn ASP.NET eine Fehlerseite rendern, die durch eine nicht behandelte Ausnahme verursacht wird, die von einem benutzerdefinierten Encoder ausgelöst wurde, ASP.NET wird nicht versucht, seine Fehler o zu codieren. Zeigen durch Aufrufen des benutzerdefinierten Encoders. Dadurch wird vermieden, rekursive fehlerbedingungen.  – Wenn Sie ASP.NET HTTP-Header in IIS sendet, weist ASP.NET keine Funktion für nicht behandelte Ausnahmen. Aus diesem Grund werden die standardmäßige ASP.NET-Seite-Fehler (wenn Konfigurationseinstellungen können auf dieser Seite angezeigt werden) gerendert.</para>
    </block>
    <altmember cref="T:System.Web.HttpUtility" />
    <altmember cref="T:System.Web.HttpServerUtility" />
    <altmember cref="T:System.Web.Configuration.HttpRuntimeSection" />
    <altmember cref="T:System.Web.Security.AntiXss.AntiXssEncoder" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpEncoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.Util.HttpEncoder" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.Util.HttpEncoder Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Util.HttpEncoder Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.Util.HttpEncoder.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Util::HttpEncoder ^ Current { System::Web::Util::HttpEncoder ^ get(); void set(System::Web::Util::HttpEncoder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.Util.HttpEncoder with get, set" Usage="System.Web.Util.HttpEncoder.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.HttpEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Web.Util.HttpEncoder" />-Typ ab, der in einer Anwendung verwendet wird, oder legt ihn fest.</summary>
        <value>Ein Verweis auf den Codierer-Decodierer-Typ, der verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein abgeleiteter <xref:System.Web.Util.HttpEncoder> in der Konfigurationsdatei angegeben wird die <xref:System.Web.Util.HttpEncoder.Current%2A> Eigenschaft einen Verweis auf den benutzerdefinierten Typ zurückgibt. Wenn kein benutzerdefinierter Encoder verwendet wird, gibt die Eigenschaft jedoch einen Verweis auf den Standardwert ASP.NET <xref:System.Web.Util.HttpEncoder> Instanz.  
  
 Die <xref:System.Web.Util.HttpEncoder.Current%2A> Eigenschaft ist nicht threadsicher. Legen Sie diese Eigenschaft nur in der Anwendungsverzeichnis `Application_Start` -Methode, da `Application_Start` in einem einzelnen Thread ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Encoderinstanz, die dieser Eigenschaft zugewiesen wird, ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Web.Util.HttpEncoder Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Util.HttpEncoder Default" />
      <MemberSignature Language="DocId" Value="P:System.Web.Util.HttpEncoder.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As HttpEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Util::HttpEncoder ^ Default { System::Web::Util::HttpEncoder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Web.Util.HttpEncoder" Usage="System.Web.Util.HttpEncoder.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.HttpEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf den Standardcodierer für ASP.NET ab.</summary>
        <value>Ein Verweis auf den Standardcodierer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein häufig auftretendes Problem Codierung ist, die standardmäßig ASP.NET <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> Verhalten konvertiert Leerzeichen in das Zeichen "+". In der Vergangenheit wurde das "+"-Zeichen ein Internetkonvention für die Codierung von Leerzeichen in einer URL in einem besser lesbaren Weise. Gemäß den Standards, wird das Leerzeichen jedoch als "% 20" und instead of codiert werden sollte als das Zeichen "+". ASP.NET können Sie einen Weitere Standards kompatible Codierung Algorithmus implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderNameValueEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HeaderNameValueEncode (string headerName, string headerValue, out string encodedHeaderName, out string encodedHeaderValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HeaderNameValueEncode(string headerName, string headerValue, [out] string&amp; encodedHeaderName, [out] string&amp; encodedHeaderValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HeaderNameValueEncode(System.String,System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HeaderNameValueEncode (headerName As String, headerValue As String, ByRef encodedHeaderName As String, ByRef encodedHeaderValue As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HeaderNameValueEncode(System::String ^ headerName, System::String ^ headerValue, [Runtime::InteropServices::Out] System::String ^ % encodedHeaderName, [Runtime::InteropServices::Out] System::String ^ % encodedHeaderValue);" />
      <MemberSignature Language="F#" Value="abstract member HeaderNameValueEncode : string * string *  *  -&gt; unit&#xA;override this.HeaderNameValueEncode : string * string *  *  -&gt; unit" Usage="httpEncoder.HeaderNameValueEncode (headerName, headerValue, encodedHeaderName, encodedHeaderValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="headerName" Type="System.String" />
        <Parameter Name="headerValue" Type="System.String" />
        <Parameter Name="encodedHeaderName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="encodedHeaderValue" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="headerName">Der Name des zu codierenden HTTP-Headers.</param>
        <param name="headerValue">Der Wert des zu codierenden HTTP-Headers.</param>
        <param name="encodedHeaderName">Enthält nach dem Beenden dieser Methode den codierten Namen, der für einen HTTP-Header verwendet werden soll. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="encodedHeaderValue">Enthält nach dem Beenden dieser Methode den codierten Wert, der für einen HTTP-Header verwendet werden soll. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Codiert einen Headernamen und einen Wert in eine Zeichenfolge, die als HTTP-Header verwendet werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> Methode nimmt Eingabezeichenfolgen aus der `headerName` und `headerValue` Parameter und codiert werden. Die codierte Werte werden als Ausgabeparameter zurückgegeben.  
  
 Die <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> Methode verwendet die folgende Logik, um Namen von Spaltenüberschriften und Werte zu codieren:  
  
-   Alle Zeichen, dessen Unicode-Wert kleiner als ASCII-Zeichen 32, mit Ausnahme von ASCII-Zeichen 9 ist, werden in einem Format der URL-codierte `%NN` , in dem die `N` Zeichen hexadezimale Werte darstellen.  
  
-   ASCII-Zeichen 9 (das horizontale Tabulatorzeichen) ist nicht das URL-codiert.  
  
-   ASCII-Zeichen 127 wird als codiert `%7F`.  
  
-   Alle anderen Zeichen werden nicht codiert.  
  
    > [!NOTE]
    >  Obwohl diese Methode für Unicode-Werten verwendet werden kann, wird es in der Regel für Werte im ASCII-Bereich verwendet.  
  
 Die standardmäßige Implementierung des der <xref:System.Web.Util.HttpEncoder.HeaderNameValueEncode%2A> -Methode gibt den Wert der `headerValue` in `encodedHeaderValue` Wenn `headerValue` ist `null` oder ist eine leere Zeichenfolge. Auf ähnliche Weise die Standardimplementierung gibt den Wert der `headerName` in `encodedHeaderName` Wenn `headerName` ist `null` oder ist eine leere Zeichenfolge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlAttributeEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlAttributeEncode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlAttributeEncode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlAttributeEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlAttributeEncode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlAttributeEncode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member HtmlAttributeEncode : string * System.IO.TextWriter -&gt; unit&#xA;override this.HtmlAttributeEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpEncoder.HtmlAttributeEncode (value, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Die zu codierende Zeichenfolge.</param>
        <param name="output">Der TextWriter, in den der codierte Wert geschrieben werden soll.</param>
        <summary>Codiert einen eingehenden Wert in eine Zeichenfolge, die in ein HTML-Attribut eingefügt werden kann, das durch einfache oder doppelte Anführungszeichen getrennt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A> Methode codiert Zeichen mithilfe der standardmäßigen HTML-Entitäten. Z. B. die `<` (öffnende spitze Klammer) wird als codiert `&lt;` und `\` (umgekehrter Schrägstrich) wird als codiert `&#92;`.  
  
 Es ist sicherer, verwenden Sie <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A> in einfachen Anführungszeichen und doppelten Anführungszeichen Attribute. Die Werte müssen in Anführungszeichen gesetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="output" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlDecode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlDecode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlDecode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlDecode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member HtmlDecode : string * System.IO.TextWriter -&gt; unit&#xA;override this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpEncoder.HtmlDecode (value, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Die zu decodierende Zeichenfolge.</param>
        <param name="output">Der TextWriter, in den der decodierte Wert geschrieben werden soll.</param>
        <summary>Hebt die Codierung eines Werts von einer HTML-codierten Zeichenfolge auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Zeichenfolgen, die die Decodierung ASP.NET-Logik decodiert werden kann.  
  
|Zeichenfolge|Regel|  
|------------------------|----------|  
|`&#NNN;` (decimal Codes für ASCII-Zeichen).|Decodiert als das angegebene ASCII-Zeichen. Die Zeichensequenz an die erste Ziffer nach dem Nummernzeichen (#) beginnt und endet mit dem Semikolon.|  
|`&#xZZ;` (hexadezimal Codes für ASCII-Zeichen).|Decodiert als das angegebene ASCII-Zeichen. Die codierte Binärdaten gibt das Zeichen mithilfe von hexadezimalen Zeichen anstelle eines decimal-Werts. Die Zeichensequenz an die erste Ziffer nach dem Nummernzeichen (#) beginnt und endet mit dem Semikolon.|  
|Benannte HTML-Entitäten.|Decodiert als das entsprechende ASCII-Zeichen.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="output" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="protected internal virtual void HtmlEncode (string value, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void HtmlEncode(string value, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub HtmlEncode (value As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void HtmlEncode(System::String ^ value, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member HtmlEncode : string * System.IO.TextWriter -&gt; unit&#xA;override this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpEncoder.HtmlEncode (value, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="value">Die zu codierende Zeichenfolge.</param>
        <param name="output">Der TextWriter, in den der codierte Wert geschrieben werden soll.</param>
        <summary>Codiert eine Zeichenfolge in eine HTML-codierte Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Zeichenfolgen, die die Codierung ASP.NET-Logik decodiert werden kann.  
  
|Zeichen|Codiert als|  
|---------------|----------------|  
|`<` (die öffnende spitze Klammer)|`&lt;`|  
|`>` (schließende spitze Klammer)|`&gt;`|  
|`"` (doppelte Anführungszeichen)|`&quot;`|  
|`&` (kaufmännisches und-Zeichen)|`&amp;`|  
|`\` (umgekehrter Schrägstrich)|`&#92;`|  
|ASCII-Zeichen von 160 bis 255|`&#NNN;`, wobei `NNN` den dreistelligen dezimaler Zeichencode ist|  
  
 Wenn Sie überschreiben die <xref:System.Web.Util.HttpEncoder.HtmlEncode%2A> -Methode, Sie müssen Ausgabe erstellt, die auch in doppelten Anführungszeichen oder einfachen Anführungszeichen HTML-Attribute sicher ist. Dies zutrifft, Analyse, indem das Razor-Modul, in dem Markup und Code werden, z. B. kombiniert können \<Attr tag = "@value" >. Darüber hinaus die @-Operator ist nicht kontextabhängige Wenn vom Razor-Modul verarbeitet wird, daher ruft er <xref:System.Web.Util.HttpEncoder.HtmlEncode%2A> statt <xref:System.Web.Util.HttpEncoder.HtmlAttributeEncode%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="output" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="JavaScriptStringEncode">
      <MemberSignature Language="C#" Value="protected internal virtual string JavaScriptStringEncode (string value);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string JavaScriptStringEncode(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.JavaScriptStringEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function JavaScriptStringEncode (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ JavaScriptStringEncode(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member JavaScriptStringEncode : string -&gt; string&#xA;override this.JavaScriptStringEncode : string -&gt; string" Usage="httpEncoder.JavaScriptStringEncode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu codierende Zeichenfolge.</param>
        <summary>Codiert eine Zeichenfolge.</summary>
        <returns>Eine codierte Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL-Codierung wird sichergestellt, dass es sich bei allen Browsern Text in URL-Zeichenfolgen ordnungsgemäß übermitteln. Zeichen, z. B. ein Fragezeichen (?), kaufmännisches und-Zeichen (&), Schrägstrich (/) und Leerzeichen möglicherweise abgeschnitten, oder von einigen Browsern beschädigt werden. Daher müssen diese Zeichen codiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="protected internal virtual byte[] UrlEncode (byte[] bytes, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance unsigned int8[] UrlEncode(unsigned int8[] bytes, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.UrlEncode(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function UrlEncode (bytes As Byte(), offset As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ UrlEncode(cli::array &lt;System::Byte&gt; ^ bytes, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member UrlEncode : byte[] * int * int -&gt; byte[]&#xA;override this.UrlEncode : byte[] * int * int -&gt; byte[]" Usage="httpEncoder.UrlEncode (bytes, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Array von zu codierenden Bytes.</param>
        <param name="offset">Die Position im <c>Bytearray</c>, an der die Codierung begonnen werden soll.</param>
        <param name="count">Die zu codierende Anzahl der Elemente im <c>Bytearray</c>.</param>
        <summary>Codiert ein Array von Zeichen, die in einer URL nicht zulässig sind, in eine hexadezimale Zeichenentitätsentsprechung.</summary>
        <returns>Ein Array von codierten Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> Methode wird aufgerufen, indem Sie mehrere URL-Codierungsmethoden in der <xref:System.Web.HttpUtility> Klasse.  
  
 Die <xref:System.Web.Util.HttpEncoder.UrlEncode%2A> Methode, die einem beliebigen Zeichen, die nicht in den Satz von ASCII-Zeichen, gilt als URL-sichere URL-Codierung. Leerzeichen werden als ASCII codiert "`+"` Zeichen. URL-sichere ASCII-Zeichen enthalten, die ASCII-Zeichen (A bis Z und ein bis Z), Ziffern (0 bis 9) und einige Satzzeichen. Die folgende Tabelle enthält die Satzzeichen, die als URL-sichere ASCII-Zeichen betrachtet werden.  
  
|Zeichen|Beschreibung |  
|---------------|-----------------|  
|-|Bindestrich|  
|_|Unterstrich|  
|sein.|Zeitraum (Punkt)|  
|!|Ausrufezeichen|  
|*|Sternchen)|  
|(|Öffnende Klammer|  
|)|Schließende Klammer|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0 (null) oder größer als die Länge des <paramref name="bytes" />-Arrays.  Oder:  <paramref name="count" /> ist kleiner als 0 (null) oder <paramref name="count" /> plus <paramref name="offset" /> ist größer als die Länge des <paramref name="bytes" />-Arrays.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="protected internal virtual string UrlPathEncode (string value);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string UrlPathEncode(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Util.HttpEncoder.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function UrlPathEncode (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ UrlPathEncode(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member UrlPathEncode : string -&gt; string&#xA;override this.UrlPathEncode : string -&gt; string" Usage="httpEncoder.UrlPathEncode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Services</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu codierende Zeichenfolge.</param>
        <summary>Codiert einen Unterabschnitt einer URL.</summary>
        <returns>Eine URL-codierte Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Util.HttpEncoder.UrlPathEncode%2A>-Methode wird von der <xref:System.Web.HttpUtility.UrlPathEncode%2A>-Methode aufgerufen. Die <xref:System.Web.HttpUtility.UrlPathEncode%2A> Methode führt die folgenden Schritte aus:  
  
-   Wendet die Codierung Logik von der <xref:System.Web.Util.HttpEncoder.UrlPathEncode%2A> Methode, um nur die pfadanteil der URL (welche die Abfragezeichenfolge ausschließt). Die Methode wird davon ausgegangen, dass die URL als UTF-8-Zeichenfolge codiert ist.  
  
-   Codiert nicht-Leerzeichen, sodass nur eine Teilmenge der ersten 128 ASCII-Zeichen in der resultierenden codierten Zeichenfolge verwendet wird. Alle Zeichen zu Unicode-Wert 128 und höher, oder 32 und weniger sind URL-codiert.  
  
-   Leerzeichen werden als %20 codiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>