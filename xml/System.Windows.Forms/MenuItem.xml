<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="afe244ae78c567f03f80f85d4f1fecb35108497e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37567294" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein einzelnes Element dar, das in einem <see cref="T:System.Windows.Forms.MainMenu" /> oder einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird. Obwohl <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> das <see cref="T:System.Windows.Forms.MenuItem" />-Steuerelement vorheriger Versionen ersetzt und funktionell erweitert, wird das <see cref="T:System.Windows.Forms.MenuItem" />-Steuerelement sowohl aus Gründen der Abwärtskompatibilität als auch, falls gewünscht, für die zukünftige Verwendung beibehalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Reihenfolge für eine <xref:System.Windows.Forms.MenuItem> um angezeigt zu werden, müssen Sie sie zum Hinzufügen einer <xref:System.Windows.Forms.MainMenu> oder <xref:System.Windows.Forms.ContextMenu>. Sie können zum Erstellen von Untermenüs hinzufügen <xref:System.Windows.Forms.MenuItem> Objekte die <xref:System.Windows.Forms.Menu.MenuItems%2A> Eigenschaft des übergeordneten Elements <xref:System.Windows.Forms.MenuItem>.  
  
 Die <xref:System.Windows.Forms.MenuItem> Klasse enthält Eigenschaften, mit denen Sie die Darstellung und Funktionalität eines Menüelements konfigurieren können. Um ein Häkchen neben einem Menüelement anzuzeigen, verwenden Sie die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft. Sie können diese Funktion verwenden, um ein Menüelement zu identifizieren, die in einer Liste von sich gegenseitig ausschließende Menüelemente ausgewählt ist. Für, wenn Sie z. B. einen Satz von Menüelementen zum Festlegen der Farbe des Texts in einem <xref:System.Windows.Forms.TextBox> -Steuerelement, können Sie die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft identifizieren, die zurzeit ausgewählte Farbe. Die <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Eigenschaft kann verwendet werden, um eine Tastenkombination zu definieren, die auf das Menüelement gedrückt werden kann.  
  
 Für <xref:System.Windows.Forms.MenuItem> Objekte in einer Anwendung (MDI, Multiple Document Interface) angezeigt werden, können Sie die <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode, um die Menüs von MDI-Formulars merge Elements mit denen der untergeordneten Formulare um eine konsolidierte Menüstruktur zu erstellen. Da eine <xref:System.Windows.Forms.MenuItem> kann nicht wiederverwendet werden an mehreren Standorten gleichzeitig, wie z. B. einer <xref:System.Windows.Forms.MainMenu> und ein <xref:System.Windows.Forms.ContextMenu>, können Sie die <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> Methode, um eine Kopie erstellen eine <xref:System.Windows.Forms.MenuItem> für die Verwendung in einem anderen Speicherort.  
  
 Die <xref:System.Windows.Forms.MenuItem.Popup> Ereignis können Sie Aufgaben ausführen, bevor ein Menü angezeigt wird. Beispielsweise können Sie einen Ereignishandler für dieses Ereignis zum Anzeigen oder Ausblenden von Menüelementen, die basierend auf den Zustand Ihres Codes erstellen. Die <xref:System.Windows.Forms.MenuItem.Select> Ereignis können Sie Aufgaben wie das detaillierte Hilfe für Menüelemente Ihrer Anwendung bereitstellen, wenn der Benutzer den Mauszeiger auf ein Menüelement platziert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit eine Menüstruktur für ein Formular erstellt. Fügt der Beispielcode eine <xref:System.Windows.Forms.MenuItem> zur Darstellung der Menüelement der obersten Ebene, ein Untermenüelement hinzufügt, zum Auswählen einer Größe von Schriftart und fügt dann zwei Untermenüelemente auf dieses Menüelement, das kleinen und großen Schriftart-Optionen in einer Anwendung darstellen. Das Beispiel erfordert, dass es ist ein <xref:System.Windows.Forms.MainMenu> Objekt mit dem Namen `mainMenu1` und vier <xref:System.Windows.Forms.MenuItem> Objekte, die mit dem Namen `menuItem1`, `menuItem2`, `menuItem3`, und `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert ein <see cref="T:System.Windows.Forms.MenuItem" /> mit leerer Beschriftung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Erstellen eines leeres <xref:System.Windows.Forms.MenuItem> diesen Konstruktor verwenden, können Sie die Eigenschaften und Methoden von der <xref:System.Windows.Forms.MenuItem> Klasse, um das Aussehen und Verhalten der anzugeben Ihre <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> mit dieser Version des Konstruktors.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung angeben, für das Menüelement mit der `text` Parameter, Sie können auch angeben ein Zugriffsschlüssels durch eine '&'-Zeichen vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit.  
  
 Festlegen der `text` Parameter, um "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> , die die Beschriftung des Menüelements angibt, die zum Zeitpunkt der es erstellt wird.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Ereignishandler für das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis des Menüelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung angeben, für das Menüelement mit der `text` Parameter, Sie können auch angeben ein Zugriffsschlüssels Platzieren einer '&' vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit.  
  
 Festlegen der `text` Parameter, um "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
 Darüber hinaus können Sie mithilfe dieses Konstruktors einen Delegaten angeben, die behandelt die <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das Menüelement, das erstellt wird. Die <xref:System.EventHandler> , dass Sie für diesen Konstruktor übergeben, müssen für einen Ereignishandler aufrufen, die verarbeiten kann konfiguriert werden die <xref:System.Windows.Forms.MenuItem.Click> Ereignis. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> Objekt mit einer angegebenen Beschriftung und ein <xref:System.EventHandler> Delegaten verbunden mit einem Ereignishandler, die behandelt die <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das Menüelement.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Array von Untermenüelementen, die für das Menüelement definiert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung angeben, für das Menüelement mit der `text` Parameter, Sie können auch angeben ein Zugriffsschlüssels Platzieren einer '&' vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit.  
  
 Festlegen der `text` Parameter, um "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
 Die `items` Parameter können Sie ein Array von Menüelementen zum Definieren eines Untermenüs für dieses Menüelement zuweisen. Jedes Element im Array kann auch ein Array mit Menüelementen, die zugewiesen haben. Dadurch können Sie vollständige Menüstrukturen erstellen, und weisen sie an den Konstruktor für das Menüelement.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Objekt mit einer angegebenen Beschriftung, ein Ereignishandler verbunden, die an eine Methode, die das Ereignis behandelt jedes Menüelement in einem Array von Untermenüelementen.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung, einem Ereignishandler und einer zugeordneten Tastenkombination für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung angeben, für das Menüelement mit der `text` Parameter, Sie können auch angeben ein Zugriffsschlüssels Platzieren einer '&' vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit. Dieser Konstruktor ermöglicht auch Ihnen die Angabe eine Tastenkombination neben einen Zugriffsschlüssel für die Navigation per Tastatur zu bieten. Tastenkombinationen können Sie eine Kombination aus Schlüssel angeben, die verwendet werden kann, um das Menüelement zu aktivieren.  
  
 Festlegen der `text` Parameter, um "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
 Darüber hinaus können Sie mithilfe dieses Konstruktors einen Delegaten angeben, die behandelt die <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das Menüelement, das erstellt wird. Die <xref:System.EventHandler> , dass Sie für diesen Konstruktor übergeben, müssen für einen Ereignishandler aufrufen, die verarbeiten kann konfiguriert werden die <xref:System.Windows.Forms.MenuItem.Click> Ereignis. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Objekt mit einer angegebenen Beschriftung, Tastatur und einen Ereignishandler verbunden, die an eine Methode, die das Ereignis für das Menüelement behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Einer der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</param>
        <param name="mergeOrder">Die relative Position, die dieses Menüelement in einem zusammengeführten Menü einnimmt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onPopup">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onSelect">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung, definierten Ereignishandlern für die Ereignisse <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> und <see cref="E:System.Windows.Forms.MenuItem.Popup" />, einer Tastenkombination, einem Zusammenführungstyp und einer Zusammenführungsfolge, die für das Menüelement angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung angeben, für das Menüelement mit der `text` Parameter, Sie können auch angeben ein Zugriffsschlüssels Platzieren einer '&' vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit.  
  
 Festlegen der `text` Parameter, um "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
 Die `items` Parameter können Sie ein Array von Menüelementen zum Definieren eines Untermenüs für dieses Menüelement zuweisen. Jedes Element im Array kann auch ein Array mit Menüelementen, die zugewiesen haben. Dadurch können Sie vollständige Menüstrukturen erstellen, und weisen sie an den Konstruktor für das Menüelement.  
  
 Die `mergeType` und `mergeOrder` Parametern können Sie bestimmen, wie dieses Menüelement verhält, wenn das Menüelement mit einem anderen Menü zusammengeführt wird. Abhängig vom Wert für die Angabe der `mergeType` Parameter, Sie können entweder hinzufügen, entfernen, ersetzen oder Zusammenführen von das Menüelement und seine Untermenüelemente an, mit dem Menü aus, die mit der sie zusammengeführt werden. Die `mergeOrder` Parameter bestimmt, in dem Menüelement, das erstellt wird, wenn Sie im Menü zusammengeführt wird positioniert wird.  
  
 Darüber hinaus können Sie diesen Konstruktor verwenden, zum Erstellen einer <xref:System.Windows.Forms.MenuItem> und Verbindung mit einem Ereignishandler im Code, die das Klicken auf das Menüelement verarbeitet wird. Die <xref:System.EventHandler> sollte, dass Sie an diesen Konstruktor übergeben, um einen Ereignishandler aufrufen, die verarbeiten kann konfiguriert werden die <xref:System.Windows.Forms.MenuItem.Click> Ereignis. Sie können auch verbinden, verwenden Sie diese Version des Konstruktors, der <xref:System.Windows.Forms.MenuItem.Popup> und <xref:System.Windows.Forms.MenuItem.Select> Ereignisse, um zu bestimmen, wenn dieses Menüelement ausgewählt ist. Diese Ereignisse können für Aufgaben wie z. B., der angibt, ob ein Häkchen neben Untermenüelemente anzuzeigen, zu aktivieren oder Deaktivieren von Menüelementen, die abhängig vom Status der Anwendung. Die <xref:System.Windows.Forms.MenuItem.Select> und <xref:System.Windows.Forms.MenuItem.Click> Ereignisse ausgelöst werden, nur für <xref:System.Windows.Forms.MenuItem> Objekte, die keine übergeordneten Elemente. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Menüelement, das einen Beschriftung und die Tastenkombination Schlüssel aufweist. Das Menüelement verfügt auch über die Ereignishandler definiert, die für die <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, und <xref:System.Windows.Forms.MenuItem.Select> Ereignisse. Wenn dieses Menüelement zusammengeführt wird, wird es dem Menüelement, das das Menü mit der Merge-Ordnung 0 (null) hinzugefügt werden.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Untermenüelement oder Menüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.BarBreak%2A> Eigenschaft, um ein Menü zu erstellen, in dem jedes Menüelement horizontal nebeneinander statt in einer vertikalen Liste platziert wird. Sie können diese Eigenschaft auch verwenden, eine Menüleiste zu erstellen, die mehrere Zeilen mit Menüelemente der obersten Ebene enthält.  
  
 Diese Eigenschaft unterscheidet sich von der <xref:System.Windows.Forms.MenuItem.Break%2A> Eigenschaft im, dass eine Leiste am linken Rand der einzelnen Menüelemente angezeigt wird, das ist die <xref:System.Windows.Forms.MenuItem.Break%2A> -Eigenschaftensatz auf `true`. Die Leiste wird nur angezeigt, wenn das Menüelement nicht auf ein Menüelement der obersten Ebene ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> mit zwei Untermenüelemente. Die zwei Untermenüelemente werden horizontal angezeigt, statt zu vertikal verwenden die <xref:System.Windows.Forms.MenuItem.BarBreak%2A> Eigenschaft.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Element in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Menüelement oder Untermenüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.Break%2A> Eigenschaft, um ein Menü zu erstellen, in dem jedes Menü horizontal nebeneinander statt in einer vertikalen Liste platziert wird. Sie können diese Eigenschaft auch verwenden, eine Menüleiste zu erstellen, die mehrere Zeilen mit Menüelemente der obersten Ebene enthält.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Menü mit zwei Menüelemente der obersten Ebene auf die oberste Zeile und ein Menüelement in der unteren Zeile.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob neben dem Text des Menüelements ein Häkchen angezeigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement mit einem Häkchen versehen ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft in Kombination mit anderen Menüelemente in einem Menü Zustand für eine Anwendung bereitgestellt. Beispielsweise können Sie ein Häkchen auf ein Menüelement in einer Gruppe von Elementen, identifizieren Sie die Größe der Schriftart für den Text in einer Anwendung angezeigt werden soll platzieren. Sie können auch die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft, um das ausgewählte Menüelement in einer Gruppe von sich gegenseitig ausschließende Menüelemente zu identifizieren.  
  
> [!NOTE]
>  Diese Eigenschaft kann nicht festgelegt werden, um `true` für Menüelemente der obersten Ebene.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft, um den Status in einer Anwendung bereitzustellen. In diesem Beispiel wird eine Gruppe von Menüelementen an die Farbe für den Text in einem <xref:System.Windows.Forms.TextBox> Steuerelement. Der bereitgestellte Ereignishandler wird verwendet, durch die <xref:System.Windows.Forms.MenuItem.Click> Ereignis der drei Menüelemente. Jedes Menüelement gibt eine Textfarbe `menuItemRed` (Rot), `menuItemGreen` (Grün), oder `menuItemBlue` (Blau). Der Ereignishandler bestimmt, welches Menüelement geklickt wurde, wird ein Häkchen, um das ausgewählte Menüelement und ändert die Textfarbe des Formulars <xref:System.Windows.Forms.TextBox> Steuerelement. Im Beispiel erfordert, dass die <xref:System.Drawing> Namespace wurde in das Formular, das in diesem Code eingefügt wird. Im Beispiel erfordert außerdem, dass eine <xref:System.Windows.Forms.TextBox> wurde hinzugefügt, die in diesem Beispielcode sich in befindet Form mit dem Namen `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <see cref="T:System.Windows.Forms.MenuItem" /> ist ein Menü der obersten Ebene oder verfügt über untergeordnete Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn auf das Menüelement geklickt wird oder wenn es unter Verwendung einer für das Menüelement definierten Tastenkombination oder Zugriffstaste ausgewählt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.MenuItem.Click> Ereignis tritt auf, wenn dies <xref:System.Windows.Forms.MenuItem> wird der Benutzer geklickt hat. Außerdem wird dieses Ereignis tritt auf, wenn der Benutzer das Menüelement mithilfe der Tastatur auswählt und drückt die EINGABETASTE. Es kann auch auftreten, wenn eine Zugriffstaste oder Tastenkombination gedrückt wird, zugeordnet ist die <xref:System.Windows.Forms.MenuItem>. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Menu.MenuItems%2A> -Eigenschaft für die <xref:System.Windows.Forms.MenuItem> Elemente enthält, dieses Ereignis wird nicht ausgelöst. Dieses Ereignis wird nicht für Elemente des übergeordneten Menüs ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Click> Ereignis auszuführenden Vorgänge fest, wenn eine <xref:System.Windows.Forms.MenuItem> geklickt wird. Das Beispiel erstellt eine <xref:System.Windows.Forms.MainMenu> namens `mainMenu1` und fügt zwei <xref:System.Windows.Forms.MenuItem> Objekte `topMenuItem` (`File`) und `menuItem1` (`Open`). Es verbindet dann die `Click` Ereignis, um die `menuItem1_Click` -Ereignishandler. Klickt der Benutzer die `Open` Menüelement eine <xref:System.Windows.Forms.OpenFileDialog> initialisiert und angezeigt. Das Beispiel muss nach der Erstellung einer <xref:System.Windows.Forms.Form> mit dem Namen `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Kopie einer <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das duplizierte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> Objekte können nicht in mehr als einem Ort verwendet werden, es sei denn, Sie eine Kopie erhalten der <xref:System.Windows.Forms.MenuItem>. Sie können diese Methode, um eine Kopie dieses Menüelement, für die Verwendung im Aufrufen einer <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, oder andere <xref:System.Windows.Forms.MenuItem> innerhalb Ihrer Anwendung. Wenn ein Menüelement geklont wird, werden angegeben, in das ursprüngliche Menüelement Ereignishandler weiterhin in die geklonte Version des Menüelements. Angenommen, Sie erstellt haben eine <xref:System.Windows.Forms.MenuItem> und verbundene seine <xref:System.Windows.Forms.MenuItem.Click> Ereignis an einen Ereignishandler. Wenn das Menüelement geklont wird, wird das duplizierte Menü-Element den gleichen Ereignishandler aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel Klonen eine <xref:System.Windows.Forms.MenuItem> und zeigt ihn in eine <xref:System.Windows.Forms.ContextMenu>. Im Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> vorhanden ist, eine <xref:System.Windows.Forms.MainMenu> in einem Formular durch den Namen des `menuItem1` und eine <xref:System.Windows.Forms.ContextMenu> Objekt mit dem Namen `contextMenu1` auch auf dem Formular vorhanden ist.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Das <see cref="T:System.Windows.Forms.MenuItem" />, das das zu kopierende Menüelement darstellt.</param>
        <summary>Erstellt eine Kopie des angegebenen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, um Kopien von Menüelementen zu erstellen, die Sie bereits für die Verwendung in einem Kontextmenü oder eine andere Menüstruktur innerhalb Ihrer Anwendung erstellt haben. Diese Version von <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> ermöglicht Ihnen die Angabe einen bestimmten <xref:System.Windows.Forms.MenuItem> statt dem Menüelement, das kopiert werden soll, die die Methode aufruft. Sie können diese Methode verwenden, Initialisieren eines neuen <xref:System.Windows.Forms.MenuItem> Objekt mit einer Kopie eines anderen <xref:System.Windows.Forms.MenuItem>. Wenn ein Menüelement geklont wird, werden angegeben, in das ursprüngliche Menüelement Ereignishandler weiterhin in die geklonte Version des Menüelements. Angenommen, Sie erstellt haben eine <xref:System.Windows.Forms.MenuItem> und verbundene seine <xref:System.Windows.Forms.MenuItem.Click> Ereignis an einen Ereignishandler. Wenn das Menüelement geklont wird, wird das duplizierte Menü-Element den gleichen Ereignishandler aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initialisiert eine neue <xref:System.Windows.Forms.MenuItem> mit einer Kopie eines vorhandenen <xref:System.Windows.Forms.MenuItem> , werden in einem <xref:System.Windows.Forms.MainMenu> in einem Formular. Der Code fügt dann das geklonte <xref:System.Windows.Forms.MenuItem> zu einem <xref:System.Windows.Forms.ContextMenu> auf dem Formular. In diesem Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> ist bereits erstellt und mit dem Namen `menuItem1` und eine <xref:System.Windows.Forms.ContextMenu> Steuerelement erstellt wurde und mit dem Namen `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement das Standardmenüelement ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement das Standardelement in einem Menü ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardmenüelement für ein Menü wird fettgedruckt. Wenn der Benutzer über ein Untermenü doppelklickt, enthält ein Standardelement, das Standardelement ausgewählt ist und das Untermenü geschlossen wird. Sie können die <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> Eigenschaft an, um die Standardaktion, die in einem Menü oder im Kontextmenü erwartet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Menüelement mit zwei Untermenüelemente an. Im Beispiel wird `menuItem2` als das standardmäßige Menüelement, indem die <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> Eigenschaft.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, wenn Sie <xref:System.Windows.Forms.MenuItem> nicht mehr benötigen. Die <xref:System.Windows.Forms.MenuItem.Dispose%2A>-Methode bewirkt, dass <xref:System.Windows.Forms.MenuItem> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Windows.Forms.MenuItem.Dispose%2A>, Sie müssen alle Verweise auf Freigeben der <xref:System.Windows.Forms.MenuItem> , damit der belegte Speicher durch die Garbagecollection wieder zugänglich gemacht werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, bevor Sie den letzten Verweis auf das <xref:System.Windows.Forms.MenuItem> freigeben. Andernfalls die Ressourcen der <xref:System.Windows.Forms.MenuItem> ist mit reserviert, bis der Garbage Collection-Aufrufe der <xref:System.Windows.Forms.MenuItem> Destruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />-Eigenschaft eines Menüelements auf <see langword="true" /> festgelegt ist und das Zeichnen des Menüelements angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.DrawItemEventArgs> Argument übergeben wird, um eine <xref:System.Windows.Forms.MenuItem.DrawItem> -Ereignishandler stellt eine <xref:System.Drawing.Graphics> -Objekt, das Ihnen ermöglicht, die Zeichnung und andere grafische Vorgänge auf der Oberfläche des Menüelements ausgeführt. Sie können diesen Ereignishandler verwenden, benutzerdefinierte Menüs erstellen, die Anforderungen Ihrer Anwendung zu erfüllen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie behandelt die <xref:System.Windows.Forms.MenuItem.DrawItem> Ereignis. In diesem Beispiel zeichnet ein Menü mit einer <xref:System.Drawing.Brush> und <xref:System.Drawing.Font>, und zeichnet dann eine <xref:System.Drawing.Rectangle> rund um das Menüelement. Die Zeichnung erfolgt über die <xref:System.Drawing.Graphics> -Objekt, das an den Ereignishandler in der <xref:System.Windows.Forms.DrawItemEventArgs> Parameter. Dieses Beispiel erfordert, dass Sie initialisiert haben die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> -Eigenschaft für das Element, das `true`. Für das C#-Beispiel, fügen Sie den folgenden Code im Konstruktor des Formulars, nach `InitializeComponent`, um das Ereignis zu verknüpfen:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement aktiviert ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.MenuItem> , deaktiviert wird in eine graue Farbe an seinem Zustand angezeigt. Wenn eine übergeordnete Menüelement deaktiviert ist, werden alle Untermenüelemente nicht angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Popup> Ereignis, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die bieten Unterstützung für Ausschneide-, Kopier- und Löschvorgänge aktiviert sind, bevor sie, im angezeigt werden Menü angezeigt wird. Im Beispiel wird bestimmt, ob `textBox1`, <xref:System.Windows.Forms.TextBox> steuern, auf dem Formular, aktiviert ist, hat den Eingabefokus, und vor dem Aktivieren der ausgewählten Text der <xref:System.Windows.Forms.MenuItem> Objekte. Dieses Beispiel erfordert, dass drei <xref:System.Windows.Forms.MenuItem> benannte Objekte werden erstellt, `menuCut`, `menuCopy`, und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Position des Menüelements im übergeordneten Menü angibt, oder legt diesen fest.</summary>
        <value>Der nullbasierte Index, der die Position des Menüelements im übergeordneten Menü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die indizierte Position eines Menüelements in der menüelementauflistung des übergeordneten Menü bereit. Sie können diese Eigenschaft verwenden, um ein Menüelement an einen anderen Speicherort in diesem Menü zu verschieben. Sie können diese Eigenschaft auch verwenden, beim Erstellen einer <xref:System.Windows.Forms.MenuItem> dessen Position in einer Menüstruktur zum Zeitpunkt der Erstellung angeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird, wechselt die Position von zwei Menüelemente in einem Menü. Im folgenden Codebeispiel erfordert, dass zwei <xref:System.Windows.Forms.MenuItem> benannte Objekte werden erstellt, `menuItem1` und `menuItem2`. Die `menuItem1` Menüelement wird in das Menü, eine Position nach unten verschoben. zwar `menuItem2` eine Position nach oben.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der zugewiesene Wert ist kleiner als 0 (null) oder größer als die Elementanzahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement untergeordnete Menüelemente enthält.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement untergeordnete Menüelemente enthält. <see langword="false" />, wenn das Menü ein eigenständiges Menüelement ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft mit der <xref:System.Windows.Forms.MenuItem.Parent%2A> Eigenschaft zum Navigieren in Code über eine gesamte Menüstruktur.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, ob alle Untermenüs zugeordnet sind eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`. Wenn alle Untermenüs vorhanden sind, deaktiviert er sie durch Festlegen der <xref:System.Windows.Forms.MenuItem.Enabled%2A> Eigenschaft `false`. Das Beispiel erfordert, dass es ist ein <xref:System.Windows.Forms.MenuItem> erstellt haben `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement mit einer Liste der untergeordneten MDI-Fenster (Multiple Document Interface) aufgefüllt wird, die im zugeordneten Formular angezeigt werden, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn eine Liste untergeordneter MDI-Fenster in diesem Menüelement angezeigt wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Menüelement ausgewählt ist, eine untergeordnetes MDI-Fensterliste angezeigt wird, wird die Liste als Untermenü des Menüelements angezeigt. Nur Formulare, die als untergeordnete MDI-Formulare definiert sind, werden in der Fensterliste im angezeigt. Nur neun untergeordnete Fenster können zu einem Zeitpunkt angezeigt werden. Wenn es mehr als neun untergeordnete Fenster angezeigt sind, wird ein Menüelement "Weitere Windows..." am Ende der Liste des Fensters angezeigt. Klicken Sie auf dieses Menüelement zeigt ein Dialogfeld mit einer vollständigen Liste der untergeordneten Fenster, die derzeit aktiv sind.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> , wird verwendet, um die Liste der aktuell geöffneten untergeordneten MDI-Formularen in einem MDI-Formular anzuzeigen.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dem Menü die Größe eines Menüelements bekannt sein muss, bevor dieses gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit dieses Ereignis ausgelöst werden können, benötigen Sie die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> des Menüelements-eigenschaftseinstellung `true`. Dieses Ereignis wird ausgelöst, bevor ownerdrawn-Menüs gezeichnet werden, um die Größe des Menüelements gezeichnet werden soll, um angegeben werden. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Da die  Klasse erbt von , Sie können diese Eigenschaft auch verwenden, wenn die  eines Formulars zugeordnet ist. Im Beispiel meldet sich ein Ereignishandler für das Vorhandensein der <xref:System.Windows.Forms.MenuItem.MeasureItem> Ereignis. In diesem Bericht können Sie entnehmen, wann das Ereignis tritt auf, können Sie beim Debuggen unterstützen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt, eine Instanz des Typs enthält <xref:System.Windows.Forms.MenuItem> mit dem Namen `MenuItem1`. Stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.MenuItem.MeasureItem> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Windows-Bezeichner für dieses Menüelement angibt.</summary>
        <value>Der Windows-Bezeichner für dieses Menüelement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen und gibt das sich ergebende zusammengeführte <see cref="T:System.Windows.Forms.MenuItem" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das zusammengeführte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Version von <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, <xref:System.Windows.Forms.MenuItem> zurückgegeben, die eine Kopie des aktuellen Menüelements, die zusammengeführt werden, kann mit einem anderen Menüelement ohne Auswirkungen auf die Funktionalität des aktuellen Elements ist. Diese Version von der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode ist vergleichbar mit einem Aufruf der <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> -Methode, die keine Parameter enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das mit diesem Menüelement zusammenzuführende Menüelement angibt.</param>
        <summary>Führt ein anderes Menüelement mit diesem Menüelement zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menüelemente werden zusammengeführt, nach dem Wert des Menüelements <xref:System.Windows.Forms.MenuItem.MergeType%2A> und <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> Eigenschaften. Diese Version von der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode können Sie zum Zusammenführen zweier <xref:System.Windows.Forms.MenuItem> Objekte (und deren Untermenüs) in einem einzigen Menü. Zusammenführen von Menüs wird automatisch durchgeführt, wenn eine übergeordnete-Form (MDI, Multiple Document Interface) und einem untergeordneten Menüs verwendbar sind. Können Sie diese Version der Methode zum Zusammenführen zweier <xref:System.Windows.Forms.MenuItem> Objekte (und ihre Untermenüelemente) befindet sich einem <xref:System.Windows.Forms.MainMenu> Steuerelement in einem einzigen Menü, in eine <xref:System.Windows.Forms.ContextMenu>. Beispielsweise können Sie diese Version von Aufrufen der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode, um die Menüelemente eines Menüs Datei, und Bearbeiten in einem einzelnen merge <xref:System.Windows.Forms.MenuItem> , klicken Sie dann hinzugefügt und angezeigt werden kann durch eine <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet diese Version von der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode, um eine Kopie erstellen eine <xref:System.Windows.Forms.MenuItem> und mit einer anderen zusammenführen. Das zusammengeführte <xref:System.Windows.Forms.MenuItem> wird dann hinzugefügt, um eine <xref:System.Windows.Forms.ContextMenu> Steuerelement. Dieses Beispiel erfordert, dass es zwei Menüelemente, die Namen gibt `menuItem1` und `menuItem2` , das die Untermenüelemente enthalten und eine <xref:System.Windows.Forms.ContextMenu> mit dem Namen `contextMenu1` auf die Menüelemente angezeigt werden. `menuItem1` und `menuItem2` enthalten unterschiedliche Menüelemente, die in ihnen enthaltenen. Nach dem Aufruf von <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> vorgenommen wird, eine konsolidierte Menü wird erstellt.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die relative Position des Menüelements beim Merge mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein nullbasierter Index, der die Position dieses Menüelements in der Merge-Ordnung darstellt. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Ordnung eines Menüelements gibt die relative Position, mit denen dieses Menüelement gelangen, wenn die Menüstruktur der <xref:System.Windows.Forms.MenuItem> enthalten ist in mit einer anderen zusammengeführt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> Eigenschaft, um zu steuern, wie einem zusammengeführten Menü wird angezeigt. Dies ist ein vollständiges Beispiel, das ausgeführt wird, sobald Sie es Ihrem Projekt hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Verhalten dieses Menüelements beim Merge des Menüs mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MenuMerge" />-Wert, der den Zusammenführungstyp des Menüelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Typ, der ein Menüelement zeigt an, wie das Menüelement verhält, wenn es sich um die gleichen Zusammenführungsfolge als ein anderes Menüelement zusammengeführt, hat. Sie können die zusammengeführten Menüs verwenden, zum Erstellen eines konsolidierten Menüs, die basierend auf mindestens zwei vorhandenen Menüs.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Windows.Forms.MenuItem> mit der <xref:System.Windows.Forms.MenuItem.MergeType%2A> und <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> angegeben, damit dem Menüelement, das das zusammengeführte Menü an der ersten Position hinzugefügt wird.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das diesem Menüelement zugeordnete mnemonische Zeichen angibt.</summary>
        <value>Ein Zeichen, das das diesem Menüelement zugeordnete mnemonische Zeichen darstellt. Gibt das NUL-Zeichen (ASCII-Wert 0) zurück, wenn im Text von <see cref="T:System.Windows.Forms.MenuItem" /> kein mnemonisches Zeichen angegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das mnemonische Zeichen ist das erste Zeichen nach dem kaufmännischen und-Zeichen (&) im Text der <xref:System.Windows.Forms.MenuItem>. Diese Eigenschaft keine mnemonisches Zeichen zurück, wenn zwei kaufmännische und-Zeichen zusammen platziert werden, da die kaufmännischen und-Zeichen verwendet werden, ein kaufmännisches und-Zeichen im Text des anzuzeigenden der <xref:System.Windows.Forms.MenuItem> anstatt ein mnemonisches Zeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Click> Ereignis auszuführenden Vorgänge fest, wenn eine <xref:System.Windows.Forms.MenuItem> geklickt wird. Das Beispiel erstellt eine <xref:System.Windows.Forms.MainMenu> namens `mainMenu1` und fügt zwei <xref:System.Windows.Forms.MenuItem> Objekte `topMenuItem` (`File`) und `menuItem1` (`Open`). Es verbindet dann die `Click` Ereignis, um die `menuItem1_Click` -Ereignishandler. Klickt der Benutzer die `Open` Menüelement eine <xref:System.Windows.Forms.OpenFileDialog> initialisiert und angezeigt. Das Beispiel muss nach der Erstellung einer <xref:System.Windows.Forms.Form> mit dem Namen `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DrawItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> Methode.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> Methode.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Popup> Ereignis, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die bieten Unterstützung für Ausschneide-, Kopier- und Löschvorgänge aktiviert sind, bevor sie, im angezeigt werden Menü angezeigt wird. Im Beispiel wird bestimmt, ob `textBox1`, <xref:System.Windows.Forms.TextBox> steuern, auf dem Formular, aktiviert ist, hat den Eingabefokus, und vor dem Aktivieren der ausgewählten Text der <xref:System.Windows.Forms.MenuItem> Objekte. Dieses Beispiel erfordert, dass drei <xref:System.Windows.Forms.MenuItem> benannte Objekte werden erstellt, `menuCut`, `menuCopy`, und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Select> Ereignis die <xref:System.Windows.Forms.MenuItem> Klasse Hilfetext zum Zuweisen einer <xref:System.Windows.Forms.StatusBarPanel> von eine <xref:System.Windows.Forms.StatusBar> Steuerelement. In diesem Beispiel erfordert, dass <xref:System.Windows.Forms.MenuItem> Objekte, die mit dem Namen `menuOpen`, `menuSave`, und `menuExit` werden hinzugefügt, um eine <xref:System.Windows.Forms.MainMenu> Steuerelement in einem Formular. Im Beispiel erfordert außerdem, dass eine <xref:System.Windows.Forms.StatusBar> Steuerelement, mit dem Namen `statusBar1` dem Formular hinzugefügt wurde. Die <xref:System.Windows.Forms.StatusBar> -Steuerelement enthalten sollte eine <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement vom bereitgestellten Code oder von Windows gezeichnet wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement mithilfe von Code gezeichnet werden soll. <see langword="false" />, wenn das Menüelement von Windows gezeichnet werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> -Eigenschaftensatz auf `true`, müssen Sie alle Funktionen zum Zeichnen des Menüelements behandeln. Sie können diese Funktion verwenden, erstellen Sie Ihre eigenen speziellen Menüs angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, ein Menü mit einem ownerdrawn-Menüelement. Diese Beispielsatz der <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> -Eigenschaft und verwendet die `AddHandler` Anweisung und die `AddressOf` Operator zum Festlegen eines Delegaten behandeln die <xref:System.Windows.Forms.MenuItem.DrawItem> Ereignis. Um das Beispiel auszuführen, fügen Sie ihn in ein Formular, importiert der <xref:System>, <xref:System.Windows.Forms>, und <xref:System.Drawing> Namespaces. Rufen Sie `InitializeMenu` aus den Konstruktor des Formulars oder `Load` Methode.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Menü angibt, das dieses Menüelement enthält.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Menu" />, das das Menü darstellt, das dieses Menüelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, zum Abrufen der <xref:System.Windows.Forms.Menu> Objekt für ein Untermenü. Sie können eine Typumwandlung der <xref:System.Windows.Forms.Menu> von dieser Eigenschaft zurückgegebenen Objekts ein <xref:System.Windows.Forms.MenuItem> Objekt, das sie bearbeiten.  
  
   
  
## Examples  
 In diesem Beispiel erstellen Sie ein Hauptmenü und ein Menüelement der obersten Ebene, `menuItem1` (`File`). Sie erstellen außerdem zwei Menüelemente, `menuItem2` (`New`) und `menuItem3` (`Open`), und sie die Elementliste im Menü hinzufügen `menuItem1`. Anschließend wird überprüft, um finden Sie unter `menuItem3` ist einem übergeordneten Menü, das true ist, und die Informationen zu diesem übergeordneten Menü im Meldungsfeld. Dieses Beispiel erfordert, nach der Erstellung einer <xref:System.Windows.Forms.Form> mit dem Namen `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generiert ein <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis für <see cref="T:System.Windows.Forms.MenuItem" />, wobei ein Mausklick durch einen Benutzer simuliert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Menü können Sie um ein Menüelement mithilfe von Code zu aktivieren, ohne Ereignisinformationen übergeben. Wenn Sie ein Menü, das Element auf Grundlage einer Aktion, die in Ihrer Anwendung auftritt, rufen Sie aktivieren möchten z. B. die <xref:System.Windows.Forms.MenuItem.PerformClick%2A> Methode dafür <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 In diesem Beispiel, das Sie programmgesteuert klicken Sie auf ein Menüelement mithilfe der `PerformClick` Methode. Zuerst erstellen Sie ein Hauptmenü (`mainMenu1`), und fügen Sie zwei hinzu Menüelemente `menuItem1` (`File`) und `menuItem2` (`Edit`). Sie auch verwenden, die <xref:System.Windows.Forms.MenuItem.Click> Ereignis, um Daten an den Ereignishandler zu senden, wenn ein Menüelement geklickt wird. Sie verwenden die `PerformClick` Methode, klicken Sie auf die `File` Menüelement. Beim Starten der Anwendung, die `File` Menüelement aktiviert ist und ein Meldungsfeld enthält den Text "Die Datei im Menü geklickt wird." wird auf dem Bildschirm angezeigt. Das Beispiel muss nach der Erstellung einer <xref:System.Windows.Forms.Form> mit dem Namen `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Methode können Sie zum Auslösen der <xref:System.Windows.Forms.MenuItem.Select> Ereignis ohne die Ereignisinformationen an den Ereignishandler übergeben.  
  
   
  
## Examples  
 In diesem Beispiel, das Sie programmgesteuert ein Menüelement wählen Sie mithilfe der `PerformSelect` Methode. Zuerst erstellen Sie ein Hauptmenü (`mainMenu1`), und fügen Sie zwei hinzu Menüelemente `menuItem1` (`File`) und `menuItem2` (`Edit`). Sie auch verwenden, die <xref:System.Windows.Forms.MenuItem.Select> Ereignis, um Daten an den Ereignishandler zu senden, wenn ein Menüelement ausgewählt ist. Sie verwenden die `PerformSelect` Methode zum Auswählen der `File` Menüelement. Beim Starten der Anwendung, die `File` Menüelement ausgewählt ist und ein Meldungsfeld enthält den Text "Die Datei im Menü ausgewählt ist." wird auf dem Bildschirm angezeigt. Das Beispiel muss nach der Erstellung einer <xref:System.Windows.Forms.Form> mit dem Namen `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Liste der Menüelemente eines Menüelements angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt nur auf, wenn ein Menüelement anzuzeigenden Untermenüelemente verfügt. Können Sie diesen Ereignishandler hinzufügen, entfernen, aktivieren und deaktivieren, aktivieren oder Deaktivieren von Menüelementen, die basierend auf den Zustand Ihrer Anwendung, bevor sie angezeigt werden. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Popup> Ereignis, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die bieten Unterstützung für Ausschneide-, Kopier- und Löschvorgänge aktiviert sind, bevor sie, im angezeigt werden Menü angezeigt wird. Im Beispiel wird bestimmt, ob `textBox1`, <xref:System.Windows.Forms.TextBox> steuern, auf dem Formular, aktiviert ist, hat den Eingabefokus, und vor dem Aktivieren der ausgewählten Text der <xref:System.Windows.Forms.MenuItem> Objekte. Dieses Beispiel erfordert, dass drei <xref:System.Windows.Forms.MenuItem> benannte Objekte werden erstellt, `menuCut`, `menuCopy`, und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> bei Aktivierung statt eines Häkchens ein Optionsfeld anzeigt, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn statt eines Häkchens ein Optionsfeld angezeigt werden soll. <see langword="false" />, wenn bei Aktivierung des Menüelements das Standardhäkchen angezeigt werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häkchen implizieren nicht unbedingt einen sich gegenseitig ausschließenden Zustand für eine Gruppe von Menüelementen. Sie können diese Eigenschaft verwenden, die Benutzer an, dass das Kontrollkästchen eines Menüelements gegenseitig exklusiv ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft, die den Zustand einer Anwendung geändert. Im Beispiel werden eine Gruppe von Menüelementen bereitgestellt, mit denen Sie die Farbe für den Text an einer <xref:System.Windows.Forms.TextBox> Steuerelement. Im Beispiel wird der bereitgestellte Ereignishandler von verwendet die <xref:System.Windows.Forms.MenuItem.Click> Ereignis der drei Menüelemente. Jedes Menüelement gibt eine Farbe, `menuItemRed`, `menuItemGreen`, oder `menuItemBlue`. Der Ereignishandler bestimmt, welches Menüelement geklickt wurde, wird ein Häkchen, um das ausgewählte Menüelement und ändert die Textfarbe des Formulars <xref:System.Windows.Forms.TextBox> Steuerelement, mit dem Namen `textBox1`. Im Beispiel verwendet auch die <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> Eigenschaft, um zu veranschaulichen, wie eine Optionsfeld-Überprüfung verwendet wird, um Menüelemente anzuzeigen, die sich gegenseitig. In diesem Beispiel erfordert, dass die <xref:System.Drawing?displayProperty=nameWithType> Namespace das Formular mit diesem Code hinzugefügt wurde.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger auf ein Menüelement gesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird in der Regel ausgelöst, wenn der Benutzer den Mauszeiger über das Menüelement platziert. Das Ereignis kann auch ausgelöst werden, wenn der Benutzer ein Menüelement mithilfe der Tastatur, indem Sie einen Bildlauf an das Menüelement, mit den Pfeiltasten hervorgehoben. Sie können dieses Ereignis verwenden, um eine ausführliche Hilfezeichenfolge bezieht sich auf dieses Menüelement in einer Anwendung Statusleiste anzuzeigen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Menu.MenuItems%2A> -Eigenschaft für die <xref:System.Windows.Forms.MenuItem> Elemente enthält, dieses Ereignis wird nicht ausgelöst. Dieses Ereignis wird nicht für Elemente des übergeordneten Menüs ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.MenuItem.Select> Ereignis die <xref:System.Windows.Forms.MenuItem> Klasse Hilfetext zum Zuweisen einer <xref:System.Windows.Forms.StatusBarPanel> von eine <xref:System.Windows.Forms.StatusBar> Steuerelement. In diesem Beispiel erfordert, dass <xref:System.Windows.Forms.MenuItem> Objekte, die mit dem Namen `menuOpen`, `menuSave`, und `menuExit` werden hinzugefügt, um eine <xref:System.Windows.Forms.MainMenu> Steuerelement in einem Formular. Im Beispiel erfordert außerdem, dass eine <xref:System.Windows.Forms.StatusBar> Steuerelement, mit dem Namen `statusBar1` dem Formular hinzugefügt wurde. Die <xref:System.Windows.Forms.StatusBar> -Steuerelement enthalten sollte eine <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die dem Menüelement zugeordnete Tastenkombination angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte. Der Standardwert ist <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastenkombinationen für den angeben, dass eine Methode für die Benutzer häufig aktiviert verwendet Menüelemente in Ihrem Menüsystem und Tastaturzugriff auf Ihre Anwendung für Benutzer bereitzustellen, die nicht den Zugriff auf eine Maus oder einem anderen Zeiger-Gerät verfügen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menüelement erstellt, wird die Beschriftung, eine Tastenkombination zugewiesen, das Menüelement sichtbar gemacht und die Tastenkombination für das Menüelement angezeigt wird. Im Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> wurde, erstellt mit dem Namen `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die dem Menüelement zugeordnete Tastenkombination neben der Beschriftung des Menüelements angezeigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Tastenkombination neben der Beschriftung des Menüelements angezeigt wird. <see langword="false" />, wenn die Tastenkombination nicht angezeigt werden soll. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um bieten die Möglichkeit für Benutzer zum Ausblenden von Tastenkombinationen in Menüs auf Platz freizugeben oder blenden eine Tastenkombination angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menüelement erstellt, wird die Beschriftung, eine Tastenkombination zugewiesen, das Menüelement sichtbar gemacht und die Tastenkombination für das Menüelement angezeigt wird. Im Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> wurde, erstellt mit dem Namen `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Beschriftung des Menüelements angibt, oder legt diesen fest.</summary>
        <value>Der Beschriftungstext des Menüelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menüelement angeben, können Sie auch eine Tastenkombination angeben, platziert eine '&' vor dem Zeichen als Zugriffstaste verwendet werden soll. Z. B. zum Angeben des "F" in "File" als Zugriffstaste würde Sie die Beschriftung für das Menüelement als angeben "& Datei". Sie können dieses Feature verwenden, Ihre Menüs Navigation per Tastatur bereit.  
  
 Wenn diese Eigenschaft auf "`-`" bewirkt, dass das Menüelement als Trennzeichen (eine horizontale Linie) und ein standard-Menüelement nicht angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menüelement erstellt, wird die Beschriftung, eine Tastenkombination zugewiesen, das Menüelement sichtbar gemacht und die Tastenkombination für das Menüelement angezeigt wird. Im Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> wurde, erstellt mit dem Namen `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den <see cref="T:System.Windows.Forms.MenuItem" /> darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle <see cref="T:System.Windows.Forms.MenuItem" /> darstellt. Die Zeichenfolge enthält den Typ und die <see cref="P:System.Windows.Forms.MenuItem.Text" />-Eigenschaft des Steuerelements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement sichtbar ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Menüelement im Menü sichtbar gemacht wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um mit einer Menüstruktur ohne Menüs zusammengeführt, oder Deaktivieren von Menüs zu ändern. Z. B. Wenn Sie eine vollständige Funktionalität in den Menüs für Ihre Anwendung ausblenden möchten, Sie können Ausblenden des Benutzers durch Festlegen dieser Eigenschaft auf `false`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menüelement erstellt, wird die Beschriftung, eine Tastenkombination zugewiesen, das Menüelement sichtbar gemacht und die Tastenkombination für das Menüelement angezeigt wird. Im Beispiel erfordert, dass eine <xref:System.Windows.Forms.MenuItem> wurde, erstellt mit dem Namen `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>