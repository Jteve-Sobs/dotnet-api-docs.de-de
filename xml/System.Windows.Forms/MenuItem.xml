<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6485db5b8fb1df830f42a571da5c4f0dccdd37d" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86727612" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("Click")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("Click")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultProperty("Text")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultProperty("Text")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DesignTimeVisible(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DesignTimeVisible(false)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.ToolboxItem(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.ToolboxItem(false)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein einzelnes Element dar, das in einem <see cref="T:System.Windows.Forms.MainMenu" /> oder einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird.
    
Diese Klasse ist in .net Core 3,1 und höheren Versionen nicht verfügbar. Verwenden Sie <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> stattdessen, wodurch das-Steuerelement ersetzt wird <see cref="T:System.Windows.Forms.MenuItem" /> .</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

Diese Klasse ist in .net Core 3,1 und höheren Versionen nicht verfügbar. Verwenden Sie stattdessen <see cref="T:System.Windows.Forms.ToolStripMenuItem" />.

 Damit ein <xref:System.Windows.Forms.MenuItem> angezeigt werden kann, müssen Sie es einem oder einem hinzufügen <xref:System.Windows.Forms.MainMenu> <xref:System.Windows.Forms.ContextMenu> . Zum Erstellen von Untermenüs können Sie <xref:System.Windows.Forms.MenuItem> der- <xref:System.Windows.Forms.Menu.MenuItems%2A> Eigenschaft des übergeordneten-Objekts-Objekte hinzufügen <xref:System.Windows.Forms.MenuItem> .  
  
 Die- <xref:System.Windows.Forms.MenuItem> Klasse stellt Eigenschaften bereit, die es Ihnen ermöglichen, das Aussehen und die Funktionalität eines Menü Elements zu konfigurieren. Wenn Sie ein Häkchen neben einem Menü Element anzeigen möchten, verwenden Sie die- <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft. Mit dieser Funktion können Sie ein Menü Element identifizieren, das in einer Liste von sich gegenseitig ausschließenden Menü Elementen ausgewählt ist. Wenn Sie z. b. über eine Reihe von Menü Elementen zum Festlegen der Textfarbe in einem <xref:System.Windows.Forms.TextBox> Steuerelement verfügen, können Sie die-Eigenschaft verwenden, <xref:System.Windows.Forms.MenuItem.Checked%2A> um zu bestimmen, welche Farbe aktuell ausgewählt ist. Die- <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Eigenschaft kann verwendet werden, um eine Tastenkombination zu definieren, die gedrückt werden kann, um das Menü Element auszuwählen.  
  
 Für <xref:System.Windows.Forms.MenuItem> Objekte, die in einer MDI-Anwendung (Multiple Document Interface) angezeigt werden, können Sie die-Methode verwenden, <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> um die Menüs eines übergeordneten MDI-Elements für mit dem seiner untergeordneten Formulare zusammenzuführen, um eine konsolidierte Menüstruktur zu erstellen. Da ein <xref:System.Windows.Forms.MenuItem> nicht an mehreren Speicherorten gleichzeitig wieder verwendet werden kann, wie z. b. in einem <xref:System.Windows.Forms.MainMenu> und einem <xref:System.Windows.Forms.ContextMenu> , können Sie die-Methode verwenden, <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> um eine Kopie von zu erstellen, die <xref:System.Windows.Forms.MenuItem> an einem anderen Speicherort verwendet werden kann.  
  
 Mit dem- <xref:System.Windows.Forms.MenuItem.Popup> Ereignis können Sie Aufgaben ausführen, bevor ein Menü angezeigt wird. Beispielsweise können Sie einen Ereignishandler für dieses Ereignis erstellen, um Menü Elemente basierend auf dem Zustand des Codes anzuzeigen oder auszublenden. Das <xref:System.Windows.Forms.MenuItem.Select> Ereignis ermöglicht Ihnen das Ausführen von Aufgaben wie z. b. das Bereitstellen ausführlicher Hilfe für die Menü Elemente Ihrer Anwendung, wenn der Benutzer den Mauszeiger über ein Menü Element bewegt.
  
## Examples  
 Im folgenden Codebeispiel wird eine Menüstruktur für ein Formular erstellt. Im Beispielcode wird ein hinzugefügt, <xref:System.Windows.Forms.MenuItem> das das Menü Element der obersten Ebene darstellt, ein unter Menü Element zur Auswahl eines Schrift Grads hinzufügt und dann zwei unter Menü Elemente zu diesem Menü Element hinzufügt, die große und kleine Schriftart Optionen in einer Anwendung darstellen. Das Beispiel setzt voraus, dass es ein <xref:System.Windows.Forms.MainMenu> -Objekt mit dem Namen `mainMenu1` und vier-Objekte mit den <xref:System.Windows.Forms.MenuItem> Namen `menuItem1` , `menuItem2` , und gibt `menuItem3` `menuItem4` .  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert ein <see cref="T:System.Windows.Forms.MenuItem" /> mit leerer Beschriftung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem Sie mit diesem Konstruktor ein leeres Element erstellt haben <xref:System.Windows.Forms.MenuItem> , können Sie die Eigenschaften und Methoden der- <xref:System.Windows.Forms.MenuItem> Klasse verwenden, um die Darstellung und das Verhalten von anzugeben <xref:System.Windows.Forms.MenuItem> .
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Windows.Forms.MenuItem> mit dieser Version des-Konstruktors ein erstellt.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie mit dem-Parameter eine Beschriftung für das Menü Element angeben `text` , können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, ein Zeichen vom Typ "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 `text`Wenn Sie den-Parameter auf "" festlegen, `-` wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.
  
## Examples  
 Im folgenden Codebeispiel wird eine erstellt <xref:System.Windows.Forms.MenuItem> , die die Beschriftung des Menü Elements zum Zeitpunkt der Erstellung angibt.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Ereignishandler für das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis des Menüelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie mit dem-Parameter eine Beschriftung für das Menü Element angeben `text` , können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 `text`Wenn Sie den-Parameter auf "" festlegen, `-` wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen Delegaten anzugeben, der das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das erstellte Menü Element behandelt. Die, die <xref:System.EventHandler> Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das Ereignis verarbeiten kann <xref:System.Windows.Forms.MenuItem.Click> . Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.MenuItem> -Objekt mit einer angegebenen Beschriftung und einem-Delegaten erstellt, <xref:System.EventHandler> der mit einem Ereignishandler verbunden ist, der das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das Menü Element behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Array von Untermenüelementen, die für das Menüelement definiert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie mit dem-Parameter eine Beschriftung für das Menü Element angeben `text` , können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 `text`Wenn Sie den-Parameter auf "" festlegen, `-` wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Mit dem- `items` Parameter können Sie ein Array von Menü Elementen zuweisen, um ein Untermenü dieses Menü Elements zu definieren. Jedem Element im Array kann auch ein Array von Menü Elementen zugewiesen werden. Dies ermöglicht es Ihnen, komplette Menüstrukturen zu erstellen und Sie dem Konstruktor für das Menü Element zuzuweisen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird ein-Objekt mit einer angegebenen Beschriftung erstellt, einem Ereignishandler, der mit einer Methode verbunden ist, die das Ereignis der einzelnen Menü Elemente in einem Array von unter Menü Elementen behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler, shortcut As Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung, einem Ereignishandler und einer zugeordneten Tastenkombination für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie mit dem-Parameter eine Beschriftung für das Menü Element angeben `text` , können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen. Dieser Konstruktor ermöglicht Ihnen außerdem, zusätzlich zu einer Zugriffstaste eine Tastenkombination anzugeben, um die Tastaturnavigation zu ermöglichen. Mit Tastenkombinationen können Sie eine Kombination von Schlüsseln angeben, mit denen das Menü Element aktiviert werden kann.  
  
 `text`Wenn Sie den-Parameter auf "" festlegen, `-` wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen Delegaten anzugeben, der das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das erstellte Menü Element behandelt. Die, die <xref:System.EventHandler> Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das Ereignis verarbeiten kann <xref:System.Windows.Forms.MenuItem.Click> . Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird ein-Objekt mit einer angegebenen Beschriftung, einer angegebenen Tastenkombination und einem Ereignishandler erstellt, der mit einer Methode verbunden ist, die das-Ereignis für das Menü Element behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mergeType As MenuMerge, mergeOrder As Integer, shortcut As Shortcut, text As String, onClick As EventHandler, onPopup As EventHandler, onSelect As EventHandler, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Einer der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</param>
        <param name="mergeOrder">Die relative Position, die dieses Menüelement in einem zusammengeführten Menü einnimmt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onPopup">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onSelect">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung, definierten Ereignishandlern für die Ereignisse <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> und <see cref="E:System.Windows.Forms.MenuItem.Popup" />, einer Tastenkombination, einem Zusammenführungstyp und einer Zusammenführungsfolge, die für das Menüelement angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie mit dem-Parameter eine Beschriftung für das Menü Element angeben `text` , können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 `text`Wenn Sie den-Parameter auf "" festlegen, `-` wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Mit dem- `items` Parameter können Sie ein Array von Menü Elementen zuweisen, um ein Untermenü dieses Menü Elements zu definieren. Jedem Element im Array kann auch ein Array von Menü Elementen zugewiesen werden. Dies ermöglicht es Ihnen, komplette Menüstrukturen zu erstellen und Sie dem Konstruktor für das Menü Element zuzuweisen.  
  
 `mergeType`Mit dem-Parameter und dem- `mergeOrder` Parameter können Sie bestimmen, wie sich dieses Menü Element verhält, wenn das Menü Element mit einem anderen Menü zusammengeführt wird. Abhängig von dem Wert, den Sie für den `mergeType` Parameter angeben, können Sie das Menü Element und seine unter Menü Elemente mit dem Menü, mit dem es zusammengeführt wird, hinzufügen, entfernen, ersetzen oder zusammenführen. Der- `mergeOrder` Parameter bestimmt, wo das zu erstellende Menü Element positioniert wird, wenn das Menü zusammengeführt wird.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen zu erstellen <xref:System.Windows.Forms.MenuItem> und ihn mit einem Ereignishandler im Code zu verbinden, der den Klick des Menü Elements verarbeitet. Die <xref:System.EventHandler> , die Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das Ereignis verarbeiten kann <xref:System.Windows.Forms.MenuItem.Click> . Mit dieser Konstruktorversion können Sie auch die <xref:System.Windows.Forms.MenuItem.Popup> -und-Ereignisse verbinden, <xref:System.Windows.Forms.MenuItem.Select> um zu bestimmen, wann dieses Menü Element ausgewählt ist. Diese Ereignisse können für Aufgaben verwendet werden, z. b. die Bestimmung, ob ein Häkchen neben unter Menü Elementen angezeigt werden soll oder ob Menü Elemente basierend auf dem Zustand der Anwendung aktiviert oder deaktiviert werden sollen. Das <xref:System.Windows.Forms.MenuItem.Select> -Ereignis und das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis werden nur für- <xref:System.Windows.Forms.MenuItem> Objekte ausgelöst, die keine übergeordneten Menü Elemente sind. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, das über eine Beschriftung und eine Tastenkombination verfügt. Das Menü Element enthält auch Ereignishandler, die für die <xref:System.Windows.Forms.MenuItem.Popup> Ereignisse, und definiert sind <xref:System.Windows.Forms.MenuItem.Click> <xref:System.Windows.Forms.MenuItem.Select> . Wenn dieses Menü Element zusammengeführt wird, wird das Menü Element dem Menü mit der mergereihenfolge null hinzugefügt.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Untermenüelement oder Menüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die- <xref:System.Windows.Forms.MenuItem.BarBreak%2A> Eigenschaft verwenden, um ein Menü zu erstellen, in dem jedes Menü Element horizontal und nicht in einer vertikalen Liste nebeneinander platziert wird. Sie können diese Eigenschaft auch verwenden, um eine Menüleiste zu erstellen, die mehrere Zeilen mit Menü Elementen der obersten Ebene enthält.  
  
 Diese Eigenschaft unterscheidet sich von der- <xref:System.Windows.Forms.MenuItem.Break%2A> Eigenschaft darin, dass eine Leiste am linken Rand jedes Menü Elements angezeigt wird, für das die- <xref:System.Windows.Forms.MenuItem.Break%2A> Eigenschaft auf festgelegt ist `true` . Der Balken wird nur angezeigt, wenn das Menü Element kein Menü Element der obersten Ebene ist.
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.MenuItem> mit zwei unter Menü Elementen erstellt. Die beiden unter Menü Elemente werden horizontal und nicht vertikal mithilfe der- <xref:System.Windows.Forms.MenuItem.BarBreak%2A> Eigenschaft angezeigt.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Element in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Menüelement oder Untermenüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die- <xref:System.Windows.Forms.MenuItem.Break%2A> Eigenschaft verwenden, um ein Menü zu erstellen, in dem jedes Menü horizontal und nicht in einer vertikalen Liste nebeneinander platziert wird. Sie können diese Eigenschaft auch verwenden, um eine Menüleiste zu erstellen, die mehrere Zeilen mit Menü Elementen der obersten Ebene enthält.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü mit zwei Menü Elementen der obersten Ebene in der obersten Zeile und einem Menü Element in der untersten Zeile erstellt.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob neben dem Text des Menüelements ein Häkchen angezeigt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement mit einem Häkchen versehen ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die- <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft in Kombination mit anderen Menü Elementen in einem Menü verwenden, um den Zustand für eine Anwendung bereitzustellen. Beispielsweise können Sie ein Häkchen für ein Menü Element in einer Gruppe von Elementen platzieren, um die Größe der Schriftart zu identifizieren, die für den Text in einer Anwendung angezeigt werden soll. Sie können auch die- <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft verwenden, um das ausgewählte Menü Element in einer Gruppe von sich gegenseitig ausschließenden Menü Elementen zu identifizieren.  
  
> [!NOTE]
> Diese Eigenschaft kann `true` für Menü Elemente der obersten Ebene nicht auf festgelegt werden.
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft verwendet, um den Status in einer Anwendung bereitzustellen. In diesem Beispiel wird eine Gruppe von Menü Elementen verwendet, um die Farbe für den Text in einem- <xref:System.Windows.Forms.TextBox> Steuerelement anzugeben. Der angegebene Ereignishandler wird vom- <xref:System.Windows.Forms.MenuItem.Click> Ereignis von drei Menü Elementen verwendet. Jedes Menü Element gibt eine Textfarbe an `menuItemRed` (rot), `menuItemGreen` (grün) oder `menuItemBlue` (blau). Der Ereignishandler bestimmt, auf welches Menü Element geklickt wurde, platziert ein Häkchensymbol für das ausgewählte Menü Element und ändert die Textfarbe des Formular <xref:System.Windows.Forms.TextBox> Steuer Elements. Das Beispiel setzt voraus, dass der- <xref:System.Drawing> Namespace dem Formular hinzugefügt wurde, in dem dieser Code platziert wird. Das Beispiel erfordert auch, dass <xref:System.Windows.Forms.TextBox> dem Formular, in dem sich dieser Beispielcode befindet, eine hinzugefügt wurde, die den Namen hat `textBox1` .  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <see cref="T:System.Windows.Forms.MenuItem" /> ist ein Menü der obersten Ebene oder verfügt über untergeordnete Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn auf das Menüelement geklickt wird oder wenn es unter Verwendung einer für das Menüelement definierten Tastenkombination oder Zugriffstaste ausgewählt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.MenuItem.Click> Ereignis tritt auf, wenn <xref:System.Windows.Forms.MenuItem> der Benutzer darauf klickt. Dieses Ereignis tritt auch auf, wenn der Benutzer das Menü Element mithilfe der Tastatur auswählt und die EINGABETASTE drückt. Dies kann auch vorkommen, wenn eine Zugriffstaste oder eine Tastenkombination gedrückt wird, die dem zugeordnet ist <xref:System.Windows.Forms.MenuItem> . Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).  
  
> [!NOTE]
> Wenn die- <xref:System.Windows.Forms.Menu.MenuItems%2A> Eigenschaft für <xref:System.Windows.Forms.MenuItem> Elemente Elemente enthält, wird dieses Ereignis nicht ausgelöst. Dieses Ereignis wird nicht für übergeordnete Menü Elemente ausgelöst.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis zum Ausführen von Aufgaben verwendet wird, wenn auf ein <xref:System.Windows.Forms.MenuItem> geklickt wird. Im Beispiel wird ein mit dem <xref:System.Windows.Forms.MainMenu> Namen erstellt `mainMenu1` und zwei <xref:System.Windows.Forms.MenuItem> -Objekte hinzugefügt: `topMenuItem` ( `File` ) und `menuItem1` ( `Open` ). Anschließend wird das `Click` Ereignis mit dem `menuItem1_Click` Ereignishandler verbunden. Wenn der Benutzer auf das `Open` Menü Element klickt, <xref:System.Windows.Forms.OpenFileDialog> wird eine initialisiert und angezeigt. Das Beispiel erfordert, dass Sie einen mit dem Namen erstellt haben <xref:System.Windows.Forms.Form> `Form1` .  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Kopie einer <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das duplizierte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> -Objekte können nicht an mehr als einem Ort verwendet werden, es sei denn, Sie erhalten eine Kopie von <xref:System.Windows.Forms.MenuItem> . Sie können diese Methode zum Erstellen einer Kopie dieses Menü Elements zur Verwendung in <xref:System.Windows.Forms.ContextMenu> , <xref:System.Windows.Forms.MainMenu> oder einem anderen in <xref:System.Windows.Forms.MenuItem> der Anwendung verwenden. Wenn ein Menü Element geklont wird, funktionieren alle im ursprünglichen Menü Element angegebenen Ereignishandler weiterhin in der geklonten Version des Menü Elements. Wenn Sie z. b. ein erstellt <xref:System.Windows.Forms.MenuItem> und das zugehörige- <xref:System.Windows.Forms.MenuItem.Click> Ereignis mit einem Ereignishandler verknüpft haben. Wenn das Menü Element geklont wird, ruft das geklonte Menü Element denselben Ereignishandler auf.
  
## Examples  
 Im folgenden Codebeispiel wird ein geklont <xref:System.Windows.Forms.MenuItem> und in einem angezeigt <xref:System.Windows.Forms.ContextMenu> . Das Beispiel setzt voraus, dass ein <xref:System.Windows.Forms.MenuItem> in einem <xref:System.Windows.Forms.MainMenu> Formular mit dem Namen vorhanden ist `menuItem1` und dass auch ein-Objekt mit dem Namen <xref:System.Windows.Forms.ContextMenu> `contextMenu1` im Formular vorhanden ist.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Das <see cref="T:System.Windows.Forms.MenuItem" />, das das zu kopierende Menüelement darstellt.</param>
        <summary>Erstellt eine Kopie des angegebenen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, um Kopien von Menü Elementen zu erstellen, die Sie bereits für die Verwendung in einem Kontextmenü oder einer anderen Menüstruktur in der Anwendung erstellt haben. Mit dieser Version von <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> können Sie <xref:System.Windows.Forms.MenuItem> anstelle des Menü Elements, das die-Methode aufrufen soll, eine bestimmte zum Kopieren angeben. Mit dieser Methode können Sie ein neues- <xref:System.Windows.Forms.MenuItem> Objekt mit einer Kopie einer anderen initialisieren <xref:System.Windows.Forms.MenuItem> . Wenn ein Menü Element geklont wird, funktionieren alle im ursprünglichen Menü Element angegebenen Ereignishandler weiterhin in der geklonten Version des Menü Elements. Wenn Sie z. b. ein erstellt <xref:System.Windows.Forms.MenuItem> und das zugehörige- <xref:System.Windows.Forms.MenuItem.Click> Ereignis mit einem Ereignishandler verknüpft haben. Wenn das Menü Element geklont wird, ruft das geklonte Menü Element denselben Ereignishandler auf.
  
## Examples  
 Im folgenden Codebeispiel wird ein neues <xref:System.Windows.Forms.MenuItem> mit einer Kopie eines vorhandenen initialisiert <xref:System.Windows.Forms.MenuItem> , das in einem- <xref:System.Windows.Forms.MainMenu> Formular verwendet wird. Der Code fügt dann die geklonte <xref:System.Windows.Forms.MenuItem> zu einem <xref:System.Windows.Forms.ContextMenu> auf dem Formular hinzu. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.MenuItem> bereits erstellt und benannt ist `menuItem1` und dass ein <xref:System.Windows.Forms.ContextMenu> -Steuerelement erstellt und benannt wurde `contextMenu1` .  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement das Standardmenüelement ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement das Standardelement in einem Menü ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardmenü Element für ein Menü ist "Bold". Wenn der Benutzer auf ein Untermenü doppelklickt, das ein Standardelement enthält, wird das Standardelement ausgewählt, und das Untermenü ist geschlossen. Sie können die- <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> Eigenschaft verwenden, um anzugeben, die Standardaktion, die in einem Menü oder Kontextmenü erwartet wird.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element mit zwei unter Menü Elementen erstellt. Im Beispiel wird `menuItem2` mithilfe der-Eigenschaft als Standardmenü Element festgelegt <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> .  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, wenn Sie <xref:System.Windows.Forms.MenuItem> nicht mehr benötigen. Die <xref:System.Windows.Forms.MenuItem.Dispose%2A>-Methode bewirkt, dass <xref:System.Windows.Forms.MenuItem> nicht mehr verwendet werden kann. Nachdem <xref:System.Windows.Forms.MenuItem.Dispose%2A> Sie aufgerufen haben, müssen Sie alle Verweise auf freigeben, <xref:System.Windows.Forms.MenuItem> damit der Arbeitsspeicher, den Sie belegen, von Garbage Collection freigegeben werden kann.  
  
> [!NOTE]
> Rufen Sie immer <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, bevor Sie den letzten Verweis auf das <xref:System.Windows.Forms.MenuItem> freigeben. Andernfalls werden die Ressourcen, die <xref:System.Windows.Forms.MenuItem> von verwendet werden, erst freigegeben, wenn Garbage Collection den <xref:System.Windows.Forms.MenuItem> Dekonstruktor des Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />-Eigenschaft eines Menüelements auf <see langword="true" /> festgelegt ist und das Zeichnen des Menüelements angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.DrawItemEventArgs> an einen-Ereignishandler weiter gegebene-Argument <xref:System.Windows.Forms.MenuItem.DrawItem> stellt ein <xref:System.Drawing.Graphics> -Objekt bereit, das es Ihnen ermöglicht, Zeichen und andere grafische Vorgänge auf der Oberfläche des Menü Elements auszuführen. Mit diesem Ereignishandler können Sie benutzerdefinierte Menüs erstellen, die den Anforderungen Ihrer Anwendung entsprechen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das-Ereignis behandelt wird <xref:System.Windows.Forms.MenuItem.DrawItem> . In diesem Beispiel wird ein Menü Element mit einem <xref:System.Drawing.Brush> und einem gezeichnet <xref:System.Drawing.Font> , und dann wird ein <xref:System.Drawing.Rectangle> um das Menü Element gezeichnet. Die Zeichnung wird durch das- <xref:System.Drawing.Graphics> Objekt durchgeführt, das im-Parameter an den-Ereignishandler übergeben wird <xref:System.Windows.Forms.DrawItemEventArgs> . Für dieses Beispiel ist es erforderlich, dass Sie die- <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> Eigenschaft für das Element auf initialisiert haben `true` . Fügen Sie im c#-Beispiel den folgenden Code in den Konstruktor des Formulars ein, `InitializeComponent` um das-Ereignis zu verbinden:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.MenuItem> , das deaktiviert ist, wird in grau Farben angezeigt, um seinen Zustand anzugeben. Wenn ein übergeordnetes Menü Element deaktiviert ist, werden alle unter Menü Elemente nicht angezeigt.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, das in angezeigt wird Im Beispiel wird bestimmt, ob `textBox1` ein <xref:System.Windows.Forms.TextBox> Steuerelement im Formular aktiviert ist, über den Eingabefokus verfügt und Text vor dem Aktivieren der <xref:System.Windows.Forms.MenuItem> Objekte ausgewählt ist. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem> -Objekte namens `menuCut` , und erstellt wurden `menuCopy` `menuDelete` .  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Position des Menüelements im übergeordneten Menü angibt, oder legt diesen fest.</summary>
        <value>Der nullbasierte Index, der die Position des Menüelements im übergeordneten Menü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die indizierte Position eines Menü Elements in der Menü Element Auflistung des übergeordneten Menüs bereit. Mit dieser Eigenschaft können Sie ein Menü Element an einer anderen Position im Menü neu positionieren. Sie können diese Eigenschaft auch verwenden, wenn Sie einen erstellen <xref:System.Windows.Forms.MenuItem> , um seine Position in einer Menüstruktur zum Zeitpunkt der Erstellung anzugeben.
  
## Examples  
 Im folgenden Codebeispiel wird die Position von zwei Menü Elementen in einem Menü gewechselt. Im folgenden Codebeispiel ist es erforderlich, dass zwei <xref:System.Windows.Forms.MenuItem> -Objekte mit dem Namen und erstellt werden `menuItem1` `menuItem2` . Das `menuItem1` Menü Element wird im Menü um eine Position nach unten verschoben, während `menuItem2` eine Position nach oben verschoben wird.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der zugewiesene Wert ist kleiner als 0 (null) oder größer als die Elementanzahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement untergeordnete Menüelemente enthält.</summary>
        <value><see langword="true" />, wenn das Menüelement untergeordnete Menüelemente enthält. <see langword="false" />, wenn das Menü ein eigenständiges Menüelement ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft mit der- <xref:System.Windows.Forms.MenuItem.Parent%2A> Eigenschaft verwenden, um im Code durch eine gesamte Menüstruktur zu navigieren.
  
## Examples  
 Im folgenden Codebeispiel wird festgelegt, ob Untermenüs vorhanden sind, die mit einem mit dem Namen verknüpft sind <xref:System.Windows.Forms.MenuItem> `menuItem1` . Wenn ein unter Menü vorhanden ist, werden diese deaktiviert, indem die-Eigenschaft auf festgelegt wird <xref:System.Windows.Forms.MenuItem.Enabled%2A> `false` . Für das Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.MenuItem> erstelltes namens vorhanden ist `menuItem1` .  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement mit einer Liste der untergeordneten MDI-Fenster (Multiple Document Interface) aufgefüllt wird, die im zugeordneten Formular angezeigt werden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn eine Liste untergeordneter MDI-Fenster in diesem Menüelement angezeigt wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Menü Element ausgewählt wird, um eine Liste untergeordneter MDI-Fenster anzuzeigen, wird die Liste als Untermenü des Menü Elements angezeigt. Nur Formulare, die als untergeordnete MDI-Formulare definiert sind, werden in der Fensterliste angezeigt. Es können nur neun untergeordnete Fenster gleichzeitig angezeigt werden. Wenn mehr als neun untergeordnete Fenster angezeigt werden, wird ein "mehr Windows..." das Menü Element wird am Ende der Fensterliste angezeigt. Wenn Sie auf dieses Menü Element klicken, wird ein Dialogfeld mit einer kompletten Liste der untergeordneten Fenster angezeigt, die zurzeit aktiv sind.
  
## Examples  
 Im folgenden Codebeispiel wird ein erstellt <xref:System.Windows.Forms.MenuItem> , der verwendet wird, um die Liste der derzeit geöffneten untergeordneten MDI-Formulare in einem MDI-Formular anzuzeigen.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dem Menü die Größe eines Menüelements bekannt sein muss, bevor dieses gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit dieses Ereignis ausgelöst wird, muss die- <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> Eigenschaft des Menü Elements auf festgelegt sein `true` . Dieses Ereignis wird ausgelöst, bevor die Menüs des Besitzers gezeichnet werden, damit die Größe des Menü Elements angegeben werden kann. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.MenuItem.MeasureItem> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs mit dem <xref:System.Windows.Forms.MenuItem> Namen enthält `MenuItem1` . Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.MenuItem.MeasureItem> Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Windows-Bezeichner für dieses Menüelement angibt.</summary>
        <value>Der Windows-Bezeichner für dieses Menüelement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen und gibt das sich ergebende zusammengeführte <see cref="T:System.Windows.Forms.MenuItem" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das zusammengeführte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Version von aufzurufen <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> , <xref:System.Windows.Forms.MenuItem> ist das zurückgegebene eine Kopie des aktuellen Menü Elements, das mit einem anderen Menü Element zusammengeführt werden kann, ohne dass sich dies auf die Funktionalität des aktuellen Elements auswirkt. Diese Version der- <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode ähnelt dem Aufrufen der- <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> Methode, die keine Parameter enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das mit diesem Menüelement zusammenzuführende Menüelement angibt.</param>
        <summary>Führt ein anderes Menüelement mit diesem Menüelement zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menü Elemente werden gemäß dem Wert der-Eigenschaft und der-Eigenschaft des Menü Elements zusammengeführt <xref:System.Windows.Forms.MenuItem.MergeType%2A> <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> . Mit dieser Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> -Methode können Sie zwei <xref:System.Windows.Forms.MenuItem> -Objekte (und deren Untermenüs) in einem Menü zusammenführen. Die Zusammenführung des Menüs wird automatisch durchgeführt, wenn ein übergeordnetes MDI-Formular (Multiple Document Interface) und ein untergeordnetes Element über Menüs verfügen. Sie können diese Version der-Methode verwenden, um zwei <xref:System.Windows.Forms.MenuItem> Objekte (und deren unter Menü Elemente), die sich in einem-Steuerelement befinden, in einem <xref:System.Windows.Forms.MainMenu> einzelnen Menü innerhalb eines zusammenzuführen <xref:System.Windows.Forms.ContextMenu> . Beispielsweise können Sie diese Version der- <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> Methode zum Zusammenführen der Menü Elemente einer Datei und eines Bearbeitungs Menüs in einem einzelnen-Element, <xref:System.Windows.Forms.MenuItem> das dann einem hinzugefügt und von einem angezeigt werden kann, Abrufen <xref:System.Windows.Forms.ContextMenu> .
  
## Examples  
 Im folgenden Codebeispiel wird diese Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> -Methode verwendet, um eine Kopie von einem zu erstellen <xref:System.Windows.Forms.MenuItem> und mit einer anderen zu verbinden. Das zusammengeführte <xref:System.Windows.Forms.MenuItem> wird dann einem-Steuerelement hinzugefügt <xref:System.Windows.Forms.ContextMenu> . Für dieses Beispiel müssen zwei Menü Elemente aufgerufen werden `menuItem1` , die `menuItem2` unter Menü Elemente enthalten, und ein <xref:System.Windows.Forms.ContextMenu> `contextMenu1` mit dem Namen, um die Menü Elemente anzuzeigen. `menuItem1` und `menuItem2` verfügen über unterschiedliche Menü Elemente, die darin enthalten sind. Nachdem der-Befehl durch <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> geführt wurde, wird ein konsolidiertes Menü erstellt.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die relative Position des Menüelements beim Merge mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein nullbasierter Index, der die Position dieses Menüelements in der Merge-Ordnung darstellt. Die Standardeinstellung ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die mergereihenfolge eines Menü Elements gibt die relative Position an, die dieses Menü Element annimmt, wenn die Menüstruktur, in der die <xref:System.Windows.Forms.MenuItem> enthalten ist, mit einer anderen zusammengeführt wird.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der- <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> Eigenschaft gesteuert wird, wie ein zusammen geführtes Menü angezeigt wird. Dies ist ein umfassendes Beispiel, das ausgeführt werden kann, sobald Sie es dem Projekt hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Verhalten dieses Menüelements bei der Zusammenführung des Menüs mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MenuMerge" />-Wert, der den Zusammenführungstyp des Menüelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der mergetyp eines Menü Elements gibt an, wie sich das Menü Element verhält, wenn es dieselbe mergereihenfolge wie ein anderes Menü Element aufweist. Mithilfe von zusammengeführten Menüs können Sie ein konsolidiertes Menü erstellen, das auf zwei oder mehr vorhandenen Menüs basiert.
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> mit dem <xref:System.Windows.Forms.MenuItem.MergeType%2A> <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> angegebenen erstellt, sodass das Menü Element dem zusammengeführten Menü an der ersten Position hinzugefügt wird.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das diesem Menüelement zugeordnete mnemonische Zeichen angibt.</summary>
        <value>Ein Zeichen, das das diesem Menüelement zugeordnete mnemonische Zeichen darstellt. Gibt das NUL-Zeichen (ASCII-Wert 0) zurück, wenn im Text von <see cref="T:System.Windows.Forms.MenuItem" /> kein mnemonisches Zeichen angegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das mmamonische Zeichen ist das erste Zeichen nach einem kaufmännischen und-Zeichen (&) im Text von <xref:System.Windows.Forms.MenuItem> . Diese Eigenschaft gibt kein mnetmonisches Zeichen zurück, wenn zwei kaufmännische und-Zeichen verwendet werden, da die kaufmännische und-Zeichen verwendet werden, um ein kaufmännisches und-Zeichen im Text von anzuzeigen, <xref:System.Windows.Forms.MenuItem> anstatt ein mnetmonisches Zeichen zu definieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis zum Ausführen von Aufgaben verwendet wird, wenn auf ein <xref:System.Windows.Forms.MenuItem> geklickt wird. Im Beispiel wird ein mit dem <xref:System.Windows.Forms.MainMenu> Namen erstellt `mainMenu1` und zwei <xref:System.Windows.Forms.MenuItem> -Objekte hinzugefügt: `topMenuItem` ( `File` ) und `menuItem1` ( `Open` ). Anschließend wird das `Click` Ereignis mit dem `menuItem1_Click` Ereignishandler verbunden. Wenn der Benutzer auf das `Open` Menü Element klickt, <xref:System.Windows.Forms.OpenFileDialog> wird eine initialisiert und angezeigt. Das Beispiel erfordert, dass Sie einen mit dem Namen erstellt haben <xref:System.Windows.Forms.Form> `Form1` .  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DrawItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> .</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInitMenuPopup (EventArgs e);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInitMenuPopup (e As EventArgs)" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> .</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, das in angezeigt wird Im Beispiel wird bestimmt, ob `textBox1` ein <xref:System.Windows.Forms.TextBox> Steuerelement im Formular aktiviert ist, über den Eingabefokus verfügt und Text vor dem Aktivieren der <xref:System.Windows.Forms.MenuItem> Objekte ausgewählt ist. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem> -Objekte namens `menuCut` , und erstellt wurden `menuCopy` `menuDelete` .  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Select> Ereignis der-Klasse verwendet wird <xref:System.Windows.Forms.MenuItem> , um einen Hilfetext einem eines-Steuer Elements zuzuweisen <xref:System.Windows.Forms.StatusBarPanel> <xref:System.Windows.Forms.StatusBar> . Für dieses Beispiel ist es erforderlich, dass <xref:System.Windows.Forms.MenuItem> `menuOpen` `menuSave` -Objekte mit den Namen, und `menuExit` einem Steuerelement <xref:System.Windows.Forms.MainMenu> in einem Formular hinzugefügt werden. Das Beispiel erfordert auch, dass ein- <xref:System.Windows.Forms.StatusBar> Steuerelement `statusBar1` mit dem Namen dem Formular hinzugefügt wurde. Das- <xref:System.Windows.Forms.StatusBar> Steuerelement muss einen enthalten <xref:System.Windows.Forms.StatusBarPanel> .  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement vom bereitgestellten Code oder von Windows gezeichnet wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement mithilfe von Code gezeichnet werden soll. <see langword="false" />, wenn das Menüelement von Windows gezeichnet werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die- <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> Eigenschaft auf festgelegt ist `true` , müssen Sie alle Zeichnungen des Menü Elements verarbeiten. Sie können diese Funktion verwenden, um Ihre eigenen speziellen Menü anzeigen zu erstellen.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü mit einem vom Besitzer gezeichneten Menü Element veranschaulicht. In diesem Beispiel wird die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> -Eigenschaft festgelegt und die `AddHandler` -Anweisung und der- `AddressOf` Operator verwendet, um einen Delegaten zur Behandlung des <xref:System.Windows.Forms.MenuItem.DrawItem> Ereignisses festzulegen Um das Beispiel auszuführen, fügen Sie es in ein Formular ein, mit dem die <xref:System> <xref:System.Windows.Forms> -,-und- <xref:System.Drawing> Namespaces importiert werden. Ruft `InitializeMenu` den-Konstruktor oder die-Methode des Formulars auf `Load` .  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Menü angibt, das dieses Menüelement enthält.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Menu" />, das das Menü darstellt, das dieses Menüelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft können Sie das- <xref:System.Windows.Forms.Menu> Objekt für ein Untermenü abrufen. Sie können das <xref:System.Windows.Forms.Menu> von dieser Eigenschaft zurückgegebene-Objekt in ein- <xref:System.Windows.Forms.MenuItem> Objekt umwandeln, um es zu bearbeiten.
  
## Examples  
 In diesem Beispiel erstellen Sie ein Hauptmenü und ein Menü Element der obersten Ebene `menuItem1` ( `File` ). Außerdem erstellen Sie zwei Menü Elemente: `menuItem2` ( `New` ) und `menuItem3` ( `Open` ) und fügen Sie der Menü Elementliste von hinzu `menuItem1` . Dann überprüfen Sie, ob `menuItem3` ein übergeordnetes Menü hat, das true ist, und zeigt die Informationen zu diesem übergeordneten Menü im Meldungs Feld an. Dieses Beispiel erfordert, dass Sie einen mit dem Namen erstellt haben <xref:System.Windows.Forms.Form> `Form1` .  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generiert ein <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis für <see cref="T:System.Windows.Forms.MenuItem" />, wobei ein Mausklick durch einen Benutzer simuliert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Menü verwenden, um ein Menü Element durch Code zu aktivieren, ohne Ereignis Informationen zu übergeben. Wenn Sie z. b. ein Menü Element auf der Grundlage einer in der Anwendung auftretende Aktion aktivieren möchten, können Sie die- <xref:System.Windows.Forms.MenuItem.PerformClick%2A> Methode für dieses-Element aufzurufen <xref:System.Windows.Forms.MenuItem> .
  
## Examples  
 In diesem Beispiel klicken Sie Programm gesteuert auf ein Menü Element, indem Sie die- `PerformClick` Methode verwenden. Zuerst erstellen Sie ein Hauptmenü ( `mainMenu1` ) und fügen diesem zwei Menü Elemente hinzu: `menuItem1` ( `File` ) und `menuItem2` ( `Edit` ). Außerdem verwenden Sie das- <xref:System.Windows.Forms.MenuItem.Click> Ereignis, um Daten an den Ereignishandler zu senden, wenn auf ein Menü Element geklickt wird. Anschließend verwenden Sie die- `PerformClick` Methode, um auf das `File` Menü Element zu klicken. Wenn Sie die Anwendung starten, `File` wird das Menü Element aktiviert, und es wird ein Meldungs Feld mit dem Text "das Menü Datei wird geklickt" angezeigt. wird auf dem Bildschirm angezeigt. Das Beispiel erfordert, dass Sie einen mit dem Namen erstellt haben <xref:System.Windows.Forms.Form> `Form1` .  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht es Ihnen, das-Ereignis zu erhöhen, <xref:System.Windows.Forms.MenuItem.Select> ohne Ereignis Informationen an den-Ereignishandler zu übergeben.
  
## Examples  
 In diesem Beispiel wählen Sie Programm gesteuert mithilfe der-Methode ein Menü Element aus `PerformSelect` . Zuerst erstellen Sie ein Hauptmenü ( `mainMenu1` ) und fügen diesem zwei Menü Elemente hinzu: `menuItem1` ( `File` ) und `menuItem2` ( `Edit` ). Außerdem verwenden Sie das- <xref:System.Windows.Forms.MenuItem.Select> Ereignis, um Daten an den Ereignishandler zu senden, wenn ein Menü Element ausgewählt wird. Anschließend verwenden Sie die- `PerformSelect` Methode, um das `File` Menü Element auszuwählen. Wenn Sie die Anwendung starten, `File` wird das Menü Element ausgewählt, und es wird ein Meldungs Feld mit dem Text "das Menü Datei ist ausgewählt" angezeigt. wird auf dem Bildschirm angezeigt. Das Beispiel erfordert, dass Sie einen mit dem Namen erstellt haben <xref:System.Windows.Forms.Form> `Form1` .  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Liste der Menüelemente eines Menüelements angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt nur auf, wenn ein Menü Element über unter Menü Elemente zum Anzeigen verfügt. Mit diesem Ereignishandler können Sie Menü Elemente basierend auf dem Zustand Ihrer Anwendung hinzufügen, entfernen, aktivieren, deaktivieren, überprüfen oder deaktivieren, bevor Sie angezeigt werden. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, das in angezeigt wird Im Beispiel wird bestimmt, ob `textBox1` ein <xref:System.Windows.Forms.TextBox> Steuerelement im Formular aktiviert ist, über den Eingabefokus verfügt und Text vor dem Aktivieren der <xref:System.Windows.Forms.MenuItem> Objekte ausgewählt ist. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem> -Objekte namens `menuCut` , und erstellt wurden `menuCopy` `menuDelete` .  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> bei Aktivierung statt eines Häkchens ein Optionsfeld anzeigt, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn statt eines Häkchens ein Optionsfeld angezeigt werden soll. <see langword="false" />, wenn bei Aktivierung des Menüelements das Standardhäkchen angezeigt werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häkchen implizieren nicht notwendigerweise einen gegenseitig ausschließenden Zustand für eine Gruppe von Menü Elementen. Sie können diese Eigenschaft verwenden, um dem Benutzer mitzuteilen, dass das Häkchen eines Menü Elements sich gegenseitig ausschließt.
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Windows.Forms.MenuItem.Checked%2A> Eigenschaft verwendet, um den Zustand einer Anwendung zu ändern. Im Beispiel wird eine Gruppe von Menü Elementen bereitgestellt, die zum Angeben der Farbe für den Text in einem-Steuerelement verwendet werden <xref:System.Windows.Forms.TextBox> . Im Beispiel wird der angegebene Ereignishandler vom- <xref:System.Windows.Forms.MenuItem.Click> Ereignis der drei Menü Elemente verwendet. Jedes Menü Element gibt eine Farbe, `menuItemRed` , `menuItemGreen` oder an `menuItemBlue` . Der Ereignishandler bestimmt, auf welches Menü Element geklickt wurde, platziert ein Häkchensymbol für das ausgewählte Menü Element und ändert die Textfarbe des Formular Steuer Elements mit dem <xref:System.Windows.Forms.TextBox> Namen `textBox1` . Im Beispiel wird auch die- <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> Eigenschaft verwendet, um zu veranschaulichen, wie eine Optionsfeld Überprüfung zum Anzeigen von Menü Elementen verwendet wird, die sich gegenseitig ausschließen. Dieses Beispiel setzt voraus, dass der- <xref:System.Drawing?displayProperty=nameWithType> Namespace dem Formular hinzugefügt wurde, das diesen Code enthält.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger auf ein Menüelement gesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird normalerweise ausgelöst, wenn der Benutzer den Mauszeiger über dem Menü Element platziert. Das Ereignis kann auch ausgelöst werden, wenn der Benutzer mithilfe der Tastatur ein Menü Element hervorhebt, indem er mit den Pfeiltasten einen Bildlauf zum Menü Element durchführt. Sie können dieses Ereignis verwenden, um eine ausführliche Hilfe Zeichenfolge für dieses Menü Element in der Statusleiste einer Anwendung anzuzeigen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).  
  
> [!NOTE]
> Wenn die- <xref:System.Windows.Forms.Menu.MenuItems%2A> Eigenschaft für <xref:System.Windows.Forms.MenuItem> Elemente Elemente enthält, wird dieses Ereignis nicht ausgelöst. Dieses Ereignis wird nicht für übergeordnete Menü Elemente ausgelöst.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das- <xref:System.Windows.Forms.MenuItem.Select> Ereignis der-Klasse verwendet wird <xref:System.Windows.Forms.MenuItem> , um einen Hilfetext einem eines-Steuer Elements zuzuweisen <xref:System.Windows.Forms.StatusBarPanel> <xref:System.Windows.Forms.StatusBar> . Für dieses Beispiel ist es erforderlich, dass <xref:System.Windows.Forms.MenuItem> `menuOpen` `menuSave` -Objekte mit den Namen, und `menuExit` einem Steuerelement <xref:System.Windows.Forms.MainMenu> in einem Formular hinzugefügt werden. Das Beispiel erfordert auch, dass ein- <xref:System.Windows.Forms.StatusBar> Steuerelement `statusBar1` mit dem Namen dem Formular hinzugefügt wurde. Das- <xref:System.Windows.Forms.StatusBar> Steuerelement muss einen enthalten <xref:System.Windows.Forms.StatusBarPanel> .  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die dem Menüelement zugeordnete Tastenkombination angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte. Der Standardwert ist <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe von Tastenkombinationen können Benutzer häufig verwendete Menü Elemente im Menüsystem aktivieren und Tastatur Zugriff auf Ihre Anwendung für Benutzer bereitstellen, die keinen Zugriff auf eine Maus oder ein anderes Zeiger Gerät haben.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> erstellt wurde, die den Namen hat `menuItem1` .  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die dem Menüelement zugeordnete Tastenkombination neben der Beschriftung des Menüelements angezeigt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Tastenkombination neben der Beschriftung des Menüelements angezeigt wird. <see langword="false" />, wenn die Tastenkombination nicht angezeigt werden soll. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um Benutzern die Möglichkeit zu geben, Verknüpfungen aus Menüs auszublenden, um Menü Fläche zu sparen oder eine Tastenkombination auszublenden.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> erstellt wurde, die den Namen hat `menuItem1` .  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Beschriftung des Menüelements angibt, oder legt diesen fest.</summary>
        <value>Der Beschriftungstext des Menüelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "&file" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn diese Eigenschaft auf " `-` " festgelegt wird, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> erstellt wurde, die den Namen hat `menuItem1` .  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den <see cref="T:System.Windows.Forms.MenuItem" /> darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle <see cref="T:System.Windows.Forms.MenuItem" /> darstellt. Die Zeichenfolge enthält den Typ und die <see cref="P:System.Windows.Forms.MenuItem.Text" />-Eigenschaft des Steuerelements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement sichtbar ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement im Menü sichtbar gemacht wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft können Sie eine Menüstruktur ändern, ohne Menüs zusammenführen oder Menüs deaktivieren zu müssen. Wenn Sie z. b. einen kompletten Abschnitt der Funktionalität aus den Menüs für die Anwendung ausblenden möchten, können Sie diese für den Benutzer ausblenden, indem Sie diese Eigenschaft auf festlegen `false` .
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> erstellt wurde, die den Namen hat `menuItem1` .  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
