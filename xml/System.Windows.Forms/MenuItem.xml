<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a8a9b235668873a14cdf86da23f9c212168be5a2" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75178523" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein einzelnes Element dar, das in einem <see cref="T:System.Windows.Forms.MainMenu" /> oder einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird. Obwohl <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> das <see cref="T:System.Windows.Forms.MenuItem" />-Steuerelement vorheriger Versionen ersetzt und funktionell erweitert, wird das <see cref="T:System.Windows.Forms.MenuItem" />-Steuerelement sowohl aus Gründen der Abwärtskompatibilität als auch, falls gewünscht, für die zukünftige Verwendung beibehalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit eine <xref:System.Windows.Forms.MenuItem> angezeigt werden kann, müssen Sie Sie einer <xref:System.Windows.Forms.MainMenu> oder <xref:System.Windows.Forms.ContextMenu>hinzufügen. Zum Erstellen von Untermenüs können Sie <xref:System.Windows.Forms.MenuItem> Objekte der <xref:System.Windows.Forms.Menu.MenuItems%2A>-Eigenschaft des übergeordneten <xref:System.Windows.Forms.MenuItem>hinzufügen.  
  
 Die <xref:System.Windows.Forms.MenuItem>-Klasse stellt Eigenschaften bereit, die es Ihnen ermöglichen, das Aussehen und die Funktionalität eines Menü Elements zu konfigurieren. Wenn Sie ein Häkchen neben einem Menü Element anzeigen möchten, verwenden Sie die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft. Mit dieser Funktion können Sie ein Menü Element identifizieren, das in einer Liste von sich gegenseitig ausschließenden Menü Elementen ausgewählt ist. Wenn Sie z. b. über eine Reihe von Menü Elementen verfügen, um die Textfarbe in einem <xref:System.Windows.Forms.TextBox>-Steuerelement festzulegen, können Sie die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft verwenden, um zu ermitteln, welche Farbe aktuell ausgewählt ist. Die <xref:System.Windows.Forms.MenuItem.Shortcut%2A>-Eigenschaft kann verwendet werden, um eine Tastenkombination zu definieren, die gedrückt werden kann, um das Menü Element auszuwählen.  
  
 Bei <xref:System.Windows.Forms.MenuItem> Objekten, die in einer MDI-Anwendung (Multiple Document Interface) angezeigt werden, können Sie die <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>-Methode verwenden, um die Menüs eines übergeordneten MDI-Elements für mit dem ihrer untergeordneten Formulare zusammenzuführen, um eine konsolidierte Menüstruktur zu erstellen. Da eine <xref:System.Windows.Forms.MenuItem> nicht an mehreren Speicherorten gleichzeitig wieder verwendet werden kann, z. b. in einem <xref:System.Windows.Forms.MainMenu> und einem <xref:System.Windows.Forms.ContextMenu>, können Sie die <xref:System.Windows.Forms.MenuItem.CloneMenu%2A>-Methode verwenden, um eine Kopie eines <xref:System.Windows.Forms.MenuItem> zur Verwendung an einem anderen Speicherort zu erstellen.  
  
 Mit dem <xref:System.Windows.Forms.MenuItem.Popup>-Ereignis können Sie Aufgaben ausführen, bevor ein Menü angezeigt wird. Beispielsweise können Sie einen Ereignishandler für dieses Ereignis erstellen, um Menü Elemente basierend auf dem Zustand des Codes anzuzeigen oder auszublenden. Mit dem <xref:System.Windows.Forms.MenuItem.Select>-Ereignis können Sie Aufgaben ausführen, z. b. Ausführliche Hilfe zu den Menü Elementen Ihrer Anwendung bereitstellen, wenn der Benutzer den Mauszeiger über ein Menü Element bewegt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Menüstruktur für ein Formular erstellt. Im Beispielcode wird ein <xref:System.Windows.Forms.MenuItem> hinzugefügt, das das Menü Element der obersten Ebene darstellt, ein unter Menü Element zur Auswahl eines Schrift Grads hinzufügt und dann zwei unter Menü Elemente zu diesem Menü Element hinzufügt, die große und kleine Schriftart Optionen in einer Anwendung darstellen. Für das Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.MainMenu> Objekt mit dem Namen `mainMenu1` und vier <xref:System.Windows.Forms.MenuItem> Objekte mit den Namen `menuItem1`, `menuItem2`, `menuItem3`und `menuItem4`vorhanden sind.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert ein <see cref="T:System.Windows.Forms.MenuItem" /> mit leerer Beschriftung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem Sie mit diesem Konstruktor eine leere <xref:System.Windows.Forms.MenuItem> erstellt haben, können Sie die Eigenschaften und Methoden der <xref:System.Windows.Forms.MenuItem>-Klasse verwenden, um die Darstellung und das Verhalten der <xref:System.Windows.Forms.MenuItem>anzugeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> mit dieser Version des-Konstruktors erstellt.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element mit dem `text`-Parameter angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie ein "&"-Zeichen vor dem Zeichen platzieren, das als Zugriffstaste verwendet werden soll. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn Sie den `text`-Parameter auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> erstellt, die die Beschriftung des Menü Elements angibt, wenn es erstellt wird.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Ereignishandler für das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis des Menüelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element mit dem `text`-Parameter angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, ein "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn Sie den `text`-Parameter auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen Delegaten anzugeben, der das <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das erstellte Menü Element behandelt. Die <xref:System.EventHandler>, die Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das <xref:System.Windows.Forms.MenuItem.Click> Ereignis verarbeiten kann. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.MenuItem>-Objekt mit einer angegebenen Beschriftung und einem <xref:System.EventHandler> Delegaten erstellt, der mit einem Ereignishandler verbunden ist, der das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis für das Menü Element behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung und einem Array von Untermenüelementen, die für das Menüelement definiert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element mit dem `text`-Parameter angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, ein "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn Sie den `text`-Parameter auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Mit dem `items`-Parameter können Sie ein Array von Menü Elementen zuweisen, um ein Untermenü dieses Menü Elements zu definieren. Jedem Element im Array kann auch ein Array von Menü Elementen zugewiesen werden. Dies ermöglicht es Ihnen, komplette Menüstrukturen zu erstellen und Sie dem Konstruktor für das Menü Element zuzuweisen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein-Objekt mit einer angegebenen Beschriftung erstellt, einem Ereignishandler, der mit einer Methode verbunden ist, die das Ereignis der einzelnen Menü Elemente in einem Array von unter Menü Elementen behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der Klasse mit einer angegebenen Beschriftung, einem Ereignishandler und einer zugeordneten Tastenkombination für das Menüelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element mit dem `text`-Parameter angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, ein "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen. Dieser Konstruktor ermöglicht Ihnen außerdem, zusätzlich zu einer Zugriffstaste eine Tastenkombination anzugeben, um die Tastaturnavigation zu ermöglichen. Mit Tastenkombinationen können Sie eine Kombination von Schlüsseln angeben, mit denen das Menü Element aktiviert werden kann.  
  
 Wenn Sie den `text`-Parameter auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen Delegaten anzugeben, der das <xref:System.Windows.Forms.MenuItem.Click> Ereignis für das erstellte Menü Element behandelt. Die <xref:System.EventHandler>, die Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das <xref:System.Windows.Forms.MenuItem.Click> Ereignis verarbeiten kann. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein-Objekt mit einer angegebenen Beschriftung, einer angegebenen Tastenkombination und einem Ereignishandler erstellt, der mit einer Methode verbunden ist, die das-Ereignis für das Menü Element behandelt.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Einer der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</param>
        <param name="mergeOrder">Die relative Position, die dieses Menüelement in einem zusammengeführten Menü einnimmt.</param>
        <param name="shortcut">Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</param>
        <param name="text">Die Beschriftung für das Menüelement.</param>
        <param name="onClick">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Click" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onPopup">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Popup" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="onSelect">Der <see cref="T:System.EventHandler" />, der das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement behandelt.</param>
        <param name="items">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, das die Untermenüelemente für dieses Menüelement enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse mit einer angegebenen Beschriftung, definierten Ereignishandlern für die Ereignisse <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> und <see cref="E:System.Windows.Forms.MenuItem.Popup" />, einer Tastenkombination, einem Zusammenführungstyp und einer Zusammenführungsfolge, die für das Menüelement angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element mit dem `text`-Parameter angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, ein "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn Sie den `text`-Parameter auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
 Mit dem `items`-Parameter können Sie ein Array von Menü Elementen zuweisen, um ein Untermenü dieses Menü Elements zu definieren. Jedem Element im Array kann auch ein Array von Menü Elementen zugewiesen werden. Dies ermöglicht es Ihnen, komplette Menüstrukturen zu erstellen und Sie dem Konstruktor für das Menü Element zuzuweisen.  
  
 Mit den Parametern `mergeType` und `mergeOrder` können Sie feststellen, wie sich dieses Menü Element verhält, wenn das Menü Element mit einem anderen Menü zusammengeführt wird. Abhängig von dem Wert, den Sie für den `mergeType`-Parameter angeben, können Sie das Menü Element und seine unter Menü Elemente mit dem Menü, mit dem es zusammengeführt wird, hinzufügen, entfernen, ersetzen oder zusammenführen. Der `mergeOrder`-Parameter bestimmt, wo das zu erstellende Menü Element positioniert wird, wenn das Menü zusammengeführt wird.  
  
 Außerdem können Sie diesen Konstruktor verwenden, um einen <xref:System.Windows.Forms.MenuItem> zu erstellen und ihn mit einem Ereignishandler im Code zu verbinden, der den Klick des Menü Elements verarbeitet. Die <xref:System.EventHandler>, die Sie an diesen Konstruktor übergeben, muss so konfiguriert werden, dass ein Ereignishandler aufgerufen wird, der das <xref:System.Windows.Forms.MenuItem.Click> Ereignis verarbeiten kann. Mit dieser Konstruktorversion können Sie auch die <xref:System.Windows.Forms.MenuItem.Popup>-und <xref:System.Windows.Forms.MenuItem.Select> Ereignisse verbinden, um zu bestimmen, wann dieses Menü Element ausgewählt ist. Diese Ereignisse können für Aufgaben verwendet werden, z. b. die Bestimmung, ob ein Häkchen neben unter Menü Elementen angezeigt werden soll oder ob Menü Elemente basierend auf dem Zustand der Anwendung aktiviert oder deaktiviert werden sollen. Die <xref:System.Windows.Forms.MenuItem.Select>-und <xref:System.Windows.Forms.MenuItem.Click> Ereignisse werden nur für <xref:System.Windows.Forms.MenuItem> Objekte ausgelöst, bei denen es sich nicht um übergeordnete Menü Elemente handelt. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, das über eine Beschriftung und eine Tastenkombination verfügt. Das Menü Element enthält auch Ereignishandler, die für die Ereignisse <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>und <xref:System.Windows.Forms.MenuItem.Select> definiert sind. Wenn dieses Menü Element zusammengeführt wird, wird das Menü Element dem Menü mit der mergereihenfolge null hinzugefügt.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Untermenüelement oder Menüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.BarBreak%2A>-Eigenschaft verwenden, um ein Menü zu erstellen, in dem jedes Menü Element horizontal und nicht in einer vertikalen Liste nebeneinander platziert wird. Sie können diese Eigenschaft auch verwenden, um eine Menüleiste zu erstellen, die mehrere Zeilen mit Menü Elementen der obersten Ebene enthält.  
  
 Diese Eigenschaft unterscheidet sich von der <xref:System.Windows.Forms.MenuItem.Break%2A>-Eigenschaft darin, dass eine Leiste am linken Rand jedes Menü Elements angezeigt wird, für das die <xref:System.Windows.Forms.MenuItem.Break%2A>-Eigenschaft auf `true`festgelegt ist. Der Balken wird nur angezeigt, wenn das Menü Element kein Menü Element der obersten Ebene ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> mit zwei unter Menü Elementen erstellt. Die beiden unter Menü Elemente werden horizontal und nicht vertikal mithilfe der <xref:System.Windows.Forms.MenuItem.BarBreak%2A>-Eigenschaft angezeigt.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Element in einer neuen Zeile platziert wird (für ein Menüelement, das einem <see cref="T:System.Windows.Forms.MainMenu" />-Objekt hinzugefügt wurde) oder ob es in einer neuen Spalte platziert wird (für ein Menüelement oder Untermenüelement, das in einem <see cref="T:System.Windows.Forms.ContextMenu" /> angezeigt wird), oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement in einer neuen Zeile oder Spalte platziert wird; <see langword="false" />, wenn das Menüelement an seiner Standardposition verbleibt. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.Break%2A>-Eigenschaft verwenden, um ein Menü zu erstellen, in dem jedes Menü horizontal und nicht in einer vertikalen Liste nebeneinander platziert wird. Sie können diese Eigenschaft auch verwenden, um eine Menüleiste zu erstellen, die mehrere Zeilen mit Menü Elementen der obersten Ebene enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü mit zwei Menü Elementen der obersten Ebene in der obersten Zeile und einem Menü Element in der untersten Zeile erstellt.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob neben dem Text des Menüelements ein Häkchen angezeigt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement mit einem Häkchen versehen ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft in Kombination mit anderen Menü Elementen in einem Menü verwenden, um den Zustand für eine Anwendung bereitzustellen. Beispielsweise können Sie ein Häkchen für ein Menü Element in einer Gruppe von Elementen platzieren, um die Größe der Schriftart zu identifizieren, die für den Text in einer Anwendung angezeigt werden soll. Sie können auch die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft verwenden, um das ausgewählte Menü Element in einer Gruppe von sich gegenseitig ausschließenden Menü Elementen zu identifizieren.  
  
> [!NOTE]
>  Diese Eigenschaft kann für Menü Elemente der obersten Ebene nicht auf `true` festgelegt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft verwendet, um den Status in einer Anwendung bereitzustellen. In diesem Beispiel wird eine Gruppe von Menü Elementen verwendet, um die Farbe für den Text in einem <xref:System.Windows.Forms.TextBox> Steuerelement anzugeben. Der angegebene Ereignishandler wird vom <xref:System.Windows.Forms.MenuItem.Click>-Ereignis von drei Menü Elementen verwendet. Jedes Menü Element gibt eine Textfarbe an, `menuItemRed` (rot), `menuItemGreen` (grün) oder `menuItemBlue` (blau). Der Ereignishandler bestimmt, auf welches Menü Element geklickt wurde, platziert ein Häkchensymbol für das ausgewählte Menü Element und ändert die Textfarbe des <xref:System.Windows.Forms.TextBox> Steuer Elements des Formulars. Das Beispiel setzt voraus, dass der <xref:System.Drawing>-Namespace dem Formular hinzugefügt wurde, in dem dieser Code platziert wird. Das Beispiel erfordert auch, dass ein <xref:System.Windows.Forms.TextBox> dem Formular hinzugefügt wurde, in dem sich dieser Beispielcode befindet, der als `textBox1`bezeichnet wird.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <see cref="T:System.Windows.Forms.MenuItem" /> ist ein Menü der obersten Ebene oder verfügt über untergeordnete Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn auf das Menüelement geklickt wird oder wenn es unter Verwendung einer für das Menüelement definierten Tastenkombination oder Zugriffstaste ausgewählt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.MenuItem.Click> Ereignis tritt auf, wenn der Benutzer auf diesen <xref:System.Windows.Forms.MenuItem> klickt. Dieses Ereignis tritt auch auf, wenn der Benutzer das Menü Element mithilfe der Tastatur auswählt und die EINGABETASTE drückt. Dies kann auch vorkommen, wenn eine Zugriffstaste oder eine Tastenkombination gedrückt wird, die dem <xref:System.Windows.Forms.MenuItem>zugeordnet ist. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Menu.MenuItems%2A>-Eigenschaft für die <xref:System.Windows.Forms.MenuItem> Elemente enthält, wird dieses Ereignis nicht ausgelöst. Dieses Ereignis wird nicht für übergeordnete Menü Elemente ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis zum Ausführen von Aufgaben verwendet wird, wenn auf eine <xref:System.Windows.Forms.MenuItem> geklickt wird. Im Beispiel wird eine <xref:System.Windows.Forms.MainMenu> mit dem Namen `mainMenu1` erstellt und zwei <xref:System.Windows.Forms.MenuItem>-Objekte hinzugefügt, `topMenuItem` (`File`) und `menuItem1` (`Open`). Anschließend wird das `Click`-Ereignis mit dem Ereignishandler `menuItem1_Click` verbunden. Wenn der Benutzer auf das Menü Element `Open` klickt, wird ein <xref:System.Windows.Forms.OpenFileDialog> initialisiert und angezeigt. Das Beispiel erfordert, dass Sie eine <xref:System.Windows.Forms.Form> mit dem Namen `Form1`erstellt haben.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Kopie einer <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das duplizierte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> Objekte können nicht an mehr als einem Ort verwendet werden, es sei denn, Sie erhalten eine Kopie des <xref:System.Windows.Forms.MenuItem>. Diese Methode kann aufgerufen werden, um eine Kopie dieses Menü Elements für die Verwendung in einem <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>oder anderen <xref:System.Windows.Forms.MenuItem> in der Anwendung zu erstellen. Wenn ein Menü Element geklont wird, funktionieren alle im ursprünglichen Menü Element angegebenen Ereignishandler weiterhin in der geklonten Version des Menü Elements. Wenn Sie z. b. eine <xref:System.Windows.Forms.MenuItem> erstellt und das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis mit einem Ereignishandler verbunden haben. Wenn das Menü Element geklont wird, ruft das geklonte Menü Element denselben Ereignishandler auf.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.MenuItem> geklont und in einer <xref:System.Windows.Forms.ContextMenu>angezeigt. Das Beispiel setzt voraus, dass ein <xref:System.Windows.Forms.MenuItem> in einem <xref:System.Windows.Forms.MainMenu> in einem Formular mit dem Namen `menuItem1` vorhanden ist und dass ein <xref:System.Windows.Forms.ContextMenu> Objekt mit dem Namen `contextMenu1` auch im Formular vorhanden ist.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Das <see cref="T:System.Windows.Forms.MenuItem" />, das das zu kopierende Menüelement darstellt.</param>
        <summary>Erstellt eine Kopie des angegebenen <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, um Kopien von Menü Elementen zu erstellen, die Sie bereits für die Verwendung in einem Kontextmenü oder einer anderen Menüstruktur in der Anwendung erstellt haben. Mit dieser Version von <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> können Sie ein bestimmtes <xref:System.Windows.Forms.MenuItem> angeben, das kopiert werden soll, statt das Menü Element, das die-Methode aufgerufen hat. Mit dieser Methode können Sie ein neues <xref:System.Windows.Forms.MenuItem>-Objekt mit einer Kopie einer anderen <xref:System.Windows.Forms.MenuItem>initialisieren. Wenn ein Menü Element geklont wird, funktionieren alle im ursprünglichen Menü Element angegebenen Ereignishandler weiterhin in der geklonten Version des Menü Elements. Wenn Sie z. b. eine <xref:System.Windows.Forms.MenuItem> erstellt und das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis mit einem Ereignishandler verbunden haben. Wenn das Menü Element geklont wird, ruft das geklonte Menü Element denselben Ereignishandler auf.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine neue <xref:System.Windows.Forms.MenuItem> mit einer Kopie eines vorhandenen <xref:System.Windows.Forms.MenuItem> initialisiert, das in einem <xref:System.Windows.Forms.MainMenu> in einem Formular verwendet wird. Der Code fügt dann die geklonten <xref:System.Windows.Forms.MenuItem> einem <xref:System.Windows.Forms.ContextMenu> im Formular hinzu. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.MenuItem> bereits erstellt wurde und `menuItem1` heißt und dass ein <xref:System.Windows.Forms.ContextMenu>-Steuerelement erstellt und mit dem Namen `contextMenu1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement das Standardmenüelement ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement das Standardelement in einem Menü ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardmenü Element für ein Menü ist "Bold". Wenn der Benutzer auf ein Untermenü doppelklickt, das ein Standardelement enthält, wird das Standardelement ausgewählt, und das Untermenü ist geschlossen. Sie können die <xref:System.Windows.Forms.MenuItem.DefaultItem%2A>-Eigenschaft verwenden, um anzugeben, die Standardaktion, die in einem Menü oder Kontextmenü erwartet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element mit zwei unter Menü Elementen erstellt. Im Beispiel wird `menuItem2` mithilfe der <xref:System.Windows.Forms.MenuItem.DefaultItem%2A>-Eigenschaft als Standardmenü Element festgelegt.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Windows.Forms.MenuItem" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, wenn Sie <xref:System.Windows.Forms.MenuItem> nicht mehr benötigen. Die <xref:System.Windows.Forms.MenuItem.Dispose%2A>-Methode bewirkt, dass <xref:System.Windows.Forms.MenuItem> nicht mehr verwendet werden kann. Nachdem Sie <xref:System.Windows.Forms.MenuItem.Dispose%2A>aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Windows.Forms.MenuItem> freigeben, damit der Arbeitsspeicher, den Sie belegen, von Garbage Collection freigegeben werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Windows.Forms.MenuItem.Dispose%2A> auf, bevor Sie den letzten Verweis auf das <xref:System.Windows.Forms.MenuItem> freigeben. Andernfalls werden die Ressourcen, die von der <xref:System.Windows.Forms.MenuItem> verwendet werden, erst freigegeben, wenn Garbage Collection den Dekonstruktor des <xref:System.Windows.Forms.MenuItem> Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />-Eigenschaft eines Menüelements auf <see langword="true" /> festgelegt ist und das Zeichnen des Menüelements angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.DrawItemEventArgs> Argument, das an einen <xref:System.Windows.Forms.MenuItem.DrawItem>-Ereignishandler weitergegeben wird, stellt ein <xref:System.Drawing.Graphics> Objekt bereit, das es Ihnen ermöglicht, Zeichen und andere grafische Vorgänge auf der Oberfläche des Menü Elements auszuführen. Mit diesem Ereignishandler können Sie benutzerdefinierte Menüs erstellen, die den Anforderungen Ihrer Anwendung entsprechen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.DrawItem>-Ereignis behandelt wird. In diesem Beispiel wird ein Menü Element mithilfe eines <xref:System.Drawing.Brush> und eines <xref:System.Drawing.Font>gezeichnet, und dann wird ein <xref:System.Drawing.Rectangle> um das Menü Element gezeichnet. Die Zeichnung wird über das <xref:System.Drawing.Graphics>-Objekt ausgeführt, das an den-Ereignishandler im <xref:System.Windows.Forms.DrawItemEventArgs>-Parameter übergeben wird. Für dieses Beispiel ist es erforderlich, dass Sie die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>-Eigenschaft für das Element initialisiert haben, um `true`. Fügen Sie C# im folgenden Beispiel den folgenden Code im Konstruktor des Formulars nach dem `InitializeComponent`ein, um das Ereignis zu verbinden:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Forms.MenuItem>, die deaktiviert ist, wird in grau Farben angezeigt, um deren Status anzugeben. Wenn ein übergeordnetes Menü Element deaktiviert ist, werden alle unter Menü Elemente nicht angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, in dem Sie angezeigt werden Im Beispiel wird festgelegt, ob `textBox1`, ein <xref:System.Windows.Forms.TextBox> Steuerelement auf dem Formular aktiviert ist, über den Eingabefokus verfügt und Text ausgewählt ist, bevor die <xref:System.Windows.Forms.MenuItem> Objekte aktiviert werden. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem>-Objekte mit dem Namen `menuCut`, `menuCopy`erstellt und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Position des Menüelements im übergeordneten Menü angibt, oder legt diesen fest.</summary>
        <value>Der nullbasierte Index, der die Position des Menüelements im übergeordneten Menü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die indizierte Position eines Menü Elements in der Menü Element Auflistung des übergeordneten Menüs bereit. Mit dieser Eigenschaft können Sie ein Menü Element an einer anderen Position im Menü neu positionieren. Sie können diese Eigenschaft auch verwenden, wenn Sie eine <xref:System.Windows.Forms.MenuItem> erstellen, um die Position in einer Menüstruktur zum Zeitpunkt der Erstellung anzugeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Position von zwei Menü Elementen in einem Menü gewechselt. Im folgenden Codebeispiel ist es erforderlich, dass zwei <xref:System.Windows.Forms.MenuItem>-Objekte namens `menuItem1` und `menuItem2`erstellt werden. Das Menü Element `menuItem1` wird im Menü um eine Position nach unten verschoben, während `menuItem2` eine Position nach oben verschiebt.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der zugewiesene Wert ist kleiner als 0 (null) oder größer als die Elementanzahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement untergeordnete Menüelemente enthält.</summary>
        <value><see langword="true" />, wenn das Menüelement untergeordnete Menüelemente enthält. <see langword="false" />, wenn das Menü ein eigenständiges Menüelement ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft mit der <xref:System.Windows.Forms.MenuItem.Parent%2A>-Eigenschaft verwenden, um im Code durch eine gesamte Menüstruktur zu navigieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird festgelegt, ob Untermenüs vorhanden sind, die einer <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`zugeordnet sind. Wenn ein unter Menü vorhanden ist, werden diese deaktiviert, indem die <xref:System.Windows.Forms.MenuItem.Enabled%2A>-Eigenschaft auf `false`festgelegt wird. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement mit einer Liste der untergeordneten MDI-Fenster (Multiple Document Interface) aufgefüllt wird, die im zugeordneten Formular angezeigt werden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn eine Liste untergeordneter MDI-Fenster in diesem Menüelement angezeigt wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Menü Element ausgewählt wird, um eine Liste untergeordneter MDI-Fenster anzuzeigen, wird die Liste als Untermenü des Menü Elements angezeigt. Nur Formulare, die als untergeordnete MDI-Formulare definiert sind, werden in der Fensterliste angezeigt. Es können nur neun untergeordnete Fenster gleichzeitig angezeigt werden. Wenn mehr als neun untergeordnete Fenster angezeigt werden, wird ein "mehr Windows..." das Menü Element wird am Ende der Fensterliste angezeigt. Wenn Sie auf dieses Menü Element klicken, wird ein Dialogfeld mit einer kompletten Liste der untergeordneten Fenster angezeigt, die zurzeit aktiv sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> erstellt, die verwendet wird, um die Liste der derzeit geöffneten untergeordneten MDI-Formulare in einem MDI-Formular anzuzeigen.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn dem Menü die Größe eines Menüelements bekannt sein muss, bevor dieses gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit dieses Ereignis ausgelöst wird, muss die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>-Eigenschaft des Menü Elements auf `true`festgelegt sein. Dieses Ereignis wird ausgelöst, bevor die Menüs des Besitzers gezeichnet werden, damit die Größe des Menü Elements angegeben werden kann. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.MenuItem.MeasureItem> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.MenuItem> mit dem Namen `MenuItem1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.MenuItem.MeasureItem>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Windows-Bezeichner für dieses Menüelement angibt.</summary>
        <value>Der Windows-Bezeichner für dieses Menüelement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dieses <see cref="T:System.Windows.Forms.MenuItem" /> mit einem anderen <see cref="T:System.Windows.Forms.MenuItem" /> zusammen und gibt das sich ergebende zusammengeführte <see cref="T:System.Windows.Forms.MenuItem" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das zusammengeführte Menüelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Version von <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>aufgerufen haben, ist die zurückgegebene <xref:System.Windows.Forms.MenuItem> eine Kopie des aktuellen Menü Elements, das mit einem anderen Menü Element zusammengeführt werden kann, ohne dass sich dies auf die Funktionalität des aktuellen Elements auswirkt. Diese Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>-Methode ähnelt dem Aufrufen der <xref:System.Windows.Forms.MenuItem.CloneMenu%2A>-Methode, die keine Parameter enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Ein <see cref="T:System.Windows.Forms.MenuItem" />, das das mit diesem Menüelement zusammenzuführende Menüelement angibt.</param>
        <summary>Führt ein anderes Menüelement mit diesem Menüelement zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menü Elemente werden gemäß dem Wert der Eigenschaften des Menü Elements <xref:System.Windows.Forms.MenuItem.MergeType%2A> und <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> zusammengeführt. Diese Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>-Methode ermöglicht das Zusammenführen von zwei <xref:System.Windows.Forms.MenuItem> Objekten (und deren Untermenüs) zu einem Menü. Die Zusammenführung des Menüs wird automatisch durchgeführt, wenn ein übergeordnetes MDI-Formular (Multiple Document Interface) und ein untergeordnetes Element über Menüs verfügen. Sie können diese Version der-Methode verwenden, um zwei <xref:System.Windows.Forms.MenuItem> Objekte (und deren unter Menü Elemente), die sich in einem <xref:System.Windows.Forms.MainMenu>-Steuerelement befinden, in einem einzigen Menü innerhalb eines <xref:System.Windows.Forms.ContextMenu>zusammenzuführen. Beispielsweise können Sie diese Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>-Methode zum Zusammenführen der Menü Elemente einer Datei und eines Bearbeitungs Menüs in einem einzelnen <xref:System.Windows.Forms.MenuItem>, das dann einem <xref:System.Windows.Forms.ContextMenu>hinzugefügt und angezeigt werden kann, abrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Version der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>-Methode verwendet, um eine Kopie einer <xref:System.Windows.Forms.MenuItem> zu erstellen und mit einer anderen zu verbinden. Das zusammengeführte <xref:System.Windows.Forms.MenuItem> wird dann einem <xref:System.Windows.Forms.ContextMenu> Steuerelement hinzugefügt. Für dieses Beispiel ist es erforderlich, dass zwei Menü Elemente aufgerufen werden `menuItem1` und `menuItem2`, die unter Menü Elemente enthalten, sowie eine <xref:System.Windows.Forms.ContextMenu> namens `contextMenu1`, um die Menü Elemente anzuzeigen. `menuItem1` und `menuItem2` unterschiedliche Menü Elemente enthalten. Nachdem der <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> aufgerufen wurde, wird ein konsolidiertes Menü erstellt.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die relative Position des Menüelements beim Merge mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein nullbasierter Index, der die Position dieses Menüelements in der Merge-Ordnung darstellt. Der Standard ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Zusammenführung eines Menü Elements gibt die relative Position an, die dieses Menü Element annimmt, wenn die Menüstruktur, in der die <xref:System.Windows.Forms.MenuItem> enthalten ist, mit einer anderen zusammengeführt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.Windows.Forms.MenuItem.MergeOrder%2A>-Eigenschaft gesteuert wird, wie ein zusammen geführtes Menü angezeigt wird. Dies ist ein umfassendes Beispiel, das ausgeführt werden kann, sobald Sie es dem Projekt hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Verhalten dieses Menüelements beim Merge des Menüs mit einem anderen angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.MenuMerge" />-Wert, der den Zusammenführungstyp des Menüelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der mergetyp eines Menü Elements gibt an, wie sich das Menü Element verhält, wenn es dieselbe mergereihenfolge wie ein anderes Menü Element aufweist. Mithilfe von zusammengeführten Menüs können Sie ein konsolidiertes Menü erstellen, das auf zwei oder mehr vorhandenen Menüs basiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.MenuItem> mit dem <xref:System.Windows.Forms.MenuItem.MergeType%2A> und <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> angegeben, sodass das Menü Element dem zusammengeführten Menü an der ersten Position hinzugefügt wird.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.MenuMerge" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das diesem Menüelement zugeordnete mnemonische Zeichen angibt.</summary>
        <value>Ein Zeichen, das das diesem Menüelement zugeordnete mnemonische Zeichen darstellt. Gibt das NUL-Zeichen (ASCII-Wert 0) zurück, wenn im Text von <see cref="T:System.Windows.Forms.MenuItem" /> kein mnemonisches Zeichen angegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zeichen mnetmonisches Zeichen ist das erste Zeichen nach einem kaufmännischen und-Zeichen (&) im Text der <xref:System.Windows.Forms.MenuItem>. Diese Eigenschaft gibt kein mnetmonisches Zeichen zurück, wenn zwei kaufmännische und-Zeichen verknüpft werden, da die kaufmännische und-Zeichen verwendet werden, um ein kaufmännisches und-Zeichen im Text der <xref:System.Windows.Forms.MenuItem> anzuzeigen, anstatt ein mnetmonisches Zeichen zu definieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.Click" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis zum Ausführen von Aufgaben verwendet wird, wenn auf eine <xref:System.Windows.Forms.MenuItem> geklickt wird. Im Beispiel wird eine <xref:System.Windows.Forms.MainMenu> mit dem Namen `mainMenu1` erstellt und zwei <xref:System.Windows.Forms.MenuItem>-Objekte hinzugefügt, `topMenuItem` (`File`) und `menuItem1` (`Open`). Anschließend wird das `Click`-Ereignis mit dem Ereignishandler `menuItem1_Click` verbunden. Wenn der Benutzer auf das Menü Element `Open` klickt, wird ein <xref:System.Windows.Forms.OpenFileDialog> initialisiert und angezeigt. Das Beispiel erfordert, dass Sie eine <xref:System.Windows.Forms.Form> mit dem Namen `Form1`erstellt haben.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DrawItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInitMenuPopup (EventArgs e);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInitMenuPopup (e As EventArgs)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.Popup" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.Popup" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, in dem Sie angezeigt werden Im Beispiel wird festgelegt, ob `textBox1`, ein <xref:System.Windows.Forms.TextBox> Steuerelement auf dem Formular aktiviert ist, über den Eingabefokus verfügt und Text ausgewählt ist, bevor die <xref:System.Windows.Forms.MenuItem> Objekte aktiviert werden. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem>-Objekte mit dem Namen `menuCut`, `menuCopy`erstellt und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.Windows.Forms.MenuItem.Select" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Select>-Ereignis der <xref:System.Windows.Forms.MenuItem>-Klasse verwendet wird, um einem <xref:System.Windows.Forms.StatusBarPanel> eines <xref:System.Windows.Forms.StatusBar> Steuer Elements Hilfe Text zuzuweisen. Dieses Beispiel erfordert, dass <xref:System.Windows.Forms.MenuItem> Objekte mit dem Namen `menuOpen`, `menuSave`und `menuExit` zu einem <xref:System.Windows.Forms.MainMenu>-Steuerelement in einem Formular hinzugefügt werden. Das Beispiel erfordert auch, dass ein <xref:System.Windows.Forms.StatusBar>-Steuerelement mit dem Namen `statusBar1` dem Formular hinzugefügt wurde. Das <xref:System.Windows.Forms.StatusBar> Steuerelement sollte ein <xref:System.Windows.Forms.StatusBarPanel>enthalten.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement vom bereitgestellten Code oder von Windows gezeichnet wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement mithilfe von Code gezeichnet werden soll. <see langword="false" />, wenn das Menüelement von Windows gezeichnet werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>-Eigenschaft auf `true`festgelegt ist, müssen Sie alle Zeichnungen des Menü Elements verarbeiten. Sie können diese Funktion verwenden, um Ihre eigenen speziellen Menü anzeigen zu erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü mit einem vom Besitzer gezeichneten Menü Element veranschaulicht. In diesem Beispiel wird die <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>-Eigenschaft festgelegt und die `AddHandler`-Anweisung und der `AddressOf`-Operator verwendet, um einen Delegaten zur Behandlung des <xref:System.Windows.Forms.MenuItem.DrawItem> Ereignisses festzulegen. Um das Beispiel auszuführen, fügen Sie es in ein Formular ein, mit dem die <xref:System>-, <xref:System.Windows.Forms>-und <xref:System.Drawing>-Namespaces importiert werden. Ruft `InitializeMenu` aus dem Konstruktor des Formulars oder `Load` Methode auf.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Menü angibt, das dieses Menüelement enthält.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Menu" />, das das Menü darstellt, das dieses Menüelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft können Sie das <xref:System.Windows.Forms.Menu>-Objekt für ein Untermenü abrufen. Sie können das <xref:System.Windows.Forms.Menu> Objekt, das von dieser Eigenschaft zurückgegeben wird, in ein <xref:System.Windows.Forms.MenuItem> Objekt umwandeln, um es zu bearbeiten.  
  
   
  
## Examples  
 In diesem Beispiel erstellen Sie ein Hauptmenü und ein Menü Element der obersten Ebene, `menuItem1` (`File`). Außerdem erstellen Sie zwei Menü Elemente: `menuItem2` (`New`) und `menuItem3` (`Open`) und fügen Sie der Liste der Menü Elemente `menuItem1`hinzu. Dann überprüfen Sie, ob `menuItem3` ein übergeordnetes Menü erhalten hat, was true ist, und zeigt die Informationen zu diesem übergeordneten Menü im Meldungs Feld an. Für dieses Beispiel ist es erforderlich, dass Sie eine <xref:System.Windows.Forms.Form> mit dem Namen `Form1`erstellt haben.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generiert ein <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis für <see cref="T:System.Windows.Forms.MenuItem" />, wobei ein Mausklick durch einen Benutzer simuliert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Menü verwenden, um ein Menü Element durch Code zu aktivieren, ohne Ereignis Informationen zu übergeben. Wenn Sie z. b. ein Menü Element auf der Grundlage einer in der Anwendung auftretende Aktion aktivieren möchten, können Sie die <xref:System.Windows.Forms.MenuItem.PerformClick%2A>-Methode für diese <xref:System.Windows.Forms.MenuItem>abrufen.  
  
   
  
## Examples  
 In diesem Beispiel klicken Sie Programm gesteuert mit der `PerformClick`-Methode auf ein Menü Element. Zuerst erstellen Sie ein Hauptmenü (`mainMenu1`) und fügen diesem zwei Menü Elemente hinzu, `menuItem1` (`File`) und `menuItem2` (`Edit`). Außerdem verwenden Sie das <xref:System.Windows.Forms.MenuItem.Click>-Ereignis, um Daten an den Ereignishandler zu senden, wenn auf ein Menü Element geklickt wird. Anschließend verwenden Sie die `PerformClick`-Methode, um auf das Menü Element `File` zu klicken. Wenn Sie die Anwendung starten, wird das Menü Element `File` aktiviert, und es wird ein Meldungs Feld mit dem Text "das Menü Datei wird geklickt" angezeigt. wird auf dem Bildschirm angezeigt. Das Beispiel erfordert, dass Sie eine <xref:System.Windows.Forms.Form> mit dem Namen `Form1`erstellt haben.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Forms.MenuItem.Select" />-Ereignis für dieses Menüelement aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie das <xref:System.Windows.Forms.MenuItem.Select>-Ereignis erhöhen, ohne Ereignis Informationen an den-Ereignishandler zu übergeben.  
  
   
  
## Examples  
 In diesem Beispiel wählen Sie Programm gesteuert ein Menü Element aus, indem Sie die `PerformSelect`-Methode verwenden. Zuerst erstellen Sie ein Hauptmenü (`mainMenu1`) und fügen diesem zwei Menü Elemente hinzu, `menuItem1` (`File`) und `menuItem2` (`Edit`). Außerdem verwenden Sie das <xref:System.Windows.Forms.MenuItem.Select>-Ereignis, um Daten an den Ereignishandler zu senden, wenn ein Menü Element ausgewählt wird. Anschließend verwenden Sie die `PerformSelect`-Methode, um das Menü Element `File` auszuwählen. Wenn Sie die Anwendung starten, wird das Menü Element `File` ausgewählt, und es wird ein Meldungs Feld mit dem Text "das Menü Datei ist ausgewählt" angezeigt. wird auf dem Bildschirm angezeigt. Das Beispiel erfordert, dass Sie eine <xref:System.Windows.Forms.Form> mit dem Namen `Form1`erstellt haben.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Liste der Menüelemente eines Menüelements angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt nur auf, wenn ein Menü Element über unter Menü Elemente zum Anzeigen verfügt. Mit diesem Ereignishandler können Sie Menü Elemente basierend auf dem Zustand Ihrer Anwendung hinzufügen, entfernen, aktivieren, deaktivieren, überprüfen oder deaktivieren, bevor Sie angezeigt werden. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Popup> Ereignis verwendet wird, um zu bestimmen, ob <xref:System.Windows.Forms.MenuItem> Objekte, die Unterstützung für Ausschneide-, Kopier-und Löschvorgänge bieten, aktiviert sind, bevor das Menü angezeigt wird, in dem Sie angezeigt werden Im Beispiel wird festgelegt, ob `textBox1`, ein <xref:System.Windows.Forms.TextBox> Steuerelement auf dem Formular aktiviert ist, über den Eingabefokus verfügt und Text ausgewählt ist, bevor die <xref:System.Windows.Forms.MenuItem> Objekte aktiviert werden. Dieses Beispiel setzt voraus, dass drei <xref:System.Windows.Forms.MenuItem>-Objekte mit dem Namen `menuCut`, `menuCopy`erstellt und `menuDelete` erstellt wurden.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.MenuItem" /> bei Aktivierung statt eines Häkchens ein Optionsfeld anzeigt, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn statt eines Häkchens ein Optionsfeld angezeigt werden soll. <see langword="false" />, wenn bei Aktivierung des Menüelements das Standardhäkchen angezeigt werden soll. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häkchen implizieren nicht notwendigerweise einen gegenseitig ausschließenden Zustand für eine Gruppe von Menü Elementen. Sie können diese Eigenschaft verwenden, um dem Benutzer mitzuteilen, dass das Häkchen eines Menü Elements sich gegenseitig ausschließt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.MenuItem.Checked%2A>-Eigenschaft verwendet, um den Zustand einer Anwendung zu ändern. Im Beispiel wird eine Gruppe von Menü Elementen bereitgestellt, die verwendet werden, um die Farbe für den Text in einem <xref:System.Windows.Forms.TextBox> Steuerelement anzugeben. Im Beispiel wird der angegebene Ereignishandler vom <xref:System.Windows.Forms.MenuItem.Click>-Ereignis der drei Menü Elemente verwendet. Jedes Menü Element gibt eine Farbe, eine `menuItemRed`, `menuItemGreen`oder `menuItemBlue`an. Der Ereignishandler bestimmt, auf welches Menü Element geklickt wurde, platziert ein Häkchensymbol für das ausgewählte Menü Element und ändert die Textfarbe des <xref:System.Windows.Forms.TextBox> Steuer Elements des Formulars mit dem Namen `textBox1`. Im Beispiel wird auch die <xref:System.Windows.Forms.MenuItem.RadioCheck%2A>-Eigenschaft verwendet, um zu veranschaulichen, wie eine Optionsfeld Überprüfung zum Anzeigen von Menü Elementen verwendet wird, die sich gegenseitig ausschließen. Dieses Beispiel setzt voraus, dass der <xref:System.Drawing?displayProperty=nameWithType>-Namespace dem Formular hinzugefügt wurde, das diesen Code enthält.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger auf ein Menüelement gesetzt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird normalerweise ausgelöst, wenn der Benutzer den Mauszeiger über dem Menü Element platziert. Das Ereignis kann auch ausgelöst werden, wenn der Benutzer mithilfe der Tastatur ein Menü Element hervorhebt, indem er mit den Pfeiltasten einen Bildlauf zum Menü Element durchführt. Sie können dieses Ereignis verwenden, um eine ausführliche Hilfe Zeichenfolge für dieses Menü Element in der Statusleiste einer Anwendung anzuzeigen. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Wenn die <xref:System.Windows.Forms.Menu.MenuItems%2A>-Eigenschaft für die <xref:System.Windows.Forms.MenuItem> Elemente enthält, wird dieses Ereignis nicht ausgelöst. Dieses Ereignis wird nicht für übergeordnete Menü Elemente ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.MenuItem.Select>-Ereignis der <xref:System.Windows.Forms.MenuItem>-Klasse verwendet wird, um einem <xref:System.Windows.Forms.StatusBarPanel> eines <xref:System.Windows.Forms.StatusBar> Steuer Elements Hilfe Text zuzuweisen. Dieses Beispiel erfordert, dass <xref:System.Windows.Forms.MenuItem> Objekte mit dem Namen `menuOpen`, `menuSave`und `menuExit` zu einem <xref:System.Windows.Forms.MainMenu>-Steuerelement in einem Formular hinzugefügt werden. Das Beispiel erfordert auch, dass ein <xref:System.Windows.Forms.StatusBar>-Steuerelement mit dem Namen `statusBar1` dem Formular hinzugefügt wurde. Das <xref:System.Windows.Forms.StatusBar> Steuerelement sollte ein <xref:System.Windows.Forms.StatusBarPanel>enthalten.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die dem Menüelement zugeordnete Tastenkombination angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.Shortcut" />-Werte. Der Standardwert ist <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe von Tastenkombinationen können Benutzer häufig verwendete Menü Elemente im Menüsystem aktivieren und Tastatur Zugriff auf Ihre Anwendung für Benutzer bereitstellen, die keinen Zugriff auf eine Maus oder ein anderes Zeiger Gerät haben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.Shortcut" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die dem Menüelement zugeordnete Tastenkombination neben der Beschriftung des Menüelements angezeigt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Tastenkombination neben der Beschriftung des Menüelements angezeigt wird. <see langword="false" />, wenn die Tastenkombination nicht angezeigt werden soll. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um Benutzern die Möglichkeit zu geben, Verknüpfungen aus Menüs auszublenden, um Menü Fläche zu sparen oder eine Tastenkombination auszublenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Beschriftung des Menüelements angibt, oder legt diesen fest.</summary>
        <value>Der Beschriftungstext des Menüelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Beschriftung für das Menü Element angeben, können Sie auch einen Zugriffsschlüssel angeben, indem Sie vor dem Zeichen, das als Zugriffstaste verwendet werden soll, eine "&" platzieren. Wenn Sie z. b. "F" als Zugriffsschlüssel in "file" angeben möchten, geben Sie die Beschriftung für das Menü Element als "& File" an. Mit dieser Funktion können Sie Tastaturnavigation für Ihre Menüs bereitstellen.  
  
 Wenn Sie diese Eigenschaft auf "`-`" festlegen, wird das Menü Element als Trennzeichen (eine horizontale Linie) anstelle eines Standardmenü Elements angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den <see cref="T:System.Windows.Forms.MenuItem" /> darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle <see cref="T:System.Windows.Forms.MenuItem" /> darstellt. Die Zeichenfolge enthält den Typ und die <see cref="P:System.Windows.Forms.MenuItem.Text" />-Eigenschaft des Steuerelements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Menüelement sichtbar ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Menüelement im Menü sichtbar gemacht wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft können Sie eine Menüstruktur ändern, ohne Menüs zusammenführen oder Menüs deaktivieren zu müssen. Wenn Sie z. b. einen kompletten Abschnitt der Funktionalität aus den Menüs für Ihre Anwendung ausblenden möchten, können Sie diese für den Benutzer ausblenden, indem Sie diese Eigenschaft auf `false`festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Menü Element erstellt, die Beschriftung festgelegt, eine Tastenkombination zugewiesen, das Menü Element sichtbar gemacht und die Tastenkombination für das Menü Element angezeigt. Das Beispiel setzt voraus, dass eine <xref:System.Windows.Forms.MenuItem> mit dem Namen `menuItem1`erstellt wurde.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
