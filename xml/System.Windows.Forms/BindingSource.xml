<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ed599a82100f17c22a302bd2f8614e457d71953" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51900407" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingSource&#xA;Inherits Component&#xA;Implements IBindingList, IBindingListView, ICancelAddNew, ICurrencyManagerProvider, IList, ISupportInitialize, ISupportInitializeNotification, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingSource : System::ComponentModel::Component, System::Collections::IList, System::ComponentModel::IBindingList, System::ComponentModel::IBindingListView, System::ComponentModel::ICancelAddNew, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::ComponentModel::ITypedList, System::Windows::Forms::ICurrencyManagerProvider" />
  <TypeSignature Language="F#" Value="type BindingSource = class&#xA;    inherit Component&#xA;    interface IBindingListView&#xA;    interface IBindingList&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ITypedList&#xA;    interface ICancelAddNew&#xA;    interface ISupportInitializeNotification&#xA;    interface ISupportInitialize&#xA;    interface ICurrencyManagerProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt die Datenquelle für ein Formular.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource> Komponente erfüllt viele Zwecke. Zunächst vereinfacht es in einem Formular an Daten binden von Steuerelementen durch währungsverwaltung, änderungsbenachrichtigung und andere Dienste zwischen Windows Forms-Steuerelemente und Datenquellen. Dies erfolgt durch Anfügen der <xref:System.Windows.Forms.BindingSource> Komponente mit Ihrer Datenquelle mit dem <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft. Sie können optional festlegen, komplexen Bindungsszenarios der <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um eine bestimmte Spalte oder Liste in der Datenquelle. Klicken Sie dann binden Sie Steuerelemente an die <xref:System.Windows.Forms.BindingSource>. Alle weiteren Interaktionen mit den Daten erfolgt durch Aufrufe der <xref:System.Windows.Forms.BindingSource> Komponente. Beispiele für die <xref:System.Windows.Forms.BindingSource> können die Bindung zu vereinfachen, finden Sie unter [Vorgehensweise: Binden von Windows Forms-Steuerelementen an DBNull-Datenbankwerte](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) und [wie: Behandeln von Fehlern und Ausnahmen, auftreten, mit der Datenbindung](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md). Navigation und Aktualisierung der Datenquelle erfolgt über Methoden wie z. B. <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, und <xref:System.Windows.Forms.BindingSource.Remove%2A>. Vorgänge wie das Sortieren und Filtern erfolgt über die <xref:System.Windows.Forms.BindingSource.Sort%2A> und <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaften. Weitere Informationen zum Sortieren und Filtern mit der <xref:System.Windows.Forms.BindingSource>, finden Sie unter [wie: Sortieren und Filtern ADO.NET-Daten mit der BindingSource-Komponente in Windows Forms](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md).  
  
 Darüber hinaus die <xref:System.Windows.Forms.BindingSource> -Komponente als stark typisierte Datenquelle fungieren kann. Der Typ der zugrunde liegenden Datenquelle wurde in der Regel über eine der folgenden Mechanismen behoben:  
  
-   Verwenden der <xref:System.Windows.Forms.BindingSource.Add%2A> Methode zum Hinzufügen eines Elements auf die <xref:System.Windows.Forms.BindingSource> Komponente.  
  
-   Legen Sie die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft, um eine Liste, einzelnes Objekt oder Typ.  
  
 Beide Mechanismen erstellt eine stark typisierte Liste. Weitere Informationen zur Verwendung der <xref:System.Windows.Forms.BindingSource> um an einen Typ binden, finden Sie unter [Vorgehensweise: Binden eines Windows Forms-Steuerelements an einen Typ](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). Sie können auch die <xref:System.Windows.Forms.BindingSource> , die Steuerelemente an ein Factoryobjekt binden. Weitere Informationen zu dieser Vorgehensweise finden Sie unter [Vorgehensweise: Binden eines Windows Forms-Steuerelements an ein Factoryobjekt](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md).  
  
> [!NOTE]
>  Da eine <xref:System.Windows.Forms.BindingSource> behandelt sowohl einfache und komplexe Datenquellen, Terminologie ist problematisch. In dieser Klassendokumentation wird der Begriff *Liste* bezieht sich auf einer Datensammlung in der gehosteten-Datenquelle und *Element* steht für ein einzelnes Element. Wenn Funktionen erläutern zugeordnete komplexe Datenquellen, die entsprechende Begriffe *Tabelle* und *Zeile* verwendet werden.  
  
 <xref:System.Windows.Forms.BindingSource> stellt Member bereit, für den Zugriff auf die zugrunde liegenden Daten. Das aktuelle Element abgerufen werden kann, über die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft und die gesamte Liste über abgerufen werden kann die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Bearbeitungsvorgänge werden unterstützt, auf das aktuelle Element über <xref:System.Windows.Forms.BindingSource.Current%2A> und <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>, <xref:System.Windows.Forms.BindingSource.EndEdit%2A>, <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> und <xref:System.Windows.Forms.BindingSource.Add%2A> und <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methoden. Obwohl währungsverwaltung automatisch für alle Arten von zugrunde liegenden Datenquelle behandelt wird, aber diese Klasse stellt eine Anzahl von Ereignissen, z. B. <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> und <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, mit denen für die Anpassung.  
  
 Datenquellen, die an gebunden sind, eine <xref:System.Windows.Forms.BindingSource> Komponente auch navigiert und verwaltet werden kann mit der <xref:System.Windows.Forms.BindingNavigator> Klasse, die eine VCR-ähnlichen Benutzeroberfläche (UI) für die Navigation in der Elemente in einer Liste bereitstellt. Obwohl <xref:System.Windows.Forms.BindingNavigator> gebunden werden kann für jede Datenquelle, sie wurde entwickelt, für die Integration einer <xref:System.Windows.Forms.BindingSource> Komponente durch die <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Standardeigenschaft für die <xref:System.Windows.Forms.BindingSource> Klasse <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Ist das Standardereignis <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Viele der Elemente der <xref:System.Windows.Forms.BindingSource> Klasse ausgeführt werden, auf die zugrunde liegende Liste dargestellt werden, indem die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft und verweisen Sie einfach den Vorgang der zugrunde liegenden Liste. Aus diesem Grund, wenn die <xref:System.Windows.Forms.BindingSource> gebunden ist, um eine benutzerdefinierte Implementierung der <xref:System.Collections.IList>, das genaue Verhalten dieser Member möglicherweise vom Verhalten in der Dokumentation der Klasse beschriebenen unterscheiden. Z. B. die <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methodenaufrufe <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>. Die <xref:System.Windows.Forms.BindingSource> Dokumentation wird beschrieben, die <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methode unter der Voraussetzung, die die <xref:System.Collections.IList.RemoveAt%2A> Methode für das zugrunde liegende <xref:System.Collections.IList> ordnungsgemäß implementiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine <xref:System.Windows.Forms.ListBox> gebunden werden, um eine <xref:System.Windows.Forms.BindingSource>. Die <xref:System.Windows.Forms.BindingSource> gebunden ist, um eine <xref:System.ComponentModel.BindingList%601> , die eine Liste von Schriftarten enthält.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingSource" />
    <altmember cref="T:System.Windows.Forms.BindingNavigator" />
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.CurrencyManager" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.ComponentModel.IBindingList" />
    <altmember cref="T:System.ComponentModel.IEditableObject" />
    <related type="Article" href="https://msdn.microsoft.com/library/3e2faf4c-f5b8-4fa6-9fbc-f59c37ec2fb9">BindingSource-Komponente</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingSource" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingSource" />-Klasse mit den Standardeigenschaftswerten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die <xref:System.Windows.Forms.BindingSource> Eigenschaftswerte, die von diesem Konstruktor initialisiert.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : System.ComponentModel.IContainer -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Der <see cref="T:System.ComponentModel.IContainer" />, der der aktuellen <see cref="T:System.Windows.Forms.BindingSource" /> hinzugefügt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingSource" />-Klasse und fügt dem angegebenen Container die <see cref="T:System.Windows.Forms.BindingSource" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird der Standardkonstruktor aufgerufen, und fügt dann das aktuelle <xref:System.Windows.Forms.BindingSource> dem angegebenen Container. Es wird nicht in der Regel durch den Lösungsprogrammierer, sondern stattdessen von Autoren von Entwurfszeit-Umgebungen verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : obj * string -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource (dataSource, dataMember)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die Datenquelle für die <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">Der Name der bestimmten Spalte oder Liste innerhalb der Datenquelle, an die gebunden werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingSource" />-Klasse unter Verwendung der angegebenen Datenquelle und des angegebenen Datenmembers.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="bindingSource.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein <see cref="T:System.Object" />, das der internen Liste hinzugefügt werden soll.</param>
        <summary>Fügt der internen Liste ein vorhandenes Element hinzu.</summary>
        <returns>Der nullbasierte Index, an dem der durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellten zugrunde liegenden Liste <paramref name="value" /> hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Add%2A> Methode leitet den Aufruf an der zugrunde liegende Liste `Add` Methode.  
  
 Die interne Liste muss homogene Typen enthalten. Wenn die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft noch nicht festgelegt wurde, und klicken Sie dann das erste Objekt, das der Liste hinzugefügt definiert den Typ der Liste.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.BindingSource.Add%2A> Methode. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen die `PopulateBindingSourceWithFonts` Methode aus dem Konstruktor des Formulars.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> unterscheidet sich im Typ von den vorhandenen Elementen in der zugrunde liegenden Liste.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AddingNew As AddingNewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AddingNewEventHandler ^ AddingNew;" />
      <MemberSignature Language="F#" Value="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " Usage="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor der zugrunde liegenden Liste ein Element hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis tritt auf, bevor der zugrunde liegenden Liste dargestellt werden, indem Sie ein neues Objekt hinzugefügt wird die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Dieses Ereignis wird ausgelöst, nachdem die <xref:System.Windows.Forms.BindingSource.AddNew%2A> -Methode aufgerufen wird, jedoch bevor das neue Element erstellt und der zugrunde liegenden Liste hinzugefügt wird. Dieses Ereignis wird behandelt, kann der Programmierer benutzerdefinierte Erstellung bereitstellen Verhalten und Einfügen ohne für die Ableitung der <xref:System.Windows.Forms.BindingSource> Klasse. Dies erfolgt im Ereignishandler durch Festlegen der <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft der <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> Parameter, um das neue Element. Das neue Objekt der <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis muss denselben Typ wie der in der Liste enthaltene Typ oder eine Ausnahme ausgelöst wird. Kann nicht festgelegt werden die <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft, die bei der Bindung an eine <xref:System.Data.DataView> oder <xref:System.Data.DataTable> da Sie einen neuen hinzufügen können <xref:System.Data.DataRowView> der Liste.  
  
 Weitere Informationen zum Angeben von benutzerdefinierten Funktionen für neue Elemente finden Sie unter den <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methode. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Neue Elemente werden hinzugefügt, um die Liste nach der <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignishandler. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Anpassen der Hinzufügung mithilfe der BindingSource von Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" /> ist nicht der gleiche Typ wie der in der Liste enthaltene Typ.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNew () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ AddNew();" />
      <MemberSignature Language="F#" Value="abstract member AddNew : unit -&gt; obj&#xA;override this.AddNew : unit -&gt; obj" Usage="bindingSource.AddNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt der zugrunde liegenden Liste ein neues Element hinzu.</summary>
        <returns>Das erstellte und der Liste hinzugefügte <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AddNew%2A> Methode fügt ein neues Element auf die zugrunde liegende Liste dargestellt durch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Diese Methode richtet die nachstehend beschriebenen Aktionen aus:  
  
1.  Die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> -Methode automatisch aufgerufen, um alle ausstehenden Bearbeitungsvorgänge zu übertragen.  
  
2.  Die <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignis wird automatisch ausgelöst. Dieses Ereignis kann programmgesteuert behandelt werden, um das neue Element zu erstellen. Dies erfolgt im Ereignishandler durch Festlegen der <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> Eigenschaft der <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> Parameter, um das neue Element. Das neue Objekt der <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis muss denselben Typ wie der in der Liste enthaltene Typ oder eine Ausnahme ausgelöst wird.  
  
     Wenn die <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignis nicht behandelt, und die zugrunde liegende Liste eine <xref:System.ComponentModel.IBindingList>, und klicken Sie dann die Anforderung an der in der Liste übergeben wird <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> Methode. Wenn die zugrunde liegende Liste keine <xref:System.ComponentModel.IBindingList> ist, wird das Element automatisch über seinen öffentlichen Standardkonstruktor erstellt. In beiden Fällen wird das neue Element am Ende der Liste hinzugefügt.  
  
3.  Das neue Element wird sofort zur internen Liste hinzugefügt, es sei denn, die Datenquelle implementiert die <xref:System.ComponentModel.IEditableObject> Schnittstelle. In diesem Fall das neue Element ist nicht Commit bis ein expliziter Aufruf von <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> erfolgt oder ein neuen List-Vorgang initiiert wird. Bevor übernommen wird, das neue Element kann ein Rollback durch Aufrufen von <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, in diesem Fall das neue Element verworfen wird.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Neue Elemente werden hinzugefügt, um die Liste nach der <xref:System.Windows.Forms.BindingSource.AddingNew> -Ereignishandler. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Anpassen der Hinzufügung mithilfe der BindingSource von Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Forms.BindingSource.AllowNew" />-Eigenschaft ist auf <see langword="false" /> festgelegt.  
  
- oder -  
Für den aktuellen Elementtyp konnte kein öffentlicher Standardkonstruktor gefunden werden.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
        <altmember cref="T:System.ComponentModel.IBindingList" />
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowEdit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowEdit : bool" Usage="System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente in der zugrunde liegenden Liste bearbeitet werden können.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass die Listenelemente bearbeitet werden können, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> Eigenschaft wird in der Regel von anderen Komponenten verwendet, um festzustellen, ob die Bearbeitung von Elementen in der Liste zulässig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowNew As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowNew { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowNew : bool with get, set" Usage="System.Windows.Forms.BindingSource.AllowNew" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob mithilfe der <see cref="M:System.Windows.Forms.BindingSource.AddNew" />-Methode der Liste Elemente hinzugefügt werden können, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> verwendet werden kann, um der Liste Elemente hinzuzufügen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft ist hängt vom Typ der zugrunde liegenden Datenquelle. Wenn die zugrunde liegende Liste implementiert die <xref:System.ComponentModel.IBindingList> -Schnittstelle, diese Eigenschaft wird auf die zugrunde liegende Liste delegieren. Andernfalls gibt diese Eigenschaft zurück `false` Wenn die zugrunde liegende Liste eine der folgenden Merkmale aufweist:  
  
-   Weist eine feste Größe auf, laut der <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Es ist schreibgeschützt, laut der <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Den Typ des Elements keinen Standardkonstruktor.  
  
> [!NOTE]
>  Sobald der Wert dieser Eigenschaft festgelegt ist, verweist der Getter nicht mehr den Aufruf von der zugrunde liegenden Liste. Stattdessen einfach wird der Wert, der zuvor bis festgelegten der <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> Methode wird aufgerufen.  
  
 Einstellung, die diese Eigenschaft löst die <xref:System.Windows.Forms.BindingSource.ListChanged> -Ereignis mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>.  
  
 Setzen Sie die <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft `true` und der zugrunde liegende Listentyp keinen Standardkonstruktor, müssen Sie behandeln die <xref:System.Windows.Forms.BindingSource.AddingNew> Ereignis und den entsprechenden Typ zu erstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft der <xref:System.Windows.Forms.BindingSource> Komponente, bei dem Benutzer zum Hinzufügen neuer Elemente zu gestatten die <xref:System.Windows.Forms.BindingSource> Komponente zugrunde liegenden Liste. Wenn diese Eigenschaft auf `true` bewirkt, dass die Grenze <xref:System.Windows.Forms.DataGridView> Steuerelement, um die Zeile für neue Datensätze anzuzeigen.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird auf <see langword="true" /> festgelegt, wenn die zugrunde liegende, durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellte Liste eine feste Größe hat oder schreibgeschützt ist.</exception>
        <exception cref="T:System.MissingMethodException">Die Eigenschaft wird auf <see langword="true" /> festgelegt, und das <see cref="E:System.Windows.Forms.BindingSource.AddingNew" />-Ereignis wird nicht behandelt, wenn der zugrunde liegende Listentyp keinen Standardkonstruktor hat.</exception>
        <altmember cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowEdit" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowRemove" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowRemove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowRemove { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowRemove : bool" Usage="System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente aus der zugrunde liegenden Liste entfernt werden können.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass Listenelemente aus der Liste entfernt werden können, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> Eigenschaft wird in der Regel von anderen Komponenten verwendet, um festzustellen, ob die Bearbeitung von Elementen in der Liste zulässig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplySort">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Datenquelle mit der angegebenen Sortierbeschreibung oder den Sortierbeschreibungen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (sorts As ListSortDescriptionCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::ListSortDescriptionCollection ^ sorts);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit" Usage="bindingSource.ApplySort sorts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">Eine <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> mit den Sortierbeschreibungen, die auf die Datenquelle angewendet werden sollen.</param>
        <summary>Sortiert die Datenquelle mit den angegebenen Sortierbeschreibungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView> implementiert die mehrspaltige Sortierung als eine Reihe von eigenschaftenpaare-Deskriptor-Richtung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Datenquelle ist keine <see cref="T:System.ComponentModel.IBindingListView" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (property As PropertyDescriptor, sort As ListSortDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::PropertyDescriptor ^ property, System::ComponentModel::ListSortDirection sort);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit" Usage="bindingSource.ApplySort (property, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">Ein <see cref="T:System.ComponentModel.PropertyDescriptor" />, der die Eigenschaft beschreibt, durch die die Datenquelle sortiert werden soll.</param>
        <param name="sort">Eine <see cref="T:System.ComponentModel.ListSortDirection" />, die angibt, wie die Liste sortiert werden soll.</param>
        <summary>Sortiert die Datenquelle mit dem angegebenen Eigenschaftendeskriptor und der Sortierreihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.IBindingList> implementiert die einzelne spaltensortierung mit einer <xref:System.ComponentModel.PropertyDescriptor> an eine Eigenschaft, um nach zu sortieren und eine <xref:System.ComponentModel.ListSortDirection> , der angibt, ob der Inhalt der Eigenschaft in aufsteigender oder absteigender Reihenfolge sortiert werden sollen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Datenquelle ist keine <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingComplete As BindingCompleteEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingCompleteEventHandler ^ BindingComplete;" />
      <MemberSignature Language="F#" Value="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " Usage="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn alle Clients an diese <see cref="T:System.Windows.Forms.BindingSource" /> gebunden wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.BindingComplete> Ereignis tritt auf, nachdem alle Clients in der Regel Steuerelemente gebunden wurden mit dem aktuellen <xref:System.Windows.Forms.BindingSource>. Der Handler für dieses Ereignis kann die entsprechende Aktion basierend auf den Erfolg, Fehler oder Ausnahmen, die im Bindungsprozess, untersuchen die <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> Eigenschaft der <xref:System.Windows.Forms.BindingCompleteEventArgs> Parameter.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Behandlung der <xref:System.Windows.Forms.BindingSource.BindingComplete> Ereignis. Um diesen Code auszuführen, fügen Sie ihn in eine leere Codedatei.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState" />
        <altmember cref="T:System.Windows.Forms.BindingCompleteEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingSource.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den aktuellen Bearbeitungsvorgang ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwirft die Änderungen an Daten seit der letzten Speichern oder laden Vorgang aus, wenn beide der folgenden Bedingungen erfüllt sind:  
  
-   Die Datenquelle implementiert die <xref:System.ComponentModel.IEditableObject> Schnittstelle.  
  
-   Die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Methode noch nicht aufgerufen wurde.  
  
 Diese Methode ruft die <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> Methode des zugrunde liegenden <xref:System.Windows.Forms.CurrencyManager>, und klicken Sie auf Zeilenebene Änderungen ausgerichtet ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="bindingSource.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Clear%2A> Methode entfernt alle Elemente aus der zugrunde liegenden Liste dargestellt werden, indem die <xref:System.Windows.Forms.BindingSource.List%2A> -Eigenschaft und legt die <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft 0 (null).  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="bindingSource.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das <see cref="T:System.Object" />, das in der durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellten zugrunde liegenden Liste gesucht werden soll. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob es sich bei einem Objekt um ein Element in der Liste handelt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter in <see cref="P:System.Windows.Forms.BindingSource.List" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Implementierung hängt von der zugrunde liegenden Liste ist `Contains` -Methode in der Regel die folgenden Merkmale treffen:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> wird durchsucht, ab dem ersten Element bis zum letzten Element.  
  
-   Die zugrunde liegende Methode führt eine lineare Suche; aus diesem Grund ist die durchschnittliche Ausführungszeit proportional zu den Wert des der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft.  
  
-   Die zugrunde liegende Methode bestimmt die Gleichheit durch Aufrufen der <xref:System.Object.Equals%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (arr As Array, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ arr, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="bindingSource.CopyTo (arr, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Das Zielarray.</param>
        <param name="index">Der Index im Zielarray, ab dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt der <see cref="P:System.Windows.Forms.BindingSource.List" /> ab dem angegebenen Indexwert in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, kombinieren Sie Elemente aus mehreren Quellen in ein einzelnes Array.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Forms.BindingSource.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Elemente in der zugrunde liegenden Liste ab und berücksichtigt den aktuellen <see cref="P:System.Windows.Forms.BindingSource.Filter" />-Wert.</summary>
        <value>Die Gesamtanzahl der gefilterten Elemente in der zugrunde liegenden Liste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Count%2A> -Eigenschaft ruft die Anzahl der Elemente in der zugrunde liegenden Liste dargestellt werden, indem die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft durch den Wert des geänderten der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche namens `button1`. Ordnen Sie die `button1_Click` -Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrencyManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::CurrencyManager ^ CurrencyManager { System::Windows::Forms::CurrencyManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrencyManager : System.Windows.Forms.CurrencyManager" Usage="System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.ICurrencyManagerProvider.CurrencyManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datensatzzeigerverwaltung ab, die dieser <see cref="T:System.Windows.Forms.BindingSource" /> zugeordnet ist.</summary>
        <value>Das dieser <see cref="T:System.Windows.Forms.CurrencyManager" /> zugeordnete <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den währungs-Manager für eine andere Bindung für die Verwendung der gleichen Datenmember zugreifen möchten die <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : obj" Usage="System.Windows.Forms.BindingSource.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Element in der Liste ab.</summary>
        <value>Ein <see cref="T:System.Object" />, das das aktuelle Element in der durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellten zugrunde liegenden Liste darstellt, oder <see langword="null" />, wenn die Liste keine Elemente enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft zum Zugreifen auf das aktuelle Element, jedoch die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft, um die gesamte Liste abzurufen. Um den Typ des aktuellen Objekts zu ermitteln, verwenden die <xref:System.Object.GetType%2A>, oder <xref:System.Object.ToString%2A> Methoden.  
  
 Um das aktuelle Element zu ändern, legen die <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft, um eine neue ganzzahligen Wert, oder verwenden Sie eine der die Navigation-Methoden wie z. B. <xref:System.Windows.Forms.BindingSource.MoveNext%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, und rufen die `PopulateBindingSourceWithFonts` Methode des Formulars <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanged : EventHandler " Usage="member this.CurrentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das derzeit gebundene Element geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.CurrentChanged> Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.BindingSource.Current%2A> eigenschaftsänderungen für einen der folgenden Gründe:  
  
-   Die aktuelle Position der <xref:System.Windows.Forms.BindingSource.List%2A> Änderungen.  
  
-   Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften ändern.  
  
-   Die Mitgliedschaft der zugrunde liegenden <xref:System.Windows.Forms.BindingSource.List%2A> geändert wird, wodurch <xref:System.Windows.Forms.BindingSource.Position%2A> zum Verweisen auf ein anderes Element. Beispiele hierfür sind das Hinzufügen oder Löschen eines Elements, bevor Sie das aktuelle Element löschen oder verschieben das aktuelle Element selbst oder Verschieben eines Elements in der aktuellen Position.  
  
-   Die zugrunde liegende Liste wird durch eine neue sortieren oder Filtern Vorgang aktualisiert.  
  
 Wenn dieses Ereignis ausgelöst wird, die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft enthält bereits den neuen Wert.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged> ist das Standardereignis für die <xref:System.Windows.Forms.BindingSource> Klasse.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentItemChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentItemChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentItemChanged : EventHandler " Usage="member this.CurrentItemChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich ein Eigenschaftswert der <see cref="P:System.Windows.Forms.BindingSource.Current" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> Ereignis wird ausgelöst, als Antwort auf alle Umstände, die Auslösen der <xref:System.Windows.Forms.BindingSource.CurrentChanged> Ereignis. Darüber hinaus <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> wird auch ausgelöst, wenn der Wert einer der Eigenschaften des <xref:System.Windows.Forms.BindingSource.Current%2A> geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataError As BindingManagerDataErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingManagerDataErrorEventHandler ^ DataError;" />
      <MemberSignature Language="F#" Value="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " Usage="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine positionsbezogene Ausnahme automatisch durch <see cref="T:System.Windows.Forms.BindingSource" /> behandelt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis dient nur zu Informationszwecken und meldet nur CLS-kompatible Ausnahmen. Um zu bestimmen, welche Art von Ausnahme aufgetreten ist, behandeln Sie dieses Ereignis aus, und überprüfen Sie die <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> Eigenschaft der <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataMember : string with get, set" Usage="System.Windows.Forms.BindingSource.DataMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die bestimmte Liste in der Datenquelle ab, zu der derzeit eine Bindung besteht, oder legt diese fest.</summary>
        <value>Der Name einer Liste (oder Zeile) in der <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.DataSource%2A> enthält mehrere Listen (oder Tabellen) von Daten, Sie sollten festlegen, die <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um den Namen einer der Quellen.  
  
 Einstellung, die diese Eigenschaft löst die <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Ereignis  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataMemberChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataMemberChanged;" />
      <MemberSignature Language="F#" Value="member this.DataMemberChanged : EventHandler " Usage="member this.DataMemberChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.BindingSource.DataMember" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.DataMember%2A> eigenschaftenänderungen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : obj with get, set" Usage="System.Windows.Forms.BindingSource.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenquelle ab, mit der eine Bindung besteht, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Object" />, das als Datenquelle fungiert. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaft kann auf eine Anzahl von Datenquellen, einschließlich Typen, Objekte und Listen mit Typen festgelegt werden. Die resultierende Datenquelle wird als Liste verfügbar gemacht werden. Die folgende Tabelle zeigt einige allgemeine Datenquellen und die resultierende Liste Auswertung.  
  
|DataSource-Eigenschaft|Listenergebnisse|  
|-------------------------|------------------|  
|`null`|Ein leeres <xref:System.ComponentModel.IBindingList> von Objekten. Hinzufügen eines Elements wird die Liste in den Typ des hinzugefügten Elements.|  
|`null` mit <xref:System.Windows.Forms.BindingSource.DataMember%2A> festlegen|Nicht unterstützt, löst <xref:System.ArgumentException>.|  
|Nicht-List-Typ oder ein Objekt vom Typ "T"|Leere <xref:System.ComponentModel.IBindingList> vom Typ "T".|  
|Array-Instanz|<xref:System.ComponentModel.IBindingList> die die Elemente des Arrays enthält.|  
|<xref:System.Collections.IEnumerable> Instanz|Ein <xref:System.ComponentModel.IBindingList> , enthält die <xref:System.Collections.IEnumerable> Elemente.|  
|Liste der Instanz, die mit Typ "T"|<xref:System.ComponentModel.IBindingList> die Instanz, die Typ "T" enthält.|  
  
 Darüber hinaus <xref:System.Windows.Forms.BindingSource.DataSource%2A> kann auf andere Listentypen festgelegt werden, z. B. <xref:System.ComponentModel.IListSource> und <xref:System.ComponentModel.ITypedList> und <xref:System.Windows.Forms.BindingSource> entsprechend behandelt. In diesem Fall sollte der in der Liste enthaltene Typ einen Standardkonstruktor verfügen.  
  
 Wenn Sie eine Datenquelle festlegen, wenn der angegebene Verweis mehr als eine Liste oder Tabelle enthält, müssen Sie festlegen der <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaft, um eine Zeichenfolge, die Liste zum Binden an angibt. Einstellung, die diese Eigenschaft löst die <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Ereignis.  
  
> [!NOTE]
>  Wenn Sie Änderungen vornehmen der <xref:System.Windows.Forms.BindingSource.DataSource%2A> Eigenschaftswert, Sie sollten dies auf dem Thread der Benutzeroberfläche (UI), stellen Sie sicher, dass die Benutzeroberfläche die Änderungen widerspiegelt.  
  
 Die <xref:System.Windows.Forms.BindingSource.DataSource%2A> -Eigenschaft ist die Standardeigenschaft für die <xref:System.Windows.Forms.BindingSource> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Liste mit Kunden zugewiesen der <xref:System.Windows.Forms.BindingSource.DataSource%2A> von einem <xref:System.Windows.Forms.BindingSource> Komponente. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels unter [wie: Auslösen von Änderungsbenachrichtigungen mithilfe der ResetItem-Methode einer BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.ComponentModel.IListSource" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberSignature Language="F#" Value="member this.DataSourceChanged : EventHandler " Usage="member this.DataSourceChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.BindingSource.DataSource" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.DataSource%2A> eigenschaftenänderungen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="bindingSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Windows.Forms.BindingSource" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter true ist, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.Windows.Forms.BindingSource> Verweise. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndEdit();" />
      <MemberSignature Language="F#" Value="member this.EndEdit : unit -&gt; unit" Usage="bindingSource.EndEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet anstehende Änderungen auf die zugrunde liegende Datenquelle an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.EndEdit%2A> -Methode aufgerufen wird, werden alle ausstehenden Änderungen an der zugrunde liegende Datenquelle angewendet.  
  
 Diese Methode hat keine Auswirkungen, es sei denn, die von der Datenquelle enthaltenen Objekte implementieren die <xref:System.ComponentModel.IEditableObject> Schnittstelle. Wenn die Objekte nicht implementieren die <xref:System.ComponentModel.IEditableObject> -Schnittstelle, Änderungen an den Daten in der unmittelbar nach jeder Änderung in der zugrunde liegenden Datenquelle kopiert werden.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.Windows.Forms.BindingSource.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausdruck ab, mit dem die anzuzeigenden Zeilen gefiltert werden, oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge, die angibt, wie Zeilen gefiltert werden sollen. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel in Szenarien für komplexe Datenbindung, verwendet der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft können Sie eine Teilmenge der Anzeigen der <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Nur den zugrunde liegenden Listen, implementieren die <xref:System.ComponentModel.IBindingListView> Schnittstelle unterstützen filtern.  
  
 Wenn <xref:System.Windows.Forms.BindingSource.Filter%2A> nicht `null`, <xref:System.Windows.Forms.BindingSource> übergibt diese Eigenschaft an die zugrunde liegende Liste. Wenn Sie diese Eigenschaft während der objektinitialisierung festgelegt, wird der Aufruf zurückgestellt werden nach Abschluss der Initialisierung.  
  
 Geben Sie den Namen einer Spalte, gefolgt von einem Operator und einen Wert zu filtern, zum Erstellen ein Filterwerts. Die akzeptierte Filtersyntax hängt von der zugrunde liegenden Datenquelle ab. Ist die zugrunde liegenden Datenquelle eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, können Sie angeben, boolesche Ausdrücke, die mit der Syntax, dokumentiert, die für die <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der Wert des der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft wirkt sich auf den Wert des der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft. Darüber hinaus die <xref:System.Windows.Forms.BindingSource.Filter%2A> Wert bleibt erhalten, wenn die Datenquelle ändert. Zum Beenden der Filterung der <xref:System.Windows.Forms.BindingSource.DataSource%2A>, rufen Sie die <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndFilter` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular sollten importiert die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveFilter" />
        <altmember cref="P:System.ComponentModel.IBindingList.IsSorted" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht das angegebene Element in der Datenquelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (prop As PropertyDescriptor, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Find(System::ComponentModel::PropertyDescriptor ^ prop, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int&#xA;override this.Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int" Usage="bindingSource.Find (prop, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop">Die zu suchende <see cref="T:System.ComponentModel.PropertyDescriptor" />.</param>
        <param name="key">Der Wert von <c>prop</c>, mit dem eine Übereinstimmung gefunden werden soll.</param>
        <summary>Sucht nach dem Index des Elements, das den angegebenen Eigenschaftenbezeichner hat.</summary>
        <returns>Der nullbasierte Index des Elements, das für <see cref="T:System.ComponentModel.PropertyDescriptor" /> den angegebenen Wert hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel in komplexen Fällen für die Datenbindung verwendet, um die erste Zeile suchen, in denen der Wert des Felds angegeben, die `prop` Parameter entspricht dem Wert von der `key` Parameter  
  
 Diese Methode leitet die Anforderung einfach auf die zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> Methode. Wenn die zugrunde liegende Datenquelle ist z. B. eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, diese Methode ruft die <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> Methode. Das Verhalten der <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, z. B. der Wert zurückgegeben, wenn kein übereinstimmendes Element gefunden wird, hängt von der Implementierung der Methode in der zugrunde liegenden Liste.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.BindingSource.Find%2A>-Methode verwenden. Das vollständige Beispiel finden Sie unter dem Thema der Übersicht über die Klasse.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste ist nicht vom Typ <see cref="T:System.ComponentModel.IBindingList" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (propertyName As String, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ propertyName, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.Find : string * obj -&gt; int" Usage="bindingSource.Find (propertyName, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der Eigenschaft, nach der gesucht werden soll.</param>
        <param name="key">Der Wert des zu suchenden Elements mit dem angegebenen <c>propertyName</c>.</param>
        <summary>Gibt den Index des Elements in der Liste mit dem angegebenen Eigenschaftennamen und Eigenschaftswert zurück.</summary>
        <returns>Der nullbasierte Index des Elements mit dem angegebenen Eigenschaftennamen und dem angegebenen Eigenschaftswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Find%2A> Methode kann nur verwendet werden, wenn die zugrunde liegende Liste ist ein <xref:System.ComponentModel.IBindingList> Suche implementiert. Diese Methode leitet die Anforderung einfach auf die zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> Methode. Beispielsweise ist die zugrunde liegenden Datenquelle eine <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, oder <xref:System.Data.DataView>, diese Methode konvertiert `propertyName` auf eine <xref:System.ComponentModel.PropertyDescriptor> und ruft die <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> Methode. Das Verhalten der <xref:System.Windows.Forms.BindingSource.Find%2A>, z. B. der Wert zurückgegeben, wenn kein übereinstimmendes Element gefunden wird, hängt von der Implementierung der Methode in der zugrunde liegenden Liste.  
  
 Die Eigenschaft beim Vergleich wird Groß-/Kleinschreibung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Forms.BindingSource.Find%2A> -Methode mit einem <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndFind` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular sollten importiert die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die zugrunde liegende Liste ist keine <see cref="T:System.ComponentModel.IBindingList" /> mit implementierter Suchfunktion.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyName" /> stimmt mit keiner Eigenschaft in der Liste überein.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="bindingSource.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator für die <see cref="P:System.Windows.Forms.BindingSource.List" /> ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="bindingSource.GetItemProperties listAccessors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" />-Objekten, die in der Liste als bindbar gesucht werden sollen.</param>
        <summary>Ruft ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" />-Objekten ab, das die bindbaren Eigenschaften des Datenquellenlistentyps darstellt.</summary>
        <returns>Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" />-Objekten, die die Eigenschaften für diesen Listentyp darstellen, die zum Binden von Daten verwendet werden.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string&#xA;override this.GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string" Usage="bindingSource.GetListName listAccessors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Ein Array von <see cref="T:System.ComponentModel.PropertyDescriptor" />-Objekten, die in der Liste als bindbar gesucht werden sollen.</param>
        <summary>Ruft den Namen der Liste ab, die Daten für die Bindung bereitstellt.</summary>
        <returns>Der Name der Liste, die die Daten für die Bindung bereitstellt.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelatedCurrencyManager (dataMember As String) As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::CurrencyManager ^ GetRelatedCurrencyManager(System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="abstract member GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager&#xA;override this.GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager" Usage="bindingSource.GetRelatedCurrencyManager dataMember" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.ICurrencyManagerProvider.GetRelatedCurrencyManager(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Der Name der Spalte oder Liste innerhalb der Datenquelle, für die die Datensatzzeigerverwaltung (Currency Manager) abgerufen werden soll.</param>
        <summary>Ruft die entsprechende Datensatzzeigerverwaltung für den angegebenen Datenmember ab.</summary>
        <returns>Der entsprechende <see cref="T:System.Windows.Forms.CurrencyManager" /> für den angegebenen Datenmember.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `dataMember` ist `null` oder eine leere Zeichenfolge (""), <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> gibt den wichtigsten währungs-Manager; Andernfalls überprüft, ob eine andere <xref:System.Windows.Forms.BindingSource> an den angegebenen Datenmember gebundenen und gibt seine währungs-Manager.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="bindingSource.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das <see cref="T:System.Object" />, das in der durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellten zugrunde liegenden Liste gesucht werden soll. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens innerhalb der gesamten Liste zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens des <paramref name="value" />-Parameters, andernfalls -1, wenn sich <paramref name="value" /> nicht in der Liste befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Implementierung hängt von der zugrunde liegenden Liste ist `IndexOf` -Methode in der Regel die folgenden Merkmale treffen:  
  
-   Die <xref:System.Windows.Forms.BindingSource.List%2A> wird durchsucht, ab dem ersten Element bis zum letzten Element.  
  
-   Die zugrunde liegende Methode führt eine lineare Suche; aus diesem Grund ist die durchschnittliche Ausführungszeit proportional zu den Wert des der <xref:System.Windows.Forms.BindingSource.Count%2A> Eigenschaft.  
  
-   Die zugrunde liegende Methode bestimmt die Gleichheit durch Aufrufen der <xref:System.Object.Equals%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="bindingSource.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <c>value</c> eingefügt werden soll.</param>
        <param name="value">Der einzufügende <see cref="T:System.Object" />. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Fügt ein Element am angegebenen Index in der Liste ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Liste ist schreibgeschützt oder weist eine feste Größe auf.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBindingSuspended As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBindingSuspended { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBindingSuspended : bool" Usage="System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Listenbindung unterbrochen ist.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass die Bindung unterbrochen ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugrunde liegende Liste eine feste Größe hat.</summary>
        <value>
          <see langword="true" />, wenn die zugrunde liegende Liste eine feste Größe hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste eine feste Größe verfügt, können dabei nicht das Hinzufügen oder Entfernen von Elementen nach die Liste erstellt wurde, aber Sie können vorhandene Elemente ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugrunde liegende Liste schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die Liste schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste mit schreibgeschützten lässt das Hinzufügen, entfernen, oder Ändern von Listenelementen nach Erstellung die Liste nicht zu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSorted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSorted : bool" Usage="System.Windows.Forms.BindingSource.IsSorted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Elemente in der zugrunde liegenden Liste sortiert sind.</summary>
        <value>
          <see langword="true" />, wenn die Liste eine <see cref="T:System.ComponentModel.IBindingList" /> ist und sortiert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A> Gibt immer `false` ist die Liste kein <xref:System.ComponentModel.IBindingList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die Auflistung synchronisiert ist (threadsicher).</summary>
        <value>
          <see langword="true" />, um anzugeben, dass die Liste synchronisiert ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Windows.Forms.BindingSource.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Ruft das Listenelement am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Item%2A> Eigenschaft darstellt, den Indexer für diese Klasse. Er akzeptiert `null` als gültiger Wert und ermöglicht es doppelte Elemente in der Liste.  
  
 Ein Wert löst festlegen die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.List : System.Collections.IList" Usage="System.Windows.Forms.BindingSource.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Liste ab, an die die Verbindung gebunden wird.</summary>
        <value>Eine <see cref="T:System.Collections.IList" />, die die Liste darstellt, oder <see langword="null" />, wenn keine zugrunde liegende Liste vorhanden ist, die dieser <see cref="T:System.Windows.Forms.BindingSource" /> zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource> Klasse einheitlich behandelt verschiedene Datenquellen. Im Idealfall die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft sollte festgelegt werden, um eine allgemeine <xref:System.Collections.IList>. Allerdings kann manchmal erforderlich, diese Eigenschaft auf einen spezifischeren Typ umzuwandeln sein. Die folgende Tabelle zeigt den zugrunde liegende Listentyp, der den Typ oder Wert, der Datenquelle abhängt.  
  
|Datenquellentyp|Beschreibung der zugrunde liegenden Liste|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> und <xref:System.Windows.Forms.BindingSource.DataMember%2A> sind `null`|Ein leerer <xref:System.Collections.ArrayList>.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> ist `null`, aber <xref:System.Windows.Forms.BindingSource.DataMember%2A> nicht `null`|None; Fehler beim Abrufen der <xref:System.Windows.Forms.BindingSource.List%2A> löst eine <xref:System.ArgumentException>.|  
|Ein <xref:System.Array> Instanz|Eine <xref:System.Array>.|  
|Ein <xref:System.ComponentModel.IListSource> Instanz|Der Rückgabewert von einem Aufruf der <xref:System.ComponentModel.IListSource.GetList%2A> -Methode dieses <xref:System.ComponentModel.IListSource> Instanz.|  
|Ein <xref:System.ComponentModel.IBindingList> Instanz|Eine <xref:System.ComponentModel.IBindingList>.|  
|Ein <xref:System.Collections.IList> Instanz|Eine <xref:System.Collections.IList>.|  
|Nicht<xref:System.Collections.IList> Instanz des Typs "T"|Ein <xref:System.ComponentModel.BindingList%601> mit je einem Element.|  
|Ein <xref:System.ComponentModel.ICustomTypeDescriptor> Instanz|Ein <xref:System.Collections.ArrayList> mit je einem Element.|  
|Ein <xref:System.Collections.IEnumerable>.|Ein <xref:System.Collections.ArrayList> mit den Elementen, die kopiert.|  
|Die <xref:System.Array> Typ mit <xref:System.Windows.Forms.BindingSource.DataMember%2A> des Elements geben Sie "T"|Ein <xref:System.ComponentModel.BindingList%601>.|  
|Ein <xref:System.Type> darstellt, die eine <xref:System.ComponentModel.IListSource> oder <xref:System.ComponentModel.ITypedList>|Eine Instanz erstellt, die durch einen Aufruf der <xref:System.Activator.CreateInstance%28System.Type%29> Methode der <xref:System.Activator> Klasse. Ein <xref:System.NotSupportedException> können ausgelöst werden.|  
|Die <xref:System.Collections.IList> Typ mit <xref:System.Windows.Forms.BindingSource.DataMember%2A> des Elements geben Sie "T"<br /><br /> - oder - <br /><br /> Nicht<xref:System.Collections.IList> Typ|Ein <xref:System.ComponentModel.BindingList%601>.|  
|Die <xref:System.ComponentModel.ICustomTypeDescriptor> Typ|None; Fehler beim Abrufen der <xref:System.Windows.Forms.BindingSource.List%2A> löst eine <xref:System.NotSupportedException>.|  
  
 Wenn der Typ abgerufen wird die <xref:System.Collections.IList> -Schnittstelle, die zugrunde liegende Auflistung kann komplexer sein, z. B. eine <xref:System.Collections.ArrayList> oder <xref:System.Data.DataView> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche namens `button1`. Ordnen Sie die `button1_Click` -Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberSignature Language="F#" Value="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " Usage="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die zugrunde liegende Liste oder ein Element in der Liste geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis tritt auf, wenn eine der Mitgliedschaft oder die Metadaten der zugrunde liegenden Liste dargestellt werden Änderung, indem Sie die <xref:System.Windows.Forms.BindingSource.List%2A> Eigenschaft. Dieses Ereignis wird beispielsweise ausgelöst, wenn Elemente hinzugefügt, entfernt oder verschoben, oder die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften ändern. Die Werte der <xref:System.Windows.Forms.BindingSource.Sort%2A> und <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaften werden beibehalten, wenn dieses Ereignis auftritt.  
  
 Dieses Ereignis kann vollständig unterdrückt werden, wenn die <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Behandlung der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis die <xref:System.Windows.Forms.BindingSource> Komponente erkennen, wann die <xref:System.Windows.Forms.BindingSource> zugrunde liegende Liste der Komponente geändert wird.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFirst();" />
      <MemberSignature Language="F#" Value="member this.MoveFirst : unit -&gt; unit" Usage="bindingSource.MoveFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum ersten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert der <xref:System.Windows.Forms.BindingSource.Position%2A> -Eigenschaft auf 0, der das erste Element in der zugrunde liegenden Datenquelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche namens `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen Sie die `button1_click` -Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveLast();" />
      <MemberSignature Language="F#" Value="member this.MoveLast : unit -&gt; unit" Usage="bindingSource.MoveLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum letzten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert von der <xref:System.Windows.Forms.BindingSource.Position%2A> -Eigenschaft auf den Index des letzten Elements in der zugrunde liegenden Datenquelle, die gleich dem Wert des ist der <xref:System.Windows.Forms.BindingSource.Count%2A> -Eigenschaft minus 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveNext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveNext();" />
      <MemberSignature Language="F#" Value="member this.MoveNext : unit -&gt; unit" Usage="bindingSource.MoveNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum nächsten Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändert den aktuellen Wert der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft mit dem nächsten Element in der zugrunde liegenden Datenquelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche namens `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen Sie die `button1_click` -Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Sub MovePrevious ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MovePrevious();" />
      <MemberSignature Language="F#" Value="member this.MovePrevious : unit -&gt; unit" Usage="bindingSource.MovePrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt zum vorherigen Element in der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ändert den aktuellen Wert des der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft zum vorherigen Element in der zugrunde liegenden Datenquelle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAddingNew (e As AddingNewEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAddingNew(System::ComponentModel::AddingNewEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit&#xA;override this.OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit" Usage="bindingSource.OnAddingNew e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.AddingNew" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingComplete (e As BindingCompleteEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingComplete(System::Windows::Forms::BindingCompleteEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit&#xA;override this.OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit" Usage="bindingSource.OnBindingComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.BindingCompleteEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.BindingComplete" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentItemChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentItemChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentItemChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataError (e As BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataError(System::Windows::Forms::BindingManagerDataErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit&#xA;override this.OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit" Usage="bindingSource.OnDataError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataError" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataError%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataMemberChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataMemberChanged : EventArgs -&gt; unit&#xA;override this.OnDataMemberChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataMemberChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.  
  
Mit der <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataSourceChanged : EventArgs -&gt; unit&#xA;override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnListChanged (e As ListChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnListChanged(System::ComponentModel::ListChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit&#xA;override this.OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit" Usage="bindingSource.OnListChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnListChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPositionChanged : EventArgs -&gt; unit&#xA;override this.OnPositionChanged : EventArgs -&gt; unit" Usage="bindingSource.OnPositionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.ListChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingSource.PositionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberSignature Language="VB.NET" Value="Public Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Position { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int with get, set" Usage="System.Windows.Forms.BindingSource.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index des aktuellen Elements in der zugrunde liegenden Liste ab oder legt diesen fest.</summary>
        <value>Ein nullbasierter Index, der die Position des aktuellen Elements in der zugrunde liegenden Liste angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Festlegen der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft außerhalb des gültigen Bereichs von Werten werden folgendermaßen behandelt:  
  
-   Negative Werte werden als 0 behandelt.  
  
-   Werte größer als oder gleich <xref:System.Windows.Forms.BindingSource.Count%2A> fungieren als <xref:System.Windows.Forms.BindingSource.Count%2A> minus 1.  
  
 Ändern der <xref:System.Windows.Forms.BindingSource.Position%2A> Eigenschaft passt die <xref:System.Windows.Forms.BindingSource.Current%2A> Eigenschaft entsprechend.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, und <xref:System.Windows.Forms.BindingSource.Position%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular, importiert der <xref:System.Drawing.Drawing2D> Namespace und enthält eine <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1` und eine Schaltfläche namens `button1`. Zuordnen der `Form1_Load` und `Form1_Paint` Methoden mit den <xref:System.Windows.Forms.Form.Load> und <xref:System.Windows.Forms.Control.Paint> Ereignisse für das Formular, und ordnen Sie die `button1_click` -Methode mit der <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PositionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PositionChanged;" />
      <MemberSignature Language="F#" Value="member this.PositionChanged : EventHandler " Usage="member this.PositionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem sich der Wert der <see cref="P:System.Windows.Forms.BindingSource.Position" />-Eigenschaft geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.PositionChanged> Ereignis tritt auf, nachdem die <xref:System.Windows.Forms.BindingSource.Position%2A> -Eigenschaft geändert hat.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property RaiseListChangedEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RaiseListChangedEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RaiseListChangedEvents : bool with get, set" Usage="System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />-Ereignis ausgelöst werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />-Ereignisse ausgelöst werden sollen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`, er unterbricht das Auslösen von <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse. Dieses Ereignis gibt an, dass die gebundene Liste ein Verfahren anwenden, einschließlich hinzufügen, löschen, einfügen oder Ändern von Elementen geändert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="bindingSource.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Element, das aus der durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellten zugrunde liegenden Liste entfernt werden soll.</param>
        <summary>Entfernt das angegebene Element aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Remove%2A> Methode bewirkt, dass die Liste zu suchende der `value` Parameter. Wenn gefunden, versucht diese Methode wird, entfernen Sie das Element aus der <xref:System.Windows.Forms.BindingSource.List%2A>. Dieser Versuch fehl, wenn die Liste eine feste Größe hat oder schreibgeschützt ist. Diese beiden Bedingungen getestet werden können, mit der <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> und <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> Eigenschaften bzw.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste hat eine feste Größe oder ist schreibgeschützt.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="bindingSource.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus dieser Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese beiden Bedingungen getestet werden können, mit der <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> und <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> Eigenschaften bzw.  
  
 Diese Methode löst die <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, und <xref:System.Windows.Forms.BindingSource.Count%2A> Member. Um dieses Beispiel auszuführen, fügen Sie den Code in ein Formular enthält ein <xref:System.Windows.Forms.BindingSource> mit dem Namen `BindingSource1`, zwei Bezeichnungen, die mit dem Namen `label1` und `label2`, und eine Schaltfläche namens `button1`. Ordnen Sie die `button1_Click` -Methode mit dem <xref:System.Windows.Forms.Control.Click> -Ereignis für `button1`. Visual Basic-Benutzer müssen einen Verweis auf "System.Data.dll" hinzufügen.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als der Wert der <see cref="P:System.Windows.Forms.BindingSource.Count" />-Eigenschaft.</exception>
        <exception cref="T:System.NotSupportedException">Die durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellte zugrunde liegende Liste ist schreibgeschützt oder hat eine feste Größe.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCurrent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; unit" Usage="bindingSource.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das aktuelle Element aus der Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A> Methode entspricht der <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Windows.Forms.BindingSource.AllowRemove" />-Eigenschaft ist <see langword="false" />.  
  
- oder -  
 <see cref="P:System.Windows.Forms.BindingSource.Position" /> ist kleiner als 0 (null) oder größer als <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Die durch die <see cref="P:System.Windows.Forms.BindingSource.List" />-Eigenschaft dargestellte zugrunde liegende Liste ist schreibgeschützt oder hat eine feste Größe.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveFilter ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveFilter();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFilter : unit -&gt; unit&#xA;override this.RemoveFilter : unit -&gt; unit" Usage="bindingSource.RemoveFilter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den Filter, der der <see cref="T:System.Windows.Forms.BindingSource" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Methode leitet die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> Methode. Listet nur implementiert <xref:System.ComponentModel.IBindingListView> unterstützen filtern.  
  
 Standardmäßig ein Aufruf dieser Methode entspricht dem Festlegen der <xref:System.Windows.Forms.BindingSource.Filter%2A> Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste unterstützt keine Filterung.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveSort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveSort();" />
      <MemberSignature Language="F#" Value="abstract member RemoveSort : unit -&gt; unit&#xA;override this.RemoveSort : unit -&gt; unit" Usage="bindingSource.RemoveSort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die Sortierung, die der <see cref="T:System.Windows.Forms.BindingSource" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> Methode leitet die Anforderung an der zugrunde liegende Liste <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> Methode. Listet nur implementiert <xref:System.ComponentModel.IBindingList> unterstützen die Sortierung.  
  
 Standardmäßig ein Aufruf dieser Methode entspricht dem Festlegen der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste unterstützt keine Sortierung.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetAllowNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetAllowNew();" />
      <MemberSignature Language="F#" Value="abstract member ResetAllowNew : unit -&gt; unit&#xA;override this.ResetAllowNew : unit -&gt; unit" Usage="bindingSource.ResetAllowNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert die <see cref="P:System.Windows.Forms.BindingSource.AllowNew" />-Eigenschaft erneut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> Methode Replikationsfehlern der <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft entsprechend den Wert des entsprechenden <xref:System.Windows.Forms.BindingSource.AllowNew%2A> Eigenschaft in der zugrunde liegenden Liste.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings (metadataChanged As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings(bool metadataChanged);" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : bool -&gt; unit" Usage="bindingSource.ResetBindings metadataChanged" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged">
          <see langword="true" />, wenn sich das Datenschema geändert hat, <see langword="false" />, wenn sich nur Werte geändert haben.</param>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement alle Elemente in der Liste erneut eingelesen und ihre angezeigten Werte aktualisiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Methode dass alle gebundenen Steuerelementen die <xref:System.Windows.Forms.BindingSource> , deren Werte zu aktualisieren. Die Methode wird durch Auslösen der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis mindestens einmal; die `metaDataChanged` Parameter gibt die Art der zugrunde liegenden Änderung an.  
  
-   Ein `metaDataChanged` Wert `true` gibt an, dass das Datenschema des <xref:System.Windows.Forms.BindingSource> hat sich geändert. Ein <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis wird ausgelöst, mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType.PropertyDescriptorChanged?displayProperty=nameWithType>.  
  
-   Ein `metaDataChanged` Wert `false` gibt an, dass nur die Werte von einem oder mehreren Elementen geändert haben.  
  
 Unabhängig vom Wert der `metaDataChanged`, <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis wird ausgelöst, mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>. Infolgedessen wird aufrufen <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> mit dem Parameter `true` löst zwei <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> wird automatisch aufgerufen, wenn ein anderer Member wesentliche Änderungen an der Datenbindung, wie z. B. Einstellung sendet die <xref:System.Windows.Forms.BindingSource.DataSource%2A> oder <xref:System.Windows.Forms.BindingSource.DataMember%2A> Eigenschaften. Allerdings kann der Programmierer diese Methode auch explizit aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden von einer Arrayliste, die keine änderungsbenachrichtigung bereitstellt. Ein Element wird aus der Liste entfernt, und die gebundenen Steuerelementen von der Änderung benachrichtigt werden, durch Aufrufen der <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [Vorgehensweise: Reflektieren von Datenquellenaktualisierungen in einem Windows Forms-Steuerelement mit der BindingSource-Komponente](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCurrentItem ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCurrentItem();" />
      <MemberSignature Language="F#" Value="member this.ResetCurrentItem : unit -&gt; unit" Usage="bindingSource.ResetCurrentItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement das aktuell ausgewählte Element erneut eingelesen und sein angezeigter Wert aktualisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen dieser Methode bewirkt, dass die <xref:System.Windows.Forms.BindingSource.ListChanged> -Ereignis auftritt, wobei das geänderte Element an der aktuellen Position.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetItem (itemIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetItem(int itemIndex);" />
      <MemberSignature Language="F#" Value="member this.ResetItem : int -&gt; unit" Usage="bindingSource.ResetItem itemIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Der nullbasierte Index des geänderten Elements.</param>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement das Element am angegebenen Index erneut eingelesen und sein angezeigter Wert aktualisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.ResetItem%2A> -Methode benachrichtigt alle Steuerelemente, die an das Element am angegebenen gebunden <xref:System.Windows.Forms.BindingSource.Position%2A> , deren Werte zu aktualisieren. Die Methode wird durch Auslösen der <xref:System.Windows.Forms.BindingSource.ListChanged> -Ereignis mit <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> festgelegt <xref:System.ComponentModel.ListChangedType.ItemChanged?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A> wird automatisch aufgerufen, wenn der Wert eines einzelnen Elements geändert wird. Allerdings kann der Programmierer diese Methode auch explizit aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.BindingSource> -Komponente zum Binden einer Liste, um eine <xref:System.Windows.Forms.DataGridView> Steuerelement. Die Liste löst keine änderungsbenachrichtigungen, also die <xref:System.Windows.Forms.BindingSource.ResetItem%2A> Methode für die <xref:System.Windows.Forms.BindingSource> dient zum Auslösen der <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignis. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels [wie: Auslösen von Änderungsbenachrichtigungen mithilfe der ResetItem-Methode einer BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeBinding();" />
      <MemberSignature Language="F#" Value="member this.ResumeBinding : unit -&gt; unit" Usage="bindingSource.ResumeBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Datenbindung fort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> stehen zwei Methoden, die die temporären Unterbrechung und Wiederaufnahme der Datenbindung in einem Szenario für die einfache Datenbindung zu ermöglichen. Sie würden die Datenbindung in der Regel anhalten, wenn der Benutzer zugelassen werden muss, Datenfelder mehrere Änderungen vornehmen, bevor die Überprüfung erfolgt. Beispielsweise würde, wenn ein Feld in Übereinstimmung mit einer Sekunde geändert werden, muss jedoch überprüft das erste Feld das zweite Feld Fehler werden.  
  
> [!NOTE]
>  Mithilfe von <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> verhindert, dass die Änderungen per Push übermittelt, in der Datenquelle bis <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> aufgerufen wird, aber eigentlich verhindert nicht, dass alle Ereignisse auftreten. Steuerelemente, die komplexe Datenbindung, z. B. Verwenden der <xref:System.Windows.Forms.DataGridView> steuern, aktualisieren Sie die Werte, die basierend auf Change-Ereignissen wie z. B. die <xref:System.Windows.Forms.CurrencyManager.ListChanged> -Ereignis, daher ist das Aufrufen <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> wird nicht verhindert, dass sie Änderungen an der Datenquelle empfangen. Aus diesem Grund dies <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> dienen zur Verwendung mit einfachen gebundene Steuerelemente, z. B. die <xref:System.Windows.Forms.TextBox> Steuerelement. Alternativ können diese Methoden in einem Szenario mit komplexe Bindung, wenn Sie unterdrücken <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse durch Festlegen der <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Property Sort As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Sort { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Sort : string with get, set" Usage="System.Windows.Forms.BindingSource.Sort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zum Sortieren verwendeten Spaltennamen und die Sortierreihenfolge für die Anzeige der Zeilen in der Datenquelle ab oder legt diese fest.</summary>
        <value>Eine Zeichenfolge mit Berücksichtigung der Groß- und Kleinschreibung, die den Spaltennamen enthält, und auf die "ASC" (für aufsteigend) oder "DESC" (für absteigend) folgt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft ist eine Groß-/Kleinschreibung Zeichenfolge, die Namen der Spalten zum Sortieren der Zeilen sowie die Sortierreihenfolge angibt. Spalten werden standardmäßig in aufsteigender Reihenfolge sortiert. Mehrere Spalten können durch Kommas getrennt, z. B. `"State, ZipCode DESC"`.  
  
 Damit die Sortierung unterstützt, muss die zugrunde liegende Liste implementieren die <xref:System.ComponentModel.IBindingList> oder <xref:System.ComponentModel.IBindingListView> Schnittstellen. Diese Funktion kann abgefragt werden, über die <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> Eigenschaft. Die mehrspaltige Sortierung ist verfügbar, wenn die <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> Eigenschaft `true`.  
  
 Festlegen der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft ändert sich je nach Typ die interne Liste:  
  
-   Wenn die Liste vom Typ <xref:System.ComponentModel.IBindingList>, <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> und <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> Eigenschaften werden in der internen Liste festgelegt.  
  
-   Wenn die Liste vom Typ <xref:System.ComponentModel.IBindingListView>, <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> festgelegt wird.  
  
 Eigenschaften für die interne Liste sortieren werden nur geändert werden, wenn die Sortierzeichenfolge nicht `null`. Die `get` Accessor für diese Eigenschaft wird nicht den Sortierwert der internen Liste; stattdessen wird zurückgegeben, die `set` Accessor-Wert. Der Wert des der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft wird beibehalten, wenn die Datenquelle ändert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Forms.BindingSource.Sort%2A> Eigenschaft, um eine grundlegende Sortierung mit einer <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndSort` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular sollten importiert die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Forms.BindingSource.Sort%2A> -Eigenschaft zum Ausführen erweiterter Sortierung mit einer <xref:System.Data.DataView>. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen `PopulateDataViewAndAdvancedSort` aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode. Das Formular sollten importiert die <xref:System.Xml> und <xref:System.IO> Namespaces.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveSort" />
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As ListSortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDescriptionCollection ^ SortDescriptions { System::ComponentModel::ListSortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.ListSortDescriptionCollection" Usage="System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der auf die Datenquelle angewendeten Sortierbeschreibungen ab.</summary>
        <value>Wenn die Datenquelle eine <see cref="T:System.ComponentModel.IBindingListView" /> ist, eine <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> mit den auf die Liste angewendeten Sortierbeschreibungen, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste kein <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> gibt immer `null`.  
  
 Die <xref:System.ComponentModel.ListSortDescriptionCollection> ist eine schreibgeschützte Auflistung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDirection As ListSortDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDirection SortDirection { System::ComponentModel::ListSortDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDirection : System.ComponentModel.ListSortDirection" Usage="System.Windows.Forms.BindingSource.SortDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Reihenfolge ab, in der die Elemente in der Liste sortiert werden.</summary>
        <value>Einer der <see cref="T:System.ComponentModel.ListSortDirection" />-Werte, der die Reihenfolge angibt, in der Liste sortiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegende Liste ist keiner <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortDirection%2A> Eigenschaft gibt immer zurück <xref:System.ComponentModel.ListSortDirection.Ascending>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortProperty As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ SortProperty { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortProperty : System.ComponentModel.PropertyDescriptor" Usage="System.Windows.Forms.BindingSource.SortProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.ComponentModel.PropertyDescriptor" /> ab, der für die Sortierung der Liste verwendet wird.</summary>
        <value>Wenn die Liste eine <see cref="T:System.ComponentModel.IBindingList" /> ist, der <see cref="T:System.ComponentModel.PropertyDescriptor" />, der für Sortierung verwendet wird, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste kein <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> gibt immer `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAdvancedSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAdvancedSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAdvancedSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die mehrspaltige Sortierung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn die Liste eine <see cref="T:System.ComponentModel.IBindingListView" /> ist und mehrspaltige Sortierung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste kein <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeNotification : bool" Usage="System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Änderungsbenachrichtigung unterstützt.</summary>
        <value>
          <see langword="true" /> in allen Fällen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsFiltering { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsFiltering : bool" Usage="System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Filterung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn die Liste eine <see cref="T:System.ComponentModel.IBindingListView" /> ist und Filterung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Liste kein <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSearching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSearching { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSearching : bool" Usage="System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle Suchvorgänge mit der <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />-Methode unterstützt.</summary>
        <value>
          <see langword="true" />, wenn die Liste eine <see cref="T:System.ComponentModel.IBindingList" /> ist und Suchvorgänge mit der <see cref="Overload:System.Windows.Forms.BindingSource.Find" />-Methode unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Datenquelle nicht ist ein <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> Member. Das vollständige Beispiel finden Sie unter dem Thema der Übersicht über die Klasse.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenquelle die Sortierung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn die Datenquelle eine <see cref="T:System.ComponentModel.IBindingList" /> ist und Sortierung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Datenquelle ist keiner <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> -Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendBinding();" />
      <MemberSignature Language="F#" Value="member this.SuspendBinding : unit -&gt; unit" Usage="bindingSource.SuspendBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht die Datenbindung, sodass die gebundene Datenquelle nicht durch Änderungen aktualisiert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> stehen zwei Methoden, die die temporären Unterbrechung und Wiederaufnahme der Datenbindung in einem Szenario für die einfache Datenbindung zu ermöglichen. Sie würden die Datenbindung in der Regel anhalten, wenn der Benutzer zugelassen werden muss, Datenfelder mehrere Änderungen vornehmen, bevor die Überprüfung erfolgt. Beispielsweise würde, wenn ein Feld in Übereinstimmung mit einer Sekunde geändert werden, muss jedoch überprüft das erste Feld das zweite Feld Fehler werden.  
  
> [!NOTE]
>  Mithilfe von <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und verhindert, dass die Änderungen per Push übermittelt, in der Datenquelle bis <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> aufgerufen wird, aber eigentlich verhindert nicht, dass alle Ereignisse auftreten. Steuerelemente, die komplexe Datenbindung, z. B. Verwenden der <xref:System.Windows.Forms.DataGridView> steuern, aktualisieren Sie die Werte, die basierend auf Change-Ereignissen wie z. B. die <xref:System.Windows.Forms.CurrencyManager.ListChanged> -Ereignis, daher ist das Aufrufen <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> wird nicht verhindert, dass sie Änderungen an der Datenquelle empfangen. Aus diesem Grund dies <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> und <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> dienen zur Verwendung mit einfachen gebundene Steuerelemente, z. B. die <xref:System.Windows.Forms.TextBox> Steuerelement. Alternativ können diese Methoden in einem Szenario mit komplexe Bindung, wenn Sie unterdrücken <xref:System.Windows.Forms.BindingSource.ListChanged> Ereignisse durch Festlegen der <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> Eigenschaft `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf die zugrunde liegende Liste synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die zugrunde liegende Liste synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIndex (property As PropertyDescriptor) Implements IBindingList.AddIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.AddIndex(System::ComponentModel::PropertyDescriptor ^ property) = System::ComponentModel::IBindingList::AddIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">Der <see cref="T:System.ComponentModel.PropertyDescriptor" />, der den Indizes hinzugefügt werden soll, die für die Suche verwendet werden.</param>
        <summary>Fügt den Indizes, die für die Suche verwendet werden, den <see cref="T:System.ComponentModel.PropertyDescriptor" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zugrunde liegende Liste ist ein <xref:System.ComponentModel.IBindingList> geben, diese Methode fügt die <xref:System.ComponentModel.PropertyDescriptor> auf die Indizes; andernfalls, wird beim Aufruf löst diese Methode eine <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die zugrunde liegende Liste ist keine <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (prop As PropertyDescriptor) Implements IBindingList.RemoveIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.RemoveIndex(System::ComponentModel::PropertyDescriptor ^ prop) = System::ComponentModel::IBindingList::RemoveIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop">Der <see cref="T:System.ComponentModel.PropertyDescriptor" />, der aus den für die Suche verwendeten Indizes entfernt werden soll.</param>
        <summary>Entfernt den <see cref="T:System.ComponentModel.PropertyDescriptor" /> aus den Indizes, die für die Suche verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegende Liste ist keiner <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>, diese Methode löst immer eine <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew (position As Integer) Implements ICancelAddNew.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.CancelNew(int position) = System::ComponentModel::ICancelAddNew::CancelNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Der Index des Elements, das der Auflistung hinzugefügt wurde.</param>
        <summary>Entfernt ein anstehendes neues Element aus der Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> ein Rollback ausstehende Hinzufügung eines Elements, an dem vom angegebenen Index in die Auflistung zuvor hinzugefügte Methode `position`. Die `position` Parameter ist erforderlich, da mehrere neue Elemente gleichzeitig ausstehend sein können.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub EndNew (position As Integer) Implements ICancelAddNew.EndNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.EndNew(int position) = System::ComponentModel::ICancelAddNew::EndNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Der Index des Elements, das der Auflistung hinzugefügt wurde.</param>
        <summary>Übergibt ein anstehendes neues Element an die Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> Methode führt einen Commit für ein ausstehendes Hinzufügen eines Elements, das zuvor hinzugefügt haben, am dem angegebenen Index in die Collection `position`. Die `position` Parameter ist erforderlich, da mehrere neue Elemente gleichzeitig ausstehend sein können.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert der <see cref="T:System.Windows.Forms.BindingSource" /> den Start der Initialisierung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert der <see cref="T:System.Windows.Forms.BindingSource" /> den Abschluss der Initialisierung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.Initialized">
      <MemberSignature Language="C#" Value="event EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#Initialized" />
      <MemberSignature Language="VB.NET" Value="Custom Event Initialized As EventHandler Implements System.ComponentModel.ISupportInitializeNotification" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsInitialized As Boolean Implements ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::ISupportInitializeNotification::IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Windows.Forms.BindingSource" /> initialisiert ist.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass <see cref="T:System.Windows.Forms.BindingSource" /> initialisiert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Forms.BindingSource>-Instanz in eine <xref:System.ComponentModel.ISupportInitializeNotification>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>