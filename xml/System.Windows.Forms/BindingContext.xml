<Type Name="BindingContext" FullName="System.Windows.Forms.BindingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8dfc19b6ab06ae93332d7a31c61699eba8648d7f" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53496718" /></Metadata><TypeSignature Language="C#" Value="public class BindingContext : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingContext extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingContext" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingContext&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingContext : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BindingContext = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("CollectionChanged")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Verwaltet die Auflistung von <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekten für ein beliebiges Objekt, das von der <see cref="T:System.Windows.Forms.Control" />-Klasse erbt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Windows-Formular verfügt über mindestens ein <xref:System.Windows.Forms.BindingContext> Objekt, das verwaltet die <xref:System.Windows.Forms.BindingManagerBase> Objekte für das Formular. Da die <xref:System.Windows.Forms.BindingManagerBase> Klasse ist abstrakt, der Rückgabetyp der <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft ist entweder eine <xref:System.Windows.Forms.CurrencyManager> oder ein <xref:System.Windows.Forms.PropertyManager>. Wenn die Datenquelle eines Objekts ist, die nur eine einzelne Eigenschaft (statt eine Liste von Objekten) zurückgeben, können die <xref:System.Type> ist eine <xref:System.Windows.Forms.PropertyManager>. Wenn Sie angeben, z. B. eine <xref:System.Windows.Forms.TextBox> als Datenquelle, eine <xref:System.Windows.Forms.PropertyManager> zurückgegeben wird. Andererseits, wenn die Datenquelle eines Objekts ist, implementiert <xref:System.Collections.IList> oder <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.CurrencyManager> zurückgegeben wird.  
  
 Für jede Datenquelle in einem Windows Form, es gibt einen einzigen <xref:System.Windows.Forms.CurrencyManager> oder <xref:System.Windows.Forms.PropertyManager>. Da es möglicherweise mehrere Datenquellen, die mit einem Windows-Formular verknüpfte der <xref:System.Windows.Forms.BindingContext> können Sie eine bestimmte abrufen <xref:System.Windows.Forms.CurrencyManager> mit einer Datenquelle verknüpft ist.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft, die <xref:System.Windows.Forms.BindingContext> erstellt ein neues <xref:System.Windows.Forms.BindingManagerBase> ist nicht bereits vorhanden. Dies kann zu einer gewissen Verwirrung führen, da das zurückgegebene Objekt nicht verwalten kann, die Liste (oder eine beliebige Liste), die Sie möchten. Um zu verhindern, Rückgabe einer ungültigen <xref:System.Windows.Forms.BindingManagerBase>, verwenden die <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um zu bestimmen, ob das beabsichtigte <xref:System.Windows.Forms.BindingManagerBase> ist bereits vorhanden.  
  
 Wenn Sie ein Container-Steuerelement, z. B. verwenden eine <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.Panel>, oder <xref:System.Windows.Forms.TabControl>, um datengebundene Steuerelemente enthalten, können Sie erstellen eine <xref:System.Windows.Forms.BindingContext> für diese Container-Steuerelement und dessen Steuerelemente. Anschließend kann jeder Teil des Formulars verwaltet werden, durch seine eigene <xref:System.Windows.Forms.BindingManagerBase>. Finden Sie unter den <xref:System.Windows.Forms.BindingContext.%23ctor%2A> Konstruktor für Weitere Informationen zum Erstellen von mehreren <xref:System.Windows.Forms.BindingManagerBase> Objekte für die gleiche Datenquelle.  
  
 Wenn Sie beim Hinzufügen einer <xref:System.Windows.Forms.TextBox> Steuerelement eines Formulars und der Bindung an eine Spalte einer Tabelle in einem Dataset, das Steuerelement kommuniziert mit der <xref:System.Windows.Forms.BindingContext> dieses Formulars. Die <xref:System.Windows.Forms.BindingContext>, spricht dagegen an die spezifische <xref:System.Windows.Forms.CurrencyManager> für diese datenzuordnung. Wenn Sie abgefragt der `Position` Eigenschaft der <xref:System.Windows.Forms.CurrencyManager>, meldet den aktuellen Datensatz für die Bindung, <xref:System.Windows.Forms.TextBox> Steuerelement. Das folgende Codebeispiel zeigt ein <xref:System.Windows.Forms.TextBox> -Steuerelement gebunden ist, die `FirstName` Spalte eine `Customers` -Tabelle auf die `dataSet1` Dataset über die <xref:System.Windows.Forms.BindingContext> für das Formular, befindet er sich auf.  
  
```vb  
TextBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName")  
  
```  
  
```csharp  
textBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName");  
  
```  
  
```cpp  
textBox1->DataBindings->Add("Text", dataSet1, "Customers.FirstName");  
```  
  
 Können Sie eine zweite hinzufügen <xref:System.Windows.Forms.TextBox> Control (`TextBox2`) auf das Formular und binden Sie es an der `LastName` Spalte die `Customers` -Tabelle in einem Dataset. Die <xref:System.Windows.Forms.BindingContext> beachtet die erste Bindung (`TextBox1` zu `Customers.FirstName`), damit sie die gleichen verwenden würden <xref:System.Windows.Forms.CurrencyManager>, wie die beiden Textfelder an dasselbe Dataset gebunden sind (`DataSet1`).  
  
```vb  
TextBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName")  
  
```  
  
```csharp  
textBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName");  
  
```  
  
```cpp  
textBox2->DataBindings->Add("Text", dataSet1, "Customers.LastName");  
```  
  
 Wenn Sie eine Bindung `TextBox2` an ein anderes Dataset, das <xref:System.Windows.Forms.BindingContext> erstellt und verwaltet eine zweite <xref:System.Windows.Forms.CurrencyManager>.  
  
 Es ist wichtig, die konsistent über das Festlegen der <xref:System.Windows.Forms.ListControl.DataSource%2A> und <xref:System.Windows.Forms.ListControl.DisplayMember%2A> Eigenschaften ist, andernfalls die <xref:System.Windows.Forms.BindingContext> erstellt mehrere Currency-Manager für das gleiche Dataset, das zu Fehlern führt. Das folgende Codebeispiel zeigt einige Möglichkeiten zum Festlegen von Eigenschaften und ihre zugeordneten <xref:System.Windows.Forms.BindingContext> Objekte. Sie können die mit einem der folgenden Methoden, Eigenschaften festlegen, solange Sie im gesamten Code konsistent sind.  
  
```vb  
ComboBox1.DataSource = DataSet1  
ComboBox1.DisplayMember = "Customers.FirstName"  
Me.BindingContext(dataSet1, "Customers").Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1;  
comboBox1.DisplayMember = "Customers.FirstName";  
this.BindingContext[dataSet1, "Customers"].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1;  
comboBox1->DisplayMember = "Customers.FirstName";  
this->BindingContext->get_Item(dataSet1, "Customers")->Position = 1;  
  
```  
  
```vb  
ComboBox1.DataSource = DataSet1.Customers  
ComboBox1.DisplayMember = "FirstName"  
Me.BindingContext(dataSet1.Customers).Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1.Customers;  
comboBox1.DisplayMember = "FirstName";  
this.BindingContext[dataSet1.Customers].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1->Customers;  
comboBox1->DisplayMember = "FirstName";  
this->BindingContext->get_Item(dataSet1->Customers)->Position = 1;  
  
```  
  
> [!NOTE]
>  Binden Sie die meisten Windows Forms-Anwendungen über eine <xref:System.Windows.Forms.BindingSource>. Die <xref:System.Windows.Forms.BindingSource> Komponente kapselt einen <xref:System.Windows.Forms.CurrencyManager> und macht die <xref:System.Windows.Forms.CurrencyManager> Programmierschnittstelle. Bei Verwendung einer <xref:System.Windows.Forms.BindingSource> verwenden Sie für die Bindung, die vom offengelegten Mitglieder der <xref:System.Windows.Forms.BindingSource> zum Bearbeiten von "Currency" (, also `Position`) ohne Umweg über den <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt vier <xref:System.Windows.Forms.Binding> Objekte zum Binden von fünf-Steuerelementen: eine <xref:System.Windows.Forms.DateTimePicker> und vier <xref:System.Windows.Forms.TextBox> -Steuerelementen: an verschiedene Datenquellen. Die <xref:System.Windows.Forms.BindingContext> dient dann zum Abrufen der <xref:System.Windows.Forms.BindingManagerBase> für jede Datenquelle.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
    <altmember cref="T:System.Windows.Forms.Binding" />
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingContext" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sollten Sie mehrere <xref:System.Windows.Forms.BindingManagerBase> -Instanzen für die gleiche Datenquelle, erstellen Sie ein neues <xref:System.Windows.Forms.BindingContext> und legen Sie dafür die <xref:System.Windows.Forms.Control.BindingContext%2A> Eigenschaft eines Objekts, die von erbt die <xref:System.Windows.Forms.Control> Klasse. Angenommen, zwei <xref:System.Windows.Forms.BindingManagerBase> Objekte (aus zwei verschiedenen <xref:System.Windows.Forms.BindingContext> Objekte), können Sie festlegen, die <xref:System.Windows.Forms.BindingManagerBase.Position%2A> Eigenschaften der einzelnen <xref:System.Windows.Forms.BindingManagerBase> auf unterschiedliche Werte. Dies bewirkt, dass jede Gruppe von datengebundene Steuerelemente zum Anzeigen von anderer Werten aus derselben Datenquelle.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt zwei neue <xref:System.Windows.Forms.BindingContext> Objekte und weist jedes Objekt die <xref:System.Windows.Forms.BindingContext> Eigenschaft eine <xref:System.Windows.Forms.GroupBox> Steuerelement. `GroupBox1` enthält `TextBox1`, und `GroupBox2` enthält `TextBox2` (die erfolgt mithilfe der <xref:System.Windows.Forms.Control.ControlCollection.AddRange%2A> Methode der <xref:System.Windows.Forms.Control.ControlCollection> Klasse). Das Beispiel fügt dann <xref:System.Windows.Forms.Binding> Objekte, die beiden <xref:System.Windows.Forms.TextBox> -Steuerelemente, jedes auf dieselbe Datenquelle und denselben Datenmember gebunden. Das Beispiel zeigt auch zwei Ereignishandler, mit denen die <xref:System.Windows.Forms.BindingContext> aus der <xref:System.Windows.Forms.GroupBox> Steuerelemente zum Festlegen der <xref:System.Windows.Forms.BindingManagerBase.Position%2A> Eigenschaft, die auf anderen <xref:System.Windows.Forms.BindingManagerBase> Objekte.  
  
 [!code-cpp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="protected internal void Add (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Add(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Add(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Add (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Add(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="member this.Add : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.Add (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Der mit dem <see cref="T:System.Object" /> verknüpfte <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCore">
      <MemberSignature Language="C#" Value="protected virtual void AddCore (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddCore(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.AddCore(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddCore (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddCore(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="abstract member AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit&#xA;override this.AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.AddCore (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Das der <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Objekt.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSource" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="listManager" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="protected internal void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Clear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="bindingContext.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht sämtliche <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekte aus der Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCore">
      <MemberSignature Language="C#" Value="protected virtual void ClearCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.ClearCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearCore();" />
      <MemberSignature Language="F#" Value="abstract member ClearCore : unit -&gt; unit&#xA;override this.ClearCore : unit -&gt; unit" Usage="bindingContext.ClearCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CollectionChangeEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CollectionChangeEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingContext.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CollectionChanged As CollectionChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CollectionChangeEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " Usage="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CollectionChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst beim Behandeln immer eine <see cref="T:System.NotImplementedException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingContext.CollectionChanged> Ereignis ist veraltet und löst immer eine <xref:System.NotImplementedException> beim behandeln. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Tritt in allen Fällen auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Forms.BindingContext" /> den angegebenen <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj -&gt; bool" Usage="bindingContext.Contains dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter den <xref:System.Windows.Forms.Binding> -Klasse eine Liste der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Finden Sie unter den <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft Informationen zur Rückgabe einer <xref:System.Windows.Forms.BindingManagerBase> nur eine Datenquelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um zu bestimmen, ob eine <xref:System.Windows.Forms.BindingManagerBase> für jedes Steuerelement in einem Formular vorhanden ist. Das Beispiel übergibt jedes <xref:System.Data.DataTable> in einem <xref:System.Data.DataSet> an die Methode.  
  
 [!code-cpp[Classic BindingContext.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object, dataMember As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj * string -&gt; bool" Usage="bindingContext.Contains (dataSource, dataMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <param name="dataMember">Die Informationen, die zum Auflösen in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> benötigt werden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter den <xref:System.Windows.Forms.Binding> -Klasse eine Liste der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Finden Sie unter den <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft Informationen zur Rückgabe einer <xref:System.Windows.Forms.BindingManagerBase> mit einer Datenquelle und des Datenmembers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode zu testen, ob ein bestimmtes <xref:System.Windows.Forms.BindingManagerBase> vorhanden ist, bevor Sie versuchen, den sie über die <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft.  
  
 [!code-cpp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn die Auflistung schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle zugeordnet ist.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die <xref:System.Windows.Forms.BindingManagerBase> erfordert keinen Navigationspfad werden sollen. Z. B. wenn die <xref:System.Windows.Forms.BindingManagerBase> verwaltet einen Satz von <xref:System.Windows.Forms.Binding> Objekten, einer <xref:System.Collections.ArrayList> oder <xref:System.Data.DataTable> als die <xref:System.Windows.Forms.Binding.DataSource%2A>, kein Pfad ist erforderlich.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft gibt stets eine <xref:System.Windows.Forms.BindingManagerBase>, und keine zurück `null`.  
  
 Finden Sie unter den <xref:System.Windows.Forms.Binding> -Klasse eine Liste der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt drei <xref:System.Windows.Forms.BindingManagerBase> Objekte: eine für eine <xref:System.Data.DataView>, eine für eine <xref:System.Collections.ArrayList>, und eine für die <xref:System.Windows.Forms.Binding.DataSource%2A> von eine <xref:System.Windows.Forms.Binding> gehört, die eine <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 [!code-cpp[Classic BindingContext.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.this Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource, string dataMember] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object, string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object, dataMember As String) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^, System::String ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource, System::String ^ dataMember); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj * string) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <param name="dataMember">Ein Navigationspfad mit den Informationen, die in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> aufgelöst werden.</param>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle und den angegebenen Datenmember.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die <xref:System.Windows.Forms.BindingManagerBase> verwaltet einen Satz von <xref:System.Windows.Forms.Binding> Objekte, die für die die Datenquelle, die mehrere Objekte enthält. Z. B. eine <xref:System.Data.DataSet> kann mehrere enthalten <xref:System.Data.DataTable> von verknüpften Objekten <xref:System.Data.DataRelation> Objekte. In diesem Fall ist erforderlich, der Pfad zum Aktivieren der <xref:System.Windows.Forms.BindingContext> den richtigen zurückzugebenden <xref:System.Windows.Forms.BindingManagerBase>.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft gibt stets eine <xref:System.Windows.Forms.BindingManagerBase>, wenn die `dataMember` Parameter ist ungültig. Es gibt keine zurück `null`.  
  
 Finden Sie unter den <xref:System.Windows.Forms.Binding> -Klasse eine Liste der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Wenn die gewünschte <xref:System.Windows.Forms.BindingManagerBase> verwaltet eine Liste der Pfad muss mit einer Liste auch beenden. Beispielsweise der folgende C#-Code bindet einen <xref:System.Windows.Forms.TextBox> Steuerelement als das Bestelldatum in einer Tabelle mit Bestellungen. Der Navigationspfad enthält die <xref:System.Data.DataTable.TableName%2A>, <xref:System.Data.DataRelation.RelationName%2A>, und die <xref:System.Data.DataColumn.ColumnName%2A>. Allerdings die <xref:System.Windows.Forms.BindingManagerBase> muss abgerufen werden, nur über die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataRelation.RelationName%2A> (dieser wird in einer Liste aufgelöst).  
  
```  
// The navigation path for a Binding ends with a property.  
textBox1.DataBindings.Add  
("Text", dataSet1, "Customers.custToOrders.OrderDate");  
// The navigation path for the BindingManagerBase ends with a list.  
BindingManagerBase bmOrders = this.BindingContext  
[dataSet1, "Customers.custToOrders"];  
```  
  
 Bei der Rückgabe eine <xref:System.Windows.Forms.BindingManagerBase>, verwenden Sie die gleiche Datenquelle wie die <xref:System.Windows.Forms.Binding> und nur den Navigationspfad zu ändern.  
  
 Verwenden der <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um zu bestimmen, ob die gewünschte <xref:System.Windows.Forms.BindingManagerBase> ist bereits vorhanden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Forms.BindingContext.Item%2A> zum Abrufen der <xref:System.Windows.Forms.BindingManagerBase> für eine bestimmte Bindung. Darüber hinaus erfahren Sie, wie behandeln die <xref:System.Windows.Forms.BindingManagerBase.BindingComplete> -Ereignis für die <xref:System.Windows.Forms.BindingManagerBase> um sicherzustellen, dass mehrere Steuerelemente, die an die gleiche Datenquelle gebunden sind, synchronisiert bleiben, wenn die Werte des Steuerelements geändert wird. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen die `InitializeControlsAndData` Methode aus dem Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Der angegebene <paramref name="dataMember" /> ist innerhalb der Datenquelle nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.ComponentModel.CollectionChangeEventArgs ccevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.ComponentModel.CollectionChangeEventArgs ccevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (ccevent As CollectionChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::ComponentModel::CollectionChangeEventArgs ^ ccevent);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit" Usage="bindingContext.OnCollectionChanged ccevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ccevent" Type="System.ComponentModel.CollectionChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="ccevent">Ein <see cref="T:System.ComponentModel.CollectionChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingContext.CollectionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingContext.OnCollectionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected internal void Remove (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Remove(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Remove (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Remove(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="bindingContext.Remove dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Löscht die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCore">
      <MemberSignature Language="C#" Value="protected virtual void RemoveCore (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemoveCore(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.RemoveCore(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemoveCore (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RemoveCore(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCore : obj -&gt; unit&#xA;override this.RemoveCore : obj -&gt; unit" Usage="bindingContext.RemoveCore dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Entfernt die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array ar, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array ar, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (ar As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ ar, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ar">Ein <see cref="T:System.Array" />, in das kopiert werden soll.</param>
        <param name="index">Der Auflistungsindex, ab dem kopiert werden soll.</param>
        <summary>Kopiert die Elemente der Auflistung beginnend am Auflistungsindex in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der <see cref="T:System.Windows.Forms.CurrencyManager" />-Objekte ab, die vom <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</summary>
        <value>Die Anzahl der Datenquellen, die von <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel gibt die Anzahl der <xref:System.Windows.Forms.CurrencyManager> vom verwalteten Objekte die <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung synchronisiert ist.</summary>
        <value><see langword="true" />, wenn die Auflistung threadsicher ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das für die Synchronisierung (Threadsicherheit) verwendet werden soll.</summary>
        <value>Diese Eigenschaft wird von <see cref="T:System.Collections.ICollection" /> abgeleitet und wird überschrieben, sodass immer <see langword="null" /> zurückgegeben wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator für die Auflistung ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.IEnumerator> zurückgegebenes der <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> Methode können Sie Durchlaufen der Auflistung, die von verwaltet die <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> -Methode zur Rückgabe einer <xref:System.Collections.IEnumerator> für die <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBinding">
      <MemberSignature Language="C#" Value="public static void UpdateBinding (System.Windows.Forms.BindingContext newBindingContext, System.Windows.Forms.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateBinding(class System.Windows.Forms.BindingContext newBindingContext, class System.Windows.Forms.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.UpdateBinding(System.Windows.Forms.BindingContext,System.Windows.Forms.Binding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateBinding(System::Windows::Forms::BindingContext ^ newBindingContext, System::Windows::Forms::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="static member UpdateBinding : System.Windows.Forms.BindingContext * System.Windows.Forms.Binding -&gt; unit" Usage="System.Windows.Forms.BindingContext.UpdateBinding (newBindingContext, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBindingContext" Type="System.Windows.Forms.BindingContext" />
        <Parameter Name="binding" Type="System.Windows.Forms.Binding" />
      </Parameters>
      <Docs>
        <param name="newBindingContext">Der neue <see cref="T:System.Windows.Forms.BindingContext" />, der dem <see cref="T:System.Windows.Forms.Binding" /> zugeordnet werden soll.</param>
        <param name="binding">Das <see cref="T:System.Windows.Forms.Binding" />, das dem neuen <see cref="T:System.Windows.Forms.BindingContext" /> zugeordnet werden soll.</param>
        <summary>Ordnet einem neuen <see cref="T:System.Windows.Forms.Binding" /> ein <see cref="T:System.Windows.Forms.BindingContext" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist vorgesehen, aktualisieren die Bindungen der implementierenden Komponenten <xref:System.Windows.Forms.IBindableComponent>, wenn ihre <xref:System.Windows.Forms.BindingContext> Änderungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>