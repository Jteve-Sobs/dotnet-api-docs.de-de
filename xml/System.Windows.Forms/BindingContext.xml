<Type Name="BindingContext" FullName="System.Windows.Forms.BindingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23d06549db28151cea7e5c08cd7e5bb4775dc102" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70359382" /></Metadata><TypeSignature Language="C#" Value="public class BindingContext : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingContext extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingContext" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingContext&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingContext : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BindingContext = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CollectionChanged")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Verwaltet die Auflistung von <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekten für ein beliebiges Objekt, das von der <see cref="T:System.Windows.Forms.Control" />-Klasse erbt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Windows Form verfügt über mindestens ein <xref:System.Windows.Forms.BindingContext> Objekt, das die <xref:System.Windows.Forms.BindingManagerBase> Objekte für das Formular verwaltet. Da es sich um eine <xref:System.Windows.Forms.CurrencyManager> abstrakte <xref:System.Windows.Forms.PropertyManager> <xref:System.Windows.Forms.BindingContext.Item%2A> <xref:System.Windows.Forms.BindingManagerBase> Klasse handelt, ist der Rückgabetyp der Eigenschaft entweder oder. Wenn die Datenquelle ein Objekt ist, das nur eine einzelne Eigenschaft (anstelle einer Liste von Objekten) zurückgeben kann, <xref:System.Type> ist ein <xref:System.Windows.Forms.PropertyManager>. Wenn Sie z. b. <xref:System.Windows.Forms.TextBox> als Datenquelle angeben, wird eine <xref:System.Windows.Forms.PropertyManager> zurückgegeben. Wenn die Datenquelle dagegen ein Objekt ist, das oder <xref:System.Collections.IList> <xref:System.ComponentModel.IBindingList>implementiert, wird eine <xref:System.Windows.Forms.CurrencyManager> zurückgegeben.  
  
 Für jede Datenquelle in einem Windows Form gibt es ein einzelnes <xref:System.Windows.Forms.CurrencyManager> oder. <xref:System.Windows.Forms.PropertyManager> Da einem Windows Form mehrere Datenquellen zugeordnet werden können, können Sie mit <xref:System.Windows.Forms.BindingContext> dem <xref:System.Windows.Forms.CurrencyManager> alle einer Datenquelle zugeordneten Datenquellen abrufen.  
  
> [!NOTE]
>  Wenn Sie die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft verwenden <xref:System.Windows.Forms.BindingContext> , wird eine <xref:System.Windows.Forms.BindingManagerBase> neue erstellt, wenn Sie noch nicht vorhanden ist. Dies kann zu Verwirrung führen, da das zurückgegebene Objekt möglicherweise nicht die Liste (oder eine Liste) verwaltet, die Sie beabsichtigen. Verwenden Sie die <xref:System.Windows.Forms.BindingContext.Contains%2A> -Methode <xref:System.Windows.Forms.BindingManagerBase>, um zu verhindern, dass die beabsichtigte <xref:System.Windows.Forms.BindingManagerBase> bereits vorhanden ist.  
  
 Wenn Sie ein Container Steuerelement wie <xref:System.Windows.Forms.GroupBox>z. b., <xref:System.Windows.Forms.Panel>oder <xref:System.Windows.Forms.TabControl>verwenden, um Daten gebundene Steuerelemente zu enthalten, können Sie <xref:System.Windows.Forms.BindingContext> nur für dieses Container Steuerelement und seine Steuerelemente erstellen. Anschließend kann jeder Teil des Formulars eigen <xref:System.Windows.Forms.BindingManagerBase>ständig verwaltet werden. Weitere Informationen <xref:System.Windows.Forms.BindingContext.%23ctor%2A> zum Erstellen von mehreren <xref:System.Windows.Forms.BindingManagerBase> Objekten für die gleiche Datenquelle finden Sie im-Konstruktor.  
  
 Wenn Sie einem Formular <xref:System.Windows.Forms.TextBox> ein Steuerelement hinzufügen und es an eine Spalte einer Tabelle in einem DataSet binden, kommuniziert das Steuerelement mit <xref:System.Windows.Forms.BindingContext> dem dieser Form. Der <xref:System.Windows.Forms.BindingContext>spricht wiederum mit dem spezifischen <xref:System.Windows.Forms.CurrencyManager> für diese Datenzuordnung. Wenn Sie die `Position` -Eigenschaft <xref:System.Windows.Forms.CurrencyManager>des-Objekts abgefragt haben, wird der aktuelle Datensatz für die Bindung dieses <xref:System.Windows.Forms.TextBox> Steuer Elements gemeldet. Im folgenden <xref:System.Windows.Forms.TextBox> Codebeispiel wird ein-Steuerelement an die `FirstName` -Spalte einer `Customers` Tabelle im `dataSet1` DataSet über die <xref:System.Windows.Forms.BindingContext> für das Formular gebunden, in dem es sich befindet.  
  
```vb  
TextBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName")  
  
```  
  
```csharp  
textBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName");  
  
```  
  
```cpp  
textBox1->DataBindings->Add("Text", dataSet1, "Customers.FirstName");  
```  
  
 Sie können dem Formular ein <xref:System.Windows.Forms.TextBox> zweites-`TextBox2`Steuerelement () hinzufügen und es `Customers` an `LastName` die-Spalte der-Tabelle im gleichen Dataset binden. Der <xref:System.Windows.Forms.BindingContext> kennt die erste Bindung (`TextBox1` an `Customers.FirstName`), daher würde die gleiche <xref:System.Windows.Forms.CurrencyManager>verwendet werden, da beide Textfelder an dasselbe Dataset gebunden sind (`DataSet1`).  
  
```vb  
TextBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName")  
  
```  
  
```csharp  
textBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName");  
  
```  
  
```cpp  
textBox2->DataBindings->Add("Text", dataSet1, "Customers.LastName");  
```  
  
 Wenn Sie eine `TextBox2` Bindung an ein anderes Dataset erstellen <xref:System.Windows.Forms.BindingContext> , erstellt und verwaltet eine <xref:System.Windows.Forms.CurrencyManager>zweite.  
  
 Es ist wichtig, dass Sie konsistent sind, wie Sie <xref:System.Windows.Forms.ListControl.DataSource%2A> die <xref:System.Windows.Forms.ListControl.DisplayMember%2A> -Eigenschaft und die- <xref:System.Windows.Forms.BindingContext> Eigenschaft festlegen. andernfalls erstellt der mehrere Währungs Manager für das gleiche DataSet, was zu Fehlern führt. Das folgende Codebeispiel zeigt einige Möglichkeiten, um die Eigenschaften und die zugehörigen <xref:System.Windows.Forms.BindingContext> Objekte festzulegen. Sie können die Eigenschaften mit einer der folgenden Methoden festlegen, solange Sie im gesamten Code konsistent sind.  
  
```vb  
ComboBox1.DataSource = DataSet1  
ComboBox1.DisplayMember = "Customers.FirstName"  
Me.BindingContext(dataSet1, "Customers").Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1;  
comboBox1.DisplayMember = "Customers.FirstName";  
this.BindingContext[dataSet1, "Customers"].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1;  
comboBox1->DisplayMember = "Customers.FirstName";  
this->BindingContext->get_Item(dataSet1, "Customers")->Position = 1;  
  
```  
  
```vb  
ComboBox1.DataSource = DataSet1.Customers  
ComboBox1.DisplayMember = "FirstName"  
Me.BindingContext(dataSet1.Customers).Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1.Customers;  
comboBox1.DisplayMember = "FirstName";  
this.BindingContext[dataSet1.Customers].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1->Customers;  
comboBox1->DisplayMember = "FirstName";  
this->BindingContext->get_Item(dataSet1->Customers)->Position = 1;  
  
```  
  
> [!NOTE]
>  Die meisten Windows Forms Anwendungen werden über <xref:System.Windows.Forms.BindingSource>eine gebunden. Die <xref:System.Windows.Forms.BindingSource> -Komponente kapselt <xref:System.Windows.Forms.CurrencyManager> eine und macht <xref:System.Windows.Forms.CurrencyManager> die Programmierschnittstelle verfügbar. Wenn Sie einen <xref:System.Windows.Forms.BindingSource> für die <xref:System.Windows.Forms.BindingSource> Bindung verwenden, sollten Sie die Elemente, die von verfügbar gemacht werden, verwenden, um " `Position`Currency" (d <xref:System.Windows.Forms.BindingContext>. h.) zu bearbeiten, anstatt durchzugehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden vier <xref:System.Windows.Forms.Binding> -Objekte erstellt, um fünf Steuer <xref:System.Windows.Forms.DateTimePicker> Elemente- <xref:System.Windows.Forms.TextBox> a und vier-Steuerelemente an mehrere Datenquellen zu binden. Der <xref:System.Windows.Forms.BindingContext> wird dann verwendet, um die <xref:System.Windows.Forms.BindingManagerBase> für jede Datenquelle zu erhalten.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
    <altmember cref="T:System.Windows.Forms.Binding" />
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingContext" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingManagerBase> Wenn Sie über mehrere Instanzen für dieselbe Datenquelle verfügen möchten, erstellen Sie eine neue <xref:System.Windows.Forms.BindingContext> , und legen Sie Sie auf die <xref:System.Windows.Forms.Control.BindingContext%2A> -Eigenschaft eines Objekts fest, das <xref:System.Windows.Forms.Control> von der-Klasse erbt. Wenn Sie z. b. über <xref:System.Windows.Forms.BindingManagerBase> zwei Objekte verfügen (von <xref:System.Windows.Forms.BindingContext> zwei verschiedenen Objekten), können Sie <xref:System.Windows.Forms.BindingManagerBase.Position%2A> die Eigenschaften der <xref:System.Windows.Forms.BindingManagerBase> einzelnen Objekte auf verschiedene Werte festlegen. Dies bewirkt, dass jeder Satz Daten gebundener Steuerelemente verschiedene Werte aus derselben Datenquelle anzeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei neue <xref:System.Windows.Forms.BindingContext> -Objekte erstellt und jedes-Objekt <xref:System.Windows.Forms.BindingContext> der-Eigenschaft <xref:System.Windows.Forms.GroupBox> eines-Steuer Elements zugewiesen. `GroupBox1`enthält `TextBox1`, und `GroupBox2` <xref:System.Windows.Forms.Control.ControlCollection.AddRange%2A> enthält `TextBox2` (<xref:System.Windows.Forms.Control.ControlCollection> Dies wird mithilfe der-Methode der-Klasse erreicht). Im Beispiel werden dann <xref:System.Windows.Forms.Binding> -Objekte zu den <xref:System.Windows.Forms.TextBox> zwei-Steuerelementen hinzugefügt, die jeweils an dieselbe Datenquelle und denselben Datenmember gebunden werden. Das Beispiel zeigt auch zwei Ereignishandler <xref:System.Windows.Forms.BindingContext> , die den aus den <xref:System.Windows.Forms.GroupBox> -Steuerelementen verwenden, <xref:System.Windows.Forms.BindingManagerBase.Position%2A> um die- <xref:System.Windows.Forms.BindingManagerBase> Eigenschaft für verschiedene Objekte festzulegen.  
  
 [!code-cpp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="protected internal void Add (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Add(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Add(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Add (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Add(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="member this.Add : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.Add (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Der mit dem <see cref="T:System.Object" /> verknüpfte <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCore">
      <MemberSignature Language="C#" Value="protected virtual void AddCore (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddCore(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.AddCore(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddCore (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddCore(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberSignature Language="F#" Value="abstract member AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit&#xA;override this.AddCore : obj * System.Windows.Forms.BindingManagerBase -&gt; unit" Usage="bindingContext.AddCore (dataSource, listManager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Das der <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Objekt.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSource" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="listManager" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="protected internal void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Clear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="bindingContext.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht sämtliche <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekte aus der Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCore">
      <MemberSignature Language="C#" Value="protected virtual void ClearCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.ClearCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearCore();" />
      <MemberSignature Language="F#" Value="abstract member ClearCore : unit -&gt; unit&#xA;override this.ClearCore : unit -&gt; unit" Usage="bindingContext.ClearCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CollectionChangeEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CollectionChangeEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingContext.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CollectionChanged As CollectionChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CollectionChangeEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " Usage="member this.CollectionChanged : System.ComponentModel.CollectionChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CollectionChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst beim Behandeln immer eine <see cref="T:System.NotImplementedException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.BindingContext.CollectionChanged> Ereignis ist veraltet und löst immer eine <xref:System.NotImplementedException> aus, wenn es behandelt wird. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Tritt in allen Fällen auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Forms.BindingContext" /> den angegebenen <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj -&gt; bool" Usage="bindingContext.Contains dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste <xref:System.Windows.Forms.Binding> der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen finden Sie unter der-Klasse.  
  
 Informationen zum <xref:System.Windows.Forms.BindingContext.Item%2A> zurückgeben eines <xref:System.Windows.Forms.BindingManagerBase> mit nur einer Datenquelle finden Sie unter der-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.Contains%2A> -Methode verwendet, um <xref:System.Windows.Forms.BindingManagerBase> zu bestimmen, ob ein für jedes Steuerelement in einem Formular vorhanden ist. Das Beispiel übergibt jede <xref:System.Data.DataTable> in einer <xref:System.Data.DataSet> an die-Methode.  
  
 [!code-cpp[Classic BindingContext.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object, dataMember As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="member this.Contains : obj * string -&gt; bool" Usage="bindingContext.Contains (dataSource, dataMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <param name="dataMember">Die Informationen, die zum Auflösen in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> benötigt werden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste <xref:System.Windows.Forms.Binding> der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen finden Sie unter der-Klasse.  
  
 Informationen zum <xref:System.Windows.Forms.BindingContext.Item%2A> zurückgeben eines <xref:System.Windows.Forms.BindingManagerBase> mit einer Datenquelle und einem Datenmember finden Sie in der-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.Contains%2A> -Methode verwendet, um zu <xref:System.Windows.Forms.BindingManagerBase> testen, ob ein bestimmtes vorhanden ist, <xref:System.Windows.Forms.BindingContext.Item%2A> bevor versucht wird, die-Eigenschaft zu erhalten.  
  
 [!code-cpp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn die Auflistung schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle zugeordnet ist.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung <xref:System.Windows.Forms.BindingManagerBase> , wenn die gewünschte keinen Navigationspfad erfordert. Wenn <xref:System.Windows.Forms.BindingManagerBase> beispielsweise eine Gruppe von <xref:System.Windows.Forms.Binding> -Objekten verwaltet, die <xref:System.Collections.ArrayList> oder <xref:System.Data.DataTable> als <xref:System.Windows.Forms.Binding.DataSource%2A>verwenden, ist kein Navigationspfad erforderlich.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft <xref:System.Windows.Forms.BindingManagerBase>gibt immer zurück, und gibt nie `null`zurück.  
  
 Eine Liste <xref:System.Windows.Forms.Binding> der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen finden Sie unter der-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel <xref:System.Windows.Forms.BindingManagerBase> <xref:System.Collections.ArrayList>werden drei Objekte zurückgegeben: eine <xref:System.Data.DataView>für eine, eine für eine und eine für <xref:System.Windows.Forms.Binding.DataSource%2A> die eines <xref:System.Windows.Forms.Binding> -Objekts, das <xref:System.Windows.Forms.TextBox> zu einem-Steuerelement gehört.  
  
 [!code-cpp[Classic BindingContext.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.this Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource, string dataMember] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object, string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object, dataMember As String) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^, System::String ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource, System::String ^ dataMember); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj * string) : System.Windows.Forms.BindingManagerBase" Usage="System.Windows.Forms.BindingContext.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <param name="dataMember">Ein Navigationspfad mit den Informationen, die in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> aufgelöst werden.</param>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle und den angegebenen Datenmember.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung <xref:System.Windows.Forms.BindingManagerBase> , wenn von eine <xref:System.Windows.Forms.Binding> Gruppe von-Objekten verwaltet wird, für die die Datenquelle mehrere-Objekte enthält. Beispielsweise kann ein <xref:System.Data.DataSet> mehrere <xref:System.Data.DataTable> -Objekte enthalten, die <xref:System.Data.DataRelation> von-Objekten verknüpft sind. In einem solchen Fall ist der Navigationspfad erforderlich, damit der <xref:System.Windows.Forms.BindingContext> die richtige <xref:System.Windows.Forms.BindingManagerBase>zurückgeben kann.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft <xref:System.Windows.Forms.BindingManagerBase>gibt immer zurück, wenn der `dataMember` -Parameter gültig ist. Es wird niemals zurück `null`gegeben.  
  
 Eine Liste <xref:System.Windows.Forms.Binding> der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen finden Sie unter der-Klasse.  
  
 Wenn das gewünschte <xref:System.Windows.Forms.BindingManagerBase> eine Liste verwaltet, muss der Navigationspfad ebenfalls mit einer Liste enden. Mit dem folgenden C# Code wird z. b <xref:System.Windows.Forms.TextBox> . ein-Steuerelement an das Bestelldatum in einer Tabelle mit Aufträgen gebunden. Der Navigationspfad enthält <xref:System.Data.DataTable.TableName%2A> <xref:System.Data.DataRelation.RelationName%2A>,, und <xref:System.Data.DataColumn.ColumnName%2A>. Allerdings muss <xref:System.Windows.Forms.BindingManagerBase> der <xref:System.Data.DataTable.TableName%2A> nur mithilfe von und <xref:System.Data.DataRelation.RelationName%2A> abgerufen werden, die in eine Liste aufgelöst werden.  
  
```  
// The navigation path for a Binding ends with a property.  
textBox1.DataBindings.Add  
("Text", dataSet1, "Customers.custToOrders.OrderDate");  
// The navigation path for the BindingManagerBase ends with a list.  
BindingManagerBase bmOrders = this.BindingContext  
[dataSet1, "Customers.custToOrders"];  
```  
  
 Wenn Sie einen <xref:System.Windows.Forms.BindingManagerBase>zurückgeben, sollten Sie die gleiche Datenquelle wie <xref:System.Windows.Forms.Binding> die verwenden und nur den Navigationspfad ändern.  
  
 Verwenden Sie <xref:System.Windows.Forms.BindingContext.Contains%2A> die-Methode, um zu <xref:System.Windows.Forms.BindingManagerBase> bestimmen, ob das gewünschte bereits vorhanden ist  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Windows.Forms.BindingContext.Item%2A> verwendet wird, <xref:System.Windows.Forms.BindingManagerBase> um den für eine bestimmte Bindung abzurufen. Außerdem wird gezeigt, wie das <xref:System.Windows.Forms.BindingManagerBase.BindingComplete> -Ereignis <xref:System.Windows.Forms.BindingManagerBase> für behandelt wird, um sicherzustellen, dass mehrere Steuerelemente, die an dieselbe Datenquelle gebunden sind, synchronisiert bleiben, wenn einer der Steuerelement Werte geändert wird. Fügen Sie zum Ausführen dieses Beispiels den Code in ein Windows Form ein, und `InitializeControlsAndData` nennen Sie die-Methode aus dem Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> der Ereignis Behandlungsmethode.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Der angegebene <paramref name="dataMember" /> ist innerhalb der Datenquelle nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.ComponentModel.CollectionChangeEventArgs ccevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.ComponentModel.CollectionChangeEventArgs ccevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (ccevent As CollectionChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::ComponentModel::CollectionChangeEventArgs ^ ccevent);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.ComponentModel.CollectionChangeEventArgs -&gt; unit" Usage="bindingContext.OnCollectionChanged ccevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ccevent" Type="System.ComponentModel.CollectionChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="ccevent">Ein <see cref="T:System.ComponentModel.CollectionChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingContext.CollectionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingContext.OnCollectionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected internal void Remove (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Remove(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Remove (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Remove(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="bindingContext.Remove dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Löscht die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCore">
      <MemberSignature Language="C#" Value="protected virtual void RemoveCore (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemoveCore(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.RemoveCore(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemoveCore (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RemoveCore(System::Object ^ dataSource);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCore : obj -&gt; unit&#xA;override this.RemoveCore : obj -&gt; unit" Usage="bindingContext.RemoveCore dataSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Entfernt die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array ar, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array ar, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (ar As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ ar, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ar">Ein <see cref="T:System.Array" />, in das kopiert werden soll.</param>
        <param name="index">Der Auflistungsindex, ab dem kopiert werden soll.</param>
        <summary>Kopiert die Elemente der Auflistung beginnend am Auflistungsindex in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der <see cref="T:System.Windows.Forms.CurrencyManager" />-Objekte ab, die vom <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</summary>
        <value>Die Anzahl der Datenquellen, die von <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Anzahl der <xref:System.Windows.Forms.CurrencyManager> -Objekte zurückgegeben <xref:System.Windows.Forms.BindingContext>, die von der verwaltet werden.  
  
 [!code-cpp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung synchronisiert ist.</summary>
        <value><see langword="true" />, wenn die Auflistung threadsicher ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das für die Synchronisierung (Threadsicherheit) verwendet werden soll.</summary>
        <value>Diese Eigenschaft wird von <see cref="T:System.Collections.ICollection" /> abgeleitet und wird überschrieben, sodass immer <see langword="null" /> zurückgegeben wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator für die Auflistung ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.IEnumerator> , der von <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> der-Methode zurückgegeben wird, ermöglicht es Ihnen, <xref:System.Windows.Forms.BindingContext>die von verwaltete Auflistung zu durchlaufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> -Methode verwendet, <xref:System.Collections.IEnumerator> um einen <xref:System.Windows.Forms.BindingContext>für das zurückzugeben.  
  
 [!code-cpp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBinding">
      <MemberSignature Language="C#" Value="public static void UpdateBinding (System.Windows.Forms.BindingContext newBindingContext, System.Windows.Forms.Binding binding);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateBinding(class System.Windows.Forms.BindingContext newBindingContext, class System.Windows.Forms.Binding binding) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.UpdateBinding(System.Windows.Forms.BindingContext,System.Windows.Forms.Binding)" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateBinding(System::Windows::Forms::BindingContext ^ newBindingContext, System::Windows::Forms::Binding ^ binding);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member UpdateBinding : System.Windows.Forms.BindingContext * System.Windows.Forms.Binding -&gt; unit" Usage="System.Windows.Forms.BindingContext.UpdateBinding (newBindingContext, binding)" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBindingContext" Type="System.Windows.Forms.BindingContext" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="binding" Type="System.Windows.Forms.Binding" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="newBindingContext">Der neue <see cref="T:System.Windows.Forms.BindingContext" />, der dem <see cref="T:System.Windows.Forms.Binding" /> zugeordnet werden soll.</param>
        <param name="binding">Das <see cref="T:System.Windows.Forms.Binding" />, das dem neuen <see cref="T:System.Windows.Forms.BindingContext" /> zugeordnet werden soll.</param>
        <summary>Ordnet einem neuen <see cref="T:System.Windows.Forms.Binding" /> ein <see cref="T:System.Windows.Forms.BindingContext" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient zum Aktualisieren der Bindungen von Komponenten, die <xref:System.Windows.Forms.IBindableComponent>implementieren, wenn <xref:System.Windows.Forms.BindingContext> Ihre Änderungen vorgenommen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
