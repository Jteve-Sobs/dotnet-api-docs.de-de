<Type Name="BindingContext" FullName="System.Windows.Forms.BindingContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="007176cc5a06d5e0411f9aa18aded00b939a9363" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659577" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingContext : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingContext extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingContext" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingContext&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingContext : System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CollectionChanged")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Verwaltet die Auflistung von <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekten für ein beliebiges Objekt, das von der <see cref="T:System.Windows.Forms.Control" />-Klasse erbt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Windows Form verfügt über mindestens ein <xref:System.Windows.Forms.BindingContext> Objekt, das verwaltet die <xref:System.Windows.Forms.BindingManagerBase> Objekte für das Formular. Da die <xref:System.Windows.Forms.BindingManagerBase> Klasse ist abstrakt, den Rückgabetyp der <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft ist entweder ein <xref:System.Windows.Forms.CurrencyManager> oder eine <xref:System.Windows.Forms.PropertyManager>. Wenn die Datenquelle ein Objekt ist, die nur eine einzelne Eigenschaft (statt eine Liste von Objekten) zurückgeben, können die <xref:System.Type> ist eine <xref:System.Windows.Forms.PropertyManager>. Wenn Sie angeben, z. B. eine <xref:System.Windows.Forms.TextBox> als Datenquelle, eine <xref:System.Windows.Forms.PropertyManager> zurückgegeben. Andererseits, wenn die Datenquelle ein Objekt ist, implementiert <xref:System.Collections.IList> oder <xref:System.ComponentModel.IBindingList>ein <xref:System.Windows.Forms.CurrencyManager> zurückgegeben wird.  
  
 Für jede Datenquelle in einem Windows Form, es gibt einen einzigen <xref:System.Windows.Forms.CurrencyManager> oder <xref:System.Windows.Forms.PropertyManager>. Da es möglicherweise mehrere Datenquellen mit einem Windows Form, die <xref:System.Windows.Forms.BindingContext> können Sie zum Abrufen einer bestimmtes <xref:System.Windows.Forms.CurrencyManager> einer Datenquelle zugeordnet.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft, die <xref:System.Windows.Forms.BindingContext> erstellt ein neues <xref:System.Windows.Forms.BindingManagerBase> , wenn diese nicht bereits vorhanden ist. Dies kann zu einer gewissen Verwirrung führen, da das zurückgegebene Objekt nicht verwalten kann, der Liste (oder eine beliebige Liste), die Sie aufbewahren. Um zu verhindern, Rückgabe einer ungültigen <xref:System.Windows.Forms.BindingManagerBase>, verwenden Sie die <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um festzustellen, wo die gewünschte <xref:System.Windows.Forms.BindingManagerBase> ist bereits vorhanden.  
  
 Wenn Sie ein Container-Steuerelement, z. B. verwenden eine <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.Panel>, oder <xref:System.Windows.Forms.TabControl>, um datengebundene Steuerelemente enthalten, können Sie erstellen eine <xref:System.Windows.Forms.BindingContext> für diese Container-Steuerelement und seine Steuerelemente. Anschließend kann jeden Teil des Formulars verwaltet werden, durch seine eigene <xref:System.Windows.Forms.BindingManagerBase>. Finden Sie unter der <xref:System.Windows.Forms.BindingContext.%23ctor%2A> Konstruktor für Weitere Informationen zum Erstellen von mehreren <xref:System.Windows.Forms.BindingManagerBase> Objekte für die gleiche Datenquelle.  
  
 Wenn Sie beim Hinzufügen einer <xref:System.Windows.Forms.TextBox> -Steuerelements zu einem Formular und binden es an eine Spalte einer Tabelle in einem Dataset, das Steuerelement kommuniziert mit der <xref:System.Windows.Forms.BindingContext> dieses Formulars. Die <xref:System.Windows.Forms.BindingContext>, kommuniziert wiederum an die spezifische <xref:System.Windows.Forms.CurrencyManager> für diese datenzuordnung. Wenn Sie abgefragt der `Position` Eigenschaft der <xref:System.Windows.Forms.CurrencyManager>, meldet sie den aktuellen Datensatz für die Bindung, die <xref:System.Windows.Forms.TextBox> Steuerelement. Im folgenden Codebeispiel eine <xref:System.Windows.Forms.TextBox> gebunden ist die `FirstName` Spalte eine `Customers` -Tabelle auf die `dataSet1` Dataset über die <xref:System.Windows.Forms.BindingContext> für das Formular befindet er sich auf.  
  
```vb  
TextBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName")  
  
```  
  
```csharp  
textBox1.DataBindings.Add("Text", dataSet1, "Customers.FirstName");  
  
```  
  
```cpp  
textBox1->DataBindings->Add("Text", dataSet1, "Customers.FirstName");  
```  
  
 Können Sie eine zweite hinzufügen <xref:System.Windows.Forms.TextBox> Steuerelement (`TextBox2`) in das Formular und binden Sie es an die `LastName` Spalte der `Customers` -Tabelle in einem Dataset. Die <xref:System.Windows.Forms.BindingContext> erkennt die erste Bindung (`TextBox1` auf `Customers.FirstName`), sodass es die gleiche verwenden würden <xref:System.Windows.Forms.CurrencyManager>, wie beide Textfelder an dasselbe Dataset gebunden sind (`DataSet1`).  
  
```vb  
TextBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName")  
  
```  
  
```csharp  
textBox2.DataBindings.Add("Text", dataSet1, "Customers.LastName");  
  
```  
  
```cpp  
textBox2->DataBindings->Add("Text", dataSet1, "Customers.LastName");  
```  
  
 Wenn Sie binden `TextBox2` auf ein anderes Dataset der <xref:System.Windows.Forms.BindingContext> erstellt und verwaltet eine zweite <xref:System.Windows.Forms.CurrencyManager>.  
  
 Es ist wichtig, darüber, wie Sie festgelegt konsistent sein, damit die <xref:System.Windows.Forms.ListControl.DataSource%2A> und <xref:System.Windows.Forms.ListControl.DisplayMember%2A> Eigenschaften ist, andernfalls der <xref:System.Windows.Forms.BindingContext> erstellt mehrere Currency-Managern für das gleiche Dataset, was zu Fehlern führt. Das folgende Codebeispiel zeigt verschiedene Möglichkeiten, legen Sie die Eigenschaften und ihre zugeordneten <xref:System.Windows.Forms.BindingContext> Objekte. Sie können die mit einer der folgenden Methoden, Eigenschaften festlegen, solange Sie während des gesamten Codes konsistent sind.  
  
```vb  
ComboBox1.DataSource = DataSet1  
ComboBox1.DisplayMember = "Customers.FirstName"  
Me.BindingContext(dataSet1, "Customers").Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1;  
comboBox1.DisplayMember = "Customers.FirstName";  
this.BindingContext[dataSet1, "Customers"].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1;  
comboBox1->DisplayMember = "Customers.FirstName";  
this->BindingContext->get_Item(dataSet1, "Customers")->Position = 1;  
  
```  
  
```vb  
ComboBox1.DataSource = DataSet1.Customers  
ComboBox1.DisplayMember = "FirstName"  
Me.BindingContext(dataSet1.Customers).Position = 1  
  
```  
  
```csharp  
comboBox1.DataSource = DataSet1.Customers;  
comboBox1.DisplayMember = "FirstName";  
this.BindingContext[dataSet1.Customers].Position = 1;  
  
```  
  
```cpp  
comboBox1->DataSource = dataSet1->Customers;  
comboBox1->DisplayMember = "FirstName";  
this->BindingContext->get_Item(dataSet1->Customers)->Position = 1;  
  
```  
  
> [!NOTE]
>  Binden Sie die meisten Windows Forms-Anwendungen über einen <xref:System.Windows.Forms.BindingSource>. Die <xref:System.Windows.Forms.BindingSource> Komponente kapselt einen <xref:System.Windows.Forms.CurrencyManager> und macht die <xref:System.Windows.Forms.CurrencyManager> Programmierschnittstelle. Bei Verwendung eine <xref:System.Windows.Forms.BindingSource> für die Bindung, sollten Sie verwenden Sie die Elemente, die verfügbar gemacht werden, indem Sie die <xref:System.Windows.Forms.BindingSource> zum Bearbeiten von "Currency" (d. h. `Position`) ohne Umweg über die <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt vier <xref:System.Windows.Forms.Binding> Objekte fünf Steuerelemente binden – eine <xref:System.Windows.Forms.DateTimePicker> und vier <xref:System.Windows.Forms.TextBox> Steuerelemente – auf mehrere Datenquellen. Die <xref:System.Windows.Forms.BindingContext> dient dann zum Abrufen der <xref:System.Windows.Forms.BindingManagerBase> für jede Datenquelle.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
    <altmember cref="T:System.Windows.Forms.Binding" />
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.BindingContext" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gegebenenfalls, mehrere <xref:System.Windows.Forms.BindingManagerBase> Instanzen für die gleiche Datenquelle, erstellen Sie ein neues <xref:System.Windows.Forms.BindingContext> und legen Sie dafür die <xref:System.Windows.Forms.Control.BindingContext%2A> Eigenschaft eines Objekts, die von erben die <xref:System.Windows.Forms.Control> Klasse. Angenommen, Sie haben zwei <xref:System.Windows.Forms.BindingManagerBase> Objekte (aus zwei verschiedenen <xref:System.Windows.Forms.BindingContext> Objekte), können Sie festlegen, die <xref:System.Windows.Forms.BindingManagerBase.Position%2A> Eigenschaften der einzelnen <xref:System.Windows.Forms.BindingManagerBase> auf unterschiedliche Werte. Dies bewirkt, dass jeder Satz von datengebundenen Steuerelementen zum Anzeigen von unterschiedliche Werte aus der gleichen Datenquelle.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt zwei neue <xref:System.Windows.Forms.BindingContext> -Objekte und weist jedes Objekt die <xref:System.Windows.Forms.BindingContext> Eigenschaft ein <xref:System.Windows.Forms.GroupBox> Steuerelement. `GroupBox1` enthält `TextBox1`, und `GroupBox2` enthält `TextBox2` (dem erfolgt mithilfe der <xref:System.Windows.Forms.Control.ControlCollection.AddRange%2A> Methode der <xref:System.Windows.Forms.Control.ControlCollection> Klasse). Im Beispiel fügt dann <xref:System.Windows.Forms.Binding> -Objekten, die beiden <xref:System.Windows.Forms.TextBox> Steuerelemente, binden jedes Element dieselbe Datenquelle und Datenmember. Das Beispiel zeigt auch zwei Ereignishandler, mit denen die <xref:System.Windows.Forms.BindingContext> aus der <xref:System.Windows.Forms.GroupBox> Steuerelemente Festlegen der <xref:System.Windows.Forms.BindingManagerBase.Position%2A> Eigenschaft auf verschiedenen <xref:System.Windows.Forms.BindingManagerBase> Objekte.  
  
 [!code-cpp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="protected internal void Add (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Add(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Add(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Add (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Add(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Der mit dem <see cref="T:System.Object" /> verknüpfte <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCore">
      <MemberSignature Language="C#" Value="protected virtual void AddCore (object dataSource, System.Windows.Forms.BindingManagerBase listManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddCore(object dataSource, class System.Windows.Forms.BindingManagerBase listManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.AddCore(System.Object,System.Windows.Forms.BindingManagerBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddCore (dataSource As Object, listManager As BindingManagerBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddCore(System::Object ^ dataSource, System::Windows::Forms::BindingManagerBase ^ listManager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="listManager" Type="System.Windows.Forms.BindingManagerBase" />
      </Parameters>
      <Docs>
        <param name="dataSource">Das der <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Objekt.</param>
        <param name="listManager">Das hinzuzufügende <see cref="T:System.Windows.Forms.BindingManagerBase" />.</param>
        <summary>Fügt der Auflistung die <see cref="T:System.Windows.Forms.BindingManagerBase" /> hinzu, die einer bestimmten Datenquelle zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSource" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="listManager" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="protected internal void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Clear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht sämtliche <see cref="T:System.Windows.Forms.BindingManagerBase" />-Objekte aus der Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCore">
      <MemberSignature Language="C#" Value="protected virtual void ClearCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.ClearCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CollectionChangeEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CollectionChangeEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingContext.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CollectionChanged As CollectionChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CollectionChangeEventHandler ^ CollectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CollectionChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst beim Behandeln immer eine <see cref="T:System.NotImplementedException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.BindingContext.CollectionChanged> Ereignis ist veraltet und löst immer eine <xref:System.NotImplementedException> Wenn behandelt. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Tritt in allen Fällen auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Forms.BindingContext" /> den angegebenen <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der <xref:System.Windows.Forms.Binding> Klasse eine Liste der möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Finden Sie unter der <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft Informationen zum Zurückgeben einer <xref:System.Windows.Forms.BindingManagerBase> nur eine Datenquelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um zu bestimmen, ob eine <xref:System.Windows.Forms.BindingManagerBase> für jedes Steuerelement in einem Formular vorhanden ist. Das Beispiel übergibt jedes <xref:System.Data.DataTable> in einem <xref:System.Data.DataSet> an die Methode.  
  
 [!code-cpp[Classic BindingContext.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Contains(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (dataSource As Object, dataMember As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Ein <see cref="T:System.Object" />, das die Datenquelle darstellt.</param>
        <param name="dataMember">Die Informationen, die zum Auflösen in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> benötigt werden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Windows.Forms.BindingContext" /> die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Windows.Forms.BindingContext" /> das angegebene <see cref="T:System.Windows.Forms.BindingManagerBase" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der <xref:System.Windows.Forms.Binding> Klasse eine Liste mit möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Finden Sie unter der <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft Informationen zum Zurückgeben einer <xref:System.Windows.Forms.BindingManagerBase> mit einer Datenquelle und einem-Datenmember.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode zu testen, ob ein bestimmtes <xref:System.Windows.Forms.BindingManagerBase> vorhanden ist, bevor Sie versuchen, erhalten sie über die <xref:System.Windows.Forms.BindingContext.Item%2A> Eigenschaft.  
  
 [!code-cpp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.Contains1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.Contains1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.Contains1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die Auflistung schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle zugeordnet ist.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die <xref:System.Windows.Forms.BindingManagerBase> erfordert keinen Navigationspfad werden sollen. Z. B. wenn die <xref:System.Windows.Forms.BindingManagerBase> verwaltet einen Satz von <xref:System.Windows.Forms.Binding> -Objekten, bei denen ein <xref:System.Collections.ArrayList> oder <xref:System.Data.DataTable> als die <xref:System.Windows.Forms.Binding.DataSource%2A>, keine Navigationspfad ist erforderlich.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft gibt stets eine <xref:System.Windows.Forms.BindingManagerBase>, und keine zurück `null`.  
  
 Finden Sie unter der <xref:System.Windows.Forms.Binding> Klasse eine Liste mit möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt drei <xref:System.Windows.Forms.BindingManagerBase> Objekte: eine für eine <xref:System.Data.DataView>möglich für ein <xref:System.Collections.ArrayList>, und eine für die <xref:System.Windows.Forms.Binding.DataSource%2A> von einer <xref:System.Windows.Forms.Binding> angehört eine <xref:System.Windows.Forms.TextBox> Steuerelement.  
  
 [!code-cpp[Classic BindingContext.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.this Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BindingManagerBase this[object dataSource, string dataMember] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingManagerBase Item(object, string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.Item(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(dataSource As Object, dataMember As String) As BindingManagerBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BindingManagerBase ^ default[System::Object ^, System::String ^] { System::Windows::Forms::BindingManagerBase ^ get(System::Object ^ dataSource, System::String ^ dataMember); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die einer bestimmten <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <param name="dataMember">Ein Navigationspfad mit den Informationen, die in eine bestimmte <see cref="T:System.Windows.Forms.BindingManagerBase" /> aufgelöst werden.</param>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.BindingManagerBase" /> ab, die der angegebenen Datenquelle und dem angegebenen Datenmember zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Windows.Forms.BindingManagerBase" /> für die angegebene Datenquelle und den angegebenen Datenmember.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die <xref:System.Windows.Forms.BindingManagerBase> verwaltet einen Satz von <xref:System.Windows.Forms.Binding> Objekte, die für die die Datenquelle mehrere Objekte enthält. Z. B. eine <xref:System.Data.DataSet> kann mehrere enthalten <xref:System.Data.DataTable> verknüpft, indem Sie Objekte <xref:System.Data.DataRelation> Objekte. In diesem Fall der Navigationspfad Aktivierung erforderlich ist der <xref:System.Windows.Forms.BindingContext> den richtigen zurückzugebenden <xref:System.Windows.Forms.BindingManagerBase>.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.BindingContext.Item%2A> -Eigenschaft gibt stets eine <xref:System.Windows.Forms.BindingManagerBase>, wenn die `dataMember` Parameter ist ungültig. Es gibt keine zurück `null`.  
  
 Finden Sie unter der <xref:System.Windows.Forms.Binding> Klasse eine Liste mit möglichen Datenquellen und Informationen zum Erstellen von Bindungen zwischen Steuerelementen und Datenquellen.  
  
 Wenn die gewünschte <xref:System.Windows.Forms.BindingManagerBase> verwaltet eine Liste der Navigationspfad auch mit einer Liste enden. Beispielsweise der folgende C#-Code bindet einen <xref:System.Windows.Forms.TextBox> Steuerelement an das Auftragsdatum in einer Tabelle mit Bestellungen. Der Navigationspfad enthält die <xref:System.Data.DataTable.TableName%2A>, <xref:System.Data.DataRelation.RelationName%2A>, und die <xref:System.Data.DataColumn.ColumnName%2A>. Allerdings die <xref:System.Windows.Forms.BindingManagerBase> müssen mit nur abgerufen werden, die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataRelation.RelationName%2A> (dieser wird in einer Liste aufgelöst).  
  
```  
// The navigation path for a Binding ends with a property.  
textBox1.DataBindings.Add  
("Text", dataSet1, "Customers.custToOrders.OrderDate");  
// The navigation path for the BindingManagerBase ends with a list.  
BindingManagerBase bmOrders = this.BindingContext  
[dataSet1, "Customers.custToOrders"];  
```  
  
 Bei der Rückgabe eine <xref:System.Windows.Forms.BindingManagerBase>, sollten Sie die gleiche Datenquelle als verwenden die <xref:System.Windows.Forms.Binding> und nur den Navigationspfad ändern.  
  
 Verwenden der <xref:System.Windows.Forms.BindingContext.Contains%2A> Methode, um festzustellen, wo die gewünschte <xref:System.Windows.Forms.BindingManagerBase> ist bereits vorhanden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.BindingContext.Item%2A> zum Abrufen der <xref:System.Windows.Forms.BindingManagerBase> für eine bestimmte Bindung. Außerdem wird gezeigt, wie behandelt die <xref:System.Windows.Forms.BindingManagerBase.BindingComplete> -Ereignis für die <xref:System.Windows.Forms.BindingManagerBase> um sicherzustellen, dass mehrere an die gleiche Datenquelle gebundenen Steuerelemente synchronisiert bleiben, wenn einer der Steuerelementwerte geändert wird. Um dieses Beispiel auszuführen, fügen Sie den Code in einem Windows Form, und rufen die `InitializeControlsAndData` Methode aus den Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load> Ereignisbehandlungsmethode.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.BindingSourceMultipleControls#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMultipleControls/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Der angegebene <paramref name="dataMember" /> ist innerhalb der Datenquelle nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.Forms.BindingsCollection" />
        <altmember cref="T:System.Windows.Forms.Binding" />
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.ComponentModel.CollectionChangeEventArgs ccevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.ComponentModel.CollectionChangeEventArgs ccevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (ccevent As CollectionChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::ComponentModel::CollectionChangeEventArgs ^ ccevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ccevent" Type="System.ComponentModel.CollectionChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="ccevent">Ein <see cref="T:System.ComponentModel.CollectionChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.BindingContext.CollectionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.BindingContext.OnCollectionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.BindingContext.OnCollectionChanged(System.ComponentModel.CollectionChangeEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected internal void Remove (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void Remove(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub Remove (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void Remove(System::Object ^ dataSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Löscht die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCore">
      <MemberSignature Language="C#" Value="protected virtual void RemoveCore (object dataSource);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RemoveCore(object dataSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.RemoveCore(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RemoveCore (dataSource As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RemoveCore(System::Object ^ dataSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataSource">Die der zu entfernenden <see cref="T:System.Windows.Forms.BindingManagerBase" /> zugeordnete Datenquelle.</param>
        <summary>Entfernt die der angegebenen Datenquelle zugeordnete <see cref="T:System.Windows.Forms.BindingManagerBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array ar, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array ar, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (ar As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ ar, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ar">Ein <see cref="T:System.Array" />, in das kopiert werden soll.</param>
        <param name="index">Der Auflistungsindex, ab dem kopiert werden soll.</param>
        <summary>Kopiert die Elemente der Auflistung beginnend am Auflistungsindex in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der <see cref="T:System.Windows.Forms.CurrencyManager" />-Objekte ab, die vom <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</summary>
        <value>Die Anzahl der Datenquellen, die von <see cref="T:System.Windows.Forms.BindingContext" /> verwaltet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel gibt die Anzahl der <xref:System.Windows.Forms.CurrencyManager> durch verwaltete Objekte die <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.ICollection.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.ICollection.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung synchronisiert ist.</summary>
        <value>
          <see langword="true" />, wenn die Auflistung threadsicher ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird von <xref:System.Collections.ICollection> abgeleitet und wird überschrieben, sodass immer `false` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingContext.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das für die Synchronisierung (Threadsicherheit) verwendet werden soll.</summary>
        <value>Diese Eigenschaft wird von <see cref="T:System.Collections.ICollection" /> abgeleitet und wird überschrieben, sodass immer <see langword="null" /> zurückgegeben wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator für die Auflistung ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.IEnumerator> zurückgegebenes der <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> Methode ermöglicht das Durchlaufen der Auflistung, die von verwaltet die <xref:System.Windows.Forms.BindingContext>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Windows.Forms.BindingContext.System%23Collections%23IEnumerable%23GetEnumerator%2A> -Methode zur Rückgabe einer <xref:System.Collections.IEnumerator> für die <xref:System.Windows.Forms.BindingContext>.  
  
 [!code-cpp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext.IEnumerable.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext.IEnumerable.GetEnumerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateBinding">
      <MemberSignature Language="C#" Value="public static void UpdateBinding (System.Windows.Forms.BindingContext newBindingContext, System.Windows.Forms.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateBinding(class System.Windows.Forms.BindingContext newBindingContext, class System.Windows.Forms.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingContext.UpdateBinding(System.Windows.Forms.BindingContext,System.Windows.Forms.Binding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateBinding(System::Windows::Forms::BindingContext ^ newBindingContext, System::Windows::Forms::Binding ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBindingContext" Type="System.Windows.Forms.BindingContext" />
        <Parameter Name="binding" Type="System.Windows.Forms.Binding" />
      </Parameters>
      <Docs>
        <param name="newBindingContext">Der neue <see cref="T:System.Windows.Forms.BindingContext" />, der dem <see cref="T:System.Windows.Forms.Binding" /> zugeordnet werden soll.</param>
        <param name="binding">Das <see cref="T:System.Windows.Forms.Binding" />, das dem neuen <see cref="T:System.Windows.Forms.BindingContext" /> zugeordnet werden soll.</param>
        <summary>Ordnet einem neuen <see cref="T:System.Windows.Forms.Binding" /> ein <see cref="T:System.Windows.Forms.BindingContext" /> zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient die Bindungen der implementierenden Komponenten aktualisieren <xref:System.Windows.Forms.IBindableComponent>, wenn ihre <xref:System.Windows.Forms.BindingContext> ändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>