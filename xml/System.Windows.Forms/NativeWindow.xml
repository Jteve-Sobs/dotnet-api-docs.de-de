<Type Name="NativeWindow" FullName="System.Windows.Forms.NativeWindow">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f08773771fb4a10a7de82ed774e9bbcb32dbf4e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39979286" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NativeWindow : MarshalByRefObject, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi NativeWindow extends System.MarshalByRefObject implements class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.NativeWindow" />
  <TypeSignature Language="VB.NET" Value="Public Class NativeWindow&#xA;Inherits MarshalByRefObject&#xA;Implements IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class NativeWindow : MarshalByRefObject, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type NativeWindow = class&#xA;    inherit MarshalByRefObject&#xA;    interface IWin32Window" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Kapselung eines Fensterhandles und einer Fensterprozedur auf niedriger Ebene bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse verwaltet automatisch Fenster-Klasse erstellen und registrieren.  
  
 Ein Fenster ist nicht für die Garbagecollection, wenn sie ein Fensterhandle zugeordnet ist. Um sicherzustellen, dass die Garbagecollection, Handles müssen entweder zerstört werden manuell mithilfe <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> oder mit freigegeben <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methode wird aufgerufen, wenn die WM_NCDESTROY-Meldung verarbeitet wird. Dies bedeutet, es gibt Fälle, in die bei Sie nicht manuell aufrufen müssen <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>, aber es empfiehlt sich, dafür ist.  
  
 Die <xref:System.Windows.Forms.NativeWindow> -Klasse bietet die folgenden Eigenschaften und Methoden zum Verwalten von Handles: <xref:System.Windows.Forms.NativeWindow.Handle%2A>, <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A>, <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A>, <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A>, und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abfangender Betriebssystem fenstermeldungen in eine Fensterprozedur, und erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassenname. Das Beispiel erstellt zwei Klassen, die von erben <xref:System.Windows.Forms.NativeWindow> , die dazu.  
  
 Die `MyNativeWindowListener` Klasse stellt eine Verbindung zu der Fensterprozedur des Formulars an den Konstruktor übergeben, und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle zu identifizieren der <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Ruft die `form1.ApplicationActivated` Methode.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Die Klasse veranschaulicht die Verwendung der <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen von fenstermeldungen, die empfangen werden.  
  
 [!code-cpp[NativeWindow#1](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#1)]
 [!code-csharp[NativeWindow#1](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#1)]
 [!code-vb[NativeWindow#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <altmember cref="T:System.IntPtr" />
    <altmember cref="T:System.Windows.Forms.Application" />
    <altmember cref="T:System.Windows.Forms.AxHost" />
    <altmember cref="T:System.Windows.Forms.Control" />
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.IWin32Window" />
    <altmember cref="T:System.Windows.Forms.Message" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NativeWindow();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine Instanz der <see cref="T:System.Windows.Forms.NativeWindow" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Standardeinstellung <xref:System.Windows.Forms.NativeWindow.%23ctor%2A> Konstruktor, der vom Compiler bereitgestellt. Die <xref:System.Windows.Forms.NativeWindow> -Klasse verfügt auch über einen statischen Konstruktor, der Anwendung domänenweite Meldungshandler und Hashtabellen initialisiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="AssignHandle">
      <MemberSignature Language="C#" Value="public void AssignHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssignHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssignHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssignHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.AssignHandle : nativeint -&gt; unit" Usage="nativeWindow.AssignHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle, das diesem Fenster zugewiesen werden soll.</param>
        <summary>Weist diesem Fenster ein Handle zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.NativeWindow.WndProc%2A> fängt der Windows-Meldungen gesendet, um die `handle` Parameter. Verwendung <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Fensterprozedur des Handles an die Standardfensterprozedur zurücksetzen.  
  
 Die <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> Methodenaufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um anzugeben, dass der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
> [!NOTE]
>  Das Handle für das zuweisen, kann nicht in einem anderen Anwendungsprozess sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abfangender Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse stellt eine Verbindung zu der Fensterprozedur des Formulars an den Konstruktor übergeben, und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Behandeln von Methoden zum Bestimmen der <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle wird zugewiesen, auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Ruft die `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codebeispiel.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Diesem Fenster ist bereits ein Handle zugeordnet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Fensterprozedur für das zugeordnete systemeigene Fenster konnte nicht abgerufen werden.</exception>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="public virtual void CreateHandle (System.Windows.Forms.CreateParams cp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateHandle(class System.Windows.Forms.CreateParams cp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CreateHandle (cp As CreateParams)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateHandle(System::Windows::Forms::CreateParams ^ cp);" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : System.Windows.Forms.CreateParams -&gt; unit&#xA;override this.CreateHandle : System.Windows.Forms.CreateParams -&gt; unit" Usage="nativeWindow.CreateHandle cp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cp" Type="System.Windows.Forms.CreateParams" />
      </Parameters>
      <Docs>
        <param name="cp">Ein <see cref="T:System.Windows.Forms.CreateParams" />, das die Erstellungsparameter für dieses Fenster angibt.</param>
        <summary>Erstellt mithilfe der angegebenen Erstellungsparameter ein Fenster mit dem zugehörigen Handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cp` Parameter gibt an, die Werte, die an die systemeigene Win32 übergeben werden `CreateWindowEx` Methode, um ein Fenster und das Handle zu erstellen.  
  
 Wenn die <xref:System.Windows.Forms.CreateParams.ClassName%2A> Feld ist nicht `null`, das neu erstellte Fenster-Handle aus der angegebenen Klasse erbt. Z. B. wenn <xref:System.Windows.Forms.CreateParams.ClassName%2A> nastaven NA hodnotu `BUTTON`, das neu erstellte Fenster basiert darauf, dass die Win32 `BUTTON` Fensterklasse. Die <xref:System.Windows.Forms.CreateParams.Param%2A> Eigenschaft der <xref:System.Windows.Forms.CreateParams.ClassName%2A> Objekt muss entweder `null` oder Verweis auf eine Instanz einer Klasse, die als Struktur deklariert wurde.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codebeispiel.  
  
> [!NOTE]
>  Der bereitgestellte Klassenname ist mit dem Betriebssystem registriert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassenname. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird eine Schaltfläche Win32-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Window-Stile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen von fenstermeldungen, die empfangen werden. Im Beispiel wird für die Nachricht WM_ACTIVATEAPP gesucht werden soll, kann dies in einem realen Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Meldungen an das übergeordnete Fenster anstelle des Fensters. Finden Sie unter der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Das Betriebssystem verfügte nicht über ausreichende Ressourcen zum Erstellen des systemeigenen Fensters.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die systemeigene Win32-API konnte das angegebene Fenster nicht erstellen.</exception>
        <exception cref="T:System.InvalidOperationException">Das Handle des aktuellen systemeigenen Fensters wurde bereits zugeordnet, d. h., die Eigenschaft <see cref="P:System.Windows.Forms.NativeWindow.Handle" /> ist ungleich <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Um ein Fenster auf oberster Ebene zu erstellen. Diese Berechtigung ist nur gefordert werden, wenn der Fensterstil nicht über ein untergeordnetes Element ist oder wenn das Fenster nicht über ein übergeordnetes Element verfügt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="public void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="member this.DefWndProc :  -&gt; unit" Usage="nativeWindow.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die derzeit verarbeitete Meldung.</param>
        <summary>Ruft die diesem Fenster zugeordnete Standardfensterprozedur auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel nur rufen Sie die <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> Methode, wenn Sie Abfangen von fenstermeldungen sind, und die Standardfensterprozedur zur Verarbeitung der Nachricht möchten. <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> sollte nicht aufgerufen werden, um eine fenstermeldung an das Fenster zu senden. Rufen Sie die Win32 `SendMessage` stattdessen funktionieren.  
  
 Es ist ein Fehler Aufrufen <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> bei der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft ist 0.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode in einer abgeleiteten Klasse zum Implementieren von benutzerdefinierten generalisierte Meldungsbehandlung für einen bestimmten systemeigene Fenster oder eine .NET Windows Forms <see cref="T:System.Windows.Forms.Control" />. Benutzerdefinierte Verarbeitung kann ausgeführt werden, vor, nach oder anstatt eines Aufrufs an die basisklassenimplementierung dieser Methode, die standard-Nachrichtenverarbeitung führt.  Im Gegensatz dazu Hinzufügen benutzerdefinierter Nachrichtenbehandlung für eine Anwendung kann, über ausgeführt werden die <see cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" /> Methode der <see cref="T:System.Windows.Forms.Application" /> Klasse.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="public virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="nativeWindow.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zerstört das Fenster und das Handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zerstört das Fenster zugeordnet der <xref:System.Windows.Forms.NativeWindow.Handle%2A>, legt die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 und der Aufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um die Änderung zu übernehmen. In der Regel nur aufrufen <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> Sie abschließend das systemeigene Fenster.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow> Klasse automatisch zerstört das zugeordnete Fenster und ihre Ressourcen als Reaktion auf eine WM_DESTROY-Meldung freizugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NativeWindow ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="nativeWindow.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die diesem Fenster zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.NativeWindow.Finalize%2A> Methode entfernt die abgeleitete Win32-Klasse mit dem aktuellen <xref:System.Windows.Forms.NativeWindow> -Instanz gibt das Handle frei, und sendet Sie eine WM_CLOSE-Meldung an das zugeordnete Fenster.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.#ctor" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.NativeWindow FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.NativeWindow FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As NativeWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::NativeWindow ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.NativeWindow" Usage="System.Windows.Forms.NativeWindow.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NativeWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Handle für ein Fenster.</param>
        <summary>Ruft das dem angegebenen Handle zugeordnete Fenster ab.</summary>
        <returns>Das dem angegebenen Handle zugeordnete <see cref="T:System.Windows.Forms.NativeWindow" />. Diese Methode gibt <see langword="null" /> zurück, wenn dem Handle kein Fenster zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Handle von einer anderen Methode erhalten, verwenden Sie diese Methode, um das Fenster, die dem Handle zugeordneten abzurufen. Das Handle muss bereits im Besitz eines anderen <xref:System.Windows.Forms.NativeWindow> im aktuellen Prozess ist, andernfalls `null` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.NativeWindow.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.NativeWindow.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für dieses Fenster ab.</summary>
        <value>Bei einem erfolgreichen Abruf ein <see cref="T:System.IntPtr" />, der das Handle für das zugeordnete systemeigene Win32-Fenster darstellt, andernfalls 0 (null), wenn dem Fenster kein Handle zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode beim Aufrufen von Windows-API-Methoden, die ein Handle für eine Fenster- oder Steuerelement zu erfordern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassenname. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen. Das Beispiel zeigt auch, überschreiben die <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Änderungen.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> auf die Schaltfläche "festgelegt. Dadurch wird eine Schaltfläche Win32-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Window-Stile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen von fenstermeldungen, die empfangen werden. Im Beispiel wird für die Nachricht WM_ACTIVATEAPP gesucht werden soll, kann dieser in einem realen Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Meldungen an das übergeordnete Fenster anstelle des Fensters. Finden Sie unter der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleChange">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleChange();" />
      <MemberSignature Language="F#" Value="abstract member OnHandleChange : unit -&gt; unit&#xA;override this.OnHandleChange : unit -&gt; unit" Usage="nativeWindow.OnHandleChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Benachrichtigungsmethode an, die aufgerufen wird, wenn das Handle für ein Fenster geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassenname. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen. Das Beispiel zeigt auch, überschreiben die <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Änderungen.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird eine Schaltfläche Win32-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Window-Stile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen von fenstermeldungen, die empfangen werden. Im Beispiel wird für die Nachricht WM_ACTIVATEAPP gesucht werden soll, kann dies in einem realen Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codebeispiel.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Meldungen an das übergeordnete Fenster anstelle des Fensters. Finden Sie unter der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode zum Nachverfolgen von Änderungen, die an der das Fensterhandle vorgenommen werden.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="protected virtual void OnThreadException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnThreadException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnThreadException (e As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnThreadException(Exception ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnThreadException : Exception -&gt; unit&#xA;override this.OnThreadException : Exception -&gt; unit" Usage="nativeWindow.OnThreadException e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">Eine <see cref="T:System.Exception" />, die die nicht behandelte Threadausnahme angibt.</param>
        <summary>Verwaltet beim Überschreiben in einer abgeleiteten Klasse eine nicht behandelte Threadausnahme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Windows.Forms.Application.OnThreadException%2A> Behandlung der thread-Ausnahmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="T:System.Windows.Forms.Application" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="public virtual void ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseHandle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; unit&#xA;override this.ReleaseHandle : unit -&gt; unit" Usage="nativeWindow.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das diesem Fenster zugeordnete Handle frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht das Fensterhandle zerstören. Stattdessen wird das Handle der Fensterprozedur an die Standardfensterprozedur. Wird die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 fest und ruft <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> um die Änderung wiederzugeben.  
  
 Ein Fenster ruft diese Methode automatisch, wenn sie eine native WM_NCDESTROY-Win32-Nachricht empfängt, gibt an, dass Windows das Handle zerstört wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abfangender Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse stellt eine Verbindung zu der Fensterprozedur des Formulars an den Konstruktor übergeben, und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle zu identifizieren die <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Ruft die `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codebeispiel.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="nativeWindow.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die der aktuellen Windows-Meldung zugeordnet ist.</param>
        <summary>Ruft die diesem Fenster zugeordnete Standardfensterprozedur auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn eine fenstermeldung für das Handle des Fensters gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abfangender Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erbt <xref:System.Windows.Forms.NativeWindow> um dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse stellt eine Verbindung zu der Fensterprozedur des Formulars an den Konstruktor übergeben, und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle zu identifizieren die <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle wird zugewiesen, auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Ruft die `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codebeispiel.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode, um bestimmten Nachrichtenverarbeitung zu implementieren. Rufen Sie <c>Basis. WndProc</c> für nicht verarbeitete Nachrichten.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnThreadException(System.Exception)" />
      </Docs>
    </Member>
  </Members>
</Type>