<Type Name="NativeWindow" FullName="System.Windows.Forms.NativeWindow">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="547a0fa86ff2ce303d6c98e4bb8cd3b372c52847" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36517313" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NativeWindow : MarshalByRefObject, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi NativeWindow extends System.MarshalByRefObject implements class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.NativeWindow" />
  <TypeSignature Language="VB.NET" Value="Public Class NativeWindow&#xA;Inherits MarshalByRefObject&#xA;Implements IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class NativeWindow : MarshalByRefObject, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type NativeWindow = class&#xA;    inherit MarshalByRefObject&#xA;    interface IWin32Window" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Kapselung eines Fensterhandles und einer Fensterprozedur auf niedriger Ebene bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse verwaltet automatisch erstellen und die Registrierung.  
  
 Ein Fenster ist nicht für die Garbagecollection geeignet, wenn sie ein Fensterhandle zugeordnet ist. Um sicherzustellen, dass die Garbagecollection, Handles müssen entweder zerstört manuell mit <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> oder freigegeben werden, mithilfe von <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methode wird aufgerufen, wenn die WM_NCDESTROY-Meldung verarbeitet wird. Dies bedeutet, es gibt Fälle, in das bei Sie nicht manuell aufrufen müssen <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>, aber es empfiehlt sich zu diesem Zweck ist.  
  
 Die <xref:System.Windows.Forms.NativeWindow> Klasse enthält die folgenden Eigenschaften und Methoden zum Verwalten von Handles: <xref:System.Windows.Forms.NativeWindow.Handle%2A>, <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A>, <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A>, <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A>, und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur auf, und erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt zwei Klassen, die von erben <xref:System.Windows.Forms.NativeWindow> , die dieses Ziel erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Die Klasse veranschaulicht die Verwendung der <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden.  
  
 [!code-cpp[NativeWindow#1](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#1)]
 [!code-csharp[NativeWindow#1](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#1)]
 [!code-vb[NativeWindow#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <altmember cref="T:System.IntPtr" />
    <altmember cref="T:System.Windows.Forms.Application" />
    <altmember cref="T:System.Windows.Forms.AxHost" />
    <altmember cref="T:System.Windows.Forms.Control" />
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.IWin32Window" />
    <altmember cref="T:System.Windows.Forms.Message" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NativeWindow();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine Instanz der <see cref="T:System.Windows.Forms.NativeWindow" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die Standardeinstellung <xref:System.Windows.Forms.NativeWindow.%23ctor%2A> Konstruktors vom Compiler bereitgestellt. Die <xref:System.Windows.Forms.NativeWindow> -Klasse verfügt auch über einen statischen Konstruktor, der Anwendung domänenweite Meldungshandler und Hashtabellen initialisiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="AssignHandle">
      <MemberSignature Language="C#" Value="public void AssignHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssignHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssignHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssignHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.AssignHandle : nativeint -&gt; unit" Usage="nativeWindow.AssignHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle, das diesem Fenster zugewiesen werden soll.</param>
        <summary>Weist diesem Fenster ein Handle zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.NativeWindow.WndProc%2A> fängt fenstermeldungen gesendet, um die `handle` Parameter. Verwendung <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Fensterprozedur auf das Handle an die Standardfensterprozedur zurücksetzen.  
  
 Die <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> Methodenaufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um anzugeben, dass der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
> [!NOTE]
>  In einem anderen Anwendungsprozess darf nicht das Handle zugewiesen sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> -Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Behandeln von Methoden zum Bestimmen der <xref:System.Windows.Forms.NativeWindow> verwenden. Das Handle zugewiesen ist, basierend auf den <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Diesem Fenster ist bereits ein Handle zugeordnet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Fensterprozedur für das zugeordnete systemeigene Fenster konnte nicht abgerufen werden.</exception>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="public virtual void CreateHandle (System.Windows.Forms.CreateParams cp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateHandle(class System.Windows.Forms.CreateParams cp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CreateHandle (cp As CreateParams)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateHandle(System::Windows::Forms::CreateParams ^ cp);" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : System.Windows.Forms.CreateParams -&gt; unit&#xA;override this.CreateHandle : System.Windows.Forms.CreateParams -&gt; unit" Usage="nativeWindow.CreateHandle cp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cp" Type="System.Windows.Forms.CreateParams" />
      </Parameters>
      <Docs>
        <param name="cp">Ein <see cref="T:System.Windows.Forms.CreateParams" />, das die Erstellungsparameter für dieses Fenster angibt.</param>
        <summary>Erstellt mithilfe der angegebenen Erstellungsparameter ein Fenster mit dem zugehörigen Handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `cp` Parameter gibt die Werte, die an die systemeigenen Win32 übergeben werden `CreateWindowEx` Methode, um ein Fenster und dessen Handle zu erstellen.  
  
 Wenn die <xref:System.Windows.Forms.CreateParams.ClassName%2A> Feld ist nicht `null`, das neu erstellte Fensterhandle von der angegebenen Klasse erbt. Z. B. wenn <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt ist, um `BUTTON`, das neu erstellte Fenster basiert auf die Win32 `BUTTON` Fensterklasse. Die <xref:System.Windows.Forms.CreateParams.Param%2A> Eigenschaft von der <xref:System.Windows.Forms.CreateParams.ClassName%2A> Objekt muss entweder `null` oder Verweis auf eine Instanz einer Klasse, die als Struktur deklariert wurde.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
> [!NOTE]
>  Der bereitgestellte Klassenname ist mit dem Betriebssystem registriert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, kann dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Das Betriebssystem verfügte nicht über ausreichende Ressourcen zum Erstellen des systemeigenen Fensters.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Die systemeigene Win32-API konnte das angegebene Fenster nicht erstellen.</exception>
        <exception cref="T:System.InvalidOperationException">Das Handle des aktuellen systemeigenen Fensters wurde bereits zugeordnet, d. h., die Eigenschaft <see cref="P:System.Windows.Forms.NativeWindow.Handle" /> ist ungleich <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Um ein Fenster oberster Ebene zu erstellen. Durch diese Berechtigung wird nur dann gefordert, wenn der Fensterstil nicht untergeordnet ist oder wenn das Fenster nicht über ein übergeordnetes Element verfügt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="public void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="member this.DefWndProc :  -&gt; unit" Usage="nativeWindow.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die derzeit verarbeitete Meldung.</param>
        <summary>Ruft die diesem Fenster zugeordnete Standardfensterprozedur auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel nur rufen Sie die <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> Methode, wenn fenstermeldungen abfangen sind und die standardmäßige Fensterprozedur auf, die Nachricht behandeln möchten. <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> sollte nicht aufgerufen werden, um eine fenstermeldung an das Fenster zu senden. Rufen Sie die Win32 `SendMessage` stattdessen-Funktion.  
  
 Es ist ein Fehler auf, rufen Sie <xref:System.Windows.Forms.NativeWindow.DefWndProc%2A> bei der <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft ist 0.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode in einer abgeleiteten Klasse zum Implementieren von benutzerdefinierten generalisierte Meldungsbehandlung für einen bestimmten systemeigene Fenster oder .NET Windows Forms <see cref="T:System.Windows.Forms.Control" />. Benutzerdefinierte Verarbeitung kann ausgeführt werden, vor, nach oder statt einen Aufruf der basisklassenimplementierung dieser Methode, die standard-Nachrichtenverarbeitung ausführt.  Im Gegensatz dazu Hinzufügen benutzerdefinierter Nachrichtenbehandlung für eine Anwendung über durchgeführt werden, kann die <see cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" /> Methode der <see cref="T:System.Windows.Forms.Application" /> Klasse.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="public virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="nativeWindow.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zerstört das Fenster und das Handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zerstört, die zugeordnete Fenster die <xref:System.Windows.Forms.NativeWindow.Handle%2A>, legt der <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 und der Aufrufe der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode, um die Änderung zu übernehmen. In der Regel nur aufrufen <xref:System.Windows.Forms.NativeWindow.DestroyHandle%2A> Wenn Sie das systemeigene Fenster fertig sind.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.NativeWindow> -Klasse automatisch zerstört das zugeordnete Fenster und Freigeben der Ressourcen in der Antwort an eine WM_DESTROY-Meldung.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NativeWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NativeWindow ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="nativeWindow.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die diesem Fenster zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.NativeWindow.Finalize%2A> Methode entfernt die abgeleitete Win32-Klasse, die mit dem aktuellen gehört <xref:System.Windows.Forms.NativeWindow> Instanz, die das Handle freigegeben und sendet eine WM_CLOSE-Meldung an das zugeordnete Fenster.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.#ctor" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.NativeWindow FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.NativeWindow FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As NativeWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::NativeWindow ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.NativeWindow" Usage="System.Windows.Forms.NativeWindow.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NativeWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Handle für ein Fenster.</param>
        <summary>Ruft das dem angegebenen Handle zugeordnete Fenster ab.</summary>
        <returns>Das dem angegebenen Handle zugeordnete <see cref="T:System.Windows.Forms.NativeWindow" />. Diese Methode gibt <see langword="null" /> zurück, wenn dem Handle kein Fenster zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Handle von einer anderen Methode erhalten, verwenden Sie diese Methode, um das Fenster, die dem Handle zugeordneten abzurufen. Das Handle muss bereits im Besitz eines anderen <xref:System.Windows.Forms.NativeWindow> im aktuellen Prozess ist, andernfalls `null` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.NativeWindow.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.NativeWindow.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für dieses Fenster ab.</summary>
        <value>Bei einem erfolgreichen Abruf ein <see cref="T:System.IntPtr" />, der das Handle für das zugeordnete systemeigene Win32-Fenster darstellt, andernfalls 0 (null), wenn dem Fenster kein Handle zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode beim Aufrufen von Windows-API-Methoden, die ein Handle für ein Fenster oder ein Steuerelement zu erfordern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen. Auch das Beispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode Wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> ändert.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> legen Sie auf die Schaltfläche. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, konnte dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleChange">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleChange();" />
      <MemberSignature Language="F#" Value="abstract member OnHandleChange : unit -&gt; unit&#xA;override this.OnHandleChange : unit -&gt; unit" Usage="nativeWindow.OnHandleChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Benachrichtigungsmethode an, die aufgerufen wird, wenn das Handle für ein Fenster geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn der Wert des der <xref:System.Windows.Forms.NativeWindow.Handle%2A> -Eigenschaft geändert hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen ein Fenster mit einem bestimmten Betriebssystem Fensterklassennamen. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen. Auch das Beispiel veranschaulicht das Überschreiben der <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> Methode Wenn benachrichtigt werden, die <xref:System.Windows.Forms.NativeWindow.Handle%2A> ändert.  
  
 Die `MyNativeWindow` Klasse erstellt ein neues Fenster mit den <xref:System.Windows.Forms.CreateParams.ClassName%2A> festgelegt `BUTTON`. Dadurch wird ein Win32-Schaltfläche-Fenster erstellt. Die Position und Größe der Schaltfläche festgelegt ist, zusammen mit zusätzlichen Fensterstile angeben. Die Klasse veranschaulicht, wie die <xref:System.Windows.Forms.NativeWindow.CreateHandle%2A> -Methode und überschreiben die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode, um die Intercept-fenstermeldungen, die empfangen werden. Obwohl das Beispiel für die Nachricht WM_ACTIVATEAPP aussieht, kann dieser in ein echtes Programm mit Windows-Meldungen, die spezifisch für den erstellten Typ ersetzt werden.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
> [!NOTE]
>  Einige Steuerelementtypen senden ihre Windows-Nachrichten an das übergeordnete Fenster, anstatt das Fenster. Finden Sie in der Windows-Plattform-SDK für Weitere Informationen.  
  
 [!code-cpp[NativeWindow#3](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#3)]
 [!code-csharp[NativeWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#3)]
 [!code-vb[NativeWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode zum Nachverfolgen von Änderungen, die an das Fensterhandle vorgenommen werden.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="protected virtual void OnThreadException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnThreadException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnThreadException (e As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnThreadException(Exception ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnThreadException : Exception -&gt; unit&#xA;override this.OnThreadException : Exception -&gt; unit" Usage="nativeWindow.OnThreadException e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">Eine <see cref="T:System.Exception" />, die die nicht behandelte Threadausnahme angibt.</param>
        <summary>Verwaltet beim Überschreiben in einer abgeleiteten Klasse eine nicht behandelte Threadausnahme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Windows.Forms.Application.OnThreadException%2A> Handles thread Ausnahmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="T:System.Windows.Forms.Application" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="public virtual void ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseHandle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; unit&#xA;override this.ReleaseHandle : unit -&gt; unit" Usage="nativeWindow.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das diesem Fenster zugeordnete Handle frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zerstört nicht das Fensterhandle. Stattdessen wird das Handle Fensterprozedur an die Standardfensterprozedur. Es legt die <xref:System.Windows.Forms.NativeWindow.Handle%2A> Eigenschaft auf 0 fest und ruft <xref:System.Windows.Forms.NativeWindow.OnHandleChange%2A> um die Änderung zu übernehmen.  
  
 Ein Fenster ruft diese Methode automatisch, wenn sie eine systemeigene WM_NCDESTROY-Win32-Nachricht empfängt, gibt an, dass Windows das Handle zerstört wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> -Methode fängt die `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle ist zuweisen, die auf Grundlage der <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.AssignHandle(System.IntPtr)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.CreateHandle(System.Windows.Forms.CreateParams)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnHandleChange" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.NativeWindow.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="nativeWindow.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die der aktuellen Windows-Meldung zugeordnet ist.</param>
        <summary>Ruft die diesem Fenster zugeordnete Standardfensterprozedur auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn eine Meldung an das Handle des Fensters gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, abgefangen Betriebssystem fenstermeldungen in eine Fensterprozedur. Das Beispiel erstellt eine Klasse, die von erben <xref:System.Windows.Forms.NativeWindow> , dies zu erreichen.  
  
 Die `MyNativeWindowListener` Klasse hooks in die Fensterprozedur des Formulars an den Konstruktor übergeben und überschreibt die <xref:System.Windows.Forms.NativeWindow.WndProc%2A> Methode zum Abfangen der `WM_ACTIVATEAPP` fenstermeldung. Die Klasse veranschaulicht die Verwendung von der <xref:System.Windows.Forms.NativeWindow.AssignHandle%2A> und <xref:System.Windows.Forms.NativeWindow.ReleaseHandle%2A> Methoden, um das Fensterhandle identifizieren die <xref:System.Windows.Forms.NativeWindow> verwendet. Das Handle zugewiesen ist, basierend auf den <xref:System.Windows.Forms.Control.HandleCreated?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.HandleDestroyed?displayProperty=nameWithType> Ereignisse. Wenn die `WM_ACTIVATEAPP` fenstermeldung empfangen wird, die Klasse ruft der `form1.ApplicationActivated` Methode.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.NativeWindow> -Klassenübersicht. Code ist für die Übersichtlichkeit nicht dargestellt. Finden Sie unter <xref:System.Windows.Forms.NativeWindow> für das gesamte Codelisting.  
  
 [!code-cpp[NativeWindow#2](~/samples/snippets/cpp/VS_Snippets_Winforms/NativeWindow/CPP/form1.cpp#2)]
 [!code-csharp[NativeWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/NativeWindow/CS/form1.cs#2)]
 [!code-vb[NativeWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/NativeWindow/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Überschreiben Sie diese Methode, um die Verarbeitung von bestimmten Nachrichten implementieren. Rufen Sie <c>Basis. WndProc</c> für nicht verarbeitete Nachrichten.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.NativeWindow.Handle" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
        <altmember cref="M:System.Windows.Forms.NativeWindow.OnThreadException(System.Exception)" />
      </Docs>
    </Member>
  </Members>
</Type>