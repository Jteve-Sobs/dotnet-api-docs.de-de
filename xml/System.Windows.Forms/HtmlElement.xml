<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e5eed01eec485e323eafdf110daf33aa3de5a981" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82498060" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ein HTML-Element innerhalb einer Webseite dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> Stellt alle möglichen Typen des Elements in einem HTML-Dokument dar, z. B. `BODY`, `TABLE`, und `FORM`, u. a. Die-Klasse macht die gängigsten Eigenschaften verfügbar, die Sie für alle Elemente erwarten können.  
  
 Die meisten Elemente können über untergeordnete *Elemente*verfügen: andere HTML-Elemente, die unterhalb der Elemente platziert werden. Verwenden Sie die <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A>-Eigenschaft, um zu testen, ob ein bestimmtes Element über untergeordnete Elemente verfügt, und die <xref:System.Windows.Forms.HtmlElement.Children%2A> Auflistung, um Sie zu durchlaufen. Die <xref:System.Windows.Forms.HtmlElement.Parent%2A>-Eigenschaft gibt die <xref:System.Windows.Forms.HtmlElement> zurück, in der das aktuelle Element eingebettet ist.  
  
 Sie benötigen häufig Zugriff auf Attribute, Eigenschaften und Methoden für das zugrunde liegende Element, die nicht direkt von <xref:System.Windows.Forms.HtmlElement>verfügbar gemacht werden, z. b. das `SRC`-Attribut in einem `IMG`-Element oder die `Submit`-Methode in einer `FORM`. Mit den Methoden <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> und <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> können Sie beliebige Attribute oder Eigenschaften für ein bestimmtes Element abrufen und ändern, während <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> den Zugriff auf alle Methoden ermöglicht, die nicht im verwalteten Dokumentobjektmodell (Managed, DOM) verfügbar gemacht werden. Wenn die Anwendung die Berechtigung für nicht verwalteten Code hat, können Sie auch mit dem <xref:System.Windows.Forms.HtmlElement.DomElement%2A>-Attribut auf nicht verfügbar gemachte Eigenschaften und Methoden zugreifen.  
  
 Verwenden Sie die <xref:System.Windows.Forms.HtmlElement.TagName%2A>-Eigenschaft, um zu testen, ob ein Element einen bestimmten Typ hat.  
  
 Alle HTML-Dokumente können zur Laufzeit geändert werden. Sie können neue <xref:System.Windows.Forms.HtmlElement> Objekte mit der <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>-Methode von <xref:System.Windows.Forms.HtmlDocument>erstellen und Sie einem anderen Element mithilfe der Methoden <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> oder <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> hinzufügen. Sie können die Elemente auch als HTML-Tags erstellen und Sie einem vorhandenen Element <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>-Eigenschaft zuweisen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein beliebiges HTML-Dokument untersucht und eine Zeichenfolge abgeleitet wird, in der die HTML-Elemente beschrieben werden, wobei Einzug und Ebene verwendet werden, um anzugeben, wie tief geschachtelte Elemente im Dokument enthalten sind. Dieses Codebeispiel erfordert, dass Ihre Anwendung ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`hostet.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104876">IHTMLElement-Schnittstelle</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">IHTMLElement2-Schnittstelle</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104878">IHTMLElement3-Schnittstelle</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104879">IHTMLElement4-Schnittstelle</related>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.HtmlElementCollection" /> aller Elemente unterhalb des aktuellen Elements ab.</summary>
        <value>Eine Auflistung aller Elemente, die direkt oder indirekt untergeordnete Elemente des aktuellen Elements sind. Wenn das aktuelle Element z <c>. b.</c>eine <c>Tabelle</c>ist, gibt <see cref="P:System.Windows.Forms.HtmlElement.All" /> jedes-, <c>TR</c>-und <c>TD</c> -Element innerhalb der Tabelle sowie alle anderen in den Zellen enthaltenen Elemente zurück, z. b. <c>div</c> -und <c>Span</c> -Elemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nur auf die Elemente zugreifen möchten, die über das aktuelle Element als direkt übergeordnetes Element verfügen, verwenden Sie stattdessen die <xref:System.Windows.Forms.HtmlElement.Children%2A>-Auflistung.  
  
 Elemente in dieser Auflistung werden nicht notwendigerweise in der Quell Reihenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">Das <see cref="T:System.Windows.Forms.HtmlElement" />, das an dieser Position in der Struktur angefügt werden soll.</param>
        <summary>Fügt der Teilstruktur eines Elements ein anderes Element hinzu.</summary>
        <returns>Das Element, nachdem es der Struktur hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dem HTML-Dokumentobjektmodell (DOM) können Sie den Lauf Zeit Inhalt einer HTML-Datei auf verschiedene Weise ändern. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>, um einem vorhandenen Dokument neue Elemente hinzuzufügen, oder um ein Element auf der Seite zu verschieben.  
  
 Wenn ein Element bereits ein übergeordnetes Element aufweist, wird dieses Element durch das Anfügen eines Elements an ein anderes Element automatisch aus dem vorherigen übergeordneten Element entfernt.  
  
 Ergänzungen, die zur Laufzeit mithilfe von <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> an einem Dokument vorgenommen werden, werden nicht persistent gespeichert, wenn Sie die <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A>-Methode für das <xref:System.Windows.Forms.WebBrowser>-Steuerelement aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein neuer Hyperlink mithilfe der <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>-Methode erstellt und am Ende einer Seite mithilfe `AppendChild` auf dem `BODY`-Element hinzugefügt. Das Beispiel setzt voraus, dass die Anwendung ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`enthält.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild">AppendChild-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachEventHandler (eventName As String, eventHandler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Der Name des zu behandelnden Ereignisses.</param>
        <param name="eventHandler">Der verwaltete Code, der das Ereignis behandelt.</param>
        <summary>Fügt im HTML-DOM (Document Object Model) einen Ereignishandler für ein benanntes Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der verwaltete Dokumentobjektmodell (DOM) macht nur eine ausgewählte Anzahl von Ereignissen verfügbar. Die meisten nicht verfügbar gemachten Ereignisse werden nur für bestimmte Elementtypen definiert. beispielsweise das `submit` Ereignis, das nur für `FORM` Elemente gültig ist. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A>, um diesen nicht verfügbar gemachten Ereignissen einen Ereignishandler hinzuzufügen.  
  
 Sie sollten erst ein Ereignis an das Dokument oder eines seiner Objekte anfügen, wenn das Laden des Dokuments abgeschlossen ist. Die früheste Methode, die diese Methode aufruft, ist das <xref:System.Windows.Forms.WebBrowser.DocumentCompleted>-Ereignis des <xref:System.Windows.Forms.WebBrowser> Steuer Elements.  
  
 Weitere Informationen zu den verfügbaren nicht verwalteten Ereignissen finden Sie unter [zugreifen auf nicht verfügbar gemachte Member im verwalteten HTML-Dokumentobjektmodell und in](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) den IHTMLElement-Schnittstellen: [IHTMLElement](https://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](https://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](https://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](https://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</related>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Element über untergeordnete Elemente verfügen kann.</summary>
        <value><see langword="true" />, wenn das Element über untergeordnete Elemente verfügen kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Elemente, wie z. b. `IMG` und `SCRIPT`, können keine untergeordneten Elemente aufweisen. Verwenden Sie diese Eigenschaft, bevor Sie <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> oder <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> für ein beliebiges Element aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.HtmlElement.Click>-Ereignis auf <xref:System.Windows.Forms.HtmlDocument>behandelt. Wenn ein Element nicht zuvor mithilfe eines Mausklicks ausgewählt wurde, weist der Code das Element einer privaten Klassen Variablen namens `MoveElement`zu. Wenn ein Element ausgewählt wurde, versucht der Code, es an das Element anzufügen, auf das soeben geklickt wurde. Dieses Codebeispiel setzt voraus, dass Ihre Anwendung ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`hostet und bereits einen Ereignishandler für das <xref:System.Windows.Forms.HtmlElement.Click>-Ereignis auf <xref:System.Windows.Forms.HtmlDocument>hinzugefügt hat.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Windows.Forms.HtmlElementCollection" /> aller untergeordneten Elemente des aktuellen Elements ab.</summary>
        <value>Eine Auflistung aller <see cref="T:System.Windows.Forms.HtmlElement" />-Objekte, für die das aktuelle Element das übergeordnete Element ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viele Elemente innerhalb einer HTML-Datei können andere HTML-Elemente darunter haben. Die <xref:System.Windows.Forms.HtmlElement.Children%2A>-Auflistung bietet einen einfachen Mechanismus zum Untersuchen der Baumstruktur eines Dokuments.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> macht nur Elemente verfügbar, deren Direktes übergeordnetes Element das aktuelle Element ist. Wenn Sie über eine <xref:System.Windows.Forms.HtmlElement> für ein `TABLE` Element verfügen, erhalten <xref:System.Windows.Forms.HtmlElement.Children%2A> alle `TR` (Row)-Elemente innerhalb des `TABLE`. Zum Abrufen der `TD` (Cell)-Elemente, die in den `TR` Elementen enthalten sind, müssen Sie entweder die <xref:System.Windows.Forms.HtmlElement.Children%2A>-Auflistung für jedes einzelne `TR` Element verwenden oder die <xref:System.Windows.Forms.HtmlElement.All%2A> Auflistung auf <xref:System.Windows.Forms.HtmlElement>verwenden.  
  
 Elemente in dieser Sammlung sind nicht garantiert in der Quell Reihenfolge.  
  
 Wenn <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> `false`ist, sind `Children` immer leer.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein beliebiges HTML-Dokument untersucht, und es wird eine Zeichenfolge abgeleitet, die die Elemente beschreibt, wobei Einzug und Ebene verwendet werden, um anzugeben, wie tief geschachtelte Elemente im Dokument enthalten sind. Dies geschieht, indem die `Children` Auflistung aller Elemente rekursiv durchsucht wird, beginnend mit dem HTML-Element am oberen Rand des Dokuments. Dieses Codebeispiel erfordert, dass Ihre Anwendung über ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`verfügt.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer mit der linken Maustaste auf das Element klickt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.Click> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.Click>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
 Wenn der Benutzer auf ein Element klickt, das momentan keinen Eingabefokus besitzt, tritt das <xref:System.Windows.Forms.HtmlElement.Click> Ereignis nach dem <xref:System.Windows.Forms.HtmlElement.Focusing>-Ereignis, jedoch vor dem <xref:System.Windows.Forms.HtmlElement.LostFocus>-Ereignis für dieses Element auf.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.Click> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.Click>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536913.aspx">OnClick-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Grenzen des Clientbereichs des Elements im HTML-Dokument ab.</summary>
        <value>Der vom Element eingenommene Clientbereich, abzüglich aller von Rahmen und Bildlaufleisten eingenommenen Bereiche. Wenn Sie die Position und die Dimensionen des Elements einschließlich seiner Zusatzelemente abrufen möchten, verwenden Sie stattdessen <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> gibt Positionsdaten nur für Elemente zurück, denen eine explizite Höhe und Breite zugewiesen wurde, oder Elemente, die die absolute Positionierung verwenden. Ein Dokument ist absolut positioniert, wenn der Positions Stil auf `absolute`festgelegt ist. Anschließend kann es an einer beliebigen Koordinate auf der HTML-Seite positioniert werden.  
  
   
  
## Examples  
 Angenommen, Sie haben die folgende HTML-Seite in eine gehostete Instanz des <xref:System.Windows.Forms.WebBrowser>-Steuer Elements geladen.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie dieses Element abgerufen und seine Dimensionen erweitert werden, wenn der Client Bereich kleiner als 400 Pixel breit und 50 Pixel hoch ist. Außerdem wird der `DIV` auf den `contentEditable` Zustand festgelegt, sodass der Benutzer Text eingeben kann.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533564.aspx">clientLeft-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533565.aspx">ClientTop-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533566.aspx">ClientWidth-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533563.aspx">ClientHeight (Eigenschaft)</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetachEventHandler (eventName As String, eventHandler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Der Name des zu behandelnden Ereignisses.</param>
        <param name="eventHandler">Der verwaltete Code, der das Ereignis behandelt.</param>
        <summary>Entfernt einen Ereignishandler von einem benannten Ereignis im HTML-DOM (Document Object Model).</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">DetachEvent-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Forms.HtmlDocument" /> ab, zu dem dieses Element gehört.</summary>
        <value>Das übergeordnete Dokument dieses Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige HTML-Seiten können Frames mithilfe der `FRAMESET` Tags hosten. In diesem Fall enthält jedes einzelne `FRAME` Element seine eigene Instanz von <xref:System.Windows.Forms.HtmlDocument>. Diese Eigenschaft ist besonders nützlich, wenn Sie einen Verweis auf ein Element in einem Ereignishandler von der <xref:System.Windows.Forms.HtmlElementEventArgs>erhalten haben und eine Aktion für das Dokument ausführen müssen, in dem sich das Element befindet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen nicht verwalteten Schnittstellenzeiger für dieses Element ab.</summary>
        <value>Der com- <c>IUnknown</c> -Zeiger für das Element, das Sie in eine der HTML-Element Schnittstellen umwandeln können, z. b. <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> ist ein Wrapper für das Internet Explorer-Dokumentobjektmodell (DOM), das mit dem Component Object Model (com) geschrieben wird. Wenn Sie auf nicht verfügbar gemachte Eigenschaften oder Methoden auf den zugrunde liegenden COM-Schnittstellen (z. b. `IHTMLElement`) zugreifen müssen, können Sie dieses Objekt verwenden, um Sie abzufragen.  
  
 Damit die nicht verwalteten Schnittstellen verwendet werden können, müssen Sie die MSHTML-Bibliothek (MSHTML. dll) in Ihre Anwendung importieren. Sie können jedoch auch nicht verfügbar gemachte Eigenschaften und Methoden ausführen, indem Sie die `Invoke`-Methode verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden nicht verwaltete Schnittstellen verwendet, um den aktuell ausgewählten Text zu übernehmen und in einen Link zu konvertieren, wobei die vom Benutzer gewählte URL verwendet wird. Dieser Code wurde unter der Annahme geschrieben, dass das Formular über ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`verfügt, und dass Sie die nicht verwaltete MSHTML-Bibliothek als Verweis auf das Projekt hinzugefügt haben.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">IHTMLElement2-Schnittstelle</related>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer zweimal in rascher Folge mit der linken Maustaste auf ein Element klickt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Doppelklick wird durch die Mauseinstellungen des Betriebssystems des Benutzers bestimmt. Der Benutzer kann den Zeitraum festlegen, innerhalb dessen der zweite Mausklick erfolgen muss, damit zwei aufeinander folgende Mausklicks als Doppelklick erkannt werden.  
  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.DoubleClick> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.DoubleClick>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.DoubleClick> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.DoubleClick>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536921.aspx">OnDblClick-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer Text an bestimmte Positionen zieht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, wenn der Text an die folgenden Speicherorte gezogen wird:  
  
-   Innerhalb von oder zwischen HTML-Seiten, die im <xref:System.Windows.Forms.WebBrowser> Steuerelement oder Internet Explorer gehostet werden  
  
-   An eine andere Anwendung  
  
-   Zum Windows-Desktop  
  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.Drag> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.Drag>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.Drag> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.Drag>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536923.aspx">ONDRAG-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer einen Ziehvorgang beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.DragEnd> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.DragEnd>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.DragEnd> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.DragEnd>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536924.aspx">ondragend-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer kein Element mehr über dieses Element zieht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.DragLeave> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.DragLeave>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer Text über das Element zieht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.DragOver> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.DragOver>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.DragOver> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.DragOver>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536927.aspx">OnDragOver-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob der Benutzer Daten in dieses Element eingeben kann.</summary>
        <value><see langword="true" />, wenn das Element Eingaben von Benutzern zulässt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für `FORM` Elemente, wie Textfelder und Options Felder, wird das Festlegen von <xref:System.Windows.Forms.HtmlElement.Enabled%2A> auf `false` den Benutzer daran hindern, diese Formularfelder zu verwenden. Bei anderen Elementen, z. b. `DIV` oder `SPAN`, wird das Festlegen von <xref:System.Windows.Forms.HtmlElement.Enabled%2A> auf `false` bewirkt, dass der gesamte Text im-Element schattiert erscheint. der Text ist jedoch weiterhin wählbar. Fügen Sie einen Ereignishandler für das nicht verfügbar gemachte `onselectstart` Ereignis mithilfe der <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A>-Methode hinzu, um die Auswahl abzubrechen.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533734.aspx">deaktivierte Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das auf Gleichheit zu prüfende Objekt.</param>
        <summary>Überprüft, ob das angegebene Objekt gleich dem aktuellen Element ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> ein <see cref="T:System.Windows.Forms.HtmlElement" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das nächste Element unter diesem Element in der Dokumentstruktur ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.HtmlElement" />, das das erste unter dem aktuellen Element enthaltene Element darstellt, in der Quellreihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> in Verbindung mit <xref:System.Windows.Forms.HtmlElement.NextSibling%2A>, um die Dokumentstruktur für ein HTML-Dokument zu durchlaufen.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533755.aspx">firstChild-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Benutzereingabefokus auf das aktuelle Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus auf ein Element festlegen, wird diesem Element der Fokus gewährt und als aktives Element festgelegt. Beispielsweise wird das Element, das den Fokus besitzt, von der <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A>-Eigenschaft <xref:System.Windows.Forms.HtmlDocument>zurückgegeben.  
  
 Alle Schlüssel Striche, die nach dem Aufrufen <xref:System.Windows.Forms.HtmlElement.Focus%2A> von einem Benutzer eingegeben wurden, werden an dieses Element gesendet.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">Fokus Methode</related>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Element erstmalig den Benutzereingabefokus erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Element, das den Fokus hatte, bevor der Benutzer mithilfe der Taskleiste oder der Alt + Tab-Taste zu einer anderen Anwendung gewechselt hat, empfängt die <xref:System.Windows.Forms.HtmlElement.Focusing> und <xref:System.Windows.Forms.HtmlElement.GotFocus> Ereignisse erneut, wenn der Benutzer zu Ihrer Anwendung zurück wechselt.  
  
 Das Standardverhalten dieses Ereignisses kann nicht abgebrochen werden. Um den Fokus von einem Element zu entfernen, müssen Sie <xref:System.Windows.Forms.HtmlElement.Focus%2A> für ein anderes Element innerhalb des <xref:System.Windows.Forms.HtmlElement.GotFocus> Ereignisses abrufen.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.Focusing>-Ereignis für ein Element tritt auch auf den übergeordneten Elementen und in der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.Focusing> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.Focusing>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536935.aspx">onfoconin-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Der Name des Attributs. Bei diesem Argument wird die Groß- und Kleinschreibung nicht berücksichtigt.</param>
        <summary>Ruft den Wert des benannten Attributs im Element ab.</summary>
        <returns>Der Wert dieses Attributs im Element als <see cref="T:System.String" />-Wert. Wenn das angegebene Attribut nicht in diesem Element vorhanden ist, wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Attribut in HTML ist ein beliebiges gültiges Name-Wert-Paar für dieses Element. <xref:System.Windows.Forms.HtmlElement> macht nur die Attribute verfügbar, die allen Elementen gemeinsam sind, wobei diejenigen, die nur auf bestimmte Elementtypen zutreffen, nicht mehr verfügbar sind. `SRC` ist beispielsweise ein vordefiniertes Attribut für das `IMG`-Tag, jedoch nicht für das `DIV`-Tag. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> und <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, um die Attribute zu bearbeiten, die nicht im verwalteten Dokumentobjektmodell (DOM) verfügbar gemacht werden.  
  
 bei <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> und <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> wird Groß-/Kleinschreibung nicht beachtet  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle `META`-Tags in einem HTML-Dokument abgerufen, wobei <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> verwendet wird, um das `META`-Tag mit dem Namen `Description`zu suchen. Das Beispiel erfordert, dass Ihre Anwendung über ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`verfügt.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536429.aspx">GetAttribute-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Der Name des Tags, dessen <see cref="T:System.Windows.Forms.HtmlElement" />-Objekte Sie abrufen möchten.</param>
        <summary>Ruft eine Auflistung von Elementen ab, die in HTML durch das angegebene <c>HTML</c>-Tag dargestellt sind.</summary>
        <returns>Eine <see cref="T:System.Windows.Forms.HtmlElementCollection" />, die alle Elemente enthält, deren <c>HTML</c>-Tagname gleich <paramref name="tagName" /> ist.</returns>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536439.aspx">GetElementsByTagName-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dient als Hashfunktion für einen bestimmten Typ.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Element den Benutzereingabefokus erhalten hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten dieses Ereignisses kann nicht abgebrochen werden, und es kann nicht durch Blasen vermieden werden. Um den Fokus von einem Element zu entfernen, müssen Sie <xref:System.Windows.Forms.HtmlElement.Focus%2A> für ein anderes Element innerhalb des <xref:System.Windows.Forms.HtmlElement.GotFocus> Ereignisses abrufen.  
  
   
  
## Examples  
 Speichern Sie den folgenden HTML-Code in einer Datei, und laden Sie die Datei in ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement in einem Windows Forms-Projekt.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 Im folgenden Codebeispiel wird verhindert, dass das nächste `INPUT` Element in der Aktivier Reihenfolge den Benutzereingabe Fokus erhält, wenn das vorherige Element weniger als fünf Zeichen enthält. Das Beispiel setzt voraus, dass die zuvor erwähnte HTML-Datei in eine Instanz des <xref:System.Windows.Forms.WebBrowser>-Steuer Elements namens `WebBrowser1`geladen wird.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">onfocus-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Bezeichnung ab, durch die das Element identifiziert werden soll, oder legt diese fest.</summary>
        <value>Der eindeutige Bezeichner für das Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> muss eindeutig sein. Es können nicht zwei Elemente mit dem gleichen <xref:System.Windows.Forms.HtmlElement.Id%2A> innerhalb desselben Dokuments vorhanden sein. Verwenden Sie die <xref:System.Windows.Forms.HtmlElement.Name%2A>-Eigenschaft, um einen Bezeichner für eine Gruppe logisch verbundener Elemente anzugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533880.aspx">ID-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">name-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das HTML-Markup unter diesem Element ab oder legt es fest.</summary>
        <value>Das HTML-Markup, das die untergeordneten Elemente des aktuellen Elements definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt mehrere Möglichkeiten, einer vorhandenen HTML-Seite neue Elemente hinzuzufügen, z. b. die Methoden <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> und <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A>. Die Verwendung von <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> ist oft die schnellste Möglichkeit, neue Inhalte hinzuzufügen, wenn Sie viele Attribute oder Stile für die neuen Elemente festlegen müssen.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> unterscheidet sich von <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> darin, dass <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> den HTML-Code, der das Objekt darstellt, das Sie aufrufen, nicht einschließt. Weitere Informationen zu den Unterschieden zwischen diesen beiden Eigenschaften finden Sie unter <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>.  
  
 Durch das Festlegen von <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> werden alle untergeordneten Elemente zerstört, die zuvor an das Wenn Sie ein Element aus dem DOM abrufen und dann der <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>-Eigenschaft des übergeordneten Elements ein neues HTML-Element zuweisen, ist der Verweis auf dieses Element nutzlos, und sein Verhalten beim Aufrufen der Eigenschaften und Methoden ist nicht definiert.  
  
 Bei einigen Elementen ist das Festlegen von <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> kein gültiger Vorgang. Einige HTML-Tags verfügen über kein Schließ Endes Tag, wie z. b. das `IMG`-Tag und können daher keine geschachtelte-Elemente enthalten. Einige Tags, z. b. das `SCRIPT`-Tag, dürfen nur Textinhalte enthalten. das Festlegen von <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> führt zu einem Fehler. Für beide Tagtypen wird die <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A>-Eigenschaft `false`zurückgegeben. Sie können jedoch auch keine <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> für `TABLE` und `TR` Elemente festlegen, da das Rendern von falsch geformtem HTML zu diesen Elementen das Rendern des Dokuments beschädigen könnte. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> oder die Methoden `insertRow` und `insertCell` für die nicht verwaltete `IHTMLTable` Schnittstelle, um einer `TABLE`Zeilen und Zellen hinzuzufügen.  
  
 Wenn Sie nur Text einem Element zuweisen müssen, nicht HTML-Markup, verwenden Sie stattdessen die <xref:System.Windows.Forms.HtmlElement.InnerText%2A>-Eigenschaft.  
  
 Wenn Sie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> einen Wert zuweisen, werden alle zuvor mit <xref:System.Windows.Forms.HtmlElement.InnerText%2A>zugewiesenen Textwerte zerstört.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Erstellen von untergeordneten Elementen für dieses Element ist nicht zulässig.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533897.aspx">innerHTML (Eigenschaft)</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536452.aspx">insertAdjacentHTML-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den dem Element zugewiesenen Text ab oder legt diesen fest.</summary>
        <value>Der Text des Elements ohne jedes HTML-Markup. Wenn das Element untergeordnete Elemente enthält, wird nur der Text in diesen untergeordneten Elementen beibehalten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, HTML einem Element mit <xref:System.Windows.Forms.HtmlElement.InnerText%2A>zuzuweisen, wird der HTML-Code im Dokument als Literale angezeigt, so als würden Sie HTML in einer Textdatei anzeigen. Wenn Sie einem Element mithilfe der <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>-Eigenschaft HTML zuweisen, wird <xref:System.Windows.Forms.HtmlElement.InnerText%2A> den gesamten Text in diesem HTML-Code mit dem entfernten Markup zurückgeben.  
  
 Wenn Sie <xref:System.Windows.Forms.HtmlElement.InnerText%2A> einen Wert zuweisen, werden alle untergeordneten Elemente, die zum-Element gehören, zerstört.  
  
   
  
## Examples  
 Mit dem folgenden Code wird ein neuer Hyperlink mithilfe von <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>erstellt, und dem Link wird mithilfe der <xref:System.Windows.Forms.HtmlElement.InnerText%2A>-Eigenschaft Text zugewiesen.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das angegebene Element darf keinen Text enthalten (z. B. ein <c>IMG</c>-Element).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533899.aspx">InnerText-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Die Position, an der dieses Element in Bezug auf das aktuelle Element einzufügen ist.</param>
        <param name="newElement">Das neue einzufügende Element.</param>
        <summary>Fügt ein neues Element in das DOM (Document Object Model) ein.</summary>
        <returns>Das <see cref="T:System.Windows.Forms.HtmlElement" />, das soeben eingefügt wurde. Wenn beim Einfügen ein Fehler auftritt, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird erst aufgerufen, wenn das <xref:System.Windows.Forms.WebBrowser.DocumentCompleted>-Ereignis für das <xref:System.Windows.Forms.WebBrowser> Steuerelement aufgetreten ist. Wenn Sie diese Methode vorher aufrufen, kann dies zu einer Ausnahme führen, da das Dokument nicht vollständig geladen wurde.  
  
 Ob der Wert <xref:System.Windows.Forms.HtmlElementInsertionOrientation> gültig ist, hängt vom Typ des Elements ab. Beispielsweise ist <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> gültig, wenn es sich bei dem Element um einen `DIV`handelt, aber nicht, wenn es sich um ein `SCRIPT` oder `IMG` Element handelt, das keine untergeordneten Elemente enthalten kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein `DIV` Element am oberen Rand jeder Seite eingefügt, die Benutzer außerhalb des adatum.com-Servers anzeigen. Das Beispiel setzt voraus, dass das Formular ein <xref:System.Windows.Forms.WebBrowser>-Steuerelement mit dem Namen `WebBrowser1`enthält. In Ihrem Beispiel muss auch der Namespace <xref:System.Text.RegularExpressions>importiert werden.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536451.aspx">InsertAdjacentElement-Methode</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Methode aus, die für das aktuelle Element eindeutig ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Der Name der aufzurufenden Eigenschaft oder Methode.</param>
        <summary>Führt eine nicht verfügbar gemachte Methode für das zugrunde liegende DOM-Element dieses Elements aus.</summary>
        <returns>Das von dieser Methode zurückgegebene Element, dargestellt als <see cref="T:System.Object" />. Wenn dieses <see cref="T:System.Object" /> ein weiteres HTML-Element ist und Sie dem Projekt einen Verweis auf die nicht verwaltete MSHTML-Bibliothek hinzugefügt haben, können Sie es in seine entsprechende nicht verwaltete Schnittstelle umwandeln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um Methoden aus dem Dokumentobjektmodell (DOM) aufzurufen, die keine Entsprechungen in verwaltetem Code aufweisen. Verwenden Sie diese Version von <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>, um nicht verfügbar gemachte Methoden auszuführen, die keine Argumente akzeptieren. Ein Beispiel hierzu finden Sie unter <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Der Name der aufzurufenden Eigenschaft oder Methode.</param>
        <param name="parameter">Eine Liste von zu übergebenden Parametern.</param>
        <summary>Führt eine in der aktuellen HTML-Seite von einer Skriptsprache definierte Funktion aus.</summary>
        <returns>Das von der Funktion zurückgegebene Element, dargestellt als <see cref="T:System.Object" />. Wenn dieses <see cref="T:System.Object" /> ein weiteres HTML-Element ist und Sie dem Projekt einen Verweis auf die nicht verwaltete MSHTML-Bibliothek hinzugefügt haben, können Sie es in seine entsprechende nicht verwaltete Schnittstelle umwandeln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um Methoden aus dem Dokumentobjektmodell (DOM) aufzurufen, die keine Entsprechungen in verwaltetem Code aufweisen. Alle Argumente, die für <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> bereitgestellt werden, werden in Win32-`VARIANT` Datentypen konvertiert, bevor Sie an die benannte Skriptfunktion übergeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine `TABLE` mit dem Namen `dataTable` abgerufen und die nicht verfügbar gemachte `moveRow`-Methode verwendet, um eine Zeile vom Ende der Tabelle an den Anfang zu verschieben.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer eine Taste auf der Tastatur drückt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> tritt vor dem <xref:System.Windows.Forms.HtmlElement.KeyPress>auf, das sich vor <xref:System.Windows.Forms.HtmlElement.KeyUp>befindet.  
  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.KeyDown> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.KeyDown>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.KeyDown> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.KeyDown>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536938.aspx">OnKeyDown-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer eine Taste auf der Tastatur drückt und wieder loslässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> tritt nach <xref:System.Windows.Forms.HtmlElement.KeyDown> und vor <xref:System.Windows.Forms.HtmlElement.KeyUp>auf.  
  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.KeyPress> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.KeyPress>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.KeyPress> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.KeyPress>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536939.aspx">OnKeyPress-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer eine Taste auf der Tastatur loslässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> tritt nach <xref:System.Windows.Forms.HtmlElement.KeyPress>auf, der nach dem <xref:System.Windows.Forms.HtmlElement.KeyDown>auftritt.  
  
 Dieses Ereignis kann nicht abgebrochen werden.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.KeyUp>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.KeyUp> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.KeyUp>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536940.aspx">OnKeyUp-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzereingabefokus vom Element entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.LosingFocus> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.LosingFocus>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzereingabefokus vom Element entfernt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Element empfängt keine Schlüssel Schlag Ereignisse mehr, nachdem <xref:System.Windows.Forms.HtmlElement.LostFocus> aufgetreten ist, bis es wieder den Fokus erhält, entweder durch den Benutzer, der es auf der Seite auswählt, oder durch die Anwendung, die die <xref:System.Windows.Forms.HtmlElement.Focus%2A>-Methode für dieses Element aufrufen.  
  
 Dieses Ereignis kann nicht abgebrochen werden.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.LostFocus>-Ereignis für ein Element tritt auch auf den übergeordneten Elementen und in der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.LostFocus> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.LostFocus>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536936.aspx">onfocbrandout-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer eine Maustaste drückt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.MouseDown> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.MouseDown>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseDown> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseDown>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536944.aspx">onmouondown-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer erstmalig den Mauszeiger über das aktuelle Element bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseEnter> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseEnter>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer den Mauszeiger fort vom aktuellen Element bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseLeave> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseLeave>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer den Mauszeiger über ein Element bewegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis kann nicht abgebrochen werden.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.MouseMove>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseMove> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseMove>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536947.aspx">onmousermove-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger in die Grenzen des Elements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.MouseOver> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.MouseOver>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseOver> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseOver>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536949.aspx">"onmouseover-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer eine Maustaste loslässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardaktion für ein <xref:System.Windows.Forms.HtmlElement.MouseUp> Ereignis kann auf einem Element abgebrochen werden, indem die <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`festgelegt wird.  
  
 Ein <xref:System.Windows.Forms.HtmlElement.MouseUp>-Ereignis auf einem Element tritt auch auf den übergeordneten Elementen dieses Elements und auf der <xref:System.Windows.Forms.HtmlDocument> Klasse selbst auf, es sei denn, Sie legen die <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A>-Eigenschaft der <xref:System.Windows.Forms.HtmlElementEventArgs>-Klasse auf `true`fest.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.HtmlElement.MouseUp> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, können Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox>anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz des Typs <xref:System.Windows.Forms.HtmlElement> mit dem Namen `HtmlElement1`enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.HtmlElement.MouseUp>-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536950.aspx">onmouonup-Ereignis</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Elements ab oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.String" />, die den Namen des Elements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.HtmlElement.Name%2A>-Eigenschaft, um Elemente aus einem Dokument abzurufen, indem Sie die <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A>-Methode der Eigenschaft <xref:System.Windows.Forms.HtmlElement.All%2A> von <xref:System.Windows.Forms.HtmlDocument>verwenden.  
  
 Wenn Sie auf `INPUT` Elemente angewendet wird, definiert <xref:System.Windows.Forms.HtmlElement.Name%2A> den Variablennamen für die Daten dieses Elements, wenn dessen Formular an den Server gesendet wird.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">name-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das nächste Element auf der gleichen Ebene wie dieses Element in der Dokumentstruktur ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.HtmlElement" />, das das Element rechts neben dem aktuellen Element darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> in Verbindung mit <xref:System.Windows.Forms.HtmlElement.FirstChild%2A>, um die Dokumentstruktur für ein HTML-Element zu durchlaufen.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534189.aspx">nextsimel-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, aus dem <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> berechnet wird.</summary>
        <value>Das Element, aus dem die Offsets berechnet werden.  
  
Wenn das übergeordnete Element eines Elements oder ein anderes Element in der Hierarchie des Elements relative oder absolute Positionierung verwendet, ist <see langword="OffsetParent" /> das erste relativ bzw. absolut positionierte Element, in dem das aktuelle Element geschachtelt ist. Wenn keines der Elemente über dem aktuellen Element absolut oder relativ positioniert ist, wird <see langword="OffsetParent" /> das <c>Body</c> -Tag des Dokuments.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elemente können auf einer HTML-Seite auf eine von drei Arten positioniert werden: standardmäßige Fluss Positionierung; relative Positionierung, bei der das Element um einen festgelegten Betrag relativ zum übergeordneten Element versetzt wird. und absolute Positionierung, bei der das Element eine festgelegte Koordinaten Position relativ zur oberen linken Ecke des Dokuments erhält.  
  
 Wenn die Elemente eines Dokuments die relative oder absolute Positionierung verwenden, können Sie `OffsetParent` verwenden, um die Koordinaten Position eines Elements im Client Bereich zu berechnen.  
  
 Weitere Informationen zur Positionierung von Elementen in HTML finden Sie unter [Informationen zur Element Positionierung](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie sich <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> und <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> für `span1`, `span2` und `span3`unterscheiden:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534302.aspx">offsetParent (Eigenschaft)</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Messen der Element Dimension und des Speicher Orts</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position eines Elements relativ zu seinem übergeordneten Element ab.</summary>
        <value>Die x- und die y-Koordinatenpositionen des Elements sowie seine Breite und seine Höhe im Verhältnis zu seinem übergeordneten Element.  
  
Wenn das übergeordnete Element eines Elements relativ oder absolut positioniert ist, gibt <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> den Offset des übergeordneten Elements zurück. Wenn das Element selbst relativ zu seinem übergeordneten Element positioniert ist, gibt <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> den Offset seines übergeordneten Elements zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Elemente können auf einer HTML-Seite auf eine von drei Arten positioniert werden:  
  
-   Standardmäßige Fluss Positionierung.  
  
-   Relative Positionierung, bei der das Element um einen festgelegten Betrag relativ zum übergeordneten Element versetzt wird.  
  
-   Absolute Positionierung, bei der das Element eine festgelegte Koordinaten Position relativ zur oberen linken Ecke des Dokuments erhält.  
  
 Weitere Informationen zur Positionierung von Elementen in HTML finden Sie unter [Informationen zur Element Positionierung](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie sich <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> und <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> für `span1`, `span2` und `span3`unterscheiden:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534200.aspx">offsetleft-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534303.aspx">offsetTop (Eigenschaft)</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534304.aspx">offttwidth-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534199.aspx">offentheight (Eigenschaft)</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Messen der Element Dimension und des Speicher Orts</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Der erste <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Der zweite <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Überprüft zwei Elemente auf Gleichheit.</summary>
        <returns><see langword="true" />, wenn beide Parameter <see langword="null" /> sind oder wenn beide Elemente über die gleiche zugrunde liegende COM-Schnittstelle verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gleichheits Operator testet die `IUnknown` Zeiger der zugrunde liegenden COM-Objekte, die von den bereitgestellten <xref:System.Windows.Forms.HtmlElement> Klassen umschließt werden.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Der erste <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Der zweite <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Überprüft zwei <see cref="T:System.Windows.Forms.HtmlElement" />-Objekte auf Ungleichheit.</summary>
        <returns><see langword="true" />, wenn nur ein Element <see langword="null" /> ist oder die beiden Objekte nicht gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die äquivalente Methode für diesen Operator ist die Negation von <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HTML-Code des aktuellen Elements ab oder legt diesen fest.</summary>
        <value>Der HTML-Code für das aktuelle Element und seine untergeordneten Elemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> alle im aktuellen Element enthaltenen HTML-Elemente mit Ausnahme der umgebenden Tags des aktuellen Elements zurückgibt, enthält <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> sowohl das Tag des aktuellen Elements als auch den HTML-Code, den das Tag enthält, z. b.:  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 In diesem Beispiel wird durch Aufrufen von <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> auf `div2` Folgendes zurückgegeben:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Beim Aufrufen <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> wird Folgendes zurückgegeben:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Wenn Sie <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>einen neuen Wert zuweisen, wird der aktuelle Element Verweis ungültig. der Name, die Eigenschaften und der untergeordnete Inhalt des soeben zugewiesenen HTML werden nicht angezeigt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534310.aspx">outerHTML (Eigenschaft)</related>
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Text des aktuellen Elements ab oder legt diesen fest.</summary>
        <value>Der Text innerhalb des aktuellen Elements und seiner untergeordneten Elemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, HTML einem Element mit <xref:System.Windows.Forms.HtmlElement.OuterText%2A>zuzuweisen, wird der HTML-Code im Dokument als Literale angezeigt, so als würden Sie HTML in einer Textdatei anzeigen. Wenn Sie einem Element mithilfe der <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>-Eigenschaft HTML zuweisen, wird <xref:System.Windows.Forms.HtmlElement.OuterText%2A> den gesamten Text in diesem HTML-Code mit dem entfernten Markup zurückgeben.  
  
 Wenn Sie <xref:System.Windows.Forms.HtmlElement.OuterText%2A> einen Wert zuweisen, werden alle untergeordneten Elemente, die zum-Element gehören, zerstört.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie können Text nicht außerhalb dieses Elements festlegen.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534311.aspx">outerText-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Element des aktuellen Elements ab.</summary>
        <value>Das Element über dem aktuellen Element in der Hierarchie des HTML-Dokuments.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.HtmlElement.Parent%2A>-Eigenschaft ermöglicht die Ermittlung des Kontext eines Elements. Es ist am nützlichsten innerhalb von Ereignis Handlern, wie z. b. <xref:System.Windows.Forms.HtmlElement.Click>, das für jedes beliebige Element in der Objekthierarchie des Dokuments ausgelöst werden kann.  
  
 Die <xref:System.Windows.Forms.HtmlElement.Parent%2A>-Eigenschaft des HTML-Elements (der obere Teil eines HTML-Dokuments) verweist auf sich selbst. Wenn Sie <xref:System.Windows.Forms.HtmlElement.Parent%2A> innerhalb einer Schleife aufzurufen, überprüfen Sie, ob die Break-Bedingung der Schleife den Typ des aktuellen Elements und den Typ der `Parent` Eigenschaft vergleicht. andernfalls kann der Code eine Endlosschleife ausführen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle `IMG`-Tags in einem Dokument gefunden und mithilfe der <xref:System.Windows.Forms.HtmlElement.Parent%2A>-Eigenschaft getestet, ob die `IMG` mit einer anderen Seite hyperverknüpft ist. Wenn dies der Fall ist, weist der Code die URL dem `ALT`-Attribut des `IMG`-Tags zu, sodass Benutzer mit dem Mauszeiger über das Bild gelangen können, um zu sehen, wo Sie sich befinden.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534327.aspx">Element Element-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Der Name des auszulösenden Ereignisses.</param>
        <summary>Bewirkt, dass das benannte Ereignis alle registrierten Ereignishandler aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für den Zugriff auf HTML-Dokumentobjektmodell (DOM)-Ereignisse verwendet. Sie ruft direkt die [IHTMLElement3:: FireEvent](https://go.microsoft.com/fwlink/?LinkId=103189) -Methode auf. Weitere Informationen zur Verwendung des DOM über die <xref:System.Windows.Forms.HtmlElement>-Klasse finden Sie unter [zugreifen auf nicht verfügbar gemachte Member auf der verwalteten HTML-Dokumentobjektmodell](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den Fokus vom aktuellen Element, wenn dieses Element den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen dieser Methode wird das <xref:System.Windows.Forms.HtmlElement.LostFocus>-Ereignis für das-Element ausgelöst.  
  
 Wenn der Fokus mithilfe dieser Methode von einem Element gelöscht wird, wird es an das Dokument mit dem Element und nicht an das nächste Element in der Aktivier Reihenfolge übergeben.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">Blur-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Bei einem Wert von <see langword="true" /> wird der obere Teil des Objekts am oberen Rand des Fensters angezeigt. Bei einem Wert von <see langword="false" /> wird der untere Teil des Objekts am unteren Rand des Fensters angezeigt.</param>
        <summary>Führt einen Bildlauf durch das Dokument mit diesem Element durch, bis der obere oder untere Rand dieses Elements am Dokumentenfenster ausgerichtet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird ein Element anhand des Namens gesucht, und es wird ein Bildlauf durch die Seite durchgeführt, sodass der obere Rand des Elements am oberen Rand der sichtbaren Seite ausgerichtet wird.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536730.aspx">ScrollIntoView-Methode</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem Rand des Elements und dem linken Rand seines Inhalts ab oder legt diesen fest.</summary>
        <value>Der Abstand zwischen dem linken Rand des Elements und dem linken Rand seines Inhalts (in Pixel).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vollständigen Dimensionen des scrollbereichs sind über <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>verfügbar. `ScrollLeft` und <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> werden unabhängig verfügbar gemacht, da es sich hierbei um die einzigen beiden Eigenschaften des Bild Lauf Bereichs handelt, den Entwickler festlegen können.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">ScrollLeft-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Dimensionen des bildlauffähigen Bereichs eines Elements ab.</summary>
        <value>Die Größe und die Koordinatenposition des bildlauffähigen Bereichs eines Elements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Element verfügt über einen Bild lauffähigen Bereich, wenn sein Inhalt die Größe seiner Dimensionen überschreitet, es sei denn, der Überlauf Stil des Elements verbietet das Rendern von Scrollleisten.  
  
 Sie können die Größe des Bild Lauf Bereichs nicht direkt ändern, aber Sie können den Abstand zwischen den Rändern des Bild Lauf Bereichs und den Rändern des Elements ändern. Verwenden Sie die Eigenschaften <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> und <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A>, um dies zu erreichen.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">ScrollLeft-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">ScrollTop (Eigenschaft)</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534615.aspx">ScrollHeight-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534619.aspx">ScrollWidth-Eigenschaft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534312.aspx">Overflow-Eigenschaft</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem Rand des Elements und dem oberen Rand seines Inhalts ab oder legt diesen fest.</summary>
        <value>Der Abstand zwischen dem oberen Rand des Elements und dem oberen Rand seines Inhalts (in Pixel).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die vollständigen Dimensionen des scrollbereichs sind über <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>verfügbar. <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> und `ScrollTop` werden unabhängig verfügbar gemacht, da es sich hierbei um die einzigen beiden Eigenschaften des Bild Lauf Bereichs handelt, den Entwickler festlegen können.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">ScrollTop (Eigenschaft)</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Der Name des festzulegenden Attributs.</param>
        <param name="value">Der neue Wert dieses Attributs.</param>
        <summary>Legt den Wert des benannten Attributs für das Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Attribut in HTML ist ein beliebiges gültiges Name/Wert-Paar für dieses Element. <xref:System.Windows.Forms.HtmlElement> macht nur die Attribute verfügbar, die allen Elementen gemeinsam sind, wobei diejenigen, die nur auf bestimmte Elementtypen zutreffen, nicht mehr verfügbar sind. `SRC` ist beispielsweise ein vordefiniertes Attribut für das `IMG`-Tag, jedoch nicht für das `DIV`-Tag. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> und <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, um die Attribute zu bearbeiten, die nicht im verwalteten Dokumentobjektmodell (DOM) verfügbar gemacht werden.  
  
 Wenn `attributeName` kein definiertes Attribut für ein Element ist, wird es <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> für das Element als neues Attribut definieren.  
  
 bei <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> und <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> wird Groß-/Kleinschreibung nicht beachtet  
  
 Wenn Sie das `class`-Attribut für eine <xref:System.Windows.Forms.HtmlElement> festlegen möchten, müssen Sie beim Angeben des ersten Arguments für das-Attribut als `className` bezeichnen <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird dem aktuellen Dokument ein neues `IMG`-Element hinzugefügt, wobei <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> verwendet wird, um das `SRC`-Attribut für das Bild festzulegen.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536739.aspx">""-Methode ""</related>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine durch Semikola getrennte Liste der Formate für das aktuelle Element ab oder legt diese fest.</summary>
        <value>Eine Zeichenfolge, die aus allen Formaten des Elements besteht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der HTML-Dokumentobjektmodell (DOM) verwendet Stile, die in der World Wide Web-Cascading Stylesheets Spezifikation definiert sind, um die Anzeige eines Elements zu steuern. Stile in der <xref:System.Windows.Forms.HtmlElement.Style%2A>-Eigenschaft haben das Format von durch Trennzeichen getrennten Name-Wert-Paaren, wobei jedes Paar durch ein Semikolon getrennt ist, wie im folgenden dargestellt:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Wenn Sie die Schriftart für ein `DIV` Element auf 14-Punkt-Mal New Roman Bold festlegen möchten, würden Sie z. b. die folgende Zeichenfolge zuweisen:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Eine vollständige Liste aller verfügbaren Stile im HTML-DOM finden Sie unter [Style-Attribut](https://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position dieses Elements in der Aktivierreihenfolge ab oder legt diese fest.</summary>
        <value>Der numerische Index des Elements in der Aktivierreihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> bestimmt, welches Element in einem HTML-Dokument als nächstes den Fokus erhält, wenn der Benutzer die Tab-Taste drückt. Standardmäßig sind die einzigen in der Aktivier Reihenfolge enthaltenen Elemente `INPUT` Elemente, das `SELECT` Steuerelement und jedes Element, dessen `contentEditable`-Eigenschaft auf `true`festgelegt ist. Sie können jedes beliebige HTML-Element in der Aktivier Reihenfolge einschließen, z. b. eine `DIV`, indem Sie ihm einen expliziten <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>zuweisen.  
  
 Gültige Werte für den <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> Bereich von-32767 bis 32767.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534654.aspx">TabIndex (Eigenschaft)</related>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des HTML-Tags ab.</summary>
        <value>Der Name, der zum Erstellen dieses Elements mit HTML-Markup verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viele Elemente im HTML-Dokumentobjektmodell über Attribute, Eigenschaften und Methoden verfügen, die für diese Elemente eindeutig sind. z. b. das `HREF`-Attribut des `A`-Elements oder die `Submit`-Methode auf `FORM`. Verwenden Sie <xref:System.Windows.Forms.HtmlElement.TagName%2A>, wenn Sie über ein Element eines potenziell beliebigen Typs verfügen und einen typspezifischen Vorgang ausführen müssen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle `IMG`-Tags in einem Dokument gefunden und mithilfe der `TagName`-Eigenschaft getestet, ob die `IMG` mit einer anderen Seite hyperverknüpft ist. Wenn dies der Fall ist, weist der Code die URL dem `ALT`-Attribut des `IMG`-Tags zu, sodass Benutzer mit dem Mauszeiger über das Bild gelangen können, um zu sehen, wo Sie sich befinden.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534657.aspx">Tagname (Eigenschaft)</related>
      </Docs>
    </Member>
  </Members>
</Type>
