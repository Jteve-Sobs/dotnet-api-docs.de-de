<Type Name="Timer" FullName="System.Windows.Forms.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ac20e9673f130c36174d5220f53ff45975929dc7" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55321447" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Tick")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementiert einen Timer, der ein Ereignis in benutzerdefinierten Intervallen auslöst. Dieser Timer ist für die Verwendung in Windows Forms-Anwendungen optimiert und muss in einem Fenster verwendet werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.Timer> wird verwendet, um ein Ereignis in benutzerdefinierten Intervallen auszulösen. Dieser Windows-Zeitgeber dient für eine Singlethread-Umgebung, in dem UI-Threads verwendet werden, um Verarbeitungsvorgänge auszuführen. Es erfordert, dass der Code des Benutzer über ein UI-Nachrichtensystem zur Verfügung und immer aus dem gleichen Thread ausgeführt werden, oder den Aufruf auf einem anderen Thread zu marshallen.  
  
 Verwenden Sie bei der Verwendung dieser Zeitgeber die <xref:System.Windows.Forms.Timer.Tick> -Ereignis, einen Abrufvorgang auszuführen oder um einen Begrüßungsbildschirm für einen angegebenen Zeitraum angezeigt werden soll. Wenn die <xref:System.Windows.Forms.Timer.Enabled%2A> -Eigenschaftensatz auf `true` und die <xref:System.Windows.Forms.Timer.Interval%2A> -Eigenschaft ist größer als 0 (null), die <xref:System.Windows.Forms.Timer.Tick> Ereignis wird ausgelöst, in Intervallen auf der Grundlage der <xref:System.Windows.Forms.Timer.Interval%2A> Einstellung der Eigenschaft.  
  
 Diese Klasse stellt Methoden zum Festlegen des Zeitraums, und zum Starten und stoppen den Zeitgeber.  
  
> [!NOTE]
>  Die Windows Forms-Timer-Komponente einen einzelnen Thread und ist mit einer Genauigkeit von 55 Millisekunden beschränkt. Wenn Sie einen Multithread-Zeitgeber mit größerer Genauigkeit benötigen, verwenden die <xref:System.Timers.Timer> -Klasse in der <xref:System.Timers> Namespace.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen einfaches Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde und der Benutzer wird gefragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein neuer Timer erstellt wurde, wird es deaktiviert; d. h. <xref:System.Windows.Forms.Timer.Enabled%2A> nastaven NA hodnotu `false`. Rufen Sie zum Aktivieren des Timers den <xref:System.Windows.Forms.Timer.Start%2A> Methode bzw. einer Gruppe <xref:System.Windows.Forms.Timer.Enabled%2A> zu `true`.  
  
 Wenn der Zeitgeber deaktiviert ist, und der Zeitgeber außerhalb des gültigen Bereichs ist, wird der Zeitgeber freigegeben, bei der Garbagecollection durchgeführt wird. Wenn der Timer, aktiviert ist auch wenn es außerhalb des gültigen Bereichs ist, ist es nicht während der Garbagecollection.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Timer : System.ComponentModel.IContainer -&gt; System.Windows.Forms.Timer" Usage="new System.Windows.Forms.Timer container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Ein <see cref="T:System.ComponentModel.IContainer" />, der den Container für den Zeitgeber darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse gemeinsam mit einem angegebenen Container.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Timer> Konstruktor ermöglicht Ihnen die Zuordnung einer <xref:System.Windows.Forms.Timer> mit einem <xref:System.ComponentModel.Container> Objekt. Durch Zuordnen der <xref:System.Windows.Forms.Timer> wie folgt, übergeben Sie die Kontrolle der Lebensdauer der der <xref:System.Windows.Forms.Timer> auf die <xref:System.ComponentModel.Container>. Dies kann nützlich sein, wenn Sie eine Reihe von Komponenten in Ihrer Anwendung verwenden und gleichzeitig alle freigeben möchten. Angenommen, Sie verknüpfen ein <xref:System.Windows.Forms.ToolTip>, eine <xref:System.Windows.Forms.ImageList>, und ein <xref:System.Windows.Forms.Timer> mit einer <xref:System.ComponentModel.Container>, wird beim Aufruf <xref:System.ComponentModel.Container.Dispose%2A> auf die <xref:System.ComponentModel.Container> erzwingt eine Freigabe alle diese Komponenten ebenfalls.  
  
 Wenn Sie ein neuer Timer erstellt wurde, wird es deaktiviert; d. h. <xref:System.Windows.Forms.Timer.Enabled%2A> nastaven NA hodnotu `false`. Rufen Sie zum Aktivieren des Timers den <xref:System.Windows.Forms.Timer.Start%2A> Methode bzw. einer Gruppe <xref:System.Windows.Forms.Timer.Enabled%2A> zu `true`.  
  
 Diese Instanz ist vorhanden, bis der Container bei der Garbagecollection freigegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um nur die nicht verwalteten Ressourcen freizugeben.</param>
        <summary>Gibt außer den Speicherressourcen alle Ressourcen frei, die vom Timer verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.Timer.Dispose%2A> Wenn Sie mit der Timer fertig sind. Die <xref:System.Windows.Forms.Timer.Dispose%2A> -Methode bewirkt, dass den Timer in einem nicht verwendbaren Zustand. Nach dem Aufruf von <xref:System.Windows.Forms.Timer.Dispose%2A>, Sie müssen alle Verweise auf den Timer freigeben, damit der belegte Speicher durch die Garbagecollection wieder zugänglich gemacht werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Windows.Forms.Timer.Dispose%2A> bereits vor der Veröffentlichung des letzten Verweis auf den Timer. Andernfalls werden der Zeitgeber verwendeten Ressourcen nicht erst freigegeben werden Garbagecollection den Destruktor des Timer-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public virtual bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob der Timer ausgeführt wird.</summary>
        <value><see langword="true" />, wenn der Zeitgeber gegenwärtig aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeitgeber wird nicht während der Garbagecollection, wenn der Wert ist `true`.  
  
 Aufrufen der <xref:System.Windows.Forms.Timer.Start%2A> Methode ist identisch mit dem Festlegen <xref:System.Windows.Forms.Timer.Enabled%2A> zu `true`. Ebenso ist der Aufruf der <xref:System.Windows.Forms.Timer.Stop%2A> Methode ist identisch mit dem Festlegen <xref:System.Windows.Forms.Timer.Enabled%2A> zu `false`.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen einfaches Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde, und fragt, ob zum Ausführen des Timers fortgesetzt wird.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public int Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Interval { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : int with get, set" Usage="System.Windows.Forms.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitraum in Millisekunden vor dem Auslösen des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses nach dem letzten Eintreten des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses ab oder legt diesen fest.</summary>
        <value><see cref="T:System.Int32" /> gibt die Anzahl der Millisekunden vor dem Auslösen des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses nach dem letzten Eintreten des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses an. Der Wert kann nicht kleiner als eins sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Anzahl der Sekunden im Intervall zu erhalten, teilen Sie diese Zahl mit 1000 ein.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde, und fragt, ob zum Ausführen des Timers fortgesetzt wird.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTick">
      <MemberSignature Language="C#" Value="protected virtual void OnTick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTick : EventArgs -&gt; unit&#xA;override this.OnTick : EventArgs -&gt; unit" Usage="timer.OnTick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält. Diese ist immer <see cref="F:System.EventArgs.Empty" />.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für jede timertick aufgerufen. Ruft alle Methoden, die über hinzugefügt werden <xref:System.Windows.Forms.Timer.Tick>. Wenn Sie von erben <xref:System.Windows.Forms.Timer>, können Sie diese Methode überschreiben.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" /> in einer abgeleiteten Klasse, stellen Sie sicher, dass Sie der Basisklasse aufrufen <see cref="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" /> Methode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Zeitgeber.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Zeitgeber starten, durch Festlegen der <xref:System.Windows.Forms.Timer.Enabled%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde, und fragt, ob zum Ausführen des Timers fortgesetzt wird.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den Timer an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Zeitgeber beenden, durch Festlegen der <xref:System.Windows.Forms.Timer.Enabled%2A> Eigenschaft `false`. Ein <xref:System.Windows.Forms.Timer> Objekt aktiviert und mehrere Male in derselben anwendungssitzung deaktiviert werden kann.  
  
 Aufrufen <xref:System.Windows.Forms.Timer.Start%2A> nach der Deaktivierung einer <xref:System.Windows.Forms.Timer> durch Aufrufen von <xref:System.Windows.Forms.Timer.Stop%2A> führt dazu, dass die <xref:System.Windows.Forms.Timer> unterbrochene Intervall neu zu starten. Wenn Ihre <xref:System.Windows.Forms.Timer> für ein Intervall 5000 Millisekunden-festgelegt ist und rufen Sie <xref:System.Windows.Forms.Timer.Stop%2A> bei ungefähr 3000 Millisekunden, Aufrufen von <xref:System.Windows.Forms.Timer.Start%2A> führt dazu, dass die <xref:System.Windows.Forms.Timer> 5000 Millisekunden wartet, bevor das Auslösen der <xref:System.Windows.Forms.Timer.Tick> Ereignis.  
  
> [!NOTE]
>  Durch Aufrufen von Stop für jedes beliebige <xref:System.Windows.Forms.Timer> innerhalb einer Windows Forms Anwendung kann dazu führen, dass Nachrichten von anderen <xref:System.Windows.Forms.Timer> Komponenten in der Anwendung, die sofort verarbeitet werden, da alle <xref:System.Windows.Forms.Timer> Komponenten, die für den Thread der hauptanwendung verwendet werden. Wenn Sie zwei <xref:System.Windows.Forms.Timer> Komponenten, eine auf 700 Millisekunden und einen Satz auf 500 Millisekunden festgelegt, und rufen Sie <xref:System.Windows.Forms.Timer.Stop%2A> auf der ersten <xref:System.Windows.Forms.Timer>, Ihre Anwendung möglicherweise zuerst einen Ereignisrückruf für die zweite Komponente. Wenn sich dies problematisch, erwägen Sie die Verwendung der <xref:System.Threading.Timer> -Klasse in der <xref:System.Threading> Namespace stattdessen.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde, und fragt, ob zum Ausführen des Timers fortgesetzt wird.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Timer.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine beliebige Zeichenfolge ab, die einen Benutzerzustand darstellt, oder legt diese fest.</summary>
        <value>Eine beliebige Zeichenfolge, die einen Benutzerzustand darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tick">
      <MemberSignature Language="C#" Value="public event EventHandler Tick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Tick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Timer.Tick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Tick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Tick;" />
      <MemberSignature Language="F#" Value="member this.Tick : EventHandler " Usage="member this.Tick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das angegebene Intervall für den Timer abgelaufen und der Timer aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Diagnostics.Debug.Assert%2A> Methode für die <xref:System.Diagnostics.Debug> Klasse innerhalb der <xref:System.Windows.Forms.Timer.Tick> Ereignis Verhalten sich womöglich nicht wie erwartet, wie das Dialogfeld "Assertion" Feld kann dazu führen, dass Windows ausgelöst werden soll die <xref:System.Windows.Forms.Timer.Tick> Ereignis wiederholt. Es wird empfohlen, dass Sie davon absehen, testen die Assertionen innerhalb dieses Ereignisses und der <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, oder <xref:System.Diagnostics.Debug.WriteLineIf%2A> Methoden stattdessen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, die einen Alarm auslöst alle fünf Sekunden festlegt. Wenn der Wecker ausgelöst wird, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl wie oft der Alarm gestartet wurde, und fragt, ob zum Ausführen des Timers fortgesetzt wird.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="timer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den <see cref="T:System.Windows.Forms.Timer" /> darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle <see cref="T:System.Windows.Forms.Timer" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Timer.ToString%2A> Methode gibt eine Zeichenfolge, die den Wert der enthält die <xref:System.Windows.Forms.Timer.Interval%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>