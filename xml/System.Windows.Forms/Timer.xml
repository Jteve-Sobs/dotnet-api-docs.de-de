<Type Name="Timer" FullName="System.Windows.Forms.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40a2cccedc77420d9f12114c1bbb35ea3866d05b" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659337" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Tick")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementiert einen Timer, der ein Ereignis in benutzerdefinierten Intervallen auslöst. Dieser Timer ist für die Verwendung in Windows Forms-Anwendungen optimiert und muss in einem Fenster verwendet werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.Timer> wird verwendet, um ein Ereignis in benutzerdefinierten Intervallen auszulösen. Dieser Windows-Zeitgeber ist für eine Singlethread-Umgebung entwickelt, in dem UI-Threads verwendet werden, um Verarbeitungsvorgänge auszuführen. Es erfordert, dass der Benutzercode über ein UI-Nachrichtensystem zur Verfügung und immer aus dem gleichen Thread ausgeführt werden, oder den Aufruf auf einem anderen Thread zu marshallen.  
  
 Verwenden Sie bei Verwendung dieser Zeitgeber der <xref:System.Windows.Forms.Timer.Tick> Ereignis zum Abruf eines Vorgangs oder einen Begrüßungsbildschirm für einen angegebenen Zeitraum angezeigt. Bei jedem der <xref:System.Windows.Forms.Timer.Enabled%2A> -Eigenschaftensatz auf `true` und die <xref:System.Windows.Forms.Timer.Interval%2A> -Eigenschaft ist größer als 0 (null), die <xref:System.Windows.Forms.Timer.Tick> Ereignis wird ausgelöst, in Intervallen auf der Grundlage der <xref:System.Windows.Forms.Timer.Interval%2A> Einstellung der Eigenschaft.  
  
 Diese Klasse stellt Methoden zum Festlegen des Zeitraums sowie zum Starten und beenden Sie den Zeitgeber.  
  
> [!NOTE]
>  Die Windows Forms-Timer-Komponente ist eine Singlethread und ist mit einer Genauigkeit von 55 Millisekunden beschränkt. Wenn Sie einen Multithread-Zeitgeber mit größerer Genauigkeit benötigen, verwenden die <xref:System.Timers.Timer> -Klasse in der <xref:System.Timers> Namespace.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen einfachen Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet, und fordert den Benutzer auf, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein neuer Zeitgeber erstellt wird, wird es deaktiviert; d. h. <xref:System.Windows.Forms.Timer.Enabled%2A> festgelegt ist, um `false`. Rufen Sie zum Aktivieren des Zeitgebers die <xref:System.Windows.Forms.Timer.Start%2A> Methode bzw. einer Gruppe <xref:System.Windows.Forms.Timer.Enabled%2A> auf `true`.  
  
 Wenn der Timer deaktiviert ist, und der Zeitgeber außerhalb des gültigen Bereichs wird, wird der Timer verworfen werden, bei der Garbagecollection erfolgt. Wenn der Zeitgeber aktiviert ist, auch wenn es außerhalb des Bereichs liegt, ist es nicht Garbage collection.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::ComponentModel::IContainer ^ container);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Ein <see cref="T:System.ComponentModel.IContainer" />, der den Container für den Zeitgeber darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Timer" />-Klasse gemeinsam mit einem angegebenen Container.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Timer> Konstruktor ermöglicht das Zuordnen einer <xref:System.Windows.Forms.Timer> mit <xref:System.ComponentModel.Container> Objekt. Durch das Zuordnen der <xref:System.Windows.Forms.Timer> übergeben, wie folgt, Kontrolle über die Lebensdauer der <xref:System.Windows.Forms.Timer> zu der <xref:System.ComponentModel.Container>. Dies kann nützlich sein, wenn Sie eine Reihe von Komponenten in Ihrer Anwendung verwenden und alle gleichzeitig freigeben möchten. Angenommen, Sie ordnen eine <xref:System.Windows.Forms.ToolTip>, wird ein <xref:System.Windows.Forms.ImageList>, und ein <xref:System.Windows.Forms.Timer> mit eine <xref:System.ComponentModel.Container>wird beim Aufrufen <xref:System.ComponentModel.Container.Dispose%2A> auf die <xref:System.ComponentModel.Container> erzwingt eine Beseitigung der alle diese Komponenten auch.  
  
 Wenn Sie ein neuer Zeitgeber erstellt wird, wird es deaktiviert; d. h. <xref:System.Windows.Forms.Timer.Enabled%2A> festgelegt ist, um `false`. Rufen Sie zum Aktivieren des Zeitgebers die <xref:System.Windows.Forms.Timer.Start%2A> Methode bzw. einer Gruppe <xref:System.Windows.Forms.Timer.Enabled%2A> auf `true`.  
  
 Diese Instanz ist vorhanden, bis dessen Container in die Garbagecollection frei.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um nur die nicht verwalteten Ressourcen freizugeben.</param>
        <summary>Gibt außer den Speicherressourcen alle Ressourcen frei, die vom Timer verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.Timer.Dispose%2A> Wenn Sie mit der Timer fertig sind. Die <xref:System.Windows.Forms.Timer.Dispose%2A> Methode bewirkt, dass den Zeitgeber in einem nicht verwendbaren Zustand. Nach dem Aufruf <xref:System.Windows.Forms.Timer.Dispose%2A>, müssen Sie alle Verweise auf den Zeitgeber freigeben, damit der belegte Arbeitsspeicher von der Garbagecollection wieder zugänglich gemacht werden kann.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Windows.Forms.Timer.Dispose%2A> , bevor Sie den letzten Verweis auf den Zeitgeber freigeben. Die Ressourcen an, die der Zeitgeber verwendet werden, andernfalls nicht reserviert, bis die Garbagecollection den Destruktor des Zeitgeberobjekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public virtual bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob der Timer ausgeführt wird.</summary>
        <value>
          <see langword="true" />, wenn der Zeitgeber gegenwärtig aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeitgeber unterliegt nicht der Garbagecollection auf, wenn der Wert ist `true`.  
  
 Aufrufen der <xref:System.Windows.Forms.Timer.Start%2A> Methode entspricht der Einstellung <xref:System.Windows.Forms.Timer.Enabled%2A> auf `true`. Ebenso ist der Aufruf der <xref:System.Windows.Forms.Timer.Stop%2A> Methode entspricht der Einstellung <xref:System.Windows.Forms.Timer.Enabled%2A> auf `false`.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen einfachen Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet und fragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public int Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Interval { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitraum in Millisekunden vor dem Auslösen des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses nach dem letzten Eintreten des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses ab oder legt diesen fest.</summary>
        <value>
          <see cref="T:System.Int32" /> gibt die Anzahl der Millisekunden vor dem Auslösen des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses nach dem letzten Eintreten des <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignisses an. Der Wert kann nicht kleiner als eins sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Anzahl der Sekunden im Intervall zu erhalten, teilen Sie diese Zahl durch 1000 ein.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet und fragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTick">
      <MemberSignature Language="C#" Value="protected virtual void OnTick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält. Diese ist immer <see cref="F:System.EventArgs.Empty" />.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Timer.Tick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bei jedem Zeitgebertick aufgerufen. Ruft alle Methoden, die über hinzugefügt werden <xref:System.Windows.Forms.Timer.Tick>. Wenn Sie ein von erben <xref:System.Windows.Forms.Timer>, können Sie diese Methode überschreiben.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie der Basisklasse aufrufen, <see cref="M:System.Windows.Forms.Timer.OnTick(System.EventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Zeitgeber.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Zeitgeber starten, durch Festlegen der <xref:System.Windows.Forms.Timer.Enabled%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet und fragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den Timer an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Zeitgeber beenden, durch Festlegen der <xref:System.Windows.Forms.Timer.Enabled%2A> Eigenschaft `false`. Ein <xref:System.Windows.Forms.Timer> Objekt aktiviert und mehrere Male in derselben Anwendung Sitzung deaktiviert werden kann.  
  
 Aufrufen von <xref:System.Windows.Forms.Timer.Start%2A> nach der Deaktivierung einer <xref:System.Windows.Forms.Timer> durch Aufrufen <xref:System.Windows.Forms.Timer.Stop%2A> führt dazu, dass die <xref:System.Windows.Forms.Timer> unterbrochene Intervall neu zu starten. Wenn Ihre <xref:System.Windows.Forms.Timer> für ein Intervall 5000 Millisekunden festgelegt ist, und rufen Sie <xref:System.Windows.Forms.Timer.Stop%2A> bei ungefähr 3000 Millisekunden, Aufrufen von <xref:System.Windows.Forms.Timer.Start%2A> führt dazu, dass die <xref:System.Windows.Forms.Timer> 5000 Millisekunden wartet, bevor durch das Auslösen der <xref:System.Windows.Forms.Timer.Tick> Ereignis.  
  
> [!NOTE]
>  Durch Aufrufen von Stop für ein beliebiges <xref:System.Windows.Forms.Timer> innerhalb einer Windows Forms Anwendung kann dazu führen, dass Nachrichten von anderen <xref:System.Windows.Forms.Timer> Komponenten in die Anwendung sofort verarbeitet werden, da alle <xref:System.Windows.Forms.Timer> Komponenten, die auf Thread der hauptanwendung ausgeführt werden. Wenn Sie zwei <xref:System.Windows.Forms.Timer> Komponenten, eine auf 700 Millisekunden und einen Satz auf 500 Millisekunden festgelegt, und rufen Sie <xref:System.Windows.Forms.Timer.Stop%2A> auf der ersten <xref:System.Windows.Forms.Timer>, Ihre Anwendung möglicherweise zuerst einen Ereignisrückruf für die zweite Komponente. Wenn dies problematisch beweist, erwägen Sie die <xref:System.Threading.Timer> -Klasse in der <xref:System.Threading> Namespace stattdessen.  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet und fragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Timer.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine beliebige Zeichenfolge ab, die einen Benutzerzustand darstellt, oder legt diese fest.</summary>
        <value>Eine beliebige Zeichenfolge, die einen Benutzerzustand darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tick">
      <MemberSignature Language="C#" Value="public event EventHandler Tick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Tick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Timer.Tick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Tick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Tick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das angegebene Intervall für den Timer abgelaufen und der Timer aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Diagnostics.Debug.Assert%2A> Methode für die <xref:System.Diagnostics.Debug> Klasse innerhalb der <xref:System.Windows.Forms.Timer.Tick> Ereignis möglicherweise nicht wie erwartet verhält, als das Dialogfeld "Assertion" anzeigen Feld kann dazu führen, dass Windows zum Auslösen von der <xref:System.Windows.Forms.Timer.Tick> Ereignis wiederholt. Es wird empfohlen, Sie stellen sicher, dass Tests Assertionen innerhalb dieses Ereignisses und der <xref:System.Diagnostics.Debug.Write%2A>, <xref:System.Diagnostics.Debug.WriteIf%2A>, <xref:System.Diagnostics.Debug.WriteLine%2A>, oder <xref:System.Diagnostics.Debug.WriteLineIf%2A> Methoden stattdessen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel implementiert einen einfache Intervallzeitgeber, deaktiviert ein Alarm alle fünf Sekunden festgelegt. Wenn der Alarm auftritt, eine <xref:System.Windows.Forms.MessageBox> zeigt die Anzahl, wie oft der Alarm wurde gestartet und fragt, ob der Zeitgeber weiterhin ausgeführt werden soll.  
  
 [!code-cpp[Classic Timer Example 2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Timer Example 2/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer Example 2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Timer Example 2/CS/source.cs#1)]
 [!code-vb[Classic Timer Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Timer Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Timer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den <see cref="T:System.Windows.Forms.Timer" /> darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle <see cref="T:System.Windows.Forms.Timer" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Timer.ToString%2A> Methode gibt eine Zeichenfolge, die den Wert der enthält die <xref:System.Windows.Forms.Timer.Interval%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>