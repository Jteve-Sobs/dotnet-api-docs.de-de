<Type Name="ContainerControl" FullName="System.Windows.Forms.ContainerControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="26ef9bd193c251e9361fb335b374d0f735e30ee9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36347202" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerControl : System.Windows.Forms.ScrollableControl, System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerControl extends System.Windows.Forms.ScrollableControl implements class System.Windows.Forms.IContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerControl&#xA;Inherits ScrollableControl&#xA;Implements IContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerControl : System::Windows::Forms::ScrollableControl, System::Windows::Forms::IContainerControl" />
  <TypeSignature Language="F#" Value="type ContainerControl = class&#xA;    inherit ScrollableControl&#xA;    interface IContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ScrollableControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Forms.IContainerControl</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Fokusverwaltungsfunktionen für Steuerelemente bereit, die als Container für andere Steuerelemente verwendet werden können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.ContainerControl> stellt ein Steuerelement, das als Container für andere Steuerelemente und ermöglicht die fokusverwaltung fungieren kann. Steuerelemente, die von dieser Klasse erben, können das aktive Steuerelement nachverfolgen, das sie enthalten, selbst wenn der Fokus an einer beliebigen Stelle in einem anderen Container verschoben wird.  
  
 <xref:System.Windows.Forms.ContainerControl> -Objekte stellen eine logische Begrenzung für enthaltene Steuerelemente. Das Containersteuerelement kann das Drücken der Taste Registerkarte erfassen und Verschieben des Fokus auf das nächste Steuerelement in der Auflistung.  
  
> [!NOTE]
>  Das Containersteuerelement empfängt den Fokus nicht; der Fokus wird immer auf das erste untergeordnete Steuerelement in der Auflistung enthaltenen Steuerelemente festgelegt.  
  
 Sie in der Regel erben nicht direkt von der <xref:System.Windows.Forms.ContainerControl> Klasse. <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.UserControl>, und <xref:System.Windows.Forms.UpDownBase> Klassen erben von <xref:System.Windows.Forms.ContainerControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.UserControl" />
    <altmember cref="T:System.Windows.Forms.UpDownBase" />
    <altmember cref="T:System.Windows.Forms.IContainerControl" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.ContainerControl" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird erbt von der <xref:System.Windows.Forms.ScrollableControl> -Klasse und implementiert die <xref:System.Windows.Forms.IContainerControl> Schnittstelle. Implementierung wird hinzugefügt, um die <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> Eigenschaft und die <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> Methode.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control ActiveControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control ActiveControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ ActiveControl { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveControl : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.ContainerControl.ActiveControl" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IContainerControl.ActiveControl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktive Steuerelement im Containersteuerelement ab oder legt dieses fest.</summary>
        <value>Das derzeit aktive <see cref="T:System.Windows.Forms.Control" /> in <see cref="T:System.Windows.Forms.ContainerControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaft aktiviert ist, oder ruft das aktive Steuerelement im Containersteuerelement ab.  
  
 Um einen gültigen Wert für diese Eigenschaft zu erhalten, wird das Objekt, das ihn aufruft muss entweder enthalten, oder Sie in das Steuerelement, das Aufrufen enthalten sein. Wenn ein Formular versucht, eine andere Form Aufrufen <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Eigenschaften, erhält er einen nicht definierten Wert. In diesem Fall müssen Sie eigene Kommunikationsmechanismus für die Kommunikation zwischen den Formularen Übergabe dieser Daten zu definieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erbt von der <xref:System.Windows.Forms.ScrollableControl> -Klasse und implementiert die <xref:System.Windows.Forms.IContainerControl> Schnittstelle. Implementierung wird hinzugefügt, um die <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> Eigenschaft und die <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> Methode.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das zugewiesene <see cref="T:System.Windows.Forms.Control" /> konnte nicht aktiviert werden.</exception>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
        <altmember cref="T:System.Windows.Forms.Control" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberSignature Language="F#" Value="override this.AdjustFormScrollbars : bool -&gt; unit" Usage="containerControl.AdjustFormScrollbars displayScrollbars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          <see langword="true" />, um die Bildlaufleisten anzuzeigen, andernfalls <see langword="false" />.</param>
        <summary>Passt die Bildlaufleisten im Container anhand der aktuellen Positionen der Steuerelemente und des aktuell ausgewählten Steuerelements an.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ScrollableControl.AdjustFormScrollbars(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF AutoScaleDimensions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF AutoScaleDimensions { System::Drawing::SizeF get(); void set(System::Drawing::SizeF value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleDimensions : System.Drawing.SizeF with get, set" Usage="System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Dimensionen ab, für die das Steuerelement entworfen wurde, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.SizeF" />, die die Punkte pro Zoll (dots per inch, DPI) oder die <see cref="T:System.Drawing.Font" />-Größe enthält, für die das Steuerelement entworfen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> Eigenschaft darstellt, die Einstellung DPI oder Schriftart des Bildschirms für konzipiert, dass das Steuerelement so skaliert wurde. Insbesondere zur Entwurfszeit Mal, wenn diese Eigenschaft von Windows Forms-Designer auf den Wert den Monitor festgelegt wird derzeit verwendet wird. Klicken Sie dann, wenn das Formular zur Laufzeit, wenn geladen der <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> Eigenschaft unterscheidet sich von der <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>, die <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> Methode wird aufgerufen, um die Skalierung des Steuerelements und seiner untergeordneten Elemente. Danach <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> wird aktualisiert, um die neue Skalierungsgröße wiederzugeben.  
  
 Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Breite oder Höhe des <see cref="T:System.Drawing.SizeF" />-Werts ist beim Festlegen dieses Werts kleiner als 0 (null).</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleFactor">
      <MemberSignature Language="C#" Value="protected System.Drawing.SizeF AutoScaleFactor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF AutoScaleFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AutoScaleFactor As SizeF" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::SizeF AutoScaleFactor { System::Drawing::SizeF get(); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleFactor : System.Drawing.SizeF" Usage="System.Windows.Forms.ContainerControl.AutoScaleFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Skalierungsfaktor zwischen der aktuellen automatischen Skalierungsdimension und der automatischen Entwurfszeit-Skalierungsdimension ab.</summary>
        <value>Eine <see cref="T:System.Drawing.SizeF" />, die das Skalierungsverhältnis zwischen der aktuellen automatischen Skalierungsdimension und der automatischen Entwurfszeit-Skalierungsdimension enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> Eigenschaft darstellt, den Skalierungsfaktor zwischen der <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> und <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> Eigenschaften. Dieser Wert wird berechnet, wenn er benötigt wird. Z. B. wenn <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> ist (192, 144) und <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> ist (96, 96) und dann die <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> ist ("2.0", "1,5").  
  
 Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoScaleMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoScaleMode AutoScaleMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoScaleMode AutoScaleMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScaleMode As AutoScaleMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoScaleMode AutoScaleMode { System::Windows::Forms::AutoScaleMode get(); void set(System::Windows::Forms::AutoScaleMode value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScaleMode : System.Windows.Forms.AutoScaleMode with get, set" Usage="System.Windows.Forms.ContainerControl.AutoScaleMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoScaleMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den automatischen Skalierungsmodus des Steuerelements ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.AutoScaleMode" />, der den aktuellen Skalierungsmodus darstellt. Der Standardwert ist <see cref="F:System.Windows.Forms.AutoScaleMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> Eigenschaft gibt den aktuellen automatischen Skalierungsmodus des Steuerelements an. Skalierung von <xref:System.Windows.Forms.AutoScaleMode.Font> ist nützlich, wenn Sie möchten, haben ein Steuerelement oder ein Formular gestreckt oder verkleinert werden entsprechend der Größe der Schriftarten im Betriebssystem und verwendet werden, sollte Wenn die absolute Größe des Formulars oder Steuerelements keine Rolle spielt. Skalierung von <xref:System.Windows.Forms.AutoScaleMode.Dpi> ist nützlich, wenn die Größe des Steuerelements oder Formulars auf dem Bildschirm angezeigt werden sollen. Beispielsweise empfiehlt es sich, verwendet Punkte pro Zoll (DPI) skalieren auf ein Steuerelement, ein Diagramm oder eine andere Grafik, damit sie immer einen bestimmter Prozentsatz des Bildschirms belegt.  
  
 Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Diese Eigenschaft wurde mit einem ungültigen <see cref="T:System.Windows.Forms.AutoScaleMode" />-Wert festgelegt.</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberSignature Language="F#" Value="member this.AutoValidate : System.Windows.Forms.AutoValidate with get, set" Usage="System.Windows.Forms.ContainerControl.AutoValidate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Steuerelemente in diesem Container automatisch validiert werden, wenn der Fokus geändert wird, oder legt diesen Wert fest.</summary>
        <value>Ein aufgezählter <see cref="T:System.Windows.Forms.AutoValidate" />-Wert, der angibt, ob enthaltene Steuerelemente bei Änderung des Fokus implizit validiert werden. Der Standardwert ist <see cref="F:System.Windows.Forms.AutoValidate.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> wird für jedes Steuerelement unterscheiden. Weitere Informationen zur impliziten Validierung finden Sie unter [User Input Validation in Windows Forms](~/docs/framework/winforms/user-input-validation-in-windows-forms.md).  
  
 Festlegen dieser Eigenschaft auf einen neuen Wert löst die <xref:System.Windows.Forms.ContainerControl.AutoValidateChanged> Ereignis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird implizite Validierung für ein Formular und alle darin enthaltenen Steuerelemente deaktiviert und stattdessen Validierung aller untergeordneten des Formulars manuell ausführt, wenn eine Maus geklickt wird.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Diese Eigenschaft wurde mit einem ungültigen <see cref="T:System.Windows.Forms.AutoValidate" />-Wert festgelegt.</exception>
        <altmember cref="T:System.Windows.Forms.AutoValidate" />
        <altmember cref="Overload:System.Windows.Forms.ContainerControl.Validate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoValidateChanged : EventHandler " Usage="member this.AutoValidateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A>  
  
 <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.ContainerControl.BindingContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.ContainerControl.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft auf einen aktiven Wert festgelegt werden kann, um IME-Unterstützung zu aktivieren.</summary>
        <value>
          <see langword="false" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] und höher, IME-Funktionalität wird vom Framework behandelt und native IME-Unterstützung für einzelne Steuerelemente ist deaktiviert.  
  
 Ein Benutzersteuerelement, das von abgeleitet ist die <xref:System.Windows.Forms.ContainerControl> Klasse kann native IME-Unterstützung aktivieren, indem diese zurückzugebende Eigenschaft überschreiben `true`. Allerdings ist die Anwendung dann dafür verantwortlich, dass Sie sicher, dass keine Konflikte zwischen den systemeigenen IME und Windows Forms-IME vorhanden sind. Dieses Szenario wird nicht unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.ContainerControl.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benötigten Erstellungsparameter ab, wenn das Steuerelementhandle erstellt wird.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.CreateParams" />-Eigenschaft, die die erforderlichen Erstellungsparameter enthält, wenn das Handle für das Steuerelement erstellt wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentAutoScaleDimensions">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF CurrentAutoScaleDimensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF CurrentAutoScaleDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentAutoScaleDimensions As SizeF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::SizeF CurrentAutoScaleDimensions { System::Drawing::SizeF get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentAutoScaleDimensions : System.Drawing.SizeF" Usage="System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuellen Laufzeitdimensionen des Bildschirms ab.</summary>
        <value>Eine <see cref="T:System.Drawing.SizeF" />, die die aktuelle Größe des Bildschirms in Punkt pro Zoll (DPI) oder <see cref="T:System.Drawing.Font" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> Eigenschaft darstellt, die Verweisdimensionen auf den aktuellen Bildschirm. Im Gegensatz dazu die <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A> Eigenschaft darstellt, die zur Entwurfszeit Bezugsdimensionen die entwurfsumgebung für das aktuelle Steuerelement während der <xref:System.Windows.Forms.ContainerControl.AutoScaleFactor%2A> Eigenschaft ist das Verhältnis zwischen den beiden.  
  
 Die Interpretation der Dimension hängt von der <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> Eigenschaft auf folgende Weise:  
  
-   Wenn der Modus ist <xref:System.Windows.Forms.AutoScaleMode.Dpi>, diese Eigenschaft stellt die Auflösung des Bildschirms in Punkte pro Zoll.  
  
-   Wenn der Modus ist <xref:System.Windows.Forms.AutoScaleMode.Font>, diese Eigenschaft stellt die durchschnittliche Schriftgrad des Zeichens in Pixel.  
  
 Wenn die <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> -Eigenschaftensatz auf <xref:System.Windows.Forms.AutoScaleMode.None>, <xref:System.Windows.Forms.ContainerControl.CurrentAutoScaleDimensions%2A> gleich festgelegt ist <xref:System.Windows.Forms.ContainerControl.AutoScaleDimensions%2A>.  
  
 Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Für den aktuellen Bildschirm konnte kein Win32-Gerätekontext erstellt werden.</exception>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleDimensions" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="containerControl.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom <see cref="T:System.Windows.Forms.Control" /> und den untergeordneten Steuerelementen verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OnAutoValidateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoValidateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoValidateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoValidateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoValidateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoValidateChanged : EventArgs -&gt; unit&#xA;override this.OnAutoValidateChanged : EventArgs -&gt; unit" Usage="containerControl.OnAutoValidateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.ContainerControl.OnAutoValidateChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.ContainerControl.OnAutoValidateChanged(System.EventArgs)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberSignature Language="F#" Value="override this.OnCreateControl : unit -&gt; unit" Usage="containerControl.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst die <see cref="M:System.Windows.Forms.Control.CreateControl" />-Methode aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="containerControl.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändern der Schriftart von einer <xref:System.Windows.Forms.ContainerControl> führt dazu, dass das Layout neu berechnet und an die darin enthaltenen Steuerelemente erneut angewendet, wenn die <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A> Eigenschaft hat den Wert des <xref:System.Windows.Forms.AutoScaleMode.Font>.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.ContainerControl.OnFontChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (e As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="containerControl.OnLayout e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.LayoutEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Layout" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnParentChanged : EventArgs -&gt; unit" Usage="containerControl.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ParentChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ParentForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ParentForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ParentForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContainerControl.ParentForm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ParentForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentForm : System.Windows.Forms.Form" Usage="System.Windows.Forms.ContainerControl.ParentForm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Formular ab, dem das Containersteuerelement zugewiesen ist.</summary>
        <value>Das <see cref="T:System.Windows.Forms.Form" />, dem das Containersteuerelement zugewiesen ist. Diese Eigenschaft gibt NULL zurück, wenn das Steuerelement in Internet Explorer oder einem anderen Hostkontext ohne übergeordnetes Formular gehostet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zwei Formen erstellen: `Form1` und `Form2`. Festlegen der <xref:System.Windows.Forms.Form.IsMdiContainer%2A> Eigenschaft `Form1` zu `true` , und stellen sie die <xref:System.Windows.Forms.Form.MdiParent%2A> von `Form2`. Als Nächstes erstellen Sie eine Schaltfläche `button1`, auf jedem Formular. Wenn auf das übergeordnete Formular die Schaltfläche geklickt wird, wird der Ereignishandler das untergeordnete Formular angezeigt. Wenn auf das untergeordnete Formular die Schaltfläche geklickt wird, wird der Ereignishandler zeigt die <xref:System.Windows.Forms.Control.Name%2A> Eigenschaft des übergeordneten Formulars. Verwenden Sie die folgenden zwei Codesegmente überschreiben `button1` -Ereignishandler in beiden Formen.  
  
 [!code-cpp[ParentForm2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form1.cpp#1)]
 [!code-csharp[ParentForm2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form1.cs#1)]
 [!code-vb[ParentForm2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form1.vb#1)]  
  
 [!code-cpp[ParentForm2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentForm2/CPP/form2.cpp#2)]
 [!code-csharp[ParentForm2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentForm2/CS/form2.cs#2)]
 [!code-vb[ParentForm2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentForm2/VB/form2.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschaftswert abzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="PerformAutoScale">
      <MemberSignature Language="C#" Value="public void PerformAutoScale ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformAutoScale() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.PerformAutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformAutoScale ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformAutoScale();" />
      <MemberSignature Language="F#" Value="member this.PerformAutoScale : unit -&gt; unit" Usage="containerControl.PerformAutoScale " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt eine Skalierung für das Containersteuerelement und die dazugehörigen untergeordneten Elemente aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein expliziter Aufruf von der <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> Methode ist in der Regel nur nach programmgesteuerte Änderungen an das Layout zur Laufzeit erforderlich. <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> wird implizit aufgerufen werden, aus der <xref:System.Windows.Forms.ContainerControl.OnLayout%2A> Methode.  
  
 <xref:System.Windows.Forms.ContainerControl.PerformAutoScale%2A> ist rekursiv. jedes untergeordnete Steuerelement, wenn es sich um einen Container handelt wird über eine eigene Version dieser Methode wird aufgerufen, wenn die Version des Containers ausgeführt wird.  
  
 Weitere Informationen zur automatischen Skalierung finden Sie unter [automatische Skalierung in Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleMode" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoScaleFactor" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="containerControl.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Befehlstaste.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogChar : char -&gt; bool" Usage="containerControl.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein Dialogfeldzeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="containerControl.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Tastatureingabe im Dialogfeld.</summary>
        <returns>
          <see langword="true" />, wenn die Taste vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="override this.ProcessMnemonic : char -&gt; bool" Usage="containerControl.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein mnemonisches Zeichen.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen als mnemonisches Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessTabKey(bool forward);" />
      <MemberSignature Language="F#" Value="abstract member ProcessTabKey : bool -&gt; bool&#xA;override this.ProcessTabKey : bool -&gt; bool" Usage="containerControl.ProcessTabKey forward" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" />, um die Steuerelemente in <see cref="T:System.Windows.Forms.ContainerControl" /> vorwärts zu durchlaufen, andernfalls <see langword="false" />.</param>
        <summary>Wählt das nächste verfügbare Steuerelement aus, das zum aktiven Steuerelement wird.</summary>
        <returns>
          <see langword="true" />, wenn ein Steuerelement ausgewählt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Steuerelement mit seiner <xref:System.Windows.Forms.Control.TabStop%2A> -Eigenschaftensatz auf `false` kann nicht ausgewählt werden, damit das nächste verfügbare Steuerelement ausgewählt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="override this.Select : bool * bool -&gt; unit" Usage="containerControl.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">
          <see langword="true" />, um die Richtung für die Auswahl des Steuerelements anzugeben, andernfalls <see langword="false" />.</param>
        <param name="forward">
          <see langword="true" />, um sich in der Aktivierreihenfolge vorwärts zu bewegen, <see langword="false" />, um sich rückwärts zu bewegen.</param>
        <summary>Aktiviert ein untergeordnetes Steuerelement. Gibt optional die Richtung in der Aktivierreihenfolge für die Auswahl des Steuerelements an.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IContainerControl.ActivateControl">
      <MemberSignature Language="C#" Value="bool IContainerControl.ActivateControl (System.Windows.Forms.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Forms.IContainerControl.ActivateControl(class System.Windows.Forms.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.System#Windows#Forms#IContainerControl#ActivateControl(System.Windows.Forms.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Forms.IContainerControl.ActivateControl(System::Windows::Forms::Control ^ control) = System::Windows::Forms::IContainerControl::ActivateControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IContainerControl.ActivateControl(System.Windows.Forms.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="control">Das zu aktivierende <see cref="T:System.Windows.Forms.Control" />.</param>
        <summary>Aktiviert das angegebene Steuerelement.</summary>
        <returns>
          <see langword="true" />, wenn das Steuerelement erfolgreich aktiviert wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `control` -Parameter muss ein untergeordnetes Element des Containersteuerelements sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Vererben der <xref:System.Windows.Forms.ScrollableControl> Klasse und Implementieren der <xref:System.Windows.Forms.IContainerControl> Schnittstelle. Implementierung wird hinzugefügt, um die <xref:System.Windows.Forms.IContainerControl.ActiveControl%2A> Eigenschaft und die <xref:System.Windows.Forms.IContainerControl.ActivateControl%2A> Methode.  
  
 [!code-cpp[IContainerControl Implementation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IContainerControl Implementation/CPP/mycontainercontrol.cpp#1)]
 [!code-csharp[IContainerControl Implementation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IContainerControl Implementation/CS/mycontainercontrol.cs#1)]
 [!code-vb[IContainerControl Implementation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IContainerControl Implementation/VB/mycontainercontrol.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected virtual void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void UpdateDefaultButton();" />
      <MemberSignature Language="F#" Value="abstract member UpdateDefaultButton : unit -&gt; unit&#xA;override this.UpdateDefaultButton : unit -&gt; unit" Usage="containerControl.UpdateDefaultButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert beim Überschreiben von einer abgeleiteten Klasse, welche Schaltfläche die Standardschaltfläche darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl> Klasse bietet keine Implementierung für die <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> Methode. Klassen, die diese Methode erben müssen implementieren <xref:System.Windows.Forms.ContainerControl.UpdateDefaultButton%2A> Standardschaltfläche zu aktualisieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Überprüft den Wert des Steuerelements, das den Fokus verliert, indem das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis und das <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignis in dieser Reihenfolge ausgelöst werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate();" />
      <MemberSignature Language="F#" Value="member this.Validate : unit -&gt; bool" Usage="containerControl.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft den Wert des Steuerelements, das den Fokus verliert, indem das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis und das <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignis in dieser Reihenfolge ausgelöst werden.</summary>
        <returns>
          <see langword="true" /> wenn die Validierung erfolgreich ist; andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.Validate%2A> -Methode validiert das letzte untergeordnete Steuerelement, die nicht validiert wird und dessen Vorgänger einrichten, aber nicht einschließlich des aktuellen Containersteuerelements. Die überladene Version führt immer eine Validierung, unabhängig vom Wert für die <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> -Eigenschaft des übergeordneten Elements des Steuerelements. Aus diesem Grund verwenden Sie diese um Validierung bedingungslos zu erzwingen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public bool Validate (bool checkAutoValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Validate(bool checkAutoValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.Validate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Validate (checkAutoValidate As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Validate(bool checkAutoValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : bool -&gt; bool" Usage="containerControl.Validate checkAutoValidate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkAutoValidate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="checkAutoValidate">Wenn <see langword="true" />, wird mithilfe des Werts der <see cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />-Eigenschaft bestimmt, ob die Validierung ausgeführt werden soll. Wenn <see langword="false" />, wird die Validierung bedingungslos ausgeführt.</param>
        <summary>Überprüft den Wert des Steuerelements, das den Fokus verliert. Dies hängt bedingt davon ab, ob die automatische Validierung aktiviert ist.</summary>
        <returns>
          <see langword="true" /> wenn die Validierung erfolgreich ist; andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContainerControl.Validate%2A> -Methode validiert das letzte untergeordnete Steuerelement, die nicht validiert wird und dessen Vorgänger einrichten, aber nicht einschließlich des aktuellen Containersteuerelements. Die überladene Version führt die Überprüfung anhand der folgenden Bedingungen:  
  
-   Wenn die `checkAutoValidate` Parameter ist `true`, erfolgt die Validierung immer für die untergeordneten Steuerelemente, die nicht überprüft werden.  
  
-   Wenn die `checkAutoValidate` Parameter ist `false`, Überprüfung erfolgt nur, wenn die <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> -Eigenschaft des übergeordneten Elements des Steuerelements aktiviert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.ContainerControl.AutoValidateChanged" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bewirkt, dass alle untergeordneten Steuerelemente in einem Steuerelement, die die Validierung unterstützten, ihre Daten validieren.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren();" />
      <MemberSignature Language="F#" Value="abstract member ValidateChildren : unit -&gt; bool&#xA;override this.ValidateChildren : unit -&gt; bool" Usage="containerControl.ValidateChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass alle untergeordneten Steuerelemente in einem Steuerelement, die die Validierung unterstützten, ihre Daten validieren.</summary>
        <returns>
          <see langword="true" />, wenn alle untergeordneten Elemente erfolgreich validiert wurden, andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> wird ein Steuerelement Hierarchie Verzweigen und untersuchen Sie jedes Steuerelement, um festzustellen, ob die Validierung unterstützt. Wenn das Steuerelement vom Benutzer ausgewählt werden kann und die zugehörige <xref:System.Windows.Forms.Control.CausesValidation%2A> Eigenschaft ist `true`, <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> führt dazu, dass die <xref:System.Windows.Forms.Control.Validating> Ereignis auftritt. Wenn eines der Steuerelemente Abbrechen der <xref:System.Windows.Forms.Control.Validating> -Ereignis von dieser Methode zurückgegeben `false`ist, andernfalls wird zurückgegeben, `true`.  
  
 Wenn ein Steuerelement an eine Datenquelle gebunden ist und die <xref:System.Windows.Forms.Control.Validating> Ereignis auftritt, wird er dazu führen, dass das Steuerelement seine aktuelle Daten zurück an die Datenquelle mithilfe von Push übertragen.  
  
 Aufrufen von <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> entspricht dem Aufruf <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> mit einem <xref:System.Windows.Forms.ValidationConstraints> von <xref:System.Windows.Forms.ValidationConstraints.None>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird implizite Validierung für ein Formular und alle darin enthaltenen Steuerelemente deaktiviert und stattdessen Validierung aller untergeordneten des Formulars manuell ausführt, wenn eine Maus geklickt wird.  
  
 [!code-csharp[ValidateChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildren/CS/Form1.cs#1)]
 [!code-vb[ValidateChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildren/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public virtual bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberSignature Language="F#" Value="abstract member ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool&#xA;override this.ValidateChildren : System.Windows.Forms.ValidationConstraints -&gt; bool" Usage="containerControl.ValidateChildren validationConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Schränkt ein, bei welchen Steuerelementen das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis ausgelöst wird.</param>
        <summary>Bewirkt, dass alle untergeordneten Steuerelemente in einem Steuerelement, die die Validierung unterstützten, ihre Daten validieren.</summary>
        <returns>
          <see langword="true" />, wenn alle untergeordneten Elemente erfolgreich validiert wurden, andernfalls <see langword="false" />. Wenn sie vom <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignishandler oder vom <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignishandler aufgerufen wird, gibt diese Methode immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> die untergeordneten Elemente des aktuellen Steuerelements werden untersucht verursacht die <xref:System.Windows.Forms.Control.Validating> Ereignis, um auf ein Steuerelement auftreten, wenn sie die Kriterien erfüllt wie folgt buchstabiert <xref:System.Windows.Forms.ValidationConstraints>.  
  
 Sie können mehrere <xref:System.Windows.Forms.ValidationConstraints> Parameter gleichzeitig, indem sie mit einem bitweisen OR-Operator kombiniert werden. Kombinieren Parameter mit einem bitweisen OR-Operator führt eine logische AND-Operation. Beispielsweise Aufrufen `ValidateChildren(ValidationConstraints.ImmediateChildren | ValidationConstraints.Enabled)` löst nur die <xref:System.Windows.Forms.Control.Validating> Ereignis auf Steuerelemente, die sowohl das unmittelbar untergeordnete Element des Containers und aktiviert sind.  
  
 Unabhängig davon, welche Parameter für diese Methode angegeben werden, haben muss, ein Steuerelement seine <xref:System.Windows.Forms.Control.CausesValidation%2A> -Eigenschaftensatz auf `true` nacheinander für seine <xref:System.Windows.Forms.Control.Validating> Ereignis auftritt. Sollten Sie auch Festlegen der <xref:System.Windows.Forms.ContainerControl.AutoValidate%2A> -Eigenschaft des Steuerelements oder des Containers des Steuerelements auf `false` gegebenenfalls Validierung nur bei einem Aufruf <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, und nicht wenn der Benutzer wechselt der Fokus aus dem Steuerelement.  
  
 Wenn ein Steuerelement an eine Datenquelle gebunden ist und die <xref:System.Windows.Forms.Control.Validating> Ereignis auftritt, wird er dazu führen, dass das Steuerelement seine aktuelle Daten zurück an die Datenquelle mithilfe von Push übertragen.  
  
 Sie können nicht den gegenteiligen Effekt der erzielen eine <xref:System.Windows.Forms.ValidationConstraints> Parameter, indem eine bitweise Negation-Operator angewendet. Angenommen, Sie geben den negativen Wert der <xref:System.Windows.Forms.ValidationConstraints.Visible> Feld <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A>, es kann nicht überprüft werden alle untergeordneten Elemente, die für den Container nicht sichtbar sind. Alle negativen Parameter bereitstellen <xref:System.Windows.Forms.ContainerControl.ValidateChildren%2A> hat keine Auswirkungen auf den Container oder seine untergeordneten Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird bewirkt, dass nur die <xref:System.Windows.Forms.Control.Validating> für direkt untergeordnete Elemente des Formulars auf, dessen Ereignis <xref:System.Windows.Forms.Control.Enabled%2A> Eigenschaft ist `true`.  
  
 [!code-csharp[ValidateChildrenWithConstraints#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ValidateChildrenWithConstraints/CS/Form1.cs#1)]
 [!code-vb[ValidateChildrenWithConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ValidateChildrenWithConstraints/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="containerControl.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Verarbeitet Windows-Meldungen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>