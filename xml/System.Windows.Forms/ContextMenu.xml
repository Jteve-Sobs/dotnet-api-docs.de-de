<Type Name="ContextMenu" FullName="System.Windows.Forms.ContextMenu">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5fcc17d136f4da7b817a00d3b2a9e0fc0a1c2bba" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69194577" /></Metadata><TypeSignature Language="C#" Value="public class ContextMenu : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContextMenu extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ContextMenu" />
  <TypeSignature Language="VB.NET" Value="Public Class ContextMenu&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContextMenu : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type ContextMenu = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Popup")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Kontextmenü dar. Obwohl <see cref="T:System.Windows.Forms.ContextMenuStrip" /> das <see cref="T:System.Windows.Forms.ContextMenu" />-Steuerelement vorheriger Versionen ersetzt und funktionell erweitert, wird das <see cref="T:System.Windows.Forms.ContextMenu" />-Steuerelement sowohl aus Gründen der Abwärtskompatibilität als auch, falls gewünscht, für die zukünftige Verwendung beibehalten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.ContextMenu> -Klasse stellt Kontextmenüs dar, die angezeigt werden können, wenn der Benutzer mit der rechten Maustaste auf ein Steuerelement oder einen Bereich des Formulars klickt. Kontextmenüs werden in der Regel verwendet, um unterschiedliche Menü <xref:System.Windows.Forms.MainMenu> Elemente aus einem eines Formulars zu kombinieren, die für den Benutzer hilfreich sind, wenn der Kontext der Anwendung verwendet wird. Beispielsweise können Sie ein Kontextmenü, das einem <xref:System.Windows.Forms.TextBox> Steuerelement zugewiesen ist, verwenden, um Menü Elemente zum Ändern der Schriftart des Texts, zum Suchen von Text innerhalb des Steuer Elements oder Zwischenablage Funktionen zum Kopieren und Einfügen von Text bereitzustellen. Sie können auch neue <xref:System.Windows.Forms.MenuItem> Objekte in einem Kontextmenü anzeigen, das sich nicht in einem <xref:System.Windows.Forms.MainMenu> befindet, um bestimmte Befehle bereitzustellen, die für die <xref:System.Windows.Forms.MainMenu> Anzeige nicht geeignet sind.  
  
 In der Regel wird ein Kontextmenü angezeigt, wenn ein Benutzer mit der rechten Maustaste auf ein Steuerelement oder das Formular selbst klickt. Sichtbare Steuerelemente <xref:System.Windows.Forms.Form> und verfügen <xref:System.Windows.Forms.Control.ContextMenu%2A> über eine Eigenschaft, <xref:System.Windows.Forms.ContextMenu> die die Klasse an das Steuerelement bindet, das das Kontextmenü anzeigt. Mehr als ein Steuerelement kann einen <xref:System.Windows.Forms.ContextMenu>verwenden. Sie können die <xref:System.Windows.Forms.ContextMenu.SourceControl%2A> -Eigenschaft verwenden, um zu bestimmen, welches Steuerelement zuletzt das Kontextmenü angezeigt hat, um spezielle Aufgaben für das Steuerelement auszuführen oder das für das Steuerelement angezeigte Kontextmenü zu ändern.  
  
 Möglicherweise möchten Sie wissen, wann das Kontextmenü angezeigt wird, um Häkchen festzulegen, Elemente zu deaktivieren und andere Menü Aufgaben auszuführen, bevor dem Benutzer das Menü angezeigt wird. Sie können das <xref:System.Windows.Forms.ContextMenu.Popup> -Ereignis behandeln, um zu bestimmen, wann das Kontextmenü angezeigt wird.  
  
> [!NOTE]
>  Um Objekte wiederzuverwenden <xref:System.Windows.Forms.MenuItem> , die in einem <xref:System.Windows.Forms.MainMenu> zur Verwendung in einer <xref:System.Windows.Forms.ContextMenu>angezeigt werden, müssen Sie mithilfe der <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> -Methode der- <xref:System.Windows.Forms.MenuItem> Klasse eine Kopie des Menüs erstellen. Sie können Menü Elemente und ihre unter Menü Elemente auch mithilfe der <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> -Methode der <xref:System.Windows.Forms.MenuItem> -Klasse in einem einzelnen-Objekt zusammenführen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler für das <xref:System.Windows.Forms.ContextMenu.Popup> -Ereignis <xref:System.Windows.Forms.ContextMenu>von erstellt. Der Code im-Ereignishandler bestimmt, welche der beiden Steuer <xref:System.Windows.Forms.PictureBox> Elemente `pictureBox1` ein mit dem `textBox1` Namen und ein <xref:System.Windows.Forms.TextBox> benanntes Steuerelement sind, das das Kontextmenü anzeigt. Abhängig davon, welches Steuerelement <xref:System.Windows.Forms.ContextMenu> bewirkt hat, dass das Kontextmenü angezeigt wird, fügt <xref:System.Windows.Forms.MenuItem> das Steuerelement <xref:System.Windows.Forms.ContextMenu>die entsprechenden Objekte hinzu. Für dieses Beispiel ist es erforderlich, dass Sie über <xref:System.Windows.Forms.ContextMenu> eine Instanz der `contextMenu1`-Klasse mit dem Namen verfügen, die im Formular definiert ist. Dieses Beispiel erfordert auch, dass Sie einen <xref:System.Windows.Forms.TextBox> haben <xref:System.Windows.Forms.PictureBox> und zu einem Formular hinzugefügt haben <xref:System.Windows.Forms.Control.ContextMenu%2A> und dass die-Eigenschaft dieser Steuer `contextMenu1`Elemente auf festgelegt ist.  
  
 [!code-cpp[Classic ContextMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ContextMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ContextMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ContextMenu Example/CS/source.cs#1)]
 [!code-vb[Classic ContextMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ContextMenu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuItem" />
    <altmember cref="T:System.Windows.Forms.MainMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.ContextMenu" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContextMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContextMenu();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.ContextMenu" />-Klasse ohne Angabe von Menüelementen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem Sie diese Version des Konstruktors verwendet haben, können Sie mithilfe der <xref:System.Windows.Forms.ContextMenu> <xref:System.Windows.Forms.Menu.MenuItemCollection.Add%2A> -Methode der <xref:System.Windows.Forms.Menu.MenuItemCollection> -Klasse Menü Elemente hinzufügen. Sie können über die <xref:System.Windows.Forms.Menu.MenuItemCollection> <xref:System.Windows.Forms.Menu.MenuItems%2A> -Eigenschaft auf das zugreifen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Menu.MenuItemCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContextMenu (System.Windows.Forms.MenuItem[] menuItems);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.MenuItem[] menuItems) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.#ctor(System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (menuItems As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContextMenu(cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ menuItems);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.ContextMenu : System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.ContextMenu" Usage="new System.Windows.Forms.ContextMenu menuItems" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="menuItems" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="menuItems">Ein Array von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten, die die dem Kontextmenü hinzuzufügenden Menüelemente darstellen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.ContextMenu" />-Klasse mit dem angegebenen Satz von <see cref="T:System.Windows.Forms.MenuItem" />-Objekten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Version des Konstruktors verwenden, um eine <xref:System.Windows.Forms.ContextMenu> zu erstellen, deren Menü Elemente zum Zeitpunkt der Erstellung angegeben werden. Nachdem Sie diese Version des Konstruktors verwendet haben, können Sie mithilfe der <xref:System.Windows.Forms.ContextMenu> <xref:System.Windows.Forms.Menu.MenuItemCollection.Add%2A> -Methode der <xref:System.Windows.Forms.Menu.MenuItemCollection> -Klasse zusätzliche Menü Elemente hinzufügen. Sie können über die <xref:System.Windows.Forms.Menu.MenuItemCollection> <xref:System.Windows.Forms.Menu.MenuItems%2A> -Eigenschaft auf das zugreifen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Erstellen eines Kontextmenüs und die <xref:System.Windows.Forms.ContextMenu.Show%2A> Verwendung der-Methode veranschaulicht. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine Schaltfläche mit dem Namen Button1 enthält. Stellen Sie sicher, dass alle Ereignisse mit ihren Ereignis Behandlungsmethoden verknüpft sind.  
  
 [!code-cpp[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuItem" />
      </Docs>
    </Member>
    <Member MemberName="Collapse">
      <MemberSignature Language="C#" Value="public event EventHandler Collapse;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Collapse" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ContextMenu.Collapse" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Collapse As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Collapse;" />
      <MemberSignature Language="F#" Value="member this.Collapse : EventHandler " Usage="member this.Collapse : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Kontextmenü geschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.ContextMenu.Collapse> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> empfiehlt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> es sich, durch zu ersetzen oder die Nachricht <xref:System.Windows.Forms.TextBox>an eine mehrzeilige anfügen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz <xref:System.Windows.Forms.ContextMenu> des `ContextMenu1`Typs mit dem Namen enthält. Stellen Sie dann sicher, dass der Ereignishandler dem <xref:System.Windows.Forms.ContextMenu.Collapse> Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#170](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#170)]
 [!code-vb[System.Windows.Forms.EventExamples#170](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#170)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollapse">
      <MemberSignature Language="C#" Value="protected internal virtual void OnCollapse (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnCollapse(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.OnCollapse(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnCollapse (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnCollapse(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCollapse : EventArgs -&gt; unit&#xA;override this.OnCollapse : EventArgs -&gt; unit" Usage="contextMenu.OnCollapse e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.ContextMenu.Collapse" /> -Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="contextMenu.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.ContextMenu.Popup" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ContextMenu.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor das Kontextmenü angezeigt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis verwenden, um die <xref:System.Windows.Forms.MenuItem> Objekte zu initialisieren, bevor Sie angezeigt werden. Wenn Sie z. b. einen <xref:System.Windows.Forms.ContextMenu> für drei <xref:System.Windows.Forms.TextBox> Steuerelemente verwenden und bestimmte Menü Elemente in der <xref:System.Windows.Forms.ContextMenu> deaktivieren möchten, je nachdem <xref:System.Windows.Forms.TextBox> , welches Kontextmenü angezeigt wird, können Sie einen Ereignishandler für dieses Ereignis erstellen. Sie <xref:System.Windows.Forms.ContextMenu.SourceControl%2A> können die-Eigenschaft verwenden, um <xref:System.Windows.Forms.TextBox> zu bestimmen, welche im <xref:System.Windows.Forms.ContextMenu> Begriff ist, den <xref:System.Windows.Forms.MenuItem> anzuzeigen, und die entsprechenden Objekte zu deaktivieren.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler für das <xref:System.Windows.Forms.ContextMenu.Popup> -Ereignis <xref:System.Windows.Forms.ContextMenu>von erstellt. Der Code im-Ereignishandler bestimmt, welche der beiden Steuer <xref:System.Windows.Forms.PictureBox> Elemente `pictureBox1` ein mit dem `textBox1` Namen und ein <xref:System.Windows.Forms.TextBox> benanntes Steuerelement sind, das das Kontextmenü anzeigt. Abhängig davon, welches Steuerelement <xref:System.Windows.Forms.ContextMenu> bewirkt hat, dass das Kontextmenü angezeigt wird, fügt <xref:System.Windows.Forms.MenuItem> das Steuerelement <xref:System.Windows.Forms.ContextMenu>die entsprechenden Objekte hinzu. Für dieses Beispiel ist es erforderlich, dass Sie über <xref:System.Windows.Forms.ContextMenu> eine Instanz der `contextMenu1`-Klasse mit dem Namen verfügen, die im Formular definiert ist. Dieses Beispiel erfordert auch, dass Sie einen <xref:System.Windows.Forms.TextBox> haben <xref:System.Windows.Forms.PictureBox> und zu einem Formular hinzugefügt haben <xref:System.Windows.Forms.Control.ContextMenu%2A> und dass die-Eigenschaft dieser Steuer `contextMenu1`Elemente auf festgelegt ist.  
  
 [!code-cpp[Classic ContextMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ContextMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ContextMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ContextMenu Example/CS/source.cs#1)]
 [!code-vb[Classic ContextMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ContextMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData, System.Windows.Forms.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData, class System.Windows.Forms.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys,System.Windows.Forms.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData, System::Windows::Forms::Control ^ control);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys * System.Windows.Forms.Control -&gt; bool" Usage="contextMenu.ProcessCmdKey (msg, keyData, control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="control" Type="System.Windows.Forms.Control" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <param name="control">Das Steuerelement, auf das die Befehlstaste angewendet wird.</param>
        <summary>Verarbeitet eine Befehlstaste.</summary>
        <returns><see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird während der Nachrichten Vorverarbeitung aufgerufen, um Befehlstasten zu verarbeiten. Befehlstasten sind Schlüssel, die immer Vorrang vor regulären Eingabe Schlüsseln haben. Beispiele für Befehlstasten sind Accelerators und Menü Verknüpfungen. Die Methode muss zurück `true` geben, um anzugeben, dass Sie den Befehls Schlüssel verarbeitet `false` hat, oder um anzugeben, dass es sich bei dem Schlüssel nicht um einen Befehls Schlüssel handelt. Diese Methode wird nur aufgerufen, wenn das Steuerelement in einer Windows Forms Anwendung oder als ActiveX-Steuerelement gehostet wird.  
  
 Die <xref:System.Windows.Forms.ContextMenu.ProcessCmdKey%2A> -Methode bestimmt zuerst, ob das- <xref:System.Windows.Forms.ContextMenu>Steuerelement über ein verfügt, und <xref:System.Windows.Forms.ContextMenu> wenn dies der Fall ist, ermöglicht das Verarbeiten des Befehls Schlüssels. Wenn der Befehls Schlüssel keine Menü Verknüpfung ist und das Steuerelement über ein übergeordnetes Element verfügt, wird der Schlüssel an die <xref:System.Windows.Forms.ContextMenu.ProcessCmdKey%2A> -Methode des übergeordneten Elements übermittelt. Der Nettoeffekt ist, dass die Befehlstasten in der Steuerelement Hierarchie "Bubbled" sind. Zusätzlich zu dem Schlüssel, den der Benutzer gedrückt hat, gibt die Schlüsseldaten auch an, welche Modifizierertasten ggf. zur gleichen Zeit wie der Schlüssel gedrückt wurden. Modifizierertasten enthalten die Tasten UMSCHALT, STRG und alt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> Methode in einer abgeleiteten Klasse überschrieben wird, sollte <see langword="true" /> ein Steuerelement zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom-Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> der-Methode der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContextMenu.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.ContextMenu.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Text im Steuerelement von rechts nach links angezeigt wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.RightToLeft" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht es Ihren Menüs, Sprachen zu unterstützen, die von rechts nach links geschrieben werden. Wenn diese Eigenschaft auf `RightToLeft.Yes`festgelegt ist, wird der Text des Menü Elements von rechts nach links und nicht von der standardmäßigen Left-to-Right-Methode angezeigt.  
  
> [!NOTE]
>  Weitere Informationen zum Aktivieren der Ausrichtung von rechts nach links auf Windows Forms Steuerelemente finden Sie unter der <xref:System.Windows.Forms.Control.RightToLeft%2A> -Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der der Eigenschaft zugewiesene Wert ist kein gültiger Member der <see cref="T:System.Windows.Forms.RightToLeft" />-Enumeration.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Show">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeigt das Kontextmenü an der angegebenen Position an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.Control control, System.Drawing.Point pos);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.Control control, valuetype System.Drawing.Point pos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.Show(System.Windows.Forms.Control,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::Control ^ control, System::Drawing::Point pos);" />
      <MemberSignature Language="F#" Value="member this.Show : System.Windows.Forms.Control * System.Drawing.Point -&gt; unit" Usage="contextMenu.Show (control, pos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.Forms.Control" />
        <Parameter Name="pos" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="control">Ein <see cref="T:System.Windows.Forms.Control" />-Objekt, das das Steuerelement angibt, dem dieses Kontextmenü zugeordnet ist.</param>
        <param name="pos">Ein <see cref="T:System.Drawing.Point" />-Objekt, das die Koordinaten angibt, an denen das Menü angezeigt werden soll. Diese Koordinaten werden relativ zu den im <paramref name="control" />-Parameter festgelegten Clientkoordinaten des Steuerelements angegeben.</param>
        <summary>Zeigt das Kontextmenü an der angegebenen Position an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Windows.Forms.ContextMenu> wird ein angezeigt, wenn der Benutzer auf die Rechte Maustaste in einem Steuerelement oder Bereich des Formulars klickt <xref:System.Windows.Forms.ContextMenu> , an das der gebunden ist. Mit dieser Methode können Sie das Kontextmenü an einer bestimmten Position manuell anzeigen und mit einem bestimmten Steuerelement binden. Diese Methode wird erst zurückgegeben, wenn das Menü verworfen wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Erstellen eines Kontextmenüs und die <xref:System.Windows.Forms.ContextMenu.Show%2A> Verwendung der-Methode veranschaulicht. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine Schaltfläche mit dem Namen Button1 enthält. Stellen Sie sicher, dass alle Ereignisse mit ihren Ereignis Behandlungsmethoden verknüpft sind.  
  
 [!code-cpp[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ManualContextMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ManualContextMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="control" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das Handle des Steuerelements ist nicht vorhanden, oder das Steuerelement ist nicht sichtbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.Control control, System.Drawing.Point pos, System.Windows.Forms.LeftRightAlignment alignment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.Control control, valuetype System.Drawing.Point pos, valuetype System.Windows.Forms.LeftRightAlignment alignment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ContextMenu.Show(System.Windows.Forms.Control,System.Drawing.Point,System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::Control ^ control, System::Drawing::Point pos, System::Windows::Forms::LeftRightAlignment alignment);" />
      <MemberSignature Language="F#" Value="member this.Show : System.Windows.Forms.Control * System.Drawing.Point * System.Windows.Forms.LeftRightAlignment -&gt; unit" Usage="contextMenu.Show (control, pos, alignment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.Forms.Control" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pos" Type="System.Drawing.Point" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="alignment" Type="System.Windows.Forms.LeftRightAlignment" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">Ein <see cref="T:System.Windows.Forms.Control" />-Objekt, das das Steuerelement angibt, dem dieses Kontextmenü zugeordnet ist.</param>
        <param name="pos">Ein <see cref="T:System.Drawing.Point" />-Objekt, das die Koordinaten angibt, an denen das Menü angezeigt werden soll. Diese Koordinaten werden relativ zu den im <paramref name="control" />-Parameter festgelegten Clientkoordinaten des Steuerelements angegeben.</param>
        <param name="alignment">Eine <see cref="T:System.Windows.Forms.LeftRightAlignment" />, die die Ausrichtung des Steuerelements relativ zum <paramref name="pos" />-Parameter angibt.</param>
        <summary>Zeigt das Kontextmenü an der angegebenen Position und mit der angegebenen Ausrichtung an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control SourceControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control SourceControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ContextMenu.SourceControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ SourceControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.ContextMenu.SourceControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Steuerelement ab, das das Kontextmenü anzeigt.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Control" />, das das Kontextmenü anzeigende Steuerelement darstellt. Wenn kein Steuerelement das Kontextmenü angezeigt hat, gibt diese Eigenschaft <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft können Sie bestimmen, welches Steuerelement derzeit das in <xref:System.Windows.Forms.ContextMenu>definierte Kontextmenü anzeigt. Wenn das Kontextmenü momentan nicht angezeigt wird, können Sie diese Eigenschaft verwenden, um zu bestimmen, welches Steuerelement zuletzt das Kontextmenü angezeigt hat. Sie können diese Eigenschaft im <xref:System.Windows.Forms.ContextMenu.Popup> -Ereignis verwenden, um sicherzustellen, dass das-Steuerelement die richtigen Menü Elemente anzeigt. Sie können diese Eigenschaft auch verwenden, um einen Verweis auf das-Steuerelement an eine Methode zu übergeben, die die Aufgaben ausführt, die einem Menübefehl zugeordnet sind, der im Kontextmenü angezeigt wird. Da die <xref:System.Windows.Forms.Form> -Klasse von <xref:System.Windows.Forms.Control>erbt, können Sie diese Eigenschaft auch verwenden, <xref:System.Windows.Forms.ContextMenu> wenn dem ein Formular zugeordnet ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler für das <xref:System.Windows.Forms.ContextMenu.Popup> -Ereignis <xref:System.Windows.Forms.ContextMenu>von erstellt. Der Code im-Ereignishandler bestimmt, welche der beiden Steuer <xref:System.Windows.Forms.PictureBox> Elemente `pictureBox1` ein mit dem `textBox1` Namen und ein <xref:System.Windows.Forms.TextBox> benanntes Steuerelement sind, das das Kontextmenü anzeigt. Abhängig davon, welches Steuerelement <xref:System.Windows.Forms.ContextMenu> bewirkt hat, dass das Kontextmenü angezeigt wird, fügt <xref:System.Windows.Forms.MenuItem> das Steuerelement <xref:System.Windows.Forms.ContextMenu>die entsprechenden Objekte hinzu. Für dieses Beispiel ist es erforderlich, dass Sie über <xref:System.Windows.Forms.ContextMenu> eine Instanz der `contextMenu1`-Klasse mit dem Namen verfügen, die im Formular definiert ist. Dieses Beispiel erfordert auch, dass Sie einen <xref:System.Windows.Forms.TextBox> haben <xref:System.Windows.Forms.PictureBox> und zu einem Formular hinzugefügt haben <xref:System.Windows.Forms.Control.ContextMenu%2A> und dass die-Eigenschaft dieser Steuer `contextMenu1`Elemente auf festgelegt ist.  
  
 [!code-cpp[Classic ContextMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ContextMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ContextMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ContextMenu Example/CS/source.cs#1)]
 [!code-vb[Classic ContextMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ContextMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
