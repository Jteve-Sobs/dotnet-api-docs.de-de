<Type Name="IDataGridViewEditingControl" FullName="System.Windows.Forms.IDataGridViewEditingControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6713fc76335689e7aea18d9afe82df69c288e158" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30648694" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDataGridViewEditingControl" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDataGridViewEditingControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.IDataGridViewEditingControl" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDataGridViewEditingControl" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDataGridViewEditingControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Definiert gemeinsame Funktionen für Steuerelemente, die sich innerhalb von Zellen einer <see cref="T:System.Windows.Forms.DataGridView" /> befinden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Schnittstelle wird von allen Steuerelementen, implementiert, wie z. B. <xref:System.Windows.Forms.DataGridViewComboBoxEditingControl> und <xref:System.Windows.Forms.DataGridViewTextBoxEditingControl>, die mit entsprechenden gehostet werden <xref:System.Windows.Forms.DataGridView> Zellen, wie z. B. <xref:System.Windows.Forms.DataGridViewComboBoxCell> und <xref:System.Windows.Forms.DataGridViewTextBoxCell>, wenn sie im Bearbeitungsmodus befinden.  
  
 Zelle Typen, die Bearbeitung Steuerelementsatz zu hosten, können ihre <xref:System.Windows.Forms.DataGridViewCell.EditType%2A> Eigenschaft, um eine <xref:System.Type> darstellt, die Bearbeitung Steuerelementtyp. Wenn die Zelle den Bearbeitungsmodus wechselt, werden die folgenden Schritte ausgeführt:  
  
1.  Die <xref:System.Windows.Forms.DataGridView> Steuerelement erstellt eine Instanz der Typ des Bearbeitungssteuerelements.  
  
2.  Die <xref:System.Windows.Forms.DataGridView> Steuerelement ruft die Zelle <xref:System.Windows.Forms.DataGridViewCell.InitializeEditingControl%2A> Methode. Sie können diese Methode zum Übertragen von des Zellenwert in das Bearbeitungssteuerelement überschreiben.  
  
3.  Die <xref:System.Windows.Forms.DataGridView> Steuerelement ruft Bearbeitungssteuerelements <xref:System.Windows.Forms.IDataGridViewEditingControl.ApplyCellStyleToEditingControl%2A> -Methode auf und übergibt den aktuellen Zellstil. Sie können diese Methode, um die Darstellung des Bearbeitungssteuerelements zu initialisieren, sodass es die Darstellung der Zelle entspricht implementieren.  
  
4.  Die <xref:System.Windows.Forms.DataGridView> Steuerelement ruft Bearbeitungssteuerelements <xref:System.Windows.Forms.IDataGridViewEditingControl.PrepareEditingControlForEdit%2A> Methode. Sie können diese Methode, um die endgültige anpassen, um das Bearbeitungssteuerelement, z. B. den Steuerelementwert auswählen implementieren.  
  
 Weitere Informationen zur Implementierung <xref:System.Windows.Forms.IDataGridViewEditingControl>, finden Sie unter [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 Datentypen, z. B. Zelle <xref:System.Windows.Forms.DataGridViewCheckBoxCell> zur Ausgabe synthetisch einer Benutzeroberfläche (UI) für das Angeben von Werten ohne hosting ein Bearbeitungssteuerelement enthalten, implementieren die <xref:System.Windows.Forms.IDataGridViewEditingCell> Schnittstelle. In diesem Fall wird die Benutzeroberfläche angezeigt, unabhängig davon, ob die Zelle im Bearbeitungsmodus befindet.  
  
 Andere Zelle Typen, z. B. <xref:System.Windows.Forms.DataGridViewButtonCell>, stellen eine Benutzeroberfläche bereit, speichern jedoch keine benutzerdefinierten Werte. In diesem Fall der Zellentyp implementiert nicht <xref:System.Windows.Forms.IDataGridViewEditingCell> oder einem Bearbeitungssteuerelement hosten.  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Implementierung dieser Schnittstelle, die abgeleitet <xref:System.Windows.Forms.DateTimePicker>. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#300](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#300)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#300](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#300)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.DataGridViewCell" />
    <altmember cref="T:System.Windows.Forms.IDataGridViewEditingCell" />
    <altmember cref="T:System.Windows.Forms.DataGridViewComboBoxCell" />
    <altmember cref="T:System.Windows.Forms.DataGridViewComboBoxEditingControl" />
    <altmember cref="T:System.Windows.Forms.DataGridViewTextBoxCell" />
    <altmember cref="P:System.Windows.Forms.DataGridViewCell.EditType" />
    <altmember cref="T:System.Windows.Forms.DataGridViewTextBoxEditingControl" />
  </Docs>
  <Members>
    <Member MemberName="ApplyCellStyleToEditingControl">
      <MemberSignature Language="C#" Value="public void ApplyCellStyleToEditingControl (System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyCellStyleToEditingControl(class System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.IDataGridViewEditingControl.ApplyCellStyleToEditingControl(System.Windows.Forms.DataGridViewCellStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyCellStyleToEditingControl(System::Windows::Forms::DataGridViewCellStyle ^ dataGridViewCellStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataGridViewCellStyle" Type="System.Windows.Forms.DataGridViewCellStyle" />
      </Parameters>
      <Docs>
        <param name="dataGridViewCellStyle">Der als Vorlage für die Benutzeroberfläche zu verwendende <see cref="T:System.Windows.Forms.DataGridViewCellStyle" />.</param>
        <summary>Ändert die Benutzeroberfläche des Steuerelements so, dass dieses dem angegebenen Zellenstil entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel wird eine Implementierung dieser Methode Benutzeroberflächenautomatisierungs-Eigenschaften für das Bearbeitungssteuerelement, wie z. B. Schriftart und Hintergrundfarbe, Vordergrundfarbe, legen Sie mit den Werten der entsprechenden Eigenschaften in der `dataGridViewCellStyle`, also den Stil der Zelle hostet die -Steuerelement.  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Implementierung dieses Elements. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#303](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#303)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#303](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#303)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewCellStyle" />
      </Docs>
    </Member>
    <Member MemberName="EditingControlDataGridView">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridView EditingControlDataGridView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.DataGridView EditingControlDataGridView" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlDataGridView" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingControlDataGridView As DataGridView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridView ^ EditingControlDataGridView { System::Windows::Forms::DataGridView ^ get(); void set(System::Windows::Forms::DataGridView ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.Forms.DataGridView" /> ab, die die Zelle enthält, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Windows.Forms.DataGridView" /> mit der <see cref="T:System.Windows.Forms.DataGridViewCell" />, die bearbeitet wird. <see langword="null" />, wenn keine zugeordnete <see cref="T:System.Windows.Forms.DataGridView" /> vorhanden ist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="EditingControlFormattedValue">
      <MemberSignature Language="C#" Value="public object EditingControlFormattedValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object EditingControlFormattedValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlFormattedValue" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingControlFormattedValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ EditingControlFormattedValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den formatierten Wert der Zelle ab, die im Editor geändert wird, oder legt diesen Wert fest.</summary>
        <value>Ein <see cref="T:System.Object" />, das den formatierten Wert der Zelle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der formatierte Wert stellt den Wert dar, wie er in der Benutzeroberfläche des Steuerelements angezeigt wird. Der formatierte Wert kann in absoluten Werts und auch des Datentyps von den tatsächlichen Wert, der im Steuerelement enthaltenen unterscheiden.  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Implementierung dieses Elements. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#301](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#301)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#301](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#301)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="M:System.Windows.Forms.IDataGridViewEditingControl.GetEditingControlFormattedValue(System.Windows.Forms.DataGridViewDataErrorContexts)" />
        <altmember cref="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlValueChanged" />
      </Docs>
    </Member>
    <Member MemberName="EditingControlRowIndex">
      <MemberSignature Language="C#" Value="public int EditingControlRowIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditingControlRowIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlRowIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingControlRowIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EditingControlRowIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index der übergeordneten Zeile der besitzenden Zelle ab oder legt den Index fest.</summary>
        <value>Der Index der Zeile, die die Zelle enthält, oder -1, wenn keine übergeordnete Zeile vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.IDataGridViewEditingControl> Schnittstelle definiert keine entsprechende `ColumnIndex` Eigenschaft. Können Sie die <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlDataGridView%2A> Eigenschaft, für das übergeordnete Element abgerufen <xref:System.Windows.Forms.DataGridView> steuern und verwenden Sie die <xref:System.Windows.Forms.DataGridView.CurrentCellAddress%2A?displayProperty=nameWithType> -Eigenschaft können Sie die Zeilen- und Spaltenindizes der aktiven Zelle zu bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.DataGridViewRow" />
        <altmember cref="P:System.Windows.Forms.DataGridViewCell.RowIndex" />
      </Docs>
    </Member>
    <Member MemberName="EditingControlValueChanged">
      <MemberSignature Language="C#" Value="public bool EditingControlValueChanged { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EditingControlValueChanged" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlValueChanged" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingControlValueChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EditingControlValueChanged { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich der Wert des Bearbeitungssteuerelements vom Wert der übergeordneten Zelle unterscheidet.</summary>
        <value>
          <see langword="true" />, wenn sich der Wert des Steuerelements vom Zellenwert unterscheidet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlValueChanged%2A> -Eigenschaftensatz auf `true` um anzugeben, dass sich die Hostzelle Status hat sich geändert und seine Benutzeroberfläche (UI) muss aktualisiert werden, damit diese Änderung in Werten angezeigt. Die besitzende Zelle bzw. Tabelle wird diese Eigenschaft auf zurückgesetzt `false` nach einem Update.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zurückgeben von <see langword="true" /> in der Implementierung dieser Eigenschaft wird nicht automatisch geändert den angezeigten Wert. Wenn der Wert in das Bearbeitungssteuerelement ändert, müssen benachrichtigt der <see cref="T:System.Windows.Forms.DataGridView" /> der Änderung durch übergeben <see langword="true" /> auf die <see cref="M:System.Windows.Forms.DataGridView.NotifyCurrentCellDirty(System.Boolean)" /> Methode.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlFormattedValue" />
        <altmember cref="M:System.Windows.Forms.IDataGridViewEditingControl.GetEditingControlFormattedValue(System.Windows.Forms.DataGridViewDataErrorContexts)" />
      </Docs>
    </Member>
    <Member MemberName="EditingControlWantsInputKey">
      <MemberSignature Language="C#" Value="public bool EditingControlWantsInputKey (System.Windows.Forms.Keys keyData, bool dataGridViewWantsInputKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EditingControlWantsInputKey(valuetype System.Windows.Forms.Keys keyData, bool dataGridViewWantsInputKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.IDataGridViewEditingControl.EditingControlWantsInputKey(System.Windows.Forms.Keys,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function EditingControlWantsInputKey (keyData As Keys, dataGridViewWantsInputKey As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EditingControlWantsInputKey(System::Windows::Forms::Keys keyData, bool dataGridViewWantsInputKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
        <Parameter Name="dataGridViewWantsInputKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="keyData">Eine Instanz von <see cref="T:System.Windows.Forms.Keys" />, die die gedrückte Taste darstellt.</param>
        <param name="dataGridViewWantsInputKey">
          <see langword="true" />, wenn <see cref="T:System.Windows.Forms.DataGridView" /> die <see cref="T:System.Windows.Forms.Keys" /> in <c>keyData</c> verarbeiten soll, andernfalls <see langword="false" />.</param>
        <summary>Bestimmt, ob es sich bei der angegebenen Taste um eine normale Eingabetaste handelt, die durch das Bearbeitungssteuerelement verarbeitet werden soll, oder ob es sich um eine besondere Taste handelt, die durch die <see cref="T:System.Windows.Forms.DataGridView" /> verarbeitet werden soll.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Taste eine normale Eingabetaste ist, die durch das Bearbeitungssteuerelement behandelt werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einem Bearbeitungssteuerelement implementiert diese Methode, um zu bestimmen, welche Eingabetasten vom Steuerelement verarbeitet werden sollen und welche Eingabetasten sollte verarbeitet werden, durch die <xref:System.Windows.Forms.DataGridView>.  
  
 Die <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlWantsInputKey%2A> Methode wird aufgerufen, indem Sie die <xref:System.Windows.Forms.DataGridView>. Die <xref:System.Windows.Forms.DataGridView> übergeben wird `true` für `dataGridViewWantsInputKey` können beim Verarbeiten der `keyData`. Wenn das Bearbeitungssteuerelement lassen die <xref:System.Windows.Forms.DataGridView> behandeln die `keyData`, <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlWantsInputKey%2A> zurückgeben sollte `false` beim `dataGridViewWantsInputKey` ist `true`. Andere Implementierungen von <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlWantsInputKey%2A> kann ignoriert werden, eine `dataGridViewWantsInputKey` Wert `true` und behandeln die `keyData` in das Bearbeitungssteuerelement.  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Implementierung dieses Elements. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#305](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#305)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#305](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#305)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="EditingPanelCursor">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Cursor EditingPanelCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor EditingPanelCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.EditingPanelCursor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditingPanelCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Cursor ^ EditingPanelCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab, der verwendet wird, wenn sich der Mauszeiger über dem <see cref="P:System.Windows.Forms.DataGridView.EditingPanel" />, jedoch nicht über dem Bearbeitungssteuerelement befindet.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Cursor" />, der den für den Bearbeitungsbereich verwendeten Mauszeiger darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bereich "Bearbeiten" wird die <xref:System.Windows.Forms.Panel> , dass die Hosts die Bearbeitung steuern, wann die <xref:System.Windows.Forms.DataGridView> -Steuerelement befindet sich im Bearbeitungsmodus befindet. Das eigentliche Bearbeitungssteuerelement decken möglicherweise nicht den gesamten Clientbereich des Bearbeitungsbereichs. In diesem Fall die <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingPanelCursor%2A> Implementierung sollte zurückgeben den Cursor zu verwenden, wenn der Mauszeiger über dem Bereich, aber nicht über dem Steuerelement befindet. In der Regel sollten Sie den gleichen Cursor zurück, den vom Steuerelement verwendet. Wenn Sie möchten den Cursor zu ändern, die angezeigt wird, wenn der Mauszeiger über dem Steuerelement befindet, müssen Sie festlegen der <xref:System.Windows.Forms.Control.Cursor%2A> Eigenschaft. Können Sie festlegen, in den Konstruktor des der <xref:System.Windows.Forms.IDataGridViewEditingControl> -Implementierung, oder Sie können es in Festlegen der <xref:System.Windows.Forms.IDataGridViewEditingControl.PrepareEditingControlForEdit%2A> Implementierung.  
  
   
  
## Examples  
 Das folgende Codebeispiel stellt eine Implementierung dieses Elements. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [wie: Hosten-Steuerelementen in Windows Forms-DataGridView-Zellen](~/docs/framework/winforms/controls/how-to-host-controls-in-windows-forms-datagridview-cells.md).  
  
 [!code-csharp[System.Windows.Forms.DataGridViewCalendarColumn#311](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/CS/datagridviewcalendarcolumn.cs#311)]
 [!code-vb[System.Windows.Forms.DataGridViewCalendarColumn#311](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataGridViewCalendarColumn/VB/datagridviewcalendarcolumn.vb#311)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="T:System.Windows.Forms.Panel" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="M:System.Windows.Forms.IDataGridViewEditingControl.PrepareEditingControlForEdit(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetEditingControlFormattedValue">
      <MemberSignature Language="C#" Value="public object GetEditingControlFormattedValue (System.Windows.Forms.DataGridViewDataErrorContexts context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetEditingControlFormattedValue(valuetype System.Windows.Forms.DataGridViewDataErrorContexts context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.IDataGridViewEditingControl.GetEditingControlFormattedValue(System.Windows.Forms.DataGridViewDataErrorContexts)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEditingControlFormattedValue (context As DataGridViewDataErrorContexts) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetEditingControlFormattedValue(System::Windows::Forms::DataGridViewDataErrorContexts context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.DataGridViewDataErrorContexts" />
      </Parameters>
      <Docs>
        <param name="context">Eine bitweise Kombination von <see cref="T:System.Windows.Forms.DataGridViewDataErrorContexts" />-Werten, die den Kontext angibt, in dem die Daten benötigt werden.</param>
        <summary>Ruft den formatierten Wert der Zelle ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das die formatierte Version des Zelleninhalts darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der formatierte Wert stellt den Wert dar, wie er in der Benutzeroberfläche des Steuerelements angezeigt wird. Der formatierte Wert kann in absoluten Werts und auch des Datentyps von den tatsächlichen Wert, der im Steuerelement enthaltenen unterscheiden.  
  
 Verwenden Sie zum Festlegen des formatierten Wert des Steuerelements die <xref:System.Windows.Forms.IDataGridViewEditingControl.EditingControlFormattedValue%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ändern den Rückgabewert in der Implementierung dieser Methode wird den angezeigten Wert nicht automatisch geändert. Wenn der Wert in das Bearbeitungssteuerelement ändert, müssen benachrichtigt der <see cref="T:System.Windows.Forms.DataGridView" /> der Änderung durch übergeben <see langword="true" /> auf die <see cref="M:System.Windows.Forms.DataGridView.NotifyCurrentCellDirty(System.Boolean)" /> Methode.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
        <altmember cref="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlFormattedValue" />
        <altmember cref="P:System.Windows.Forms.IDataGridViewEditingControl.EditingControlValueChanged" />
      </Docs>
    </Member>
    <Member MemberName="PrepareEditingControlForEdit">
      <MemberSignature Language="C#" Value="public void PrepareEditingControlForEdit (bool selectAll);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PrepareEditingControlForEdit(bool selectAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.IDataGridViewEditingControl.PrepareEditingControlForEdit(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrepareEditingControlForEdit (selectAll As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PrepareEditingControlForEdit(bool selectAll);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="selectAll">
          <see langword="true" />, um den gesamten Inhalt der Zelle auszuwählen, andernfalls <see langword="false" />.</param>
        <summary>Bereitet die derzeit ausgewählte Zelle für die Bearbeitung vor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zweck dieser Methode werden das Steuerelement und dessen Inhalt für die Bearbeitung vorzubereiten. Sie möchten z. B. die Einfügemarke an das Ende des Inhalts put "oder" ändern, wie der Textinhalt ausgerichtet wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
    <Member MemberName="RepositionEditingControlOnValueChange">
      <MemberSignature Language="C#" Value="public bool RepositionEditingControlOnValueChange { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RepositionEditingControlOnValueChange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.IDataGridViewEditingControl.RepositionEditingControlOnValueChange" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RepositionEditingControlOnValueChange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RepositionEditingControlOnValueChange { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zellinhalt bei jeder Änderung des Werts neu positioniert werden muss, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn der Inhalt neu positioniert werden muss, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Situationen erfordern, dass der Zelleninhalt neu positionieren, wenn der Wert ändert. Beispielsweise müssen Zelleninhalt möglicherweise neu positionieren, wenn eine Zelle Text umbrochen wird und der Inhalt größer wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridView" />
      </Docs>
    </Member>
  </Members>
</Type>