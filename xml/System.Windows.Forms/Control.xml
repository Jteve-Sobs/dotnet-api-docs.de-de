<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4f10e7c79ce94d8b4ac6eef68bb3788ff4069811" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72401848" /></Metadata><TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert die Basisklasse für Steuerelemente. Steuerelemente sind Komponenten mit visueller Darstellung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine eigene Steuerelement Klasse zu erstellen, erben Sie von den Klassen <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> oder von anderen Windows Forms bereitgestellten Steuerelementen. Weitere Informationen zum Erstellen benutzerdefinierter Steuerelemente finden Sie unter [entwickeln von benutzerdefinierten Windows Forms-Steuerelementen mit dem .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 Die Klasse <xref:System.Windows.Forms.Control> implementiert eine sehr grundlegende Funktionalität, die von Klassen benötigt wird, die dem Benutzerinformationen anzeigen. Benutzereingaben werden über die Tastatur und die Zeigegeräte verarbeitet. Er verarbeitet das Nachrichten Routing und die Sicherheit. Sie definiert die Begrenzungen eines-Steuer Elements (seine Position und Größe), obwohl es kein zeichnen implementiert. Sie stellt ein Fenster Handle (`hWnd`) bereit.  
  
 Windows Forms Steuerelemente verwenden Ambient-Eigenschaften, damit untergeordnete Steuerelemente wie Ihre umgebende Umgebung aussehen können. Eine *Ambient-Eigenschaft* ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Wenn das Steuerelement keine <xref:System.Windows.Forms.Control.Parent%2A> hat und die-Eigenschaft nicht festgelegt ist, versucht das-Steuerelement, den Wert der Ambient-Eigenschaft über die <xref:System.Windows.Forms.Control.Site%2A>-Eigenschaft zu bestimmen. Wenn das Steuerelement nicht positioniert ist, die Site keine Umgebungs Eigenschaften unterstützt oder wenn die-Eigenschaft nicht auf dem <xref:System.Windows.Forms.AmbientProperties> festgelegt ist, verwendet das Steuerelement seine eigenen Standardwerte. In der Regel stellt eine Ambient-Eigenschaft ein Merkmal eines Steuer Elements dar, z. b. <xref:System.Windows.Forms.Control.BackColor%2A>, das an ein untergeordnetes Steuerelement übermittelt wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Zu den Umgebungs Eigenschaften, die von der <xref:System.Windows.Forms.Control>-Klasse bereitgestellt werden, gehören: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A> und <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die <xref:System.Windows.Forms.FlatStyle>-Eigenschaft auf `System` festgelegt ist, und fügen Sie ein Manifest mit der ausführbaren Datei ein, damit Ihre Windows Forms Anwendung visuelle Stile unterstützt. Ein Manifest ist eine XML-Datei, die entweder als Ressource in der ausführbaren Datei der Anwendung oder als separate Datei enthalten ist, die sich im selben Verzeichnis wie die ausführbare Datei befindet. Ein Beispiel für ein Manifest finden Sie im Beispiel Abschnitt der <xref:System.Windows.Forms.FlatStyle>-Enumeration. Weitere Informationen zur Verwendung von visuellen Stilen finden Sie unter [visuelle Stile](https://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Forms verfügt über Barrierefreiheits Unterstützung und bietet Informationen zu Ihrer Anwendung, die es Ihnen ermöglicht, mit Client Anwendungen für die Barrierefreiheit, wie z. b. Bildschirm-und reviewerdienstprogramme, Spracheingabe-Hilfsprogramme, Tastatur auf dem Bildschirm, zu arbeiten. Alternative Eingabegeräte und Hilfsprogramme für die Tastatur Erweiterung. In manchen Fällen möchten Sie den Client Anwendungen für Barrierefreiheit zusätzliche Informationen bereitstellen. Es gibt zwei Möglichkeiten, diese zusätzlichen Informationen bereitzustellen. Sie können die Eigenschaftswerte "<xref:System.Windows.Forms.Control.AccessibleName%2A>", "<xref:System.Windows.Forms.Control.AccessibleDescription%2A>", "<xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>" und "<xref:System.Windows.Forms.Control.AccessibleRole%2A>" festlegen, die an Client Anwendungen für die Barrierefreiheit gemeldet werden. Diese Methode wird normalerweise verwendet, um eingeschränkte Barrierefreiheits Informationen für vorhandene Steuerelemente bereitzustellen. Alternativ dazu können Sie auch eine eigene Klasse schreiben, die von den Klassen <xref:System.Windows.Forms.AccessibleObject> oder <xref:System.Windows.Forms.Control.ControlAccessibleObject> abgeleitet wird, sodass Sie so viele Informationen zur Barrierefreiheit bereitstellen, wie Sie benötigen.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, legen Sie die Größe eines-Steuer Elements im Konstruktor nicht fest. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft zu überschreiben.  
  
> [!NOTE]
>  Fügen Sie keine Daten Bindungen für eine <xref:System.Windows.Forms.Control> im Konstruktor hinzu. Dies führt zu Fehlern bei der Codegenerierung und kann zu unerwünschtem Verhalten führen.  
  
 Die Mehrzahl der Steuerelemente im <xref:System.Windows.Forms>-Namespace verwenden das zugrunde liegende allgemeine Windows-Steuerelement als Basis für die Erstellung auf. Weitere Informationen zu den allgemeinen Windows-Steuerelementen finden Sie unter [Allgemeine Steuerungs Referenz](https://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Um Windows Forms Steuerelemente aus einem separaten Prozess zu identifizieren, verwenden Sie einen standardmäßigen `SendMessage`-Befehl, um die WM_GETCONTROLNAME-Nachricht zu übergeben. WM_GETCONTROLNAME ist unabhängig von der Sprache und der Windows-Hierarchie. Weitere Informationen finden Sie im Thema "empfohlene Lösung für Windows Forms" unter[Automating Windows Forms](https://msdn.microsoft.com/library/ms996405.aspx).  
  
 Verwenden Sie die <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft, um den Zugriff auf das-Steuerelement aus mehreren Threads zu synchronisieren. Weitere Informationen zu Multithread-Windows Forms Steuerelementen finden Sie unter [gewusst wie: Thread sichere Aufrufe an Windows Forms Steuerelemente erstellen](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die folgenden Member sind Thread sicher: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" /> und <see cref="M:System.Windows.Forms.Control.CreateGraphics" />, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit Standardeinstellungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control>-Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms Anwendung verwendet werden. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der-Klasse verwendet wird, wird dieser Konstruktor normalerweise nicht direkt aufgerufen, sondern von einer abgeleiteten Klasse aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit bestimmtem Text.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control>-Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms Anwendung verwendet werden. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der-Klasse verwendet wird, wird dieser Konstruktor normalerweise nicht direkt aufgerufen, sondern von einer abgeleiteten Klasse aufgerufen.  
  
 Mit dieser Version des <xref:System.Windows.Forms.Control.%23ctor%2A>-Konstruktors wird der anfängliche <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert auf den `text`-Parameterwert festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">Das <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element des Steuerelements sein soll.</param>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse als untergeordnetes Steuerelement mit bestimmtem Text.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control>-Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms Anwendung verwendet werden. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der-Klasse verwendet wird, wird dieser Konstruktor normalerweise nicht direkt aufgerufen, sondern von einer abgeleiteten Klasse aufgerufen.  
  
 Mit dieser Version des <xref:System.Windows.Forms.Control.%23ctor%2A>-Konstruktors wird der anfängliche <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert auf den `text`-Parameterwert festgelegt. Der Konstruktor fügt das Steuerelement auch dem <xref:System.Windows.Forms.Control.ControlCollection> des übergeordneten Steuer Elements hinzu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <param name="left">Die <see cref="P:System.Drawing.Point.X" />-Position des Steuerelements in Pixel vom linken Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaft zugewiesen.</param>
        <param name="top">Die <see cref="P:System.Drawing.Point.Y" />-Position des Steuerelements in Pixel vom oberen Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaft zugewiesen.</param>
        <param name="width">Die Breite des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaft zugewiesen.</param>
        <param name="height">Die Höhe des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaft zugewiesen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse mit bestimmtem Text, bestimmter Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control>-Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms Anwendung verwendet werden. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der-Klasse verwendet wird, wird dieser Konstruktor normalerweise nicht direkt aufgerufen, sondern von einer abgeleiteten Klasse aufgerufen.  
  
 Mit dieser Version des <xref:System.Windows.Forms.Control.%23ctor%2A>-Konstruktors wird der anfängliche <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert auf den `text`-Parameterwert festgelegt. Die anfänglichen <xref:System.Windows.Forms.Control.Size%2A> und <xref:System.Windows.Forms.Control.Location%2A> des Steuer Elements werden durch die Parameterwerte `left`, `top`, `width` und `height` bestimmt.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, legen Sie die Größe eines-Steuer Elements im Konstruktor nicht fest. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft zu überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Das <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element des Steuerelements sein soll.</param>
        <param name="text">Der vom Steuerelement angezeigte Text.</param>
        <param name="left">Die <see cref="P:System.Drawing.Point.X" />-Position des Steuerelements in Pixel vom linken Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaft zugewiesen.</param>
        <param name="top">Die <see cref="P:System.Drawing.Point.Y" />-Position des Steuerelements in Pixel vom oberen Rand des Containers des Steuerelements. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaft zugewiesen.</param>
        <param name="width">Die Breite des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaft zugewiesen.</param>
        <param name="height">Die Höhe des Steuerelements in Pixel. Der Wert wird der <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaft zugewiesen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Control" />-Klasse als untergeordnetes Steuerelement mit bestimmtem Text, bestimmter Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control>-Klasse ist die Basisklasse für alle Steuerelemente, die in einer Windows Forms Anwendung verwendet werden. Da diese Klasse in der Regel nicht zum Erstellen einer Instanz der-Klasse verwendet wird, wird dieser Konstruktor normalerweise nicht direkt aufgerufen, sondern von einer abgeleiteten Klasse aufgerufen.  
  
 Mit dieser Version des <xref:System.Windows.Forms.Control.%23ctor%2A>-Konstruktors wird der anfängliche <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert auf den `text`-Parameterwert festgelegt. Der Konstruktor fügt das Steuerelement auch dem <xref:System.Windows.Forms.Control.ControlCollection> des übergeordneten Steuer Elements hinzu. Die anfänglichen <xref:System.Windows.Forms.Control.Size%2A> und <xref:System.Windows.Forms.Control.Location%2A> des Steuer Elements werden durch die Parameterwerte `left`, `top`, `width` und `height` bestimmt.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, legen Sie die Größe eines-Steuer Elements im Konstruktor nicht fest. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft zu überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Benachrichtigt Clientanwendungen für die Barrierefreiheit über <see cref="T:System.Windows.Forms.AccessibleEvents" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Die <see cref="T:System.Windows.Forms.AccessibleEvents" />-Enumeration, über die die Clientanwendungen für die Barrierefreiheit benachrichtigt werden sollen.</param>
        <param name="childID">Das untergeordnete <see cref="T:System.Windows.Forms.Control" />, das über das barrierefreie Ereignis benachrichtigt werden soll.</param>
        <summary>Benachrichtigt die Clientanwendungen für die Barrierefreiheit über die angegebenen <see cref="T:System.Windows.Forms.AccessibleEvents" /> für das angegebene untergeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen für jede <xref:System.Windows.Forms.AccessibleEvents>, über die Client Anwendungen für die Barrierefreiheit benachrichtigt werden sollen, die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType>-Methode abrufen. Die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>-Methode wird in der Regel aufgerufen, wenn eine Eigenschaft festgelegt wird oder innerhalb eines Ereignis Handlers. Beispielsweise können Sie die <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>-Methode aufzurufen und einen <xref:System.Windows.Forms.AccessibleEvents>-Wert von `Hide` von innerhalb des Ereignis Handlers für das <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType>-Ereignis übergeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Barrierefreiheits fähigen Diagramm Steuer Elements mithilfe der Klassen <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject>, um Barrierefreie Informationen verfügbar zu machen. Das-Steuerelement zeichnet zwei Kurven zusammen mit einer Legende. Die `ChartControlAccessibleObject`-Klasse, die von `ControlAccessibleObject` abgeleitet wird, wird in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode verwendet, um benutzerdefinierte Informationen für das Diagramm Steuerelement bereitzustellen. Da die Diagramm Legende kein tatsächliches <xref:System.Windows.Forms.Control>-basiertes Steuerelement ist, sondern stattdessen vom Diagramm Steuerelement gezeichnet wird, sind keine integrierten zugänglichen Informationen verfügbar. Aus diesem Grund überschreibt die `ChartControlAccessibleObject`-Klasse die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A>-Methode, um die `CurveLegendAccessibleObject` zurückzugeben, die barrierefreie Informationen für jeden Teil der Legende darstellt. Wenn eine barrierefreie Anwendung dieses Steuerelement verwendet, kann das Steuerelement die erforderlichen zugänglichen Informationen bereitstellen.  
  
 In diesem Code Ausschnitt wird das Aufrufen der <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A>-Methode veranschaulicht. Das gesamte Codebeispiel finden Sie in der Übersicht über <xref:System.Windows.Forms.AccessibleObject>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="objectID" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="childID" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="accEvent">Die <see cref="T:System.Windows.Forms.AccessibleEvents" />-Enumeration, über die die Clientanwendungen für die Barrierefreiheit benachrichtigt werden sollen.</param>
        <param name="objectID">Der Bezeichner von <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Das untergeordnete <see cref="T:System.Windows.Forms.Control" />, das über das barrierefreie Ereignis benachrichtigt werden soll.</param>
        <summary>Benachrichtigt die Clientanwendungen für die Barrierefreiheit über die angegebenen <see cref="T:System.Windows.Forms.AccessibleEvents" /> für das angegebene untergeordnete Steuerelement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das dem Steuerelement zugewiesene <see cref="T:System.Windows.Forms.AccessibleObject" /> ab.</summary>
        <value>Das dem Steuerelement zugewiesene <see cref="T:System.Windows.Forms.AccessibleObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie die <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode, um die von dieser Methode zurückgegebene Instanz zu steuern.  
  
 Wenn dem Steuerelement gerade kein <xref:System.Windows.Forms.AccessibleObject> zugewiesen ist, wird eine neue Instanz davon erstellt.  
  
> [!NOTE]
>  Um die <xref:System.Windows.Forms.Control.AccessibilityObject%2A>-Eigenschaft zu erhalten oder festzulegen, müssen Sie einen Verweis auf die mit [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] installierte Assembly `Accessibility` hinzufügen.  
  
 Weitere Informationen zu zugänglichen Objekten finden Sie unter [Active Accessibility](https://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardbeschreibung der Aktion des Steuerelements ab, das von Clientanwendungen für Barrierefreiheit verwendet wird, oder legt diese fest.</summary>
        <value>Die Beschreibung der Standardaktion des Steuerelements für die Verwendung durch Clientanwendungen für die Barrierefreiheit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>-Eigenschaft eines Objekts beschreibt die primäre Bearbeitungsmethode des Objekts aus der Sicht des Benutzers. Diese Eigenschaft sollte ein Verb oder ein kurzes Verb-Ausdruck sein.  
  
> [!NOTE]
>  Nicht alle Objekte haben Standard Aktionen, und einige Objekte verfügen möglicherweise über eine Standardaktion, die mit ihrer <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType>-Eigenschaft verknüpft ist, z. b. in den folgenden Beispielen:  
  
-   Ein ausgewähltes Kontrollkästchen hat die Standardaktion "uncheck" und den Wert "aktiviert".  
  
-   Ein gelöschtes Kontrollkästchen hat die Standardaktion "Check" und den Wert "deaktiviert".  
  
-   Eine Schaltfläche mit der Bezeichnung "Print" hat die Standardaktion "Press" ohne Wert.  
  
-   Eine Bezeichnung oder ein Textfeld-Steuerelement, das "Printer" anzeigt, hat keine Standardaktion, würde jedoch den Wert "Printer" aufweisen.  
  
 Weitere Informationen zu Eigenschaften von zugänglichen Objekten finden Sie unter [Inhalt von beschreibenden Eigenschaften](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements ab oder legt diese fest.</summary>
        <value>Die Beschreibung des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleDescription%2A>-Eigenschaft eines Objekts stellt eine Textbeschreibung zur visuellen Darstellung eines Objekts bereit. Die Beschreibung wird hauptsächlich verwendet, um einen größeren Kontext für Seh-oder Blind Benutzer bereitzustellen. Sie kann jedoch auch für die Kontextsuche oder andere Anwendungen verwendet werden.  
  
 Die <xref:System.Windows.Forms.Control.AccessibleDescription%2A>-Eigenschaft ist erforderlich, wenn die Beschreibung nicht offensichtlich ist, oder wenn Sie auf der Grundlage der <xref:System.Windows.Forms.Control.AccessibleName%2A>-, <xref:System.Windows.Forms.Control.AccessibleRole%2A>-, <xref:System.Windows.Forms.AccessibleObject.State%2A>-und <xref:System.Windows.Forms.AccessibleObject.Value%2A>-Eigenschaften des Objekts redundant ist. Eine Schaltfläche mit "OK" benötigt z. b. keine zusätzlichen Informationen, aber eine Schaltfläche, die ein Bild eines Kakteen anzeigt, wäre. Die Eigenschaften "<xref:System.Windows.Forms.Control.AccessibleName%2A>" und "<xref:System.Windows.Forms.Control.AccessibleRole%2A>" (und möglicherweise <xref:System.Windows.Forms.AccessibleObject.Help%2A>) für die "Kaktus"-Schaltfläche beschreiben den Zweck, aber die <xref:System.Windows.Forms.Control.AccessibleDescription%2A>-Eigenschaft würde weniger spürbare Informationen vermitteln, wie z. b. "eine Schaltfläche, die ein Bild eines Kaktus anzeigt."  
  
 Weitere Informationen zu Eigenschaften von zugänglichen Objekten finden Sie unter [Inhalt von beschreibenden Eigenschaften](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz einer abgeleiteten <xref:System.Windows.Forms.CheckBox>-Klasse erstellt, `MyCheckBox`, ihr eine <xref:System.Drawing.Image> der <xref:System.Windows.Forms.ButtonBase.Image%2A>-Eigenschaft zugewiesen und die <xref:System.Windows.Forms.Control.AccessibleName%2A>-und <xref:System.Windows.Forms.Control.AccessibleDescription%2A>-Eigenschaften festgelegt, da die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft `null` ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit dem Namen `MyForm` verfügen.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements ab oder legt diesen fest.</summary>
        <value>Der Name des von Clientanwendungen für die Barrierefreiheit verwendeten Steuerelements. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleName%2A>-Eigenschaft ist eine Bezeichnung, die das Objekt innerhalb des Containers kurz beschreibt und identifiziert, z. b. den Text in einem <xref:System.Windows.Forms.Button>, den Namen eines <xref:System.Windows.Forms.MenuItem> oder eine Bezeichnung neben einem <xref:System.Windows.Forms.TextBox>-Steuerelement.  
  
 Weitere Informationen zu Eigenschaften von zugänglichen Objekten finden Sie unter "[Inhalt von beschreibenden Eigenschaften](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz einer abgeleiteten <xref:System.Windows.Forms.CheckBox>-Klasse erstellt, `MyCheckBox`, ihr eine <xref:System.Drawing.Image> der <xref:System.Windows.Forms.ButtonBase.Image%2A>-Eigenschaft zugewiesen und die <xref:System.Windows.Forms.Control.AccessibleName%2A>-und <xref:System.Windows.Forms.Control.AccessibleDescription%2A>-Eigenschaften festgelegt, da die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft `null` ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit dem Namen `MyForm` verfügen.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die barrierefreie Rolle des Steuerelements ab oder legt diese fest.</summary>
        <value>Einer der Werte von <see cref="T:System.Windows.Forms.AccessibleRole" />. Die Standardeinstellung ist <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.AccessibleRole%2A>-Eigenschaft beschreibt, zu welcher Art von Benutzeroberflächenelement ein Objekt gehört. Wenn die Rolle des Steuerelements nicht bestimmt werden kann, wird die <xref:System.Windows.Forms.Control.AccessibleRole%2A>-Eigenschaft auf `Default` festgelegt.  
  
 Weitere Informationen zu Eigenschaften von zugänglichen Objekten finden Sie unter [Inhalt von beschreibenden Eigenschaften](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.AccessibleRole" />-Werte.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement Daten annehmen kann, die vom Benutzer darauf gezogen wurden, oder legt diesen fest.</summary>
        <value><see langword="true" /> , wenn Drag &amp;amp; Drop-Vorgänge für das Steuerelement zulässig sind, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel kann der Benutzer ein Bild oder eine Bilddatei auf das Formular ziehen und ihn an dem Punkt, an dem er abgelegt wird, anzeigen lassen. Die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode wird überschrieben, um jedes Mal, wenn das Formular gezeichnet wird, das Bild neu zu zeichnen. Andernfalls wird das Bild nur bis zum nächsten Neuzeichnen beibehalten. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragEnter> bestimmt den Typ der Daten, die in das Formular gezogen werden, und stellt das entsprechende Feedback bereit. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragDrop> zeigt das Bild auf dem Formular an, wenn ein <xref:System.Drawing.Image> aus den Daten erstellt werden kann. Da die Werte <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Bildschirm Koordinaten sind, wird im Beispiel die <xref:System.Windows.Forms.Control.PointToClient%2A>-Methode verwendet, um Sie in Client Koordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für den uneingeschränkten Zugriff auf die Zwischenablage, um diese Eigenschaft auf <see langword="true" /> festzulegen. Zugeordnete Enumeration: der <see langword="AllClipboard" />-Wert <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.AllowDrop" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.AllowDrop" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.AllowDrop" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ränder des Containers ab, an die ein Steuerelement gebunden ist, oder legt diese fest und bestimmt, wie die Größe des Steuerelements mit dessen übergeordnetem Element geändert wird.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.AnchorStyles" />-Werte. Der Standardwert ist <see langword="Top" /> und <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.Anchor%2A>-Eigenschaft, um zu definieren, wie die Größe eines Steuer Elements automatisch geändert wird, wenn dessen übergeordnetes Steuerelement geändert wird. Durch das Verankern eines Steuer Elements auf das übergeordnete Steuerelement wird sichergestellt, dass die verankerten Ränder in Bezug auf die Ränder des übergeordneten Steuer Elements beibehalten werden, wenn die Größe des übergeordneten Steuer Elements geändert wird.  
  
 Sie können ein Steuerelement an einem oder mehreren Rändern seines Containers verankern. Wenn Sie z. b. eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Button> haben, dessen <xref:System.Windows.Forms.Control.Anchor%2A>-Eigenschafts Wert auf `Top` und `Bottom` festgelegt ist, wird der <xref:System.Windows.Forms.Button> gestreckt, um die verankerte Entfernung zum oberen und unteren Rand des <xref:System.Windows.Forms.Form> beizubehalten, da die <xref:System.Windows.Forms.Control.Height%2A> der <xref:System.Windows.Forms.Form> erweitert wird.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Anchor%2A> und <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften schließen sich gegenseitig. Es kann jeweils nur eine festgelegt werden, und der letzte Satz hat Vorrang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.Button> zu einem Formular hinzugefügt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird die Schaltfläche in der unteren rechten Ecke des Formulars verankert, sodass die relative Position bei der Größenänderung des Formulars beibehalten wird. Anschließend wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt und die Größe der Schaltfläche auf die gleiche Größe wie die <xref:System.Drawing.Image> festgelegt. Im Beispiel wird dann der <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` festgelegt, und die Eigenschaft <xref:System.Windows.Forms.Control.TabIndex%2A> wird festgelegt. Schließlich fügt Sie einen Ereignishandler hinzu, der das <xref:System.Windows.Forms.Control.Click>-Ereignis der Schaltfläche behandelt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Anchor" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Anchor" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.Anchor" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft in <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" /> ab oder legt anhand dessen fest, in welcher Richtung der Bildlauf dieses Steuerelements durchgeführt wird.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der die Bildlaufposition angibt. Der Standardwert ist die linke obere Ecke des Steuerelements.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist für diese Klasse nicht relevant.</summary>
        <value>Im aktivierten Zustand <see langword="true" />, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dieses Ereignis ist für diese Klasse nicht relevant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hintergrundfarbe für das Steuerelement ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Color" />, die die Hintergrundfarbe des Steuerelements darstellt. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.BackColor%2A>-Eigenschaft unterstützt keine transparenten Farben, es sei denn, der `SupportsTransparentBackColor`-Wert von <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> ist auf `true` festgelegt.  
  
 Die <xref:System.Windows.Forms.Control.BackColor%2A>-Eigenschaft ist eine Ambient-Eigenschaft. Eine Ambient-Eigenschaft ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Weitere Informationen zu Ambient-Eigenschaften finden Sie in der <xref:System.Windows.Forms.AmbientProperties>-Klasse oder in der Übersicht über die <xref:System.Windows.Forms.Control>-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der-Steuerelemente auf die Standardsystem Farben festgelegt. Der Code ruft rekursiv selbst auf, wenn das Steuerelement über untergeordnete Steuerelemente verfügt. Für dieses Codebeispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement verfügen. ein untergeordnetes Container Steuerelement, wie z. b. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelement (en) würde jedoch die Rekursion besser veranschaulichen.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BackColor%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das im Steuerelement angezeigte Hintergrundbild ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Image" />, das das im Hintergrund des Steuerelements anzuzeigende Bild darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Verwenden Sie die <xref:System.Windows.Forms.Control.BackgroundImage%2A>-Eigenschaft, um ein Grafik Bild auf einem Steuerelement zu platzieren.  
  
> [!NOTE]
>  Bilder mit durchlässigen oder transparenten Farben werden von Windows Forms Steuerelementen nicht als Hintergrundbilder unterstützt.  
>   
>  Diese Eigenschaft wird für untergeordnete Steuerelemente, deren <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>-Eigenschaft `true` ist, nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.Button> zu einem Formular hinzugefügt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird die Schaltfläche in der unteren rechten Ecke des Formulars verankert, sodass die relative Position bei der Größenänderung des Formulars beibehalten wird. Anschließend wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt und die Größe der Schaltfläche auf die gleiche Größe wie die <xref:System.Drawing.Image> festgelegt. Im Beispiel wird dann der <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` festgelegt, und die Eigenschaft <xref:System.Windows.Forms.Control.TabIndex%2A> wird festgelegt. Schließlich fügt Sie einen Ereignishandler hinzu, der das <xref:System.Windows.Forms.Control.Click>-Ereignis der Schaltfläche behandelt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BackgroundImage%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welches Hintergrundbildlayout gemäß der Definition in der <see cref="T:System.Windows.Forms.ImageLayout" />-Enumeration verwendet wird.</summary>
        <value>Einer der Werte von <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> oder <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). Der Standardwert lautet <see cref="F:System.Windows.Forms.ImageLayout.Tile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>-Eigenschaft, um die Position und das Verhalten eines Bilds anzugeben, das Sie auf einem Steuerelement abgelegt haben. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> wird nur wirksam, wenn die Eigenschaft <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt ist.  
  
 Sie können die Leistung für große Images erhöhen, wenn Sie <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> auf einen anderen Wert als <xref:System.Windows.Forms.ImageLayout.Tile> festlegen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der angegebene Enumerationswert ist nicht vorhanden.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn sich die <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>-Eigenschaft entweder Programm gesteuert oder durch Benutzerinteraktion ändert.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen Delegaten asynchron für den Thread aus, in dem das dem Steuerelement zugrunde liegende Handle erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die keine Parameter annimmt.</param>
        <summary>Führt den angegebenen Delegaten asynchron für den Thread aus, in dem das dem Steuerelement zugrunde liegende Handle erstellt wurde.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das das Ergebnis der <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />-Operation darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat wird asynchron aufgerufen, und diese Methode wird sofort zurückgegeben. Sie können diese Methode von einem beliebigen Thread aus, auch dem Thread, der das Handle des Steuer Elements besitzt, abrufen. Wenn das Handle des Steuer Elements noch nicht vorhanden ist, durchsucht diese Methode die übergeordnete Kette des Steuer Elements, bis ein Steuerelement oder ein Formular gefunden wird, das über ein Fenster Handle verfügt. Wenn kein entsprechendes Handle gefunden werden kann, löst <xref:System.Windows.Forms.Control.BeginInvoke%2A> eine Ausnahme aus. Ausnahmen innerhalb der Delegatmethode gelten als nicht erfasst und werden an den nicht in die Anwendung eingelösten Ausnahmehandler der Anwendung gesendet.  
  
 Sie können <xref:System.Windows.Forms.Control.EndInvoke%2A> aufrufen, um den Rückgabewert aus dem Delegaten abzurufen, sofern dies nicht erforderlich ist. <xref:System.Windows.Forms.Control.EndInvoke%2A> wird blockiert, bis der Rückgabewert abgerufen werden kann.  
  
> [!NOTE]
>  Die meisten Methoden für ein Steuerelement können nur von dem Thread aufgerufen werden, in dem das Steuerelement erstellt wurde. Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen. Die Aufruf Methoden rufen immer Ihre Rückrufe im Thread des Steuer Elements auf.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht verarbeiten soll, nicht mehr aktiv ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Windows.Forms.Control.BeginInvoke%2A>-Methode veranschaulicht.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kein entsprechendes Fensterhandle wird gefunden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, args As Object()) As IAsyncResult" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat einer Methode, der Parameter derselben Anzahl und desselben Typs der im <paramref name="args" />-Parameter enthaltenen Parameter annimmt.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Dies kann <see langword="null" /> sein, wenn keine Argumente benötigt werden.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten für den Thread aus, in dem das diesem Steuerelement zugrunde liegende Handle erstellt wurde.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das das Ergebnis der <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />-Operation darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat wird asynchron aufgerufen, und diese Methode wird sofort zurückgegeben. Sie können diese Methode von einem beliebigen Thread aus, auch dem Thread, der das Handle des Steuer Elements besitzt, abrufen. Wenn das Handle des Steuer Elements noch nicht vorhanden ist, durchsucht diese Methode die übergeordnete Kette des Steuer Elements, bis ein Steuerelement oder ein Formular gefunden wird, das über ein Fenster Handle verfügt. Wenn kein entsprechendes Handle gefunden werden kann, löst <xref:System.Windows.Forms.Control.BeginInvoke%2A> eine Ausnahme aus. Ausnahmen innerhalb der Delegatmethode gelten als nicht erfasst und werden an den nicht in die Anwendung eingelösten Ausnahmehandler der Anwendung gesendet.  
  
 Sie können <xref:System.Windows.Forms.Control.EndInvoke%2A> aufrufen, um den Rückgabewert aus dem Delegaten abzurufen, sofern dies nicht erforderlich ist. <xref:System.Windows.Forms.Control.EndInvoke%2A> wird blockiert, bis der Rückgabewert abgerufen werden kann.  
  
> [!NOTE]
>  Die meisten Methoden für ein Steuerelement können nur von dem Thread aufgerufen werden, in dem das Steuerelement erstellt wurde. Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen. Die Aufruf Methoden rufen immer Ihre Rückrufe im Thread des Steuer Elements auf.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht verarbeiten soll, nicht mehr aktiv ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Windows.Forms.Control.BeginInvoke%2A>-Methode veranschaulicht.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kein entsprechendes Fensterhandle wird gefunden.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.BindingContext" /> für das Steuerelement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.BindingContext> einer <xref:System.Windows.Forms.Control> wird verwendet, um eine einzelne <xref:System.Windows.Forms.BindingManagerBase> für alle Daten gebundenen Steuerelemente zurückzugeben, die im <xref:System.Windows.Forms.Control> enthalten sind. Mit dem <xref:System.Windows.Forms.BindingManagerBase> werden alle Steuerelemente, die an dieselbe Datenquelle gebunden sind, synchronisiert. Wenn Sie z. b. die <xref:System.Windows.Forms.BindingManagerBase.Position%2A>-Eigenschaft des <xref:System.Windows.Forms.BindingManagerBase> festlegen, wird das Element in der zugrunde liegenden Liste angegeben, auf das alle Daten gebundenen Steuerelemente zeigen.  
  
 Weitere Informationen zum Erstellen einer neuen <xref:System.Windows.Forms.BindingContext> und zum Zuweisen der Eigenschaft <xref:System.Windows.Forms.Control.BindingContext%2A> finden Sie unter <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden vier <xref:System.Windows.Forms.Binding>-Objekte erstellt, um fünf Steuerelemente, ein <xref:System.Windows.Forms.DateTimePicker>-und vier <xref:System.Windows.Forms.TextBox>-Steuerelemente, an mehrere Datenquellen zu binden. Der <xref:System.Windows.Forms.BindingContext> wird dann verwendet, um die <xref:System.Windows.Forms.BindingManagerBase> für jede Datenquelle zu erhalten.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.BindingContext" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.BindingContext" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.BindingContext" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="T:System.Windows.Forms.BindingContext" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zum Hinzufügen eines neuen <xref:System.Windows.Forms.BindingContext> zur <xref:System.Windows.Forms.Control> über die <xref:System.Windows.Forms.Control.BindingContext%2A>-Eigenschaft finden Sie unter dem <xref:System.Windows.Forms.BindingContext.%23ctor%2A>-Konstruktor.  
  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.BindingContext%2A>-Eigenschaft geändert wird, indem entweder eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.EventHandler>-Delegat zum <xref:System.Windows.Forms.Control.BindingContextChanged>-Ereignis eines <xref:System.Windows.Forms.TextBox>-Steuer Elements hinzugefügt.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft entspricht der Summe des <xref:System.Windows.Forms.Control.Top%2A>-Eigenschafts Werts und des <xref:System.Windows.Forms.Control.Height%2A>-Eigenschafts Werts.  
  
 Die <xref:System.Windows.Forms.Control.Bottom%2A>-Eigenschaft ist eine schreibgeschützte Eigenschaft. Sie können diesen Eigenschafts Wert ändern, indem Sie den Wert der <xref:System.Windows.Forms.Control.Top%2A>-oder <xref:System.Windows.Forms.Control.Height%2A>-Eigenschaften ändern oder die <xref:System.Windows.Forms.Control.SetBounds%2A>-, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>-, <xref:System.Windows.Forms.Control.UpdateBounds%2A>-oder <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>-Methode aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.Bottom%2A>-Eigenschaft verwendet, um die untere Grenze eines <xref:System.Windows.Forms.TextBox>-Steuer Elements relativ zum Client Bereich des Containers zu definieren.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe und die Position des Steuerelements, einschließlich seiner Nicht-Clientelemente, in Pixel relativ zum übergeordneten Steuerelement ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" /> in Pixel relativ to zum übergeordneten Steuerelement, das die Größe und Position des Steuerelements darstellt, einschließlich seiner Nicht-Clientelemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Begrenzungen des Steuer Elements umfassen die nicht-Client Elemente wie Scrollleisten, Rahmen, Titelleisten und Menüs. Die <xref:System.Windows.Forms.Control.SetBoundsCore%2A>-Methode wird aufgerufen, um die <xref:System.Windows.Forms.Control.Bounds%2A>-Eigenschaft festzulegen. Die <xref:System.Windows.Forms.Control.Bounds%2A>-Eigenschaft wird nicht immer durch ihre `set`-Methode geändert, daher sollten Sie die <xref:System.Windows.Forms.Control.SetBoundsCore%2A>-Methode überschreiben, um sicherzustellen, dass der Code ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.Bounds%2A>-Eigenschaft festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt dieses Steuerelement am Anfang der z-Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement wird an den Anfang der z-Reihenfolge verschoben. Wenn das Steuerelement ein untergeordnetes Element eines anderen Steuer Elements ist, wird das untergeordnete Steuerelement an den Anfang der z-Reihenfolge verschoben. <xref:System.Windows.Forms.Control.BringToFront%2A> macht kein Steuerelement zu einem Steuerelement der obersten Ebene, und es wird kein <xref:System.Windows.Forms.Control.Paint>-Ereignis erhoben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird sichergestellt, dass ein <xref:System.Windows.Forms.Label> sichtbar ist, indem seine <xref:System.Windows.Forms.Control.BringToFront%2A>-Methode aufgerufen wird. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Panel> mit dem Namen `panel1` und ein <xref:System.Windows.Forms.Label> mit dem Namen `label1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft auf einen aktiven Wert festgelegt werden kann, um IME-Unterstützung zu aktivieren.</summary>
        <value><see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können diese Eigenschaft überschreiben, um `false` zurückzugeben, wenn IME nicht unterstützt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement den Fokus erhalten kann.</summary>
        <value><see langword="true" />, wenn das Steuerelement den Fokus erhalten kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit ein Steuerelement den Eingabefokus erhalten kann, muss dem Steuerelement ein Handle zugewiesen sein, und die Eigenschaften <xref:System.Windows.Forms.Control.Visible%2A> und <xref:System.Windows.Forms.Control.Enabled%2A> müssen sowohl für das Steuerelement als auch für alle übergeordneten Steuerelemente auf `true` festgelegt werden, und das Steuerelement muss ein Formular oder das äußerste par-Element des Steuer Elements sein. der Ent muss ein Formular sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Fokus auf das angegebene <xref:System.Windows.Forms.Control> festgelegt, wenn es den Fokus erhalten kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt fest, ob Ereignisse für das Steuerelement ausgelöst werden können.</summary>
        <value><see langword="true" />, wenn das Steuerelement als ActiveX-Steuerelement gehostet wird, dessen Ereignisse nicht eingefroren sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Steuerelement als ActiveX-Steuerelement gehostet wird, gibt diese Eigenschaft `false` zurück, wenn das ActiveX-Steuerelement seine Ereignisse eingefroren hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement ausgewählt werden kann.</summary>
        <value><see langword="true" />, wenn das Steuerelement ausgewählt werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` zurück, wenn der `Selectable`-Wert von <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> auf `true` festgelegt ist, in einem anderen Steuerelement enthalten ist, das Steuerelement selbst sichtbar und aktiviert ist und alle übergeordneten Steuerelemente sichtbar und aktiviert sind.  
  
 Die Windows Forms-Steuerelemente in der folgenden Liste sind nicht auswählbar und geben den Wert `false` für die Eigenschaft <xref:System.Windows.Forms.Control.CanSelect%2A> zurück. Von diesen Steuerelementen abgeleitete Steuerelemente sind ebenfalls nicht auswählbar.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (wenn im-Steuerelement kein Link vorhanden ist)  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene <xref:System.Windows.Forms.Control> ausgewählt, wenn er auswählbar ist.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Maus vom Steuerelement erfasst wurde, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Maus vom Steuerelement erfasst wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Steuerelement die Maus erfasst hat, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet. Die Maus wird in der Regel nur bei Zieh Vorgängen aufgezeichnet.  
  
 Nur im Vordergrund Fenster kann die Maus erfasst werden. Wenn ein Hintergrund Fenster versucht, empfängt das Fenster nur Meldungen für Mausereignisse, die auftreten, wenn sich der Mauszeiger innerhalb des sichtbaren Teils des Fensters befindet. Auch wenn das Vordergrund Fenster die Maus erfasst hat, kann der Benutzer weiterhin auf ein anderes Fenster klicken, um ihn in den Vordergrund zu bringen.  
  
 Wenn die Maus aufgezeichnet wird, sollten die Tastenkombinationen nicht funktionieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.Capture%2A>-Eigenschaft veranschaulicht. Um dieses Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine <xref:System.Windows.Forms.Label> mit dem Namen Label1 und zwei <xref:System.Windows.Forms.ListBox>-Steuerelemente mit den Namen ListBox1 und listbox2 enthält. Stellen Sie sicher, dass das Formular und das <xref:System.Windows.Forms.Control.MouseDown>-Ereignis mit der-Methode in diesem Beispiel verknüpft ist.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschafts Wert festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement bei Erhalt des Fokus eine Validierung für alle eine Validierung erfordernden Steuerelemente veranlasst, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Steuerelement eine Validierung für alle eine Validierung erfordernden Steuerelemente veranlasst, wenn es den Fokus erhält, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
 Der <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschafts Wert wird in der Regel auf `false` für Steuerelemente festgelegt, z. b. eine Schaltfläche  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete-Klasse <xref:System.Windows.Forms.TextBox> verwendet und eine vom Benutzer eingegebene e-Mail-Adresse überprüft. Wenn die e-Mail-Adresse nicht im Standardformat vorliegt (was "@" and "" enthält), schlägt die Validierung fehl, ein Symbol "<xref:System.Windows.Forms.ErrorProvider>" wird angezeigt, und das Ereignis wird abgebrochen. Für eine der Schaltflächen im Formular ist die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt. Durch Klicken oder Festlegen des Fokus auf diese Schaltfläche wird keine Validierung auslöst. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.TextBox>, ein <xref:System.Windows.Forms.ErrorProvider>-Steuerelement und ein <xref:System.Windows.Forms.Button> in einem Formular erstellt wurden.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.CausesValidation" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Hinweise auf den Fokus oder die Tastatur-Benutzeroberfläche ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.ChangeUICues>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.ChangeUICues> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob Aufrufe an den falschen Thread, der auf die <see cref="P:System.Windows.Forms.Control.Handle" />-Eigenschaft eines Steuerelements zugreift, abgefangen werden sollen, wenn eine Anwendung gedebuggt wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn Aufrufe an den falschen Thread abgefangen werden sollen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein anderer Thread als der erstellenden Thread eines Steuer Elements versucht, auf eine der Methoden oder Eigenschaften dieses Steuer Elements zuzugreifen, führt dies häufig zu unvorhersehbaren Ergebnissen. Eine häufige Ungültige Thread Aktivität ist ein-Rückruf für den falschen Thread, der auf die <xref:System.Windows.Forms.Control.Handle%2A>-Eigenschaft des Steuer Elements zugreift. Legen Sie <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> auf `true` fest, um diese Thread Aktivität beim Debuggen leichter zu finden und zu diagnostizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Klicken auf das Steuerelement ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.Click>-Ereignis übergibt ein <xref:System.EventArgs> an seinen Ereignishandler, sodass es nur angibt, dass ein Klick aufgetreten ist. Wenn Sie spezifischere Maus Informationen benötigen (Schaltfläche, Anzahl der Klicks, Rad Drehung oder Speicherort), verwenden Sie das Ereignis <xref:System.Windows.Forms.Control.MouseClick>. Das Ereignis "<xref:System.Windows.Forms.Control.MouseClick>" wird jedoch nicht ausgelöst, wenn der Klick durch eine andere Aktion als die der Maus verursacht wird, z. b. durch Drücken der EINGABETASTE.  
  
 Ein Doppelklick wird durch die Mauseinstellungen des Betriebssystems des Benutzers bestimmt. Der Benutzer kann den Zeitraum festlegen, innerhalb dessen der zweite Mausklick erfolgen muss, damit zwei aufeinander folgende Mausklicks als Doppelklick erkannt werden. Das <xref:System.Windows.Forms.Control.Click>-Ereignis wird jedes Mal ausgelöst, wenn auf ein Steuerelement Doppel geklickt wird. Wenn Sie z. b. über Ereignishandler für die <xref:System.Windows.Forms.Control.Click>-und <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse einer <xref:System.Windows.Forms.Form> verfügen, werden die <xref:System.Windows.Forms.Control.Click>-und <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse ausgelöst, wenn auf das Formular Doppel geklickt wird und beide Methoden aufgerufen werden. Wenn auf ein Steuerelement Doppel geklickt wird und dieses Steuerelement das <xref:System.Windows.Forms.Control.DoubleClick>-Ereignis nicht unterstützt, wird das <xref:System.Windows.Forms.Control.Click>-Ereignis möglicherweise zweimal ausgelöst.  
  
 Sie müssen den `StandardClick`-Wert <xref:System.Windows.Forms.ControlStyles> auf `true` festlegen, damit dieses Ereignis ausgelöst wird.  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
## <a name="notes-to-inheritors"></a>Hinweise für Vererber

Das Erben von einem Standard Windows Forms-Steuerelement und das Ändern der `StandardClick`-oder `StandardDoubleClick`-Werte von <xref:System.Windows.Forms.ControlStyles> in `true` kann ein unerwartetes Verhalten verursachen oder keinerlei Auswirkungen haben, wenn das Steuerelement die <xref:System.Windows.Forms.Control.Click>-oder <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse nicht unterstützt.
  
In der folgenden Tabelle sind Windows Forms Steuerelemente und das Ereignis (<xref:System.Windows.Forms.Control.Click> oder <xref:System.Windows.Forms.Control.DoubleClick>) als Antwort auf die angegebene Maus Aktion aufgeführt.

| Steuerelement | Linker Mausklick | Doppelklick mit der linken Maustaste | Mit der rechten Maustaste | Doppelklick mit der rechten Maustaste | Mittlere Maustaste | Mittlere Maustaste Doppelklick | XButton1 mit Mausklick | XButton1 Maustaste doppelklicken | XButton2 mit Mausklick | XButton2 Maustaste doppelklicken | 
| ------- | ---------------- | ----------------------- | ----------------- | ------------------------ | ------------------ | ------------------------- | -------------------- | --------------------------- | -------------------- | --------------------------- |
| <xref:System.Windows.Forms.MonthCalendar>, <xref:System.Windows.Forms.DateTimePicker>, <xref:System.Windows.Forms.HScrollBar>, <xref:System.Windows.Forms.VScrollBar> | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine |
| <xref:System.Windows.Forms.Button>, <xref:System.Windows.Forms.CheckBox>, <xref:System.Windows.Forms.RichTextBox>, <xref:System.Windows.Forms.RadioButton> | Klicken | Klicken Sie auf. | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine |
| <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.CheckedListBox>, <xref:System.Windows.Forms.ComboBox> | Klicken | Click, DoubleClick | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine |
| <xref:System.Windows.Forms.TextBox>, <xref:System.Windows.Forms.DomainUpDown>, <xref:System.Windows.Forms.NumericUpDown> | Klicken | Click, DoubleClick | Keine | Keine | Keine | Keine | Keine | Keine | Keine | Keine |
| \* <xref:System.Windows.Forms.TreeView>, \* <xref:System.Windows.Forms.ListView> | Klicken | Click, DoubleClick | Klicken | Click, DoubleClick | Keine | Keine | Keine | Keine | Keine | Keine |
| <xref:System.Windows.Forms.ProgressBar>, <xref:System.Windows.Forms.TrackBar> | Klicken | Klicken Sie auf. | Klicken | Klicken Sie auf. | Klicken | Klicken Sie auf. | Klicken | Klicken Sie auf. | Klicken | Klicken Sie auf. |
| <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.LinkLabel>, <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.PictureBox>, <xref:System.Windows.Forms.Splitter>, <xref:System.Windows.Forms.StatusBar>, <xref:System.Windows.Forms.ToolBar>, <xref:System.Windows.Forms.TabPage>, \*\* <xref:System.Windows.Forms.TabControl> | Klicken | Click, DoubleClick | Klicken | Click, DoubleClick | Klicken | Click, DoubleClick | Klicken | Click, DoubleClick | Klicken | Click, DoubleClick |

\* muss sich der Mauszeiger über einem untergeordneten Objekt befinden (<xref:System.Windows.Forms.TreeNode> oder <xref:System.Windows.Forms.ListViewItem>).  
  
 * * Die <xref:System.Windows.Forms.TabControl> muss in der <xref:System.Windows.Forms.TabControl.TabPages>-Auflistung mindestens einen <xref:System.Windows.Forms.TabPage> aufweisen.

## Examples  
 Das folgende Codebeispiel zeigt das <xref:System.Windows.Forms.Control.Click>-Ereignis in einem Ereignishandler.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Rechteck ab, das den Clientbereich des Steuerelements darstellt.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das den Clientbereich des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Client Bereich eines Steuer Elements ist die Begrenzungen des Steuer Elements, abzüglich der nicht-Client Elemente wie Scrollleisten, Rahmen, Titelleisten und Menüs.  
  
 Da Client Koordinaten relativ zur oberen linken Ecke des Client Bereichs des Steuer Elements sind, sind die Koordinaten der oberen linken Ecke des Rechtecks, das von dieser Eigenschaft zurückgegeben wird, (0,0). Sie können diese Eigenschaft verwenden, um die Größe und die Koordinaten des Client Bereichs des Steuer Elements für Aufgaben wie z. b. das Zeichnen auf der Oberfläche des Steuer Elements abzurufen.  
  
 Weitere Informationen zum Zeichnen von Steuerelementen finden Sie unter [Rendering eines Windows Forms-Steuer](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)Elements.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der automatische Bildlauf für ein Formular aktiviert, die Größe des Formulars geändert und sichergestellt, dass eine Schaltfläche sichtbar bleibt, nachdem die Größe des Formulars geändert wurde. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Button> mit dem Namen `button2` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe und Breite des Clientbereichs des Steuerelements ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Size" />, das die Abmessungen des Clientbereichs des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Client Bereich eines Steuer Elements ist die Begrenzungen des Steuer Elements, abzüglich der nicht-Client Elemente wie Scrollleisten, Rahmen, Titelleisten und Menüs. Die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>-Methode wird aufgerufen, um die <xref:System.Windows.Forms.Control.ClientSize%2A>-Eigenschaft festzulegen. Die <xref:System.Windows.Forms.Control.ClientSize%2A>-Eigenschaft wird nicht immer durch ihre `set`-Methode geändert, daher sollten Sie die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>-Methode überschreiben, um sicherzustellen, dass der Code ausgeführt wird, wenn die <xref:System.Windows.Forms.Control.ClientSize%2A>-Eigenschaft festgelegt ist.  
  
 Die Eigenschaften "<xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType>" und "<xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType>" stellen die Breite und Höhe des Client Bereichs des Steuer Elements dar. Mit dieser Eigenschaft können Sie die Größe des Client Bereichs des Steuer Elements für Aufgaben wie z. b. das Zeichnen auf der Oberfläche des Steuer Elements abrufen.  
  
 Weitere Informationen zum Zeichnen von Steuerelementen finden Sie unter [Rendering eines Windows Forms-Steuer](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)Elements.  
  
> [!NOTE]
>  Die Anwendungseinstellungen können nicht an diese Eigenschaft gebunden werden. Weitere Informationen zu Anwendungseinstellungen finden Sie unter [Übersicht über Anwendungseinstellungen](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Größe des angegebenen Steuer Elements geändert, sodass das Steuerelement seinen formatierten Text aufnehmen kann. Der formatierte Text ist die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft, der das Steuerelement zugewiesen wurde, <xref:System.Windows.Forms.Control.Font%2A> auf den Text angewendet wird. Die `AutoSizeControl`-Methode in diesem Beispiel verfügt auch über einen `textPadding`-Parameter, der die Auffüll Zeichen darstellt, die auf alle Ränder des Steuer Elements angewendet werden sollen. Damit die Auffüll Zeichen gleich sind, richten Sie den Text mit dem <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType>-Wert ein, wenn das Steuerelement ihn unterstützt.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ClientSize" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.ClientSizeChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.ClientSizeChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Unternehmens oder des Entwicklers der Anwendung ab, die das Steuerelement enthält.</summary>
        <value>Der Name des Unternehmens oder des Entwicklers der Anwendung, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CompanyName%2A>-Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft zu ändern, legen Sie den <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A>-Eigenschafts Wert von <xref:System.Reflection.AssemblyCompanyAttribute> fest. Mit C# der folgenden Codezeile wird die <xref:System.Windows.Forms.Control.CompanyName%2A>-Eigenschaft festgelegt.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, dass Sie den Namen des Unternehmens, den Produktnamen und die Produktversion für Ihre APP angeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> angezeigt, das in einer <xref:System.Windows.Forms.Form> enthalten ist. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">Der auszuwertende <see cref="T:System.Windows.Forms.Control" />.</param>
        <summary>Ruft einen Wert ab, der angibt, ob das angegebene Steuerelement dem Steuerelement untergeordnet ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Steuerelement dem Steuerelement untergeordnet ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird sichergestellt, dass ein <xref:System.Windows.Forms.Label> sichtbar ist, indem seine <xref:System.Windows.Forms.Control.BringToFront%2A>-Methode aufgerufen wird. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Panel> mit dem Namen `panel1` und ein <xref:System.Windows.Forms.Label> mit dem Namen `label1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement oder eines der untergeordneten Steuerelemente den Eingabefokus besitzt.</summary>
        <value><see langword="true" />, wenn das Steuerelement oder eines der untergeordneten Steuerelemente den Eingabefokus besitzt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um zu bestimmen, ob ein Steuerelement oder eines der darin enthaltenen Steuerelemente den Eingabefokus besitzt. Um zu bestimmen, ob das Steuerelement den Fokus besitzt, verwenden Sie die <xref:System.Windows.Forms.Control.Focused%2A>-Eigenschaft, unabhängig davon, ob eines der untergeordneten Steuerelemente den Fokus besitzt. Um einem Steuerelement den Eingabefokus zu geben, verwenden Sie die Methoden <xref:System.Windows.Forms.Control.Focus%2A> oder <xref:System.Windows.Forms.Control.Select%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das dem Steuerelement zugeordnete Kontextmenü ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.ContextMenu" />, das das diesem Steuerelement zugeordnete Kontextmenü darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie ein Kontextmenü, um Benutzern kontextspezifische Menü Optionen zur Verfügung zu stellen, wenn Sie mit der rechten Maustaste auf das Steuerelement klicken.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.ContextMenu> angezeigt, die einem <xref:System.Windows.Forms.TreeView> zugewiesen ist, wenn mit der rechten Maustaste geklickt und Sie freigegeben wird. Für diesen Code ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einer <xref:System.Windows.Forms.TreeView> verfügen. Außerdem ist es erforderlich, dass dem <xref:System.Windows.Forms.TreeView> eine <xref:System.Windows.Forms.ContextMenu> der <xref:System.Windows.Forms.Control.ContextMenu%2A>-Eigenschaft zugewiesen ist.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.ContextMenu" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.ContextMenu" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.ContextMenu" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ContextMenu" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ContextMenu%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Meldung angezeigt, wenn eine Änderung im Kontextmenü auftritt.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die diesem Steuerelement zugeordnete <see cref="T:System.Windows.Forms.ContextMenuStrip" />-Klasse ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Windows.Forms.ContextMenuStrip" /> für dieses Steuerelement, oder <see langword="null" />, wenn keine <see cref="T:System.Windows.Forms.ContextMenuStrip" /> vorhanden ist. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dem Steuerelement auch eine <xref:System.Windows.Forms.ContextMenu> zugewiesen wurde, hat die <xref:System.Windows.Forms.ContextMenu> Vorrang vor <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einer <xref:System.Windows.Forms.ContextMenuStrip> drei <xref:System.Windows.Forms.ToolStripMenuItem>-Objekte hinzugefügt werden. Außerdem wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.ContextMenuStrip%2A>-Eigenschaft des Formulars festgelegt wird.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.ContextMenuStripChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.ContextMenuStripChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Forms.Control.ControlCollection" /> ein neues Steuerelement hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Windows.Forms.Control.ControlAdded> verwendet, um ein-Steuerelement zu einem Formular hinzuzufügen, und der Name des hinzugefügten Steuer Elements wird in einem <xref:System.Windows.Forms.MessageBox> angezeigt.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Entfernen des Steuerelements aus der <see cref="T:System.Windows.Forms.Control.ControlCollection" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Windows.Forms.Control.ControlRemoved> verwendet, um ein-Steuerelement aus einem Formular zu entfernen, und der Name des entfernten Steuer Elements wird in einem <xref:System.Windows.Forms.MessageBox> angezeigt.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die im Steuerelement enthaltene Auflistung von Steuerelementen ab.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.Control.ControlCollection" />, die die Auflistung der im Steuerelement enthaltenen Steuerelemente darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Forms.Control> kann als übergeordnetes Element einer Auflistung von Steuerelementen fungieren. Wenn z. b. einer <xref:System.Windows.Forms.Form> mehrere Steuerelemente hinzugefügt werden, ist jedes der Steuerelemente ein Member des <xref:System.Windows.Forms.Control.ControlCollection>, das der <xref:System.Windows.Forms.Control.Controls%2A>-Eigenschaft des Formulars zugewiesen ist, das von der <xref:System.Windows.Forms.Control>-Klasse abgeleitet wird.  
  
 Mithilfe der in der <xref:System.Windows.Forms.Control.ControlCollection>-Klasse verfügbaren Methoden können Sie die Steuerelemente in der <xref:System.Windows.Forms.Control.ControlCollection> bearbeiten, die der <xref:System.Windows.Forms.Control.Controls%2A>-Eigenschaft zugewiesen ist.  
  
 Wenn Sie einem übergeordneten Steuerelement mehrere Steuerelemente hinzufügen, empfiehlt es sich, die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode vor dem Initialisieren der hinzu zufügenden Steuerelemente aufzurufen. Nachdem Sie dem übergeordneten Steuerelement die Steuerelemente hinzugefügt haben, können Sie die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode Dadurch wird die Leistung von Anwendungen mit vielen Steuerelementen erhöht.  
  
 Verwenden Sie die <xref:System.Windows.Forms.Control.Controls%2A>-Eigenschaft, um alle Steuerelemente eines Formulars zu durchlaufen, einschließlich der-Steuerelemente. Verwenden Sie die <xref:System.Windows.Forms.Control.GetNextControl%2A>-Methode zum Abrufen des vorherigen oder nächsten untergeordneten Steuer Elements in der Aktivier Reihenfolge. Verwenden Sie die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>-Eigenschaft, um das aktive Steuerelement eines Container Steuer Elements zu erhalten oder festzulegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.Control> aus der <xref:System.Windows.Forms.Control.ControlCollection> der abgeleiteten Klasse <xref:System.Windows.Forms.Panel> entfernt, wenn Sie ein Member der Auflistung ist. Für das Beispiel ist es erforderlich, dass Sie ein <xref:System.Windows.Forms.Panel>, ein <xref:System.Windows.Forms.Button> und mindestens ein <xref:System.Windows.Forms.RadioButton>-Steuerelement auf einem <xref:System.Windows.Forms.Form> erstellt haben. Das <xref:System.Windows.Forms.RadioButton>-Steuerelement (e) wird dem <xref:System.Windows.Forms.Panel>-Steuerelement hinzugefügt, und das <xref:System.Windows.Forms.Panel>-Steuerelement wird dem <xref:System.Windows.Forms.Form> hinzugefügt. Wenn auf die Schaltfläche geklickt wird, wird das Optionsfeld mit dem Namen `removeButton` aus der <xref:System.Windows.Forms.Control.ControlCollection> entfernt.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues Objekt für die Barrierefreiheit für das Steuerelement.</summary>
        <returns>Ein neues <see cref="T:System.Windows.Forms.AccessibleObject" /> für das Steuerelement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode nicht explizit aufrufen, wird sie beim Verweis auf die <xref:System.Windows.Forms.Control.AccessibilityObject%2A>-Eigenschaft aufgerufen.  
  
> [!NOTE]
>  Um die <xref:System.Windows.Forms.Control.AccessibilityObject%2A>-Eigenschaft zu erhalten oder festzulegen, müssen Sie einen Verweis auf die `Accessibility`-Assembly hinzufügen, die mit dem [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] installiert wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Barrierefreiheits fähigen Diagramm Steuer Elements mithilfe der Klassen <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject>, um Barrierefreie Informationen verfügbar zu machen. Das-Steuerelement zeichnet zwei Kurven zusammen mit einer Legende. Die `ChartControlAccessibleObject`-Klasse, die von `ControlAccessibleObject` abgeleitet wird, wird in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode verwendet, um benutzerdefinierte Informationen für das Diagramm Steuerelement bereitzustellen. Da die Diagramm Legende kein tatsächliches <xref:System.Windows.Forms.Control>-basiertes Steuerelement ist, sondern stattdessen vom Diagramm Steuerelement gezeichnet wird, sind keine integrierten zugänglichen Informationen verfügbar. Aus diesem Grund überschreibt die `ChartControlAccessibleObject`-Klasse die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A>-Methode, um die `CurveLegendAccessibleObject` zurückzugeben, die barrierefreie Informationen für jeden Teil der Legende darstellt. Wenn eine barrierefreie Anwendung dieses Steuerelement verwendet, kann das Steuerelement die erforderlichen zugänglichen Informationen bereitstellen.  
  
 Dieser Code Ausschnitt veranschaulicht das Überschreiben der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode. Das gesamte Codebeispiel finden Sie in der Übersicht über <xref:System.Windows.Forms.AccessibleObject>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />-Methode der Basisklasse nicht aufzurufen.</para></block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt das Erstellen des sichtbaren Steuerelements, einschließlich des Handles und aller sichtbaren untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CreateControl%2A>-Methode erzwingt, dass ein Handle für das Steuerelement und seine untergeordneten Steuerelemente erstellt wird. Diese Methode wird verwendet, wenn Sie ein Handle direkt für die Bearbeitung des Steuer Elements oder seiner untergeordneten Elemente benötigen. Wenn Sie einfach den Konstruktor eines Steuer Elements aufrufen, wird der <xref:System.Windows.Forms.Control.Handle%2A> nicht erstellt.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> erstellt kein Steuerelement handle, wenn die <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft des Steuer Elements `false` ist. Sie können entweder die <xref:System.Windows.Forms.Control.CreateHandle%2A>-Methode aufrufen oder auf die Eigenschaft <xref:System.Windows.Forms.Control.Handle%2A> zugreifen, um das Handle des Steuer Elements unabhängig von der Sichtbarkeit des Steuer Elements zu erstellen. in diesem Fall werden jedoch keine Fenster Handles für die untergeordneten Elemente des Steuer Elements erstellt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der Steuerelementauflistung für das Steuerelement.</summary>
        <returns>Eine neue Instanz der dem Steuerelement zugewiesenen <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Die Basisklassen Version dieser Methode sollte nicht von einer abgeleiteten Klasse aufgerufen werden.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement erstellt wurde.</summary>
        <value><see langword="true" />, wenn das Steuerelement erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Created%2A>-Eigenschaft gibt `true` zurück, wenn die <xref:System.Windows.Forms.Control> erfolgreich erstellt wurde, auch wenn das Handle des Steuer Elements noch nicht erstellt oder neu erstellt wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die <see cref="T:System.Drawing.Graphics" /> für das Steuerelement.</summary>
        <returns>Das <see cref="T:System.Drawing.Graphics" /> für das Steuerelement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Drawing.Graphics>-Objekt, das Sie über die <xref:System.Windows.Forms.Control.CreateGraphics%2A>-Methode abrufen, sollte normalerweise nicht beibehalten werden, nachdem die aktuelle Windows-Nachricht verarbeitet wurde, da alle mit diesem Objekt gezeichneten Elemente mit der nächsten WM_PAINT-Nachricht gelöscht werden. Daher können Sie das <xref:System.Drawing.Graphics>-Objekt für die Wiederverwendung nicht zwischenspeichern, außer wenn Sie nicht visuelle Methoden wie <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType> verwenden. Stattdessen müssen Sie <xref:System.Windows.Forms.Control.CreateGraphics%2A> jedes Mal, wenn Sie das <xref:System.Drawing.Graphics>-Objekt verwenden möchten, und dann <xref:System.Drawing.Graphics.Dispose%2A> aufzurufen, wenn Sie es nicht mehr benötigen. Weitere Informationen zu Windows-Meldungen finden Sie unter <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateGraphics%2A> legt den Besitz auf den aufrufenden Thread fest und schlägt fehl, wenn er für andere Threads aufgerufen wird.  
  
> [!NOTE]
>  Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Größe des angegebenen Steuer Elements geändert, sodass das Steuerelement seinen formatierten Text aufnehmen kann. Der formatierte Text ist die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft, der das Steuerelement zugewiesen wurde, <xref:System.Windows.Forms.Control.Font%2A> auf den Text angewendet wird. Die `AutoSizeControl`-Methode in diesem Beispiel verfügt auch über einen `textPadding`-Parameter, der die Auffüll Zeichen darstellt, die auf alle Ränder des Steuer Elements angewendet werden sollen. Damit die Auffüll Zeichen gleich sind, richten Sie den Text mit dem `MiddleCenter`-Wert <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> ein, wenn das Steuerelement es unterstützt.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für sichere untergeordnete Fenster, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="SafeSubWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Handle für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten die <xref:System.Windows.Forms.Control.CreateHandle%2A>-Methode in der Regel nicht direkt aufzurufen. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.CreateControl%2A>-Methode aufzurufen, die erzwingt, dass ein Handle für das Steuerelement und dessen untergeordnete Steuerelemente erstellt wird, wenn das Steuerelement erstellt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt befindet sich in freigegebenem Zustand.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.CreateHandle" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.Control.CreateHandle" />-Methode der Basisklasse aufruft, um sicherzustellen, dass das Handle erstellt wird.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benötigten Erstellungsparameter ab, wenn das Steuerelementhandle erstellt wird.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.CreateParams" />-Eigenschaft, die die erforderlichen Erstellungsparameter enthält, wenn das Handle für das Steuerelement erstellt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.CreateParams%2A>-Eigenschaft sollte nicht überschrieben werden und verwendet werden, um die Eigenschaften des abgeleiteten Steuer Elements anzupassen. Eigenschaften wie "<xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>", "<xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>" und "<xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType>" sollten durch die entsprechenden Eigenschaften in Ihrem Steuerelement festgelegt werden, z. b. <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. Der <xref:System.Windows.Forms.CreateParams> sollte nur erweitert werden, wenn Sie eine standardmäßige Windows-Steuerelement Klasse umwickeln oder Stile festlegen, die nicht vom Windows Forms-Namespace bereitgestellt werden. Weitere Informationen zum Erstellen von Steuerelement Parametern finden Sie unter den Funktionen `CreateWindow` und `CreateWindowEx` sowie in der Dokumentation [zur Struktur der](https://msdn.microsoft.com/library/windows/desktop/ms632603.aspx) erstellungsstruktur.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.CreateParams%2A>-Eigenschaft einer abgeleiteten <xref:System.Windows.Forms.Button>-Klasse erweitert. Die <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType>-Eigenschaft wird geändert, was bewirkt, dass die Schaltfläche ein <xref:System.Drawing.Icon> anstelle eines <xref:System.Drawing.Image> anzeigt. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der <xref:System.Windows.Forms.Button>-Klasse erbt.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">, damit der unmittelbare Aufrufer beim Abrufen des Eigenschafts Werts nicht verwalteten Code aufruft. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.CreateParams" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.CreateParams" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen.</para></block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor ab, der angezeigt wird, wenn sich der Mauszeiger über dem Steuerelement befindet, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Cursor" />, der den Cursor darstellt, der angezeigt wird, wenn sich der Mauszeiger über dem Steuerelement befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weisen Sie der <xref:System.Windows.Forms.Control.Cursor%2A>-Eigenschaft des Steuer Elements einen <xref:System.Windows.Forms.Cursor> zu, um den Cursor zu ändern, der angezeigt wird, wenn sich der Mauszeiger über dem Steuerelement befindet. Legen Sie zum vorübergehenden Ändern des Mauszeigers für alle Steuerelemente in Ihrer Anwendung die <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>-Eigenschaft fest. Normalerweise würden Sie die <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>-Eigenschaft auf einen Warte Cursor festlegen, wenn Sie eine <xref:System.Windows.Forms.ComboBox> Auffüllen oder eine Datei speichern oder laden.  
  
 Die <xref:System.Windows.Forms.Control.Cursor%2A>-Eigenschaft ist eine Ambient-Eigenschaft. Eine Ambient-Eigenschaft ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Weitere Informationen zu Ambient-Eigenschaften finden Sie in der <xref:System.Windows.Forms.AmbientProperties>-Klasse oder in der Übersicht über die <xref:System.Windows.Forms.Control>-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.ComboBox> mit den verfügbaren logischen Laufwerken des Benutzers gefüllt. Im Beispiel wird auch die <xref:System.Windows.Forms.Cursor>-Eigenschaft des Kombinations Felds festgelegt, sodass der <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType>-Cursor angezeigt wird, wenn sich der Mauszeiger über der Dropdown Schaltfläche befindet. Für diesen Code ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einer <xref:System.Windows.Forms.ComboBox> verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für sichere Unterfenster, um diesen Eigenschafts Wert festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die Methoden <see langword="get" /> und <see langword="set" /> der <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Cursor%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Maus Cursor mithilfe der <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType>-Eigenschaft, der <xref:System.Windows.Forms.Cursor>-Klasse und der <xref:System.Windows.Forms.Cursors>-Klasse geändert wird. Im Beispiel wird ein Formular erstellt, das ein <xref:System.Windows.Forms.ComboBox>-Steuerelement, ein <xref:System.Windows.Forms.Panel>-Steuerelement und ein <xref:System.Windows.Forms.ListView>-Steuerelement enthält. Der <xref:System.Windows.Forms.ComboBox> enthält alle von der <xref:System.Windows.Forms.Cursors>-Klasse bereitgestellten Cursors. Wenn der Benutzer einen Mauszeiger im <xref:System.Windows.Forms.ComboBox> auswählt, wird die Eigenschaft <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> auf den ausgewählten Cursor festgelegt, der den Cursor für die <xref:System.Windows.Forms.Panel> aktualisiert. Der <xref:System.Windows.Forms.ListView> wird jedes Mal aktualisiert, wenn das <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType>-Ereignis auftritt.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenbindungen für das Steuerelement ab.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.ControlBindingsCollection" />, die die <see cref="T:System.Windows.Forms.Binding" />-Objekte für das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.DataBindings%2A>-Eigenschaft für den Zugriff auf <xref:System.Windows.Forms.ControlBindingsCollection>. Indem Sie der Auflistung <xref:System.Windows.Forms.Binding>-Objekte hinzufügen, können Sie jede Eigenschaft eines-Steuer Elements an die-Eigenschaft eines-Objekts binden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden der <xref:System.Windows.Forms.ControlBindingsCollection> von fünf Steuerelementen <xref:System.Windows.Forms.Binding>-Objekte hinzugefügt: vier <xref:System.Windows.Forms.TextBox>-Steuerelemente und ein <xref:System.Windows.Forms.DateTimePicker>-Steuerelement. Der Zugriff auf die <xref:System.Windows.Forms.ControlBindingsCollection> erfolgt über die <xref:System.Windows.Forms.Control.DataBindings%2A>-Eigenschaft der <xref:System.Windows.Forms.Control>-Klasse.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardhintergrundfarbe des Steuerelements ab.</summary>
        <value>Die Standardhintergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Die Standardeinstellung ist <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der standardmäßige <xref:System.Windows.Forms.Control.BackColor%2A>-Eigenschafts Wert eines generischen Steuer Elements auf oberster Ebene. Abgeleitete Klassen können unterschiedliche Standardwerte aufweisen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine <xref:System.Windows.Forms.ListBox> namens ListBox1 enthält. Ruft die `Populate_ListBox`-Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load>-Ereignis Behandlungsmethode auf.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardcursor für das Steuerelement ab oder legt ihn fest.</summary>
        <value>Ein Objekt vom Typ <see cref="T:System.Windows.Forms.Cursor" />, das den aktuellen Standardcursor darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie <xref:System.Windows.Forms.Control.DefaultCursor%2A>, um einen Standard Cursor für das Steuerelement zu konfigurieren. Dies ist effizienter als das Festlegen des Cursors im Konstruktor des Steuer Elements und ermöglicht die automatische Unterstützung bestimmter Cursor bezogener Designer Funktionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardschriftart des Steuerelements ab.</summary>
        <value>Die Standard-<see cref="T:System.Drawing.Font" /> des Steuerelements. Der zurückgegebene Wert variiert je nach Betriebssystem des Benutzers und lokaler Kultureinstellung des Systems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle wird der von <xref:System.Windows.Forms.Control.DefaultFont%2A> zurückgegebene Wert abhängig vom Betriebssystem und der lokalen Kultur beschrieben.  
  
|System/und oder Kultur|Schriftart|  
|----------------------------|----------|  
|Windows NT 4X, japanische Version|MS UI Gothic, 9 Point.|  
|Arabische Fenster|Tahoma, 8 Punkt.|  
|Anderes Betriebssystem/Kultur|Logische Schriftart der MS Shell Dlg, normalerweise Microsoft San Serif 8 Point.|  
  
 MS Shell Dlg ist einem Schriftart Satz in der Systemregistrierung zugeordnet.  
  
 Wenn die vorherigen Schriftarten nicht installiert sind, ist die Standard Schriftart Tahoma, 8 Point. Wenn Tahoma, 8 Point, nicht installiert ist, gibt <xref:System.Windows.Forms.Control.DefaultFont%2A> den Wert der Eigenschaft <xref:System.Drawing.FontFamily.GenericSansSerif%2A> zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine <xref:System.Windows.Forms.ListBox> namens ListBox1 enthält. Ruft die `Populate_ListBox`-Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load>-Ereignis Behandlungsmethode auf.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardschriftart oder alternative regionale Schriftarten sind nicht auf dem Clientcomputer installiert.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardvordergrundfarbe des Steuerelements ab.</summary>
        <value>Die standardmäßige Vordergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Die Standardeinstellung ist <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der standardmäßige <xref:System.Windows.Forms.Control.ForeColor%2A>-Eigenschafts Wert eines nicht übergeordneten Steuer Elements. Abgeleitete Klassen können unterschiedliche Standardwerte aufweisen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> und <xref:System.Windows.Forms.Control.DefaultForeColor%2A> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine <xref:System.Windows.Forms.ListBox> namens ListBox1 enthält. Ruft die `Populate_ListBox`-Methode im Konstruktor des Formulars oder <xref:System.Windows.Forms.Form.Load>-Ereignis Behandlungsmethode auf.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den von dem Steuerelement unterstützten Standard-IME-Modus (Eingabemethoden-Editor) ab.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.ImeMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Eingabemethoden-Editor (Input Method Editor, IME) ist ein Programm, mit dem Benutzer komplexe Zeichen und Symbole, wie z. b. japanische Kanji-Zeichen, mithilfe einer Standardtastatur eingeben können.  
  
 Wie in der <xref:System.Windows.Forms.Control>-Klasse implementiert, gibt diese Eigenschaft immer den <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType>-Wert zurück. Der <xref:System.Windows.Forms.ImeMode.Inherit>-Wert gibt an, dass der IME-Modus vom übergeordneten Steuerelement geerbt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.DefaultImeMode%2A>-Eigenschaft überschrieben, um den Eingabemethoden-Editor zu deaktivieren.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.DefaultImeMode" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.DefaultImeMode" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen.</para></block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den als Standardwert angegebenen Leerraum zwischen Steuerelementen in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das den Standardzwischenraum zwischen Steuerelementen darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge und die Höhe in Pixel ab, die als die maximale Standardgröße eines Steuerelements angegeben ist.</summary>
        <value>Eine <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />-Struktur, die die Größe des Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge und die Höhe in Pixel ab, die als die minimale Standardgröße eines Steuerelements angegeben ist.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />-Struktur, die die Größe des Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den internen Abstand des Inhalts eines Steuerelements in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />-Objekt, das den internen Abstand des Inhalts eines Steuerelements darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardgröße des Steuerelements ab.</summary>
        <value>Die Standard-<see cref="T:System.Drawing.Size" /> des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft stellt den <xref:System.Drawing.Size> des Steuer Elements bei der anfänglichen Erstellung dar. Sie können die Größe des Steuer Elements anpassen, indem Sie den <xref:System.Windows.Forms.Control.Size%2A>-Eigenschafts Wert festlegen.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, legen Sie die <xref:System.Drawing.Size> eines Steuer Elements nicht im Konstruktor fest. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft zu überschreiben.  
  
> [!NOTE]
>  Auf Windows Server 2003-Systemen wird die Größe eines <xref:System.Windows.Forms.Form> durch die maximale Pixel Breite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft überschrieben, und die Standardgröße des Formulars ist 500 Pixel quadratisch.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.DefaultSize" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, empfiehlt es sich, eine <see cref="T:System.Drawing.Size" /> mit den gewünschten Dimensionen zurückzugeben, statt die gesamte Implementierung zu überschreiben.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc : Message -&gt; unit&#xA;override this.DefWndProc : Message -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Sendet die angegebene Meldung an die Standardfensterprozedur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Verarbeiten von Windows-Meldungen finden Sie unter der [WindowProc-Funktion](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zerstört das mit dem Steuerelement verknüpfte Handle.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.Control.DestroyHandle" />-Methode der Basisklasse aufruft, um sicherzustellen, dass das Handle zerstört wird.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den DPI-Wert für das Anzeigegerät ab, auf dem das Steuerelement aktuell angezeigt wird.</summary>
        <value>Der DPI-Wert des Anzeigegeräts.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Rechteck ab, das den Anzeigebereich des Steuerelements darstellt.</summary>
        <value>Ein <see cref="T:System.Drawing.Rectangle" />, das den Anzeigebereich des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DisplayRectangle%2A>-Eigenschaft gibt das Client Rechteck des Anzeige Bereichs des Steuer Elements zurück. Bei der Basis Steuerelement Klasse ist dies gleich dem Client Rechteck. Erbende Steuerelemente können diese jedoch ändern, wenn sich Ihr Client Bereich von Ihrem Anzeigebereich unterscheidet. Das Anzeige Rechteck ist das kleinste <xref:System.Drawing.Rectangle>, das ein-Steuerelement einschließt und zum Anordnen von Steuerelementen verwendet wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.DisplayRectangle" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.DisplayRectangle" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Alternativ müssen Sie die gesamte-Implementierung bereitstellen.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom <see cref="T:System.Windows.Forms.Control" /> und den untergeordneten Steuerelementen verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)`-Methode auf, wobei der `disposing`-Parameter auf `true` festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, wenn `disposing` auf `false` festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Windows.Forms.Control> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Wenn Sie <see langword="Dispose(Boolean)" /> überschreiben, achten Sie darauf, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" />-aufrufenen aufgerufen wurden. Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" /> finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" /> finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Forms.Control" />-Basisklasse gerade freigegeben wird.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Windows.Forms.Control" />-Basisklasse gerade freigegeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft `true` zurückgibt, wird die Basisklasse <xref:System.Windows.Forms.Control> gerade verworfen. Nachdem das Steuerelement verworfen wurde, kann es nicht mehr als gültiges Windows-Steuerelement referenziert werden. Obwohl die Instanz eines Steuer Elements verworfen wird, wird Sie weiterhin im Arbeitsspeicher beibehalten, bis Sie über Garbage Collection aus dem Arbeitsspeicher entfernt wird. Wenn ein Steuerelement verworfen wird, können Sie die <xref:System.Windows.Forms.Control.RecreateHandle%2A>-Methode nicht mehr aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welche Steuerelementrahmen am übergeordneten Steuerelement angedockt sind, und bestimmt, wie die Größe eines Steuerelements mit dem übergeordneten Steuerelement geändert wird.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.DockStyle" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.Dock%2A>-Eigenschaft, um zu definieren, wie die Größe eines Steuer Elements automatisch geändert wird, wenn dessen übergeordnetes Steuerelement geändert wird. Wenn Sie z. b. <xref:System.Windows.Forms.Control.Dock%2A> auf <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> festlegen, wird das Steuerelement am linken Rand des übergeordneten Steuer Elements ausgerichtet und seine Größe geändert, wenn die Größe des übergeordneten Steuer Elements geändert wird. Steuerelemente werden in ihrer z-Reihenfolge angedockt, d. h. das visuelle Schichten von Steuerelementen in einem Formular entlang der z-Achse (Tiefe) des Formulars.  
  
 Ein Steuerelement kann an einen Rand seines übergeordneten Containers angedockt werden oder an alle Ränder angedockt werden und den übergeordneten Container ausfüllen.  
  
 Das Festlegen der <xref:System.Windows.Forms.Control.Margin%2A>-Eigenschaft für ein angedocktes Steuerelement wirkt sich nicht auf den Abstand des Steuer Elements von den Rändern seines Containers aus.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Anchor%2A> und <xref:System.Windows.Forms.Control.Dock%2A> Eigenschaften schließen sich gegenseitig. Es kann jeweils nur eine festgelegt werden, und der letzte Satz hat Vorrang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.GroupBox> erstellt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird ein <xref:System.Windows.Forms.TextBox> erstellt und dessen <xref:System.Windows.Forms.Control.Location%2A> innerhalb des Gruppen Felds festgelegt. Anschließend wird die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft des Gruppen Felds festgelegt und das Gruppenfeld an den oberen Rand des Formulars angedockt. Schließlich wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft auf `false` festgelegt wird. Dies bewirkt, dass alle im Gruppenfeld enthaltenen Steuerelemente deaktiviert werden.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.DockStyle" />-Werte.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Dock" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Dock" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die Methoden <see langword="get" /> und <see langword="set" /> der <see cref="P:System.Windows.Forms.Control.Dock" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Dock" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Dock%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Die zu ziehenden Daten.</param>
        <param name="allowedEffects">Einer der <see cref="T:System.Windows.Forms.DragDropEffects" />-Werte.</param>
        <summary>Beginnt einen Drag &amp; Drop-Vorgang.</summary>
        <returns>Ein Wert aus der <see cref="T:System.Windows.Forms.DragDropEffects" />-Enumeration, der den abschließenden Effekt darstellt, der während des Drag &amp;amp; Drop-Vorgangs ausgeführt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `allowedEffects`-Parameter bestimmt, welche Zieh Vorgänge auftreten können. Wenn der Zieh Vorgang mit Anwendungen in einem anderen Prozess interagieren muss, sollten die Daten entweder eine verwaltete Basisklasse (<xref:System.String>, <xref:System.Drawing.Bitmap> oder <xref:System.Drawing.Imaging.Metafile>) oder ein Objekt sein, das <xref:System.Runtime.Serialization.ISerializable> oder <xref:System.Windows.Forms.IDataObject> implementiert.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Continue` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragOver> ausgelöst, um den Vorgang fortzusetzen. das Ereignis <xref:System.Windows.Forms.Control.GiveFeedback> wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode fängt alle Ausnahmen ab und löst nur die folgenden Sicherheits-oder kritischen Ausnahmen erneut aus:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Drag & Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox>-Steuerelementen veranschaulicht. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode aufgerufen, wenn die Zieh Aktion gestartet wird. Die Zieh Aktion wird gestartet, wenn die Maus während des <xref:System.Windows.Forms.Control.MouseDown>-Ereignisses mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> von der Mausposition bewegt hat. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>-Methode wird verwendet, um den Index des Elements zu bestimmen, das während des `MouseDown`-Ereignisses gezogen werden soll.  
  
 Das Beispiel zeigt auch die Verwendung von benutzerdefinierten Cursorn für den Drag & Drop-Vorgang. Für das Beispiel ist es erforderlich, dass zwei Cursor Dateien, `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis vorhanden sind, für die benutzerdefinierten Drag-und No-Drop-Cursor. Die benutzerdefinierten Cursor werden verwendet, wenn die `UseCustomCursorsCheck`-<xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierten Cursor werden im <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignishandler festgelegt.  
  
 Der Tastatur Zustand wird im <xref:System.Windows.Forms.Control.DragOver>-Ereignishandler für die Rechte `ListBox` ausgewertet, um zu bestimmen, welcher Zieh Vorgang auf dem Zustand der UMSCHALTTASTE, STRG, alt oder STRG + ALT-Taste basiert. Der Speicherort in der `ListBox`, an dem der Ablage Vorgang stattfindet, wird auch während des `DragOver`-Ereignisses festgelegt. Wenn es sich bei den zu Lösch Endes Daten nicht um einen `String` handelt, wird <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> in <xref:System.Windows.Forms.DragDropEffects> auf `None` festgelegt. Schließlich wird der Status des Drop in der `DropLocationLabel`-<xref:System.Windows.Forms.Label> angezeigt.  
  
 Die Daten, die für die Rechte `ListBox` (null) gelöscht werden, werden im <xref:System.Windows.Forms.Control.DragDrop>-Ereignishandler bestimmt, und der `String`-Wert wird an geeigneter Stelle in `ListBox` hinzugefügt. Wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird, wird der Drag & Drop-Vorgang im Ereignishandler <xref:System.Windows.Forms.Control.QueryContinueDrag> abgebrochen.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Forms.DragDropEffects>-Enumeration verwendet wird, um anzugeben, wie Daten zwischen den an einem Drag & Drop-Vorgang beteiligten Steuerelementen übertragen werden sollen. Für dieses Beispiel muss das Formular ein <xref:System.Windows.Forms.RichTextBox>-Steuerelement und ein <xref:System.Windows.Forms.ListBox>-Steuerelement enthalten, und das <xref:System.Windows.Forms.ListBox>-Steuerelement wird mit einer Liste gültiger Dateinamen aufgefüllt. Wenn der Benutzer einen Dateinamen auf das <xref:System.Windows.Forms.RichTextBox>-Steuerelement zieht, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis des-Steuer Elements ausgelöst. Innerhalb des Ereignis Handlers wird die <xref:System.Windows.Forms.DragEventArgs.Effect%2A>-Eigenschaft von <xref:System.Windows.Forms.DragEventArgs> mit <xref:System.Windows.Forms.DragDropEffects> initialisiert, um anzugeben, dass die Daten, auf die vom Dateipfad verwiesen wird, in das <xref:System.Windows.Forms.RichTextBox>-Steuerelement kopiert werden sollen.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement seine Oberfläche unter Verwendung eines sekundären Puffers neu zeichnen soll, um Flackern zu verringern oder zu vermeiden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Oberfläche des Steuerelements mit Doppelpufferung gezeichnet werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gepufferte Grafiken können das Flimmern reduzieren oder eliminieren, das durch progressives Neuzeichnen von Teilen einer angezeigten Oberfläche verursacht wird. Für gepufferte Grafiken ist es erforderlich, dass die aktualisierten Grafikdaten zuerst in einen Puffer geschrieben werden. Die Daten im Grafik Puffer werden dann schnell in den angezeigten Oberflächen Speicher geschrieben. Der relativ schnelle Switch des angezeigten Grafik Speichers verringert in der Regel das Flimmern, das andernfalls auftreten kann.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> ist keine bindbare Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Doppelklicken auf das Steuerelement ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Doppelklick wird durch die Mauseinstellungen des Betriebssystems des Benutzers bestimmt. Der Benutzer kann den Zeitraum festlegen, innerhalb dessen der zweite Mausklick erfolgen muss, damit zwei aufeinander folgende Mausklicks als Doppelklick erkannt werden. Das <xref:System.Windows.Forms.Control.Click>-Ereignis wird jedes Mal ausgelöst, wenn auf ein Steuerelement Doppel geklickt wird. Wenn Sie z. b. über Ereignishandler für die <xref:System.Windows.Forms.Control.Click>-und <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse einer <xref:System.Windows.Forms.Form> verfügen, werden die <xref:System.Windows.Forms.Control.Click>-und <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse ausgelöst, wenn auf das Formular Doppel geklickt wird und beide Methoden aufgerufen werden. Wenn auf ein Steuerelement Doppel geklickt wird und dieses Steuerelement das <xref:System.Windows.Forms.Control.DoubleClick>-Ereignis nicht unterstützt, wird das <xref:System.Windows.Forms.Control.Click>-Ereignis möglicherweise zweimal ausgelöst.  
  
 Sie müssen die Werte `StandardDoubleClick` und `StandardClick` von <xref:System.Windows.Forms.ControlStyles> auf `true` festlegen, damit dieses Ereignis ausgelöst wird. Diese Werte werden möglicherweise bereits auf `true` festgelegt, wenn Sie von vorhandenen Windows Forms Steuerelementen erben.  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.DoubleClick>-Ereignis einer <xref:System.Windows.Forms.ListBox> verwendet, um die im <xref:System.Windows.Forms.ListBox> aufgeführten Textdateien in ein <xref:System.Windows.Forms.TextBox>-Steuerelement zu laden.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Das Erben von einem Standard Windows Forms-Steuerelement und das Ändern der <see langword="StandardClick" />-oder <see langword="StandardDoubleClick" />-Werte von <see cref="T:System.Windows.Forms.ControlStyles" /> in <see langword="true" /> kann ein unerwartetes Verhalten verursachen oder keinerlei Auswirkungen haben, wenn das Steuerelement die <see cref="E:System.Windows.Forms.Control.Click" />-oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />-Ereignisse nicht unterstützt.  
  
In der folgenden Tabelle sind Windows Forms Steuerelemente und das Ereignis (<see cref="E:System.Windows.Forms.Control.Click" /> oder <see cref="E:System.Windows.Forms.Control.DoubleClick" />) als Antwort auf die angegebene Maus Aktion aufgeführt.  
  
 <list type="table"><listheader><term> Steuerelement 
 </term><description> Linker Mausklick 
 </description><description> Doppelklick mit der linken Maustaste 
 </description><description> Mit der rechten Maustaste 
 </description><description> Doppelklick mit der rechten Maustaste 
 </description><description> Mittlere Maustaste 
 </description><description> Mittlere Maustaste Doppelklick 
 </description><description> XButton1 mit Mausklick 
 </description><description> XButton1 Maustaste doppelklicken 
 </description><description> XButton2 mit Mausklick 
 </description><description> XButton2 Maustaste doppelklicken 
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />, 
 <see cref="T:System.Windows.Forms.DateTimePicker" />, 
 <see cref="T:System.Windows.Forms.RichTextBox" />, 
 <see cref="T:System.Windows.Forms.HScrollBar" />, 
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />, 
 <see cref="T:System.Windows.Forms.CheckBox" />, 
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />, 
 <see cref="T:System.Windows.Forms.CheckedListBox" />, 
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />, 
 <see cref="T:System.Windows.Forms.DomainUpDown" />, 
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description></item><item><term> *  <see cref="T:System.Windows.Forms.TreeView" />, 
\* <see cref="T:System.Windows.Forms.ListView" /></term><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description><description> Keine 
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />, 
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description><description> Klicken 
 </description><description> Klicken Sie auf. 
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />, 
 <see cref="T:System.Windows.Forms.DataGrid" />, 
 <see cref="T:System.Windows.Forms.Label" />, 
 <see cref="T:System.Windows.Forms.LinkLabel" />, 
 <see cref="T:System.Windows.Forms.Panel" />, 
 <see cref="T:System.Windows.Forms.GroupBox" />, 
 <see cref="T:System.Windows.Forms.PictureBox" />, 
 <see cref="T:System.Windows.Forms.Splitter" />, 
 <see cref="T:System.Windows.Forms.StatusBar" />, 
 <see cref="T:System.Windows.Forms.ToolBar" />, 
 <see cref="T:System.Windows.Forms.TabPage" />, 
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Klicken 
 </description><description> Click, DoubleClick 
 </description><description> Klicken 
 </description><description> Click, DoubleClick 
 </description></item></list>  

 \* muss sich der Mauszeiger über einem untergeordneten Objekt befinden (<see cref="T:System.Windows.Forms.TreeNode" /> oder <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
* * Die <see cref="T:System.Windows.Forms.TabControl" /> muss in der <see cref="P:System.Windows.Forms.TabControl.TabPages" />-Auflistung mindestens einen <see cref="T:System.Windows.Forms.TabPage" /> aufweisen.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die DPI-Einstellung für ein Steuerelement programmgesteuert geändert wird, nachdem der DPI-Wert des übergeordneten Steuerelements oder Formulars geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die DPI-Einstellung für ein Steuerelement programmgesteuert geändert wird, bevor ein DPI-Änderungsereignis für das übergeordnete Steuerelement oder Formular auftritt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Drag &amp; Drop-Vorgang abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften "<xref:System.Windows.Forms.DragEventArgs.X%2A>" und "<xref:System.Windows.Forms.DragEventArgs.Y%2A>" der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirm Koordinaten und nicht in den Client Koordinaten. In der folgenden visuellen C# Textzeile werden die Eigenschaften in einen Client <xref:System.Drawing.Point> konvertiert.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  Wenn Sie in früheren Versionen als [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] einen <xref:System.Windows.Forms.UserControl> mit <xref:System.Windows.Forms.Control.DragEnter>-und <xref:System.Windows.Forms.Control.DragDrop>-Ereignissen in einem Windows Form ablegen und etwas zur Entwurfszeit auf die <xref:System.Windows.Forms.UserControl>-Ereignisse ziehen, werden die `DropDrop`-und `DropEnter`-Ereignisse ausgelöst. Wenn Sie die Projekt Mappe jedoch schließen und erneut öffnen, werden die Ereignisse "<xref:System.Windows.Forms.Control.DragEnter>" und "<xref:System.Windows.Forms.Control.DragDrop>" nicht erneut ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.DragDrop>-Ereignisses. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt in die Begrenzungen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis wird ausgelöst, wenn der Benutzer während eines Drag & Drop-Vorgangs zuerst den Mauszeiger über das-Steuerelement zieht.  
  
> [!NOTE]
>  Wenn Sie in früheren Versionen als [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] einen <xref:System.Windows.Forms.UserControl> mit <xref:System.Windows.Forms.Control.DragEnter>-und <xref:System.Windows.Forms.Control.DragDrop>-Ereignissen in einem Windows Form ablegen und etwas zur Entwurfszeit auf die <xref:System.Windows.Forms.UserControl>-Ereignisse ziehen, werden die `DropDrop`-und `DropEnter`-Ereignisse ausgelöst. Wenn Sie die Projekt Mappe jedoch schließen und erneut öffnen, werden die Ereignisse "<xref:System.Windows.Forms.Control.DragEnter>" und "<xref:System.Windows.Forms.Control.DragDrop>" nicht erneut ausgelöst.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Continue` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragOver> ausgelöst, um den Vorgang fortzusetzen. das Ereignis <xref:System.Windows.Forms.Control.GiveFeedback> wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
    > [!NOTE]
    >  Die Eigenschaften "<xref:System.Windows.Forms.DragEventArgs.X%2A>" und "<xref:System.Windows.Forms.DragEventArgs.Y%2A>" der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirm Koordinaten und nicht in den Client Koordinaten. In der folgenden visuellen C# Textzeile werden die Eigenschaften in einen Client <xref:System.Drawing.Point> konvertiert.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Drag & Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox>-Steuerelementen veranschaulicht. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode aufgerufen, wenn die Zieh Aktion gestartet wird. Die Zieh Aktion wird gestartet, wenn die Maus während des <xref:System.Windows.Forms.Control.MouseDown>-Ereignisses mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> von der Mausposition bewegt hat. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>-Methode wird verwendet, um den Index des Elements zu bestimmen, das während des `MouseDown`-Ereignisses gezogen werden soll.  
  
 Das Beispiel zeigt auch die Verwendung von benutzerdefinierten Cursorn für den Drag & Drop-Vorgang. Für das Beispiel ist es erforderlich, dass zwei Cursor Dateien, `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis vorhanden sind, für die benutzerdefinierten Drag-und No-Drop-Cursor. Die benutzerdefinierten Cursor werden verwendet, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierten Cursor werden im <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignishandler festgelegt.  
  
 Der Tastatur Zustand wird im <xref:System.Windows.Forms.Control.DragOver>-Ereignishandler für die Rechte `ListBox` ausgewertet, um zu bestimmen, welcher Zieh Vorgang auf dem Zustand der UMSCHALTTASTE, STRG, alt oder STRG + ALT-Taste basiert. Der Speicherort in der `ListBox`, an dem der Ablage Vorgang stattfindet, wird auch während des `DragOver`-Ereignisses festgelegt. Wenn es sich bei den zu Lösch Endes Daten nicht um einen `String` handelt, wird <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> in <xref:System.Windows.Forms.DragDropEffects> auf `None` festgelegt. Schließlich wird der Status der Ablage in der `DropLocationLabel` <xref:System.Windows.Forms.Label> angezeigt.  
  
 Die Daten, die für die Rechte `ListBox` (null) gelöscht werden, werden im <xref:System.Windows.Forms.Control.DragDrop>-Ereignishandler bestimmt, und der `String`-Wert wird an geeigneter Stelle in `ListBox` hinzugefügt. Wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird, wird der Drag & Drop-Vorgang im Ereignishandler <xref:System.Windows.Forms.Control.QueryContinueDrag> abgebrochen.  
  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.DragEnter>-Ereignisses. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt aus den Grenzen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis wird ausgelöst, wenn der Benutzer den Cursor aus dem Steuerelement zieht oder der Benutzer den aktuellen Drag & Drop-Vorgang abbricht.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Continue` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragOver> ausgelöst, um den Vorgang fortzusetzen. das Ereignis <xref:System.Windows.Forms.Control.GiveFeedback> wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Drag & Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox>-Steuerelementen veranschaulicht. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode aufgerufen, wenn die Zieh Aktion gestartet wird. Die Zieh Aktion wird gestartet, wenn die Maus während des <xref:System.Windows.Forms.Control.MouseDown>-Ereignisses mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> von der Mausposition bewegt hat. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>-Methode wird verwendet, um den Index des Elements zu bestimmen, das während des `MouseDown`-Ereignisses gezogen werden soll.  
  
 Das Beispiel zeigt auch die Verwendung von benutzerdefinierten Cursorn für den Drag & Drop-Vorgang. Für das Beispiel ist es erforderlich, dass zwei Cursor Dateien, `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis vorhanden sind, für die benutzerdefinierten Drag-und No-Drop-Cursor. Die benutzerdefinierten Cursor werden verwendet, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierten Cursor werden im <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignishandler festgelegt.  
  
 Der Tastatur Zustand wird im <xref:System.Windows.Forms.Control.DragOver>-Ereignishandler für die Rechte `ListBox` ausgewertet, um zu bestimmen, welcher Zieh Vorgang auf dem Zustand der UMSCHALTTASTE, STRG, alt oder STRG + ALT-Taste basiert. Der Speicherort in der `ListBox`, an dem der Ablage Vorgang stattfindet, wird auch während des `DragOver`-Ereignisses festgelegt. Wenn es sich bei den zu Lösch Endes Daten nicht um einen `String` handelt, wird <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> in <xref:System.Windows.Forms.DragDropEffects> auf `None` festgelegt. Schließlich wird der Status der Ablage in der `DropLocationLabel` <xref:System.Windows.Forms.Label> angezeigt.  
  
 Die Daten, die für die Rechte `ListBox` (null) gelöscht werden, werden im <xref:System.Windows.Forms.Control.DragDrop>-Ereignishandler bestimmt, und der `String`-Wert wird an geeigneter Stelle in `ListBox` hinzugefügt. Wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird, wird der Drag & Drop-Vorgang im Ereignishandler <xref:System.Windows.Forms.Control.QueryContinueDrag> abgebrochen.  
  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.DragLeave>-Ereignisses. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Objekt über die Begrenzungen des Steuerelements gezogen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.DragOver>-Ereignis wird ausgelöst, wenn der Mauszeiger während eines Drag & Drop-Vorgangs innerhalb der Begrenzungen des Steuer Elements bewegt wird.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert <xref:System.Windows.Forms.DragAction>-Werts `Continue` ist, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst, um den Vorgang fortzusetzen, und das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
    > [!NOTE]
    >  Die Eigenschaften "<xref:System.Windows.Forms.DragEventArgs.X%2A>" und "<xref:System.Windows.Forms.DragEventArgs.Y%2A>" der <xref:System.Windows.Forms.DragEventArgs> befinden sich in Bildschirm Koordinaten und nicht in den Client Koordinaten. In der folgenden C# Codezeile werden die Eigenschaften in einen Client <xref:System.Drawing.Point> konvertiert:  
    >   
    >  Point ClientPoint = TargetControl. pointtoken Client (neuer Punkt (de) X, de. Y));  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Drag & Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox>-Steuerelementen veranschaulicht. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode aufgerufen, wenn die Zieh Aktion gestartet wird. Die Zieh Aktion wird gestartet, wenn die Maus während des <xref:System.Windows.Forms.Control.MouseDown>-Ereignisses mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> von der Mausposition bewegt hat. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>-Methode wird verwendet, um den Index des Elements zu bestimmen, das während des `MouseDown`-Ereignisses gezogen werden soll.  
  
 Das Beispiel zeigt auch die Verwendung von benutzerdefinierten Cursorn für den Drag & Drop-Vorgang. Für das Beispiel ist es erforderlich, dass zwei Cursor Dateien, `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis vorhanden sind, für die benutzerdefinierten Drag-und No-Drop-Cursor. Die benutzerdefinierten Cursor werden verwendet, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierten Cursor werden im <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignishandler festgelegt.  
  
 Der Tastatur Zustand wird im <xref:System.Windows.Forms.Control.DragOver>-Ereignishandler für die Rechte `ListBox` ausgewertet, um zu bestimmen, welcher Zieh Vorgang auf dem Zustand der UMSCHALTTASTE, STRG, alt oder STRG + ALT-Taste basiert. Der Speicherort in der `ListBox`, an dem der Ablage Vorgang stattfindet, wird auch während des `DragOver`-Ereignisses festgelegt. Wenn es sich bei den zu Lösch Endes Daten nicht um einen `String` handelt, wird <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> in <xref:System.Windows.Forms.DragDropEffects> auf `None` festgelegt. Schließlich wird der Status der Ablage in der `DropLocationLabel` <xref:System.Windows.Forms.Label> angezeigt.  
  
 Die Daten, die für die Rechte `ListBox` (null) gelöscht werden, werden im <xref:System.Windows.Forms.Control.DragDrop>-Ereignishandler bestimmt, und der `String`-Wert wird an geeigneter Stelle in `ListBox` hinzugefügt. Wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird, wird der Drag & Drop-Vorgang im Ereignishandler <xref:System.Windows.Forms.Control.QueryContinueDrag> abgebrochen.  
  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.DragOver>-Ereignisses. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap">Die Bitmap, in die gezeichnet werden soll.</param>
        <param name="targetBounds">Die Begrenzungen, innerhalb derer das Steuerelement gerendert wird.</param>
        <summary>Unterstützt das Rendering für die angegebene Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.DrawToBitmap%2A>-Methode wird für ActiveX-Steuerelemente nicht unterstützt. Sie können das <xref:System.Windows.Forms.Control.OnPrint%2A>-Ereignis überschreiben und ggf. eine benutzerdefinierte Druck Logik bereitstellen.  
  
 Die <xref:System.Windows.Forms.Control.DrawToBitmap%2A>-Methode weist die folgenden Einschränkungen auf:  
  
-   Für große Bitmaps kann eine <xref:System.ArgumentException> ausgelöst werden. Die maximal zulässige Größe variiert je nach Computer.  
  
-   die `Ink`-Steuerelemente für das Betriebssystem Windows XP Tablet PC Edition 2005 werden von <xref:System.Windows.Forms.Control.DrawToBitmap%2A> nicht unterstützt.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> zeichnet keinen untergeordneten <xref:System.Windows.Forms.TextBox>, wenn die <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft des <xref:System.Windows.Forms.TextBox> auf `false` festgelegt ist.  
  
-   Steuerelemente in Containern werden in umgekehrter Reihenfolge gerendert.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> ist für die <xref:System.Windows.Forms.RichTextBox> nicht voll funktionsfähig. nur der Rahmen einer Bitmap wird gezeichnet.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement auf Benutzerinteraktionen reagieren kann, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Steuerelement auf Benutzerinteraktionen reagieren kann, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft können Sie Steuerelemente zur Laufzeit aktivieren oder deaktivieren. Beispielsweise können Sie Steuerelemente deaktivieren, die nicht auf den aktuellen Zustand der Anwendung angewendet werden. Sie können ein Steuerelement auch deaktivieren, um dessen Verwendung einzuschränken. Beispielsweise kann eine Schaltfläche deaktiviert werden, um zu verhindern, dass der Benutzer darauf klickt. Wenn ein Steuerelement deaktiviert ist, kann es nicht ausgewählt werden.  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft auf `false` festlegen, wird das Kontrollkästchen der Anwendung nicht deaktiviert, oder es wird verhindert, dass das Anwendungsfenster den Fokus erhält.  
  
 Wenn die aktivierte Eigenschaft für ein Container Steuerelement auf `false` festgelegt ist, werden auch alle darin enthaltenen Steuerelemente deaktiviert. Wenn der Benutzer z. b. auf ein Steuerelement klickt, das in einem deaktivierten <xref:System.Windows.Forms.GroupBox>-Steuerelement enthalten ist, werden keine Ereignisse ausgelöst.  
  
> [!NOTE]
>  Wenn ein scrollbares Steuerelement deaktiviert ist, werden die Schiebe leisten ebenfalls deaktiviert. So kann z. b. ein deaktiviertes mehrzeilige Textfeld keinen Bildlauf durchführen, um alle Textzeilen anzuzeigen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.GroupBox> erstellt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird ein <xref:System.Windows.Forms.TextBox> erstellt und dessen <xref:System.Windows.Forms.Control.Location%2A> innerhalb des Gruppen Felds festgelegt. Anschließend wird die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft des Gruppen Felds festgelegt und das Gruppenfeld an den oberen Rand des Formulars angedockt. Schließlich wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft auf `false` festgelegt wird. Dies bewirkt, dass alle im Gruppenfeld enthaltenen Steuerelemente deaktiviert werden.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Enabled" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei <xref:System.Windows.Forms.RadioButton>-Steuerelemente verwendet, um das <xref:System.Windows.Forms.Control.EnabledChanged>-Ereignis zu veranschaulichen. Wenn Sie auf eine Schaltfläche klicken, wird der Wert der <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft der Schaltfläche "andere" in `false` geändert und ein <xref:System.Windows.Forms.MessageBox> angezeigt.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.EndInvoke(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das <see cref="T:System.IAsyncResult" />, das einen bestimmten asynchronen Aufrufvorgang darstellt, der beim Aufrufen von <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> zurückgegeben wird.</param>
        <summary>Ruft den Rückgabewert des asynchronen Vorgangs ab, der durch das übergebene <see cref="T:System.IAsyncResult" /> dargestellt wird.</summary>
        <returns>Das von dem asynchronen Vorgang generierte <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der asynchrone Vorgang nicht abgeschlossen wurde, wird diese Funktion blockiert, bis das Ergebnis verfügbar ist.  
  
> [!NOTE]
>  Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameterwert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="asyncResult" />-Objekt wurde nicht von einem vorhergehenden Aufruf der <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />-Methode desselben Steuerelements erstellt.</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Eintreten in den Bereich des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
> [!NOTE]
>  Die Ereignisse <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> werden von der <xref:System.Windows.Forms.Form>-Klasse unterdrückt. Die äquivalenten Ereignisse in der <xref:System.Windows.Forms.Form>-Klasse sind die Ereignisse <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate>. Die Ereignisse <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> sind hierarchisch und werden in der übergeordneten Kette nach oben und unten verschoben, bis das entsprechende Steuerelement erreicht wird. Angenommen, Sie verfügen über eine <xref:System.Windows.Forms.Form> mit zwei <xref:System.Windows.Forms.GroupBox>-Steuerelementen, und jedes <xref:System.Windows.Forms.GroupBox>-Steuerelement verfügt über ein <xref:System.Windows.Forms.TextBox>-Steuerelement. Wenn die Einfügemarke von einem <xref:System.Windows.Forms.TextBox> zum anderen verschoben wird, wird das <xref:System.Windows.Forms.Control.Leave>-Ereignis für die <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.GroupBox> ausgelöst, und das <xref:System.Windows.Forms.Control.Enter>-Ereignis wird für die anderen <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TextBox> ausgelöst.  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema "`WM_KILLFOCUS`" im Abschnitt "Tastatureingabe Referenz" und im Abschnitt "Nachrichten Deadlocks" des Themas [about Messages and Message Queues](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Enter>-Ereignis verwendet, um die Vordergrund-und Hintergrundfarben einer <xref:System.Windows.Forms.TextBox> unter bestimmten Bedingungen zu ändern.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Formular ab, in dem sich das Steuerelement befindet.</summary>
        <returns>Das <see cref="T:System.Windows.Forms.Form" />, in dem sich das Steuerelement befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.Control.Parent%2A>-Eigenschafts Wert des Steuer Elements ist möglicherweise nicht identisch mit dem von <xref:System.Windows.Forms.Control.FindForm%2A>-Methode zurückgegebenen <xref:System.Windows.Forms.Form>. Wenn z. b. ein <xref:System.Windows.Forms.RadioButton>-Steuerelement in einem <xref:System.Windows.Forms.GroupBox>-Steuerelement enthalten ist und sich <xref:System.Windows.Forms.GroupBox> auf einem <xref:System.Windows.Forms.Form> befindet, ist das <xref:System.Windows.Forms.Control.Parent%2A> des <xref:System.Windows.Forms.RadioButton>-Steuer Elements <xref:System.Windows.Forms.GroupBox>, und <xref:System.Windows.Forms.Control.Parent%2A> des <xref:System.Windows.Forms.GroupBox>-Steuer Elements ist die <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Formular gefunden, das die angegebene Schaltfläche enthält.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Eingabefokus auf das Steuerelement.</summary>
        <returns><see langword="true" />, wenn die Anforderung des Eingabefokus erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Focus%2A>-Methode gibt `true` zurück, wenn das Steuerelement den Eingabefokus erfolgreich empfangen hat. Das Steuerelement kann über den Eingabefokus verfügen, während keine visuellen Hinweise angezeigt werden, die den Fokus haben. Dieses Verhalten wird in erster Linie durch die unten aufgeführten nicht auswählbaren Steuerelemente oder von Ihnen abgeleitete Steuerelemente beobachtet.  
  
 Ein Steuerelement kann ausgewählt werden und den Eingabefokus erhalten, wenn Folgendes zutrifft: der `Selectable`-Wert von <xref:System.Windows.Forms.ControlStyles> ist auf `true` festgelegt, er ist in einem anderen Steuerelement enthalten, und alle übergeordneten Steuerelemente sind sichtbar und aktiviert.  
  
 Die Windows Forms-Steuerelemente in der folgenden Liste können nicht ausgewählt werden. Von diesen Steuerelementen abgeleitete Steuerelemente sind ebenfalls nicht auswählbar.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (wenn im-Steuerelement kein Link vorhanden ist)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> ist eine Methode auf niedriger Ebene, die in erster Linie für benutzerdefinierter Steuerelemente bestimmt ist. Stattdessen sollten Anwendungsprogrammierer die <xref:System.Windows.Forms.Control.Select%2A>-Methode oder die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>-Eigenschaft für untergeordnete Steuerelemente oder die <xref:System.Windows.Forms.Form.Activate%2A>-Methode für Formulare verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Fokus auf das angegebene <xref:System.Windows.Forms.Control> festgelegt, wenn es den Fokus erhalten kann.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement den Eingabefokus besitzt.</summary>
        <value><see langword="true" />, wenn das Steuerelement den Fokus besitzt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.MenuItem> deaktiviert, wenn ein <xref:System.Windows.Forms.TextBox> keinen Fokus hat. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.TextBox> mit dem Namen `textBox1` und zwei <xref:System.Windows.Forms.MenuItem>-Objekte mit dem Namen `menuItemEdit` und `menuItemEditInsertCustomerInfo` verfügen.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Focused" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Focused" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schriftart für die Anzeige von Text im Steuerelement ab oder legt diese fest.</summary>
        <value>Der <see cref="T:System.Drawing.Font" /> , der auf den Text angewendet werden soll, der im Steuerelement angezeigt wird. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultFont" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Font%2A>-Eigenschaft ist eine Ambient-Eigenschaft. Eine Ambient-Eigenschaft ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Weitere Informationen zu Ambient-Eigenschaften finden Sie in der <xref:System.Windows.Forms.AmbientProperties>-Klasse oder in der Übersicht über die <xref:System.Windows.Forms.Control>-Klasse.  
  
 Da der <xref:System.Drawing.Font> unveränderlich ist (was bedeutet, dass Sie keine seiner Eigenschaften anpassen können), können Sie die <xref:System.Windows.Forms.Control.Font%2A>-Eigenschaft nur einem neuen <xref:System.Drawing.Font> zuweisen. Allerdings können Sie die neue Schriftart auf der vorhandenen Schriftart basieren.  
  
 [Visual Basic, C#]  
  
 Im folgenden finden Sie ein Beispiel dafür, wie Sie die vorhandene Schriftart anpassen, damit Sie fett formatiert ist:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird dem Benutzer eine <xref:System.Windows.Forms.FontDialog> angezeigt, und die <xref:System.Drawing.Font> eines <xref:System.Windows.Forms.DateTimePicker>-Steuer Elements wird geändert. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit <xref:System.Windows.Forms.Button> und eine <xref:System.Windows.Forms.DateTimePicker> verfügen.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Font%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder durch Interaktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.FontChanged>-Ereignis veranschaulicht.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe der Schriftart des Steuerelements ab oder legt diese fest.</summary>
        <value>Die Höhe des <see cref="T:System.Drawing.Font" /> des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.FontHeight%2A>-Eigenschaft darf nicht auf einen anderen Wert als <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType>-Wert des Steuer Elements oder-1 festgelegt werden. Das Festlegen von <xref:System.Windows.Forms.Control.FontHeight%2A> auf-1 hat den Effekt, dass der zwischengespeicherte Höhen Wert gelöscht wird, und der Wert wird neu berechnet, wenn die Eigenschaft das nächste Mal referenziert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Vordergrundfarbe des Steuerelements ab oder legt diese fest.</summary>
        <value>Die Vordergrund-<see cref="T:System.Drawing.Color" /> des Steuerelements. Der Standardwert ist der Wert der <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />-Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ForeColor%2A>-Eigenschaft ist eine Ambient-Eigenschaft. Eine Ambient-Eigenschaft ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Weitere Informationen zu Ambient-Eigenschaften finden Sie in der <xref:System.Windows.Forms.AmbientProperties>-Klasse oder in der Übersicht über die <xref:System.Windows.Forms.Control>-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der-Steuerelemente auf die Standardsystem Farben festgelegt. Der Code ruft rekursiv selbst auf, wenn das Steuerelement über untergeordnete Steuerelemente verfügt. Für dieses Codebeispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement verfügen. ein untergeordnetes Container Steuerelement, wie z. b. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelement (en) würde jedoch die Rekursion besser veranschaulichen.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ForeColor%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder durch Interaktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das zu suchende Fensterhandle (<see langword="HWND" />).</param>
        <summary>Ruft das Steuerelement ab, das das angegebene Handle enthält.</summary>
        <returns>Das <see cref="T:System.Windows.Forms.Control" />, das das dem angegebenen Handle zugeordnete Steuerelement darstellt, gibt <see langword="null" /> zurück, wenn kein Steuerelement mit dem angegebenen Handle gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht die übergeordnete Kette des Fenster Handles, bis ein Handle gefunden wird, das einem Steuerelement zugeordnet ist. Diese Methode ist zuverlässiger als die <xref:System.Windows.Forms.Control.FromHandle%2A>-Methode, da Sie korrekt Steuerelemente zurückgibt, die mehr als ein Handle besitzen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Das zu suchende Fensterhandle (<see langword="HWND" />).</param>
        <summary>Gibt das Steuerelement zurück, das gerade dem angegebenen Handle zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.Control" />, das das dem angegebenen Handle zugeordnete Steuerelement darstellt, gibt <see langword="null" /> zurück, wenn kein Steuerelement mit dem angegebenen Handle gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.FromChildHandle%2A>-Methode, wenn Sie Steuerelemente zurückgeben müssen, die mehr als ein Handle besitzen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="objectId">Ein <see langword="Int32" />, der das abzurufende <see cref="T:System.Windows.Forms.AccessibleObject" /> bezeichnet.</param>
        <summary>Ruft die angegebene <see cref="T:System.Windows.Forms.AccessibleObject" /> ab.</summary>
        <returns>Das angegebene <see cref="T:System.Windows.Forms.AccessibleObject" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie sich ein Steuerelement verhält, wenn seine <see cref="P:System.Windows.Forms.Control.AutoSize" />-Eigenschaft aktiviert wird.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.AutoSizeMode" />-Werte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das untergeordnete Steuerelement an einer angegebenen Position ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, mit den Koordinaten der Position, an denen Sie nach einem Steuerelement suchen möchten. Die Koordinaten werden relativ zur oberen linken Ecke des Clientbereichs des Steuerelements angegeben.</param>
        <summary>Ruft das untergeordnete Steuerelement ab, das sich an den angegebenen Koordinaten befindet.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.Control" />, das das an der angegebenen Position befindliche Steuerelement darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn am angegebenen Punkt kein untergeordnetes Steuerelement vorhanden ist, gibt die <xref:System.Windows.Forms.Control.GetChildAtPoint%2A>-Methode `null` zurück.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft, wenn das zurückgegebene Steuerelement kein untergeordnetes Element des-Steuer Elements ist. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, mit den Koordinaten der Position, an denen Sie nach einem Steuerelement suchen möchten. Die Koordinaten werden relativ zur oberen linken Ecke des Clientbereichs des Steuerelements angegeben.</param>
        <param name="skipValue">Einer der Werte von <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, womit bestimmt wird, ob untergeordnete Steuerelemente eines bestimmten Typs ignoriert werden sollen.</param>
        <summary>Ruft das untergeordnete Steuerelement ab, das sich an den angegebenen Koordinaten befindet, und gibt an, ob untergeordnete Steuerelemente eines bestimmten Typs ignoriert werden sollen.</summary>
        <returns>Das untergeordnete <see cref="T:System.Windows.Forms.Control" /> an den angegebenen Koordinaten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das nächste <see cref="T:System.Windows.Forms.ContainerControl" /> aufwärts in der Kette übergeordneter Steuerelemente des Steuerelements zurück.</summary>
        <returns>Ein <see cref="T:System.Windows.Forms.IContainerControl" />, das das übergeordnete Element des <see cref="T:System.Windows.Forms.Control" /> darstellt.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Das <see cref="T:System.Windows.Forms.Control" />, mit dem die Suche begonnen werden soll.</param>
        <param name="forward"><see langword="true" />, um vorwärts in der Aktivierreihenfolge zu suchen, <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Ruft das nächste oder vorherige Steuerelement in der Aktivierreihenfolge untergeordneter Steuerelemente ab.</summary>
        <returns>Das nächste <see cref="T:System.Windows.Forms.Control" /> in der Aktivierreihenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.GetNextControl%2A>-Methode hängt von der Aktivier Reihenfolge ab. Verwenden Sie zum Durchlaufen aller Steuerelemente eines Formulars, einschließlich der-Steuerelemente, die <xref:System.Windows.Forms.Control.Controls%2A>-Eigenschaft. Um das aktive Steuerelement eines Container Steuer Elements zu erhalten oder festzulegen, verwenden Sie die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Der Bereich mit benutzerdefinierter Größe eines Steuerelements.</param>
        <summary>Ruft die Größe eines rechteckigen Bereichs ab, in den ein Steuerelement eingefügt werden kann.</summary>
        <returns>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten von <xref:System.Windows.Forms.Control.GetPreferredSize%2A> unterscheidet sich durch das Steuerelement. Der <xref:System.Windows.Forms.Control.LayoutEngine%2A> kann die zurückgegebene Größe möglicherweise dem Steuerelement nicht zuweisen. Sie können eine Größe zurückgeben, die größer ist als die im `proposedSize`-Parameter aufgeführten Einschränkungen, aber `proposedSize` sollte abnehmen, wenn die Einschränkung abnimmt. Beispielsweise sollte `GetPreferredSize(new Size(100, 0))` nicht breiter als `GetPreferredSize(new Size(200, 0))` sein. Bei der Ausnahme handelt es sich um eine `proposedSize` von 0 oder `Size.Empty`, die als nicht eingeschränkt definiert sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">Ein <see cref="T:System.Drawing.Rectangle" />, das den Bereich angibt, für den die Anzeigebegrenzungen abgerufen werden sollen.</param>
        <param name="factor">Die Höhe und Breite der Begrenzungen des Steuerelements.</param>
        <param name="specified">Einer der Werte von <see cref="T:System.Windows.Forms.BoundsSpecified" />, die die Grenzen des Steuerelements angeben, die beim Definieren seiner Größe und Position anzugeben sind.</param>
        <summary>Ruft die Begrenzungen ab, innerhalb derer das Steuerelement skaliert wird.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen darstellt, innerhalb derer das Steuerelement skaliert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die von <xref:System.Windows.Forms.Control.ScaleControl%2A> aufgerufen wird, um die Begrenzungen abzurufen, innerhalb derer das Steuerelement skaliert wird. Sie können diese Methode überschreiben, um die <xref:System.Windows.Forms.Control.ScaleControl%2A>-Skalierungs Logik wiederzuverwenden, aber Sie müssen ihre eigenen Begrenzungen angeben. Die Standard Implementierung gibt skalierte Begrenzungen zurück, die die `specified`-Begrenzungen berücksichtigen, unabhängig davon, ob das Steuerelement die oberste Ebene ist, ob es sich um eine festgelegte Breite oder eine automatische Größe handelt und ob es sich bei dem Steuerelement um Zusatzelemente handelt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Das <see cref="T:System.Windows.Forms.ControlStyles" />-Bit, dessen Wert zurückgegeben werden soll.</param>
        <summary>Ruft den Wert für das angegebene Steuerelement-Formatbit für das Steuerelement ab.</summary>
        <returns><see langword="true" />, wenn das angegebene Steuerelement-Formatbit auf <see langword="true" /> festgelegt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelement-Bitflags werden verwendet, um unterstütztes Verhalten zu kategorisieren. Ein Steuerelement kann einen Stil aktivieren, indem er die <xref:System.Windows.Forms.Control.SetStyle%2A>-Methode aufrufen und das entsprechende <xref:System.Windows.Forms.ControlStyles>-Bit und den booleschen Wert übergibt, um das-Bit auf festzulegen. Um den Wert zu bestimmen, der einem angegebenen <xref:System.Windows.Forms.ControlStyles>-Bit zugewiesen ist, verwenden Sie die <xref:System.Windows.Forms.Control.GetStyle%2A>-Methode, und übergeben Sie den <xref:System.Windows.Forms.ControlStyles>-Member zum Auswerten von.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der mit doppelter Pufferung verknüpften stilbits für einen <xref:System.Windows.Forms.Form> zurückgegeben. In diesem Beispiel wird nur `true` zurückgegeben, wenn alle stilbits auf `true` festgelegt sind.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob es sich bei dem Steuerelement um ein Steuerelement der obersten Ebene handelt.</summary>
        <returns><see langword="true" />, wenn das Steuerelement ein Steuerelement der obersten Ebene ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines Ziehvorgangs ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis wird ausgelöst, wenn ein Drag & Drop-Vorgang gestartet wird. Mit dem <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis kann die Quelle eines Drag-Ereignisses die Darstellung des Mauszeigers ändern, um dem Benutzer visuelles Feedback während eines Drag & Drop-Vorgangs zu geben.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Continue` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragOver> ausgelöst, um den Vorgang fortzusetzen. das Ereignis <xref:System.Windows.Forms.Control.GiveFeedback> wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Drag & Drop-Vorgang zwischen zwei <xref:System.Windows.Forms.ListBox>-Steuerelementen veranschaulicht. Im Beispiel wird die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode aufgerufen, wenn die Zieh Aktion gestartet wird. Die Zieh Aktion wird gestartet, wenn die Maus während des <xref:System.Windows.Forms.Control.MouseDown>-Ereignisses mehr als <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> von der Mausposition bewegt hat. Die <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>-Methode wird verwendet, um den Index des Elements zu bestimmen, das während des `MouseDown`-Ereignisses gezogen werden soll.  
  
 Das Beispiel zeigt auch die Verwendung von benutzerdefinierten Cursorn für den Drag & Drop-Vorgang. Für das Beispiel ist es erforderlich, dass zwei Cursor Dateien, `3dwarro.cur` und `3dwno.cur`, im Anwendungsverzeichnis vorhanden sind, für die benutzerdefinierten Drag-und No-Drop-Cursor. Die benutzerdefinierten Cursor werden verwendet, wenn die `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> aktiviert ist. Die benutzerdefinierten Cursor werden im <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignishandler festgelegt.  
  
 Der Tastatur Zustand wird im <xref:System.Windows.Forms.Control.DragOver>-Ereignishandler für die Rechte `ListBox` ausgewertet, um zu bestimmen, welcher Zieh Vorgang auf dem Zustand der UMSCHALTTASTE, STRG, alt oder STRG + ALT-Taste basiert. Der Speicherort in der `ListBox`, an dem der Ablage Vorgang stattfindet, wird auch während des `DragOver`-Ereignisses festgelegt. Wenn es sich bei den zu Lösch Endes Daten nicht um einen `String` handelt, wird <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> in <xref:System.Windows.Forms.DragDropEffects> auf `None` festgelegt. Schließlich wird der Status der Ablage in der `DropLocationLabel` <xref:System.Windows.Forms.Label> angezeigt.  
  
 Die Daten, die für die Rechte `ListBox` (null) gelöscht werden, werden im <xref:System.Windows.Forms.Control.DragDrop>-Ereignishandler bestimmt, und der `String`-Wert wird an geeigneter Stelle in `ListBox` hinzugefügt. Wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird, wird der Drag & Drop-Vorgang im Ereignishandler <xref:System.Windows.Forms.Control.QueryContinueDrag> abgebrochen.  
  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignisses. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement den Fokus erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
 **Hinweis** Die Ereignisse <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> sind Fokus Ereignisse auf niedriger Ebene, die an die Windows-Meldungen WM_KILLFOCUS und WM_SETFOCUS gebunden sind. In der Regel werden die Ereignisse "<xref:System.Windows.Forms.Control.GotFocus>" und "<xref:System.Windows.Forms.Control.LostFocus>" nur beim Aktualisieren von <xref:System.Windows.Forms.UICues> oder beim Schreiben von benutzerdefinierten Steuerelementen verwendet. Stattdessen sollten die Ereignisse "<xref:System.Windows.Forms.Control.Enter>" und "<xref:System.Windows.Forms.Control.Leave>" für alle Steuerelemente mit Ausnahme der <xref:System.Windows.Forms.Form>-Klasse verwendet werden, die die <xref:System.Windows.Forms.Form.Activated>-und <xref:System.Windows.Forms.Form.Deactivate>-Ereignisse verwendet. Weitere Informationen zu den Ereignissen <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> finden Sie in den Themen [WM_SETFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx) und [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.GotFocus>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.GotFocus> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle ab, an das das Steuerelement gebunden ist.</summary>
        <value>Ein <see cref="T:System.IntPtr" /> mit dem Fensterhandle (<see langword="HWND" />) des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Windows.Forms.Control.Handle%2A>-Eigenschaft ist ein Windows-`HWND`. Wenn das Handle noch nicht erstellt wurde, wird durch das verweisen auf diese Eigenschaft erzwungen, dass das Handle erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> und der <xref:System.Windows.Forms.Control.Handle%2A>-Eigenschaft veranschaulicht. Fügen Sie den folgenden Code in ein Formular ein, um das Beispiel auszuführen. Fügen Sie dem Formular zwei Schaltflächen mit dem Namen `Button1` und `Button2` hinzu, und stellen Sie sicher, dass alle Ereignisse mit ihren Ereignis Handlern verbunden sind.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Handle für das Steuerelement erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Handle wird erstellt, wenn das <xref:System.Windows.Forms.Control> zum ersten Mal angezeigt wird. Wenn z. b. eine <xref:System.Windows.Forms.Control> erstellt wird, für die <xref:System.Windows.Forms.Control.Visible%2A> auf `false` festgelegt ist, wird das <xref:System.Windows.Forms.Control.HandleCreated>-Ereignis erst ausgelöst, wenn <xref:System.Windows.Forms.Control.Visible%2A> auf `true` festgelegt ist.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.HandleCreated>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.HandleCreated> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Handle des Steuerelements gerade zerstört wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während des <xref:System.Windows.Forms.Control.HandleDestroyed>-Ereignisses ist das Steuerelement weiterhin ein gültiges Windows-Steuerelement, und der <xref:System.Windows.Forms.Control.Handle%2A> kann durch Aufrufen der <xref:System.Windows.Forms.Control.RecreateHandle%2A>-Methode neu erstellt werden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.HandleDestroyed>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.HandleDestroyed> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement ein oder mehrere untergeordnete Steuerelemente enthält.</summary>
        <value><see langword="true" />, wenn das Steuerelement ein oder mehrere untergeordnete Steuerelemente enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.Controls%2A>-Auflistung einen <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> größer als 0 (null) aufweist, gibt die Eigenschaft <xref:System.Windows.Forms.Control.HasChildren%2A> `true` zurück. Durch den Zugriff auf die <xref:System.Windows.Forms.Control.HasChildren%2A>-Eigenschaft wird die Erstellung einer <xref:System.Windows.Forms.Control.ControlCollection> nicht erzwungen, wenn das Steuerelement keine untergeordneten Elemente aufweist. Daher kann das verweisen auf diese Eigenschaft einen Leistungsvorteil beim Durchlaufen einer Struktur von Steuerelementen bieten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Windows.Forms.Control.BackColor%2A> und <xref:System.Windows.Forms.Control.ForeColor%2A> der-Steuerelemente auf die Standardsystem Farben festgelegt. Der Code ruft rekursiv selbst auf, wenn das Steuerelement über untergeordnete Steuerelemente verfügt. Für dieses Codebeispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> mit mindestens einem untergeordneten Steuerelement verfügen. ein untergeordnetes Container Steuerelement, wie z. b. eine <xref:System.Windows.Forms.Panel> oder <xref:System.Windows.Forms.GroupBox>, mit einem eigenen untergeordneten Steuerelement (en) würde jedoch die Rekursion besser veranschaulichen.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Steuerelements ab bzw. legt diese fest.</summary>
        <value>Die Höhe des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen an den Eigenschafts Werten <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Top%2A> bewirken, dass sich der <xref:System.Windows.Forms.Control.Bottom%2A>-Eigenschafts Wert des Steuer Elements ändert.  
  
> [!NOTE]
>  Die Mindesthöhe für das abgeleitete Steuerelement <xref:System.Windows.Forms.Splitter> ist ein Pixel. Die Standardhöhe für das <xref:System.Windows.Forms.Splitter>-Steuerelement beträgt drei Pixel. Wenn Sie die Höhe des Steuer Elements <xref:System.Windows.Forms.Splitter> auf einen Wert kleiner als 1 festlegen, wird der Eigenschafts Wert auf die Standardhöhe zurückgesetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Benutzer die Hilfe für ein Steuerelement anfordert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ereignis <xref:System.Windows.Forms.Control.HelpRequested> wird häufig ausgelöst, wenn der Benutzer die F1-Taste drückt, oder wenn auf eine zugeordnete kontextabhängige Hilfe Schaltfläche geklickt wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Behandlung des <xref:System.Windows.Forms.Control.HelpRequested>-Ereignisses veranschaulicht, um benutzerdefinierte Hilfe Inhalte in einem Formular anzuzeigen, das vier Adressfelder enthält. Das <xref:System.Windows.Forms.Control.HelpRequested>-Ereignis wird entweder durch Drücken der F1-Taste mit dem Fokus in einem Adressfeld oder durch das Verwenden der kontextabhängigen Hilfe Schaltfläche und durch Klicken auf den Hilfe Cursor in einem Adressfeld ausgelöst. Die <xref:System.Windows.Forms.HelpEventArgs.Handled%2A>-Eigenschaft ist auf true festgelegt, um anzugeben, dass das `HelpRequested`-Ereignis behandelt wird. Das Beispiel veranschaulicht auch das Speichern des Hilfetexts in der <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verbirgt das Steuerelement vor dem Benutzer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie das Steuerelement ausblenden, entspricht dies dem Festlegen der <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft auf `false`. Nachdem die <xref:System.Windows.Forms.Control.Hide%2A>-Methode aufgerufen wurde, gibt die <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft den Wert `false` zurück, bis die <xref:System.Windows.Forms.Control.Show%2A>-Methode aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Schaltfläche ausgeblendet, wenn die STRG-Taste gedrückt wird, wenn auf die Schaltfläche geklickt wird. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Button> mit dem Namen `button1` auf einem <xref:System.Windows.Forms.Form> verfügen.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den IME-Modus (Eingabemethoden-Editor) des Steuerelements ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.ImeMode" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein IME ist ein Programm, mit dem Benutzer komplexe Zeichen und Symbole, wie z. b. japanische Kanji-Zeichen, mithilfe einer Standardtastatur eingeben können. Die <xref:System.Windows.Forms.Control.ImeMode%2A>-Eigenschaft wird in der Regel auf <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> für ein <xref:System.Windows.Forms.TextBox>-Steuerelement festgelegt, das nur numerische Werte eingeben soll. Der <xref:System.Windows.Forms.Control.ImeMode%2A>-Eigenschafts Wert ist für die <xref:System.Windows.Forms.Form>-Klasse auf <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> festgelegt.  
  
 Die meisten Klassen, die die Eingabemethoden-Editoren nicht direkt unterstützen oder direkte Eingaben aus einer IME zulassen, legen den Wert dieser Eigenschaft auf <xref:System.Windows.Forms.ImeMode.NoControl> fest.  
  
> [!IMPORTANT]
>  Der Benutzer kann die <xref:System.Windows.Forms.Control.ImeMode%2A> interaktiv ändern, sofern er nicht Programm gesteuert auf <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType> festgelegt wurde. In diesem Fall kann der Benutzer den IME nicht verwenden.  
>   
>  Die <xref:System.Windows.Forms.Control.ImeMode%2A>-Eigenschaft wird unter Windows 8 ignoriert, wenn der globale Eingabemodus wirksam ist. Weitere Informationen finden Sie unter [Switch Text Input from an Thread to User](https://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.ImeMode" />-Enumerationswerte.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den IME-Modus eines Steuerelements ab oder legt diesen fest.</summary>
        <value>Der IME-Modus des Steuerelements.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.ImeMode%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder durch Interaktion geändert wird.  
  
 Steuerelemente, die keine Eingabemethoden-Manager unterstützen, machen dieses Ereignis nie aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird nach dem Hinzufügen des Steuerelements zu einem anderen Container aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.InitLayout%2A>-Methode wird sofort nach dem Hinzufügen eines-Steuer Elements zu einem Container aufgerufen. Die <xref:System.Windows.Forms.Control.InitLayout%2A>-Methode ermöglicht es einem Steuerelement, seinen Layoutzustand basierend auf seinem Container zu initialisieren. Beispielsweise würden Sie in der Regel verankern und Andocken auf das Steuerelement in der <xref:System.Windows.Forms.Control.InitLayout%2A>-Methode anwenden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.InitLayout" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass die <see cref="M:System.Windows.Forms.Control.InitLayout" />-Methode der Basisklasse aufgerufen wird, damit das Steuerelement ordnungsgemäß angezeigt wird.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erklärt einen bestimmten Bereich des Steuerelements für ungültig und veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erklärt die ganze Oberfläche des Steuerelements für ungültig und bewirkt, dass das Steuerelement neu gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel kann der Benutzer ein Bild oder eine Bilddatei auf das Formular ziehen und ihn an dem Punkt, an dem er abgelegt wird, anzeigen lassen. Die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode wird überschrieben, um jedes Mal, wenn das Formular gezeichnet wird, das Bild neu zu zeichnen. Andernfalls wird das Bild nur bis zum nächsten Neuzeichnen beibehalten. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragEnter> bestimmt den Typ der Daten, die in das Formular gezogen werden, und stellt das entsprechende Feedback bereit. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragDrop> zeigt das Bild auf dem Formular an, wenn ein <xref:System.Drawing.Image> aus den Daten erstellt werden kann. Da die Werte <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Bildschirm Koordinaten sind, wird im Beispiel die <xref:System.Windows.Forms.Control.PointToClient%2A>-Methode verwendet, um Sie in Client Koordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren"><see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt einen bestimmten Bereich des Steuerelements für ungültig und veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig zu erklärenden Bereich darstellt.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">Die für ungültig zu erklärende <see cref="T:System.Drawing.Region" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig zu erklärenden Bereich darstellt.</param>
        <param name="invalidateChildren"><see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">Die für ungültig zu erklärende <see cref="T:System.Drawing.Region" />.</param>
        <param name="invalidateChildren"><see langword="true" />, um die untergeordneten Steuerelemente des Steuerelements für ungültig zu erklären, andernfalls <see langword="false" />.</param>
        <summary>Erklärt den angegebenen Bereich des Steuerelements für ungültig, indem es diesen dem Aktualisierungsbereich des Steuerelements hinzufügt. Dies ist der Bereich, der beim nächsten Zeichnenvorgang neu gezeichnet wird. Außerdem wird veranlasst, dass eine Zeichnenmeldung an das Steuerelement gesendet wird. Bei Bedarf wird das dem Steuerelement zugewiesene untergeordnete Steuerelement für ungültig erklärt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode aufrufen, wird eine synchrone Farbe nicht erzwungen. um eine synchrone Farbe zu erzwingen, rufen Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode auf, nachdem Sie die Methode <xref:System.Windows.Forms.Control.Invalidate%2A> aufgerufen haben. Wenn diese Methode ohne Parameter aufgerufen wird, wird der gesamte Client Bereich der Aktualisierungs Region hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn für die Anzeige eines Steuerelements eine Neuzeichnung erforderlich ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.Invalidated>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.Invalidated> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen Delegaten in dem Thread aus, der das dem Steuerelement zugrunde liegende Fensterhandle besitzt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der eine aufzurufende Methode im Threadkontext des Steuerelements enthält.</param>
        <summary>Führt den angegebenen Delegaten für den Thread aus, der das dem Steuerelement zugrunde liegende Fensterhandle besitzt.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaten ähneln Funktions Zeigern in C oder C++ Sprachen. Delegaten Kapseln einen Verweis auf eine Methode innerhalb eines Delegatobjekts. Das Delegatobjekt kann dann an den Code weitergeleitet werden, der die referenzierte Methode aufruft, und die aufzurufende Methode kann zur Kompilierzeit nicht bekannt sein. Im Gegensatz zu Funktions Zeigern C++in C oder sind Delegaten objektorientiert, typsicher und sicherer.  
  
 Die <xref:System.Windows.Forms.Control.Invoke%2A>-Methode sucht die übergeordnete Kette des Steuer Elements, bis ein Steuerelement oder ein Formular mit einem Fenster Handle gefunden wird, wenn das zugrunde liegende Fenster Handle des aktuellen Steuer Elements noch nicht vorhanden ist. Wenn kein entsprechendes Handle gefunden werden kann, löst die <xref:System.Windows.Forms.Control.Invoke%2A>-Methode eine Ausnahme aus. Ausnahmen, die während des Aufrufens ausgelöst werden, werden an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen.  
  
 Der Delegat kann eine Instanz von <xref:System.EventHandler> sein. in diesem Fall enthält der Sender-Parameter dieses Steuerelement, und der Ereignis Parameter enthält <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Der Delegat kann auch eine Instanz von <xref:System.Windows.Forms.MethodInvoker> oder ein beliebiger anderer Delegat sein, der eine void-Parameterliste annimmt. Ein Aufruf eines <xref:System.EventHandler>-oder <xref:System.Windows.Forms.MethodInvoker>-Delegaten ist schneller als ein Aufruf eines anderen Delegattyps.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht verarbeiten soll, nicht mehr aktiv ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Steuerelemente, die einen Delegaten enthalten. Der-Delegat kapselt eine Methode, die dem Listenfeld Elemente hinzufügt, und diese Methode wird auf dem Thread ausgeführt, der das zugrunde liegende Handle des Formulars besitzt. Wenn der Benutzer auf die Schaltfläche klickt, führt `Invoke` den Delegaten aus.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat einer Methode, der Parameter derselben Anzahl und desselben Typs der im <paramref name="args" />-Parameter enthaltenen Parameter annimmt.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Dieser Parameter kann <see langword="null" /> sein, wenn die Methode keine Argumente annimmt.</param>
        <summary>Führt mit der angegebenen Argumentliste den angegebenen Delegaten für den Thread aus, der das dem Steuerelement zugrunde liegende Fensterhandle besitzt.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Rückgabewert des aufgerufenen Delegaten enthält, oder <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaten ähneln Funktions Zeigern in C oder C++ Sprachen. Delegaten Kapseln einen Verweis auf eine Methode innerhalb eines Delegatobjekts. Das Delegatobjekt kann dann an den Code weitergeleitet werden, der die referenzierte Methode aufruft, und die aufzurufende Methode kann zur Kompilierzeit nicht bekannt sein. Im Gegensatz zu Funktions Zeigern C++in C oder sind Delegaten objektorientiert, typsicher und sicherer.  
  
 Wenn das Handle des Steuer Elements noch nicht vorhanden ist, durchsucht diese Methode die übergeordnete Kette des Steuer Elements, bis ein Steuerelement oder ein Formular gefunden wird, das über ein Fenster Handle verfügt. Wenn kein entsprechendes Handle gefunden werden kann, löst diese Methode eine Ausnahme aus. Ausnahmen, die während des Aufrufens ausgelöst werden, werden an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden für ein Steuerelement, die Thread sicher sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine der Aufruf Methoden verwenden, um den Aufruf an den Thread des Steuer Elements zu Mars Hallen.  
  
 Der Delegat kann eine Instanz von <xref:System.EventHandler> sein. in diesem Fall enthält der Sender-Parameter dieses Steuerelement, und der Ereignis Parameter enthält <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Der Delegat kann auch eine Instanz von <xref:System.Windows.Forms.MethodInvoker> oder ein beliebiger anderer Delegat sein, der eine void-Parameterliste annimmt. Ein Aufruf eines <xref:System.EventHandler>-oder <xref:System.Windows.Forms.MethodInvoker>-Delegaten ist schneller als ein Aufruf eines anderen Delegattyps.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht verarbeiten soll, nicht mehr aktiv ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Steuerelemente, die einen Delegaten enthalten. Der-Delegat kapselt eine Methode, die dem Listenfeld Elemente hinzufügt, und diese Methode wird auf dem Thread ausgeführt, der das zugrunde liegende Handle des Formulars besitzt, wobei die angegebenen Argumente verwendet werden. Wenn der Benutzer auf die Schaltfläche klickt, führt `Invoke` den Delegaten aus.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GotFocus" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LostFocus" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Das <see cref="T:System.Windows.Forms.Control" />, dem das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis zugewiesen werden soll.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see langword="PaintBackground" />-Ereignis für das angegebene Steuerelement aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISynchronizeInvoke.InvokeRequired</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt ob der Aufrufer beim Aufruf von Methoden des Steuerelements eine Aufrufmethode aufrufen muss, da sich der Aufrufer in einem anderen Thread als dem befindet, in dem das Steuerelement erstellt wurde.</summary>
        <value><see langword="true" />, wenn das <see cref="P:System.Windows.Forms.Control.Handle" /> des Steuerelements in einem anderen Thread als dem aufrufenden Thread erstellt wurde, sodass Aufrufe des Steuerelements durch eine Aufrufmethode erfolgen müssen), andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente in Windows Forms sind an einen bestimmten Thread gebunden und sind nicht Thread sicher. Wenn Sie also die-Methode eines Steuer Elements von einem anderen Thread aus aufrufen, müssen Sie eine der Aufruf Methoden des Steuer Elements verwenden, um den Aufruf an den richtigen Thread zu Mars Hallen. Diese Eigenschaft kann verwendet werden, um zu bestimmen, ob eine Aufruf Methode aufgerufen werden muss. Dies kann hilfreich sein, wenn Sie nicht wissen, welcher Thread das Steuerelement besitzt.  
  
> [!NOTE]
>  Neben der <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Eigenschaft gibt es vier Methoden auf einem Steuerelement, die Thread sicher aufzurufen sind: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> und <xref:System.Windows.Forms.Control.CreateGraphics%2A>, wenn das Handle für das Steuerelement bereits erstellt wurde. Wenn <xref:System.Windows.Forms.Control.CreateGraphics%2A> aufgerufen wird, bevor das Handle des Steuer Elements in einem Hintergrund Thread erstellt wurde, kann dies zu ungültigen Thread übergreifenden aufrufen führen. Für alle anderen Methodenaufrufe sollten Sie eine dieser Aufruf Methoden verwenden, wenn Sie von einem anderen Thread aufrufen.  
  
 Wenn das Handle des Steuer Elements noch nicht vorhanden ist, durchsucht <xref:System.Windows.Forms.Control.InvokeRequired%2A> die übergeordnete Kette des Steuer Elements, bis ein Steuerelement oder ein Formular gefunden wird, das über ein Fenster Handle verfügt. Wenn kein entsprechendes Handle gefunden werden kann, gibt die <xref:System.Windows.Forms.Control.InvokeRequired%2A>-Methode `false` zurück.  
  
 Dies bedeutet, dass <xref:System.Windows.Forms.Control.InvokeRequired%2A> `false` zurückgeben kann, wenn <xref:System.Windows.Forms.Control.Invoke%2A> nicht erforderlich ist (der-Vorgang tritt im gleichen Thread auf) oder wenn das Steuerelement in einem anderen Thread erstellt wurde, das Handle des Steuer Elements jedoch noch nicht erstellt wurde.  
  
 Wenn das Handle des Steuer Elements noch nicht erstellt wurde, sollten Sie nicht einfach Eigenschaften, Methoden oder Ereignisse für das Steuerelement aufzurufen. Dies könnte dazu führen, dass das Handle des Steuer Elements im Hintergrund Thread erstellt wird, wobei das Steuerelement in einem Thread ohne nachrichtenpump isoliert und die Anwendung instabil wird.  
  
 Sie können diesen Fall schützen, indem Sie auch den Wert <xref:System.Windows.Forms.Control.IsHandleCreated%2A> überprüfen, wenn <xref:System.Windows.Forms.Control.InvokeRequired%2A> `false` in einem Hintergrund Thread zurückgibt. Wenn das Steuerungs Handle noch nicht erstellt wurde, müssen Sie warten, bis es erstellt wurde, bevor Sie <xref:System.Windows.Forms.Control.Invoke%2A> oder <xref:System.Windows.Forms.Control.BeginInvoke%2A> aufrufen. Dies geschieht in der Regel nur, wenn ein Hintergrund Thread im Konstruktor des primären Formulars für die Anwendung erstellt wird (wie in `Application.Run(new MainForm())`, bevor das Formular angezeigt wird oder `Application.Run` aufgerufen wurde.  
  
 Eine Lösung besteht darin, zu warten, bis das Handle des Formulars erstellt wurde, bevor der Hintergrund Thread gestartet wird. Erzwingen Sie die Erstellung des Handles, indem Sie die <xref:System.Windows.Forms.Control.Handle%2A>-Eigenschaft aufrufen, oder warten Sie, bis das <xref:System.Windows.Forms.Form.Load>-Ereignis den Hintergrundprozess startet.  
  
 Eine noch bessere Lösung besteht darin, den von <xref:System.Threading.SynchronizationContext> zurückgegebenen `SynchronizationContext` anstelle eines Steuer Elements für Thread übergreifendes Marshalling zu verwenden.  
  
> [!NOTE]
>  Eine Ausnahme kann ausgelöst werden, wenn der Thread, der die Nachricht verarbeiten soll, nicht mehr aktiv ist.  
  
 Weitere Informationen zu Multithread-Windows Forms Steuerelementen finden Sie unter [gewusst wie: Verwenden Sie einen Hintergrund Thread für die Suche nach Dateien](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) und [gewusst wie: Führen Sie Thread sichere Aufrufe an Windows Forms Steuerelemente ](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md) aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement für barrierefreie Anwendungen sichtbar ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Steuerelement für barrierefreie Anwendungen sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement freigegeben wurde.</summary>
        <value><see langword="true" />, wenn das Steuerelement freigegeben wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft `true` zurückgibt, wird das Steuerelement verworfen und kann nicht mehr als gültiges Windows-Steuerelement referenziert werden. Obwohl die Instanz eines Steuer Elements verworfen wird, wird Sie weiterhin im Arbeitsspeicher beibehalten, bis Sie über Garbage Collection aus dem Arbeitsspeicher entfernt wird. Wenn ein Steuerelement verworfen wird, können Sie die <xref:System.Windows.Forms.Control.RecreateHandle%2A>-Methode nicht mehr aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dem Steuerelement ein Handle zugeordnet ist.</summary>
        <value><see langword="true" />, wenn dem Steuerelement ein Handle zugeordnet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.IsHandleCreated%2A>-Eigenschaft, um zu bestimmen, ob <xref:System.Windows.Forms.Control.CreateHandle%2A> aufgerufen wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu überprüfende Zeichen.</param>
        <summary>Bestimmt, ob ein Zeichen ein vom Steuerelement erkanntes Eingabezeichen ist.</summary>
        <returns><see langword="true" />, wenn das Zeichen direkt an das Steuerelement gesendet und nicht vorverarbeitet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.IsInputChar%2A>-Methode, um zu bestimmen, ob das vom `charCode`-Parameter angegebene Zeichen ein Eingabezeichen ist, das das Steuerelement wünscht. Diese Methode wird während der Vorverarbeitung von Fenster Meldungen aufgerufen, um zu bestimmen, ob das angegebene Eingabezeichen vorverarbeitet oder direkt an das Steuerelement gesendet werden soll. Wenn <xref:System.Windows.Forms.Control.IsInputChar%2A> `true` zurückgibt, wird das angegebene Zeichen direkt an das Steuerelement gesendet. Wenn <xref:System.Windows.Forms.Control.IsInputChar%2A> `false` zurückgibt, wird das angegebene Zeichen vorverarbeitet und nur an das Steuerelement gesendet, wenn es nicht von der Vorverarbeitungs Phase verwendet wird. Die Vorverarbeitung eines Zeichens umfasst das überprüfen, ob es sich um ein mnetmonisches Zeichen eines anderen Steuer Elements handelt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte.</param>
        <summary>Bestimmt, ob es sich bei der angegebenen Taste um eine normale Eingabetaste handelt oder um eine Sondertaste, für die eine Vorverarbeitung erforderlich ist.</summary>
        <returns><see langword="true" />, wenn die angegebene Taste eine normale Taste ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode, um zu bestimmen, ob es sich bei dem vom `keyData`-Parameter angegebenen Schlüssel um einen vom Steuerelement gewünschten Eingabe Schlüssel handelt. Diese Methode wird während der Vorverarbeitung von Fenster Meldungen aufgerufen, um zu bestimmen, ob der angegebene Eingabe Schlüssel vorverarbeitet oder direkt an das Steuerelement gesendet werden soll. Wenn <xref:System.Windows.Forms.Control.IsInputKey%2A> `true` zurückgibt, wird der angegebene Schlüssel direkt an das Steuerelement gesendet. Wenn <xref:System.Windows.Forms.Control.IsInputKey%2A> `false` zurückgibt, wird der angegebene Schlüssel vorverarbeitet und nur an das Steuerelement gesendet, wenn er von der Vorverarbeitungs Phase nicht genutzt wird. Zu den vorverarbeiteten Schlüsseln zählen Registerkarte, Rückgabe, ESC-Taste, Pfeil nach oben, Pfeil nach unten, Pfeil nach links und nach-rechts-Taste.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode für ein <xref:System.Windows.Forms.TextBox>-Steuerelement überschreiben. In diesem Beispiel übernimmt die `TabTextBox`-Klasse die Tab-Taste. Wenn die `TabTextBox` den Fokus besitzt und der Benutzer die Tab-Taste drückt, werden an der Text Einfügemarke vier Leerzeichen hinzugefügt, wobei der ausgewählte Text ersetzt wird. Standardmäßig verarbeitet das <xref:System.Windows.Forms.TextBox>-Steuerelement die Tab-Taste, indem der Eingabefokus auf das nächste Steuerelement verschoben wird. In diesem Fall erreicht das KeyPress niemals die Außerkraftsetzungs Methode <xref:System.Windows.Forms.Control.OnKeyDown%2A>. Um dieses Standardverhalten zu verhindern, gibt die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methoden Überschreibung `true` zurück, wenn der Benutzer die Tab-Taste drückt. Für alle anderen Tastatureingaben gibt die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methoden Überschreibung das Ergebnis des Aufruf der Basisklassen Version der Methode zurück.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="keyVal">Der FESTSTELLTASTE-, NUM- oder ROLLEN-Member der <see cref="T:System.Windows.Forms.Keys" />-Enumeration.</param>
        <summary>Bestimmt, ob die FESTSTELLTASTE, NUM oder ROLLEN aktiviert ist.</summary>
        <returns><see langword="true" />, wenn die angegebenen Tasten aktiviert sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.Control.IsKeyLocked%2A>-Eigenschaft, um zu bestimmen, ob die Schlüssel für die Feststell Taste, die Num-Taste oder die Schiebe Sperrtaste eingeschaltet sind  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Meldungs Feld angezeigt, das angibt, ob der angegebene Schlüssel (in diesem Fall der Schlüssel Sperr Schlüssel) wirksam ist.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der <paramref name="keyVal" />-Parameter verweist auf eine andere Taste als die FESTSTELLTASTE, NUM oder ROLLEN.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement gespiegelt wird.</summary>
        <value><see langword="true" />, wenn das Steuerelement gespiegelt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein gespiegeltes Steuerelement zeigt Layout und Text von rechts nach links an. Weitere Informationen finden Sie unter [Vorgehensweise: Erstellen Sie gespiegelte Windows Forms und Steuerelemente](https://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu überprüfende Zeichen.</param>
        <param name="text">Die zu durchsuchende Zeichenfolge.</param>
        <summary>Bestimmt, ob das angegebene Zeichen das mnemonische Zeichen ist, das dem Steuerelement in der angegebenen Zeichenfolge zugewiesen wurde.</summary>
        <returns><see langword="true" />, wenn das <paramref name="charCode" />-Zeichen das dem Steuerelement zugewiesene mnemonische Zeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zeichen "mnetmonic" ist das Zeichen, das unmittelbar auf die erste Instanz von "&" in einem <xref:System.String> folgt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Erweiterung der Button-Klasse veranschaulicht, die die <xref:System.Windows.Forms.Control.ProcessMnemonic%2A>-Methode überschreibt, um benutzerdefiniertes Verhalten zu zeigen. Im Beispiel wird auch die Verwendung der Eigenschaften <xref:System.Windows.Forms.Control.CanSelect%2A> und <xref:System.Windows.Forms.Control.IsMnemonic%2A> veranschaulicht. Fügen Sie den folgenden Code nach einer Formular Klasse in dieselbe Datei ein, um dieses Beispiel auszuführen. Fügen Sie dem Formular eine Schaltfläche vom Typ `MnemonicButton` hinzu.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Taste gedrückt wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wichtige Ereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Wenn Sie Tastatur Ereignisse nur auf der Formular Ebene verarbeiten und keine anderen Steuerelemente zum Empfangen von Tastatur Ereignissen aktivieren möchten, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>-Eigenschaft in der <xref:System.Windows.Forms.Control.KeyPress>-Ereignis Behandlungsmethode des Formulars auf `true` fest. Bestimmte Schlüssel, z. b. die Registerkarten-, Rückgabe-, ESC-und Pfeiltasten, werden automatisch von Steuerelementen behandelt. Damit diese Schlüssel das <xref:System.Windows.Forms.Control.KeyDown>-Ereignis erhöhen, müssen Sie die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode in jedem Steuerelement auf dem Formular überschreiben. Der Code für die Überschreibung des <xref:System.Windows.Forms.Control.IsInputKey%2A> müsste ermitteln, ob einer der Sonderschlüssel gedrückt ist, und gibt den Wert `true` zurück. Anstatt die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode zu überschreiben, können Sie das <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignis behandeln und die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>-Eigenschaft auf `true` festlegen. Ein Codebeispiel finden Sie unter <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignis.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Ereignis <xref:System.Windows.Forms.Control.KeyDown> verwendet, um den Typ des Zeichens zu bestimmen, das in das Steuerelement eingegeben wird.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
 Im folgenden Codebeispiel wird die Reihenfolge veranschaulicht, in der die Ereignisse <xref:System.Windows.Forms.Control.KeyDown>, <xref:System.Windows.Forms.Control.KeyUp>, <xref:System.Windows.Forms.Control.KeyPress> und registriert werden.  
 
 [!code-csharp[Control.KeyDown#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyDown#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Zeichen-, die LEER- oder RÜCKTASTE gedrückt wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wichtige Ereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Das Ereignis "<xref:System.Windows.Forms.Control.KeyPress>" wird nicht von nicht-Zeichen Schlüsseln, außer Leerzeichen und Rückraum, ausgelöst. bei nicht-Zeichen Schlüsseln werden jedoch die <xref:System.Windows.Forms.Control.KeyDown>-und <xref:System.Windows.Forms.Control.KeyUp>-Ereignisse erhoben.  
  
 Verwenden Sie die <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A>-Eigenschaft, um zur Laufzeit Stichproben von Tastatureingaben auszuführen und eine Teilmenge allgemeiner Tastatureingaben zu nutzen oder zu ändern.  
  
 Wenn Sie Tastatur Ereignisse nur auf der Formular Ebene verarbeiten und keine anderen Steuerelemente zum Empfangen von Tastatur Ereignissen aktivieren möchten, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>-Eigenschaft in der <xref:System.Windows.Forms.Control.KeyPress>-Ereignis Behandlungsmethode des Formulars auf `true` fest.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Ereignis <xref:System.Windows.Forms.Control.KeyPress> verwendet, um zu verhindern, dass Zeichen in das Steuerelement eingegeben werden.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
  Im folgenden Codebeispiel wird die Reihenfolge veranschaulicht, in der die Ereignisse "<xref:System.Windows.Forms.Control.KeyDown>", "<xref:System.Windows.Forms.Control.KeyUp>" und "<xref:System.Windows.Forms.Control.KeyPress>" aufsteigend angezeigt werden. Außerdem wird die Registrierung von Ereignis Handlern  
 
 [!code-csharp[Control.KeyPress#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyPress#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Taste losgelassen wird, während das Steuerelement den Fokus hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wichtige Ereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Wenn Sie Tastatur Ereignisse nur auf der Formular Ebene verarbeiten und keine anderen Steuerelemente zum Empfangen von Tastatur Ereignissen aktivieren möchten, legen Sie die <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>-Eigenschaft in der <xref:System.Windows.Forms.Control.KeyPress>-Ereignis Behandlungsmethode des Formulars auf `true` fest. Bestimmte Schlüssel, z. b. die Registerkarten-, Rückgabe-, ESC-und Pfeiltasten, werden automatisch von Steuerelementen behandelt. Damit diese Schlüssel das <xref:System.Windows.Forms.Control.KeyUp>-Ereignis erhöhen, müssen Sie die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode in jedem Steuerelement auf dem Formular überschreiben. Der Code für die Überschreibung von <xref:System.Windows.Forms.Control.IsInputKey%2A> müsste ermitteln, ob einer der Sonderschlüssel gedrückt ist, und gibt den Wert `true` zurück.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.KeyUp>-Ereignis mit der <xref:System.Windows.Forms.Help>-Klasse verwendet, um dem Benutzer eine Popup-Format Hilfe anzuzeigen.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
 
 
  Im folgenden Codebeispiel wird die Reihenfolge veranschaulicht, in der die Ereignisse "<xref:System.Windows.Forms.Control.KeyDown>", "<xref:System.Windows.Forms.Control.KeyUp>" und "<xref:System.Windows.Forms.Control.KeyPress>" aufsteigend angezeigt werden. Außerdem wird die Registrierung von Ereignis Handlern  
 
 [!code-csharp[Control.KeyUp#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyUp#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Steuerelement seine untergeordneten Steuerelemente neu positionieren muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.Layout>-Ereignis tritt auf, wenn untergeordnete Steuerelemente hinzugefügt oder entfernt werden, wenn sich die Begrenzungen des Steuer Elements ändern und wenn andere Änderungen auftreten, die sich auf das Layout des Steuer Elements auswirken können. Das layoutereignis kann mithilfe der Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> unterdrückt werden. Durch das Anhalten des Layouts können Sie mehrere Aktionen für ein Steuerelement ausführen, ohne für jede Änderung ein Layout ausführen zu müssen. Wenn Sie z. b. die Größe ändern und ein Steuerelement verschieben, würde jeder Vorgang ein <xref:System.Windows.Forms.Control.Layout>-Ereignis auslösen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.Form> auf dem Bildschirm im <xref:System.Windows.Forms.Control.Layout>-Ereignis zentriert. Dadurch bleibt das Formular zentriert, wenn der Benutzer die Größe ändert. Für dieses Beispiel ist es erforderlich, dass Sie ein <xref:System.Windows.Forms.Form>-Steuerelement erstellt haben.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine zwischengespeicherte Instanz der Layout-Engine des Steuerelements ab.</summary>
        <value>Die <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> für den Inhalt des Steuerelements.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.LayoutEngine%2A>-Eigenschaft ruft die Layout-Engine für die untergeordneten Elemente des Steuer Elements und nicht für das Steuerelement selbst ab.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Eingabefokus das Steuerelement verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
> [!NOTE]
>  Die Ereignisse <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> werden von der <xref:System.Windows.Forms.Form>-Klasse unterdrückt. Die äquivalenten Ereignisse in der <xref:System.Windows.Forms.Form>-Klasse sind die Ereignisse <xref:System.Windows.Forms.Form.Activated> und <xref:System.Windows.Forms.Form.Deactivate>. Die Ereignisse <xref:System.Windows.Forms.Control.Enter> und <xref:System.Windows.Forms.Control.Leave> sind hierarchisch und werden in der übergeordneten Kette nach oben und unten verschoben, bis das entsprechende Steuerelement erreicht wird. Angenommen, Sie verfügen über eine <xref:System.Windows.Forms.Form> mit zwei <xref:System.Windows.Forms.GroupBox>-Steuerelementen, und jedes <xref:System.Windows.Forms.GroupBox>-Steuerelement verfügt über ein <xref:System.Windows.Forms.TextBox>-Steuerelement. Wenn die Einfügemarke von einem <xref:System.Windows.Forms.TextBox> zum anderen verschoben wird, wird das <xref:System.Windows.Forms.Control.Leave>-Ereignis für die <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.GroupBox> ausgelöst, und das <xref:System.Windows.Forms.Control.Enter>-Ereignis wird für die anderen <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TextBox> ausgelöst.  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Leave>-Ereignis verwendet, um ein-Steuerelement auf seinen vorherigen Zustand zurückzusetzen.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem linken Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem linken Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.Control.Left%2A>-Eigenschafts Wert entspricht der Eigenschaft <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> des <xref:System.Windows.Forms.Control.Location%2A>-Eigenschafts Werts des Steuer Elements.  
  
 Änderungen an den Eigenschafts Werten <xref:System.Windows.Forms.Control.Width%2A> und <xref:System.Windows.Forms.Control.Left%2A> bewirken, dass sich der <xref:System.Windows.Forms.Control.Right%2A>-Eigenschafts Wert des Steuer Elements ändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Koordinaten der linken oberen Ecke des Steuerelements relativ zur linken oberen Ecke des Containers ab oder legt diese fest.</summary>
        <value>Der <see cref="T:System.Drawing.Point" />, der die linke obere Ecke des Steuerelements relativ zur linken oberen Ecke des Containers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Drawing.Point>-Klasse ein Werttyp (`Structure` in Visual Basic, `struct` in C#Visual) ist, wird Sie als Wert zurückgegeben, was bedeutet, dass der Zugriff auf die-Eigenschaft eine Kopie des linken oberen Punkts des Steuer Elements zurückgibt. Das Anpassen der Eigenschaften "<xref:System.Drawing.Point.X%2A>" oder "<xref:System.Drawing.Point.Y%2A>" der von dieser Eigenschaft zurückgegebenen <xref:System.Drawing.Point> wirkt sich daher nicht auf die Eigenschaftswerte <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A> oder <xref:System.Windows.Forms.Control.Bottom%2A> des Steuer Elements aus. Wenn Sie diese Eigenschaften anpassen möchten, legen Sie jeden Eigenschafts Wert einzeln fest, oder legen Sie die <xref:System.Windows.Forms.Control.Location%2A>-Eigenschaft mit einem neuen <xref:System.Drawing.Point> fest.  
  
 Wenn die <xref:System.Windows.Forms.Control> ein <xref:System.Windows.Forms.Form> ist, stellt der <xref:System.Windows.Forms.Control.Location%2A>-Eigenschafts Wert die linke obere Ecke des <xref:System.Windows.Forms.Form> in Bildschirm Koordinaten dar.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.GroupBox> erstellt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird ein <xref:System.Windows.Forms.TextBox> erstellt und dessen <xref:System.Windows.Forms.Control.Location%2A> innerhalb des Gruppen Felds festgelegt. Anschließend wird die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft des Gruppen Felds festgelegt und das Gruppenfeld an den oberen Rand des Formulars angedockt. Schließlich wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft auf `false` festgelegt wird. Dies bewirkt, dass alle im Gruppenfeld enthaltenen Steuerelemente deaktiviert werden.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Location" />-Eigenschaftswert geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Location%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder durch Interaktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.LocationChanged>-Ereignis auf einem <xref:System.Windows.Forms.StatusStrip> ausgelöst, wenn die Größe des Formulars geändert wird.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public System.Drawing.Size LogicalToDeviceUnits (System.Drawing.Size value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size LogicalToDeviceUnits(valuetype System.Drawing.Size value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size LogicalToDeviceUnits(System::Drawing::Size value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Eine Größe, die skaliert werden soll.</param>
        <summary>Transformiert eine Größe von logischen in Geräteeinheiten, indem es sie entsprechend des aktuellen DPI-Werts skaliert und auf den nächsten ganzzahligen Wert für Breite und Höhe abrundet.</summary>
        <returns>Die skalierte Größe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende logische Wert.</param>
        <summary>Konvertiert einen logischen DPI-Wert in den entsprechenden DeviceUnit-DPI-Wert.</summary>
        <returns>Der resultierende DeviceUnit-Wert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement den Fokus verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
 Wenn die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft des <xref:System.ComponentModel.CancelEventArgs> im <xref:System.Windows.Forms.Control.Validating>-Ereignis Delegaten auf `true` festgelegt ist, werden alle Ereignisse, die normalerweise auftreten, nachdem das <xref:System.Windows.Forms.Control.Validating>-Ereignis unterdrückt wurde.  
  
> [!NOTE]
>  Bei den Ereignissen <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> handelt es sich um Fokus Ereignisse auf niedriger Ebene, die an die Windows-Meldungen WM_KILLFOCUS und WM_SETFOCUS gebunden sind. In der Regel werden die Ereignisse "<xref:System.Windows.Forms.Control.GotFocus>" und "<xref:System.Windows.Forms.Control.LostFocus>" nur beim Aktualisieren von <xref:System.Windows.Forms.UICues> oder beim Schreiben von benutzerdefinierten Steuerelementen verwendet. Stattdessen sollten die Ereignisse "<xref:System.Windows.Forms.Control.Enter>" und "<xref:System.Windows.Forms.Control.Leave>" für alle Steuerelemente mit Ausnahme der <xref:System.Windows.Forms.Form>-Klasse verwendet werden, die die <xref:System.Windows.Forms.Form.Activated>-und <xref:System.Windows.Forms.Form.Deactivate>-Ereignisse verwendet. Weitere Informationen zu den Ereignissen <xref:System.Windows.Forms.Control.GotFocus> und <xref:System.Windows.Forms.Control.LostFocus> finden Sie in den Themen [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) und [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Validieren des Texts für textBox1 veranschaulicht. Außerdem wird die Behandlung des <xref:System.Windows.Forms.Control.LostFocus>-Ereignisses veranschaulicht, indem die Eigenschaft <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> auf den Text in TextBox1 festgelegt wird. Im Codebeispiel wurde die <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType>-Methode verwendet, um vor dem Öffnen des Dialog Felds "Datei" einen Fehler zu überprüfen. Fügen Sie zum Ausführen dieses Beispiels den folgenden Code in ein Formular ein, das eine <xref:System.Windows.Forms.TextBox> mit dem Namen "`TextBox1`", eine <xref:System.Windows.Forms.OpenFileDialog> mit dem Namen "`OpenFileDialog1`", eine <xref:System.Windows.Forms.Button> mit dem Namen "`Button1`" und ein <xref:System.Windows.Forms.ErrorProvider> mit dem Namen "`ErrorProvider1` Stellen Sie sicher, dass alle Ereignisse ihren Ereignis Handlern zugeordnet sind.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zwischenraum zwischen Steuerelementen ab oder legt ihn fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das den Zwischenraum zwischen Steuerelementen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente erhalten Standardwerte für <xref:System.Windows.Forms.Control.Margin%2A>, die in angemessener Nähe zu den Richtlinien der Windows-Benutzeroberfläche gehören. Einige Anpassungen sind für bestimmte Anwendungen möglicherweise noch erforderlich.  
  
> [!NOTE]
>  Das Festlegen der <xref:System.Windows.Forms.Control.Margin%2A>-Eigenschaft für ein angedocktes Steuerelement wirkt sich nicht auf den Abstand des Steuer Elements von den Rändern seines Containers aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Rand des Steuerelements geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.MarginChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.MarginChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe ab, die die Obergrenze bildet, die <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> angeben kann, oder legt diese fest.</summary>
        <value>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe ab, die die Untergrenze bildet, die <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> angeben kann, oder legt diese fest.</summary>
        <value>Ein geordnetes Paar vom Typ <see cref="T:System.Drawing.Size" />, das die Breite und Höhe eines Rechtecks darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, welche der Zusatztasten (Umschalttaste, STRG und ALT) gedrückt ist.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.Keys" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine Schaltfläche ausgeblendet, wenn die STRG-Taste gedrückt wird, während auf die Schaltfläche geklickt wird. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Button> mit dem Namen `button1` auf einem <xref:System.Windows.Forms.Form> verfügen.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, welche Maustasten gedrückt sind.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.MouseButtons" />-Enumerationswerte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit dem Namen Form1 ein, das mehrere Steuerelemente enthält. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.MouseDown>-, <xref:System.Windows.Forms.Control.MouseMove>-und <xref:System.Windows.Forms.Control.MouseUp>-Ereignisse mit den Ereignis Handlern verbunden sind, die im Beispiel definiert sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement die Mausaufzeichnung verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In seltenen Szenarios müssen Sie möglicherweise unerwartete Eingaben erkennen. Beachten Sie z. b. die folgenden Szenarien:  
  
-   Während einer Maus wird der Benutzer das Startmenü durch Drücken der Windows-Taste oder STRG + ESC geöffnet.  
  
-   Während eines Mauszeigers wechselt der Benutzer durch Drücken von Alt + Tab zu einem anderen Programm.  
  
-   Während einer Maus Operation zeigt ein anderes Programm ein Fenster oder ein Meldungs Feld an, das den Fokus von der aktuellen Anwendung entfernt.  
  
 Maus Vorgänge können das Klicken und halten der Maus auf ein Formular oder ein Steuerelement oder das Ausführen eines Maus Zieh Vorgangs einschließen. Wenn Sie erkennen müssen, wenn ein Formular oder ein Steuerelement die Maus Aufzeichnung für diese und verwandte unerwartete Szenarien verliert, können Sie das Ereignis <xref:System.Windows.Forms.Control.MouseCaptureChanged> verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.MouseCaptureChanged>-Ereignis für ein <xref:System.Windows.Forms.Button>-Steuerelement veranschaulicht.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Um dieses Beispiel zu testen, führen Sie es im Debugger aus, indem Sie F5 drücken. Öffnen Sie das **Ausgabe** Fenster in Visual Studio, damit Sie sehen können, wann Ereignisse ausgelöst werden. Klicken Sie auf die <xref:System.Windows.Forms.Button>, und beachten Sie die folgende Ausgabe.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 Klicken Sie nun mit der linken Maustaste auf das <xref:System.Windows.Forms.Button>-Steuerelement. Wenn Sie auf die Maus klicken, drücken Sie Alt + Tab, um zu einem anderen Programm zu wechseln. Beachten Sie, dass das <xref:System.Windows.Forms.Control.MouseCaptureChanged>-Ereignis ausgelöst wird, sodass Sie dieses Szenario potenziell verarbeiten können. Abhängig von den Aktionen wird das Ereignis <xref:System.Windows.Forms.Control.MouseUp> möglicherweise nicht ausgelöst. Sie können diesen Test auch mit der Windows-Taste oder STRG + ESC testen.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn mit der Maus auf das Steuerelement geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Maustaste gedrückt wird, wenn sich der Cursor über einem Steuerelement befindet, werden in der Regel die folgenden Ereignisse aus dem-Steuerelement ausgelöst:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> -Ereignis.  
  
2.  <xref:System.Windows.Forms.Control.Click> -Ereignis.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> -Ereignis.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> -Ereignis.  
  
 Damit dies geschehen kann, können die verschiedenen Ereignisse in der-Klasse des Steuer Elements nicht deaktiviert werden.  
  
 Zwei einzelne Klicks, die in der Zeit genau genug vorkommen, wie durch die Mauseinstellungen des Betriebssystems des Benutzers festgelegt, generieren ein <xref:System.Windows.Forms.Control.MouseDoubleClick>-Ereignis anstelle des zweiten <xref:System.Windows.Forms.Control.MouseClick>-Ereignisses.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click>-Ereignisse sind logisch übergeordnete Ereignisse eines-Steuer Elements. Sie werden häufig durch andere Aktionen ausgelöst, z. b. durch Drücken der EINGABETASTE, wenn das Steuerelement den Fokus besitzt.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.MouseClick>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.MouseClick> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn mit der Maus auf das Steuerelement doppelgeklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.MouseDoubleClick>-Ereignis tritt auf, wenn der Benutzer eine Maustaste zweimal in der schnell Folge drückt, wenn sich der Cursor über dem Steuerelement befindet. Das Zeitintervall, in dem zwei einzelne Klicks von einem Doppelklick getrennt werden, hängt von den Mauseinstellungen des Betriebssystems des Benutzers ab.  
  
 Die folgende Ereignis Reihe wird vom-Steuerelement ausgelöst, wenn eine solche Benutzeraktion stattfindet:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> -Ereignis.  
  
2.  <xref:System.Windows.Forms.Control.Click> -Ereignis.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> -Ereignis.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> -Ereignis.  
  
5.  <xref:System.Windows.Forms.Control.MouseDown> -Ereignis.  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick> -Ereignis.  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick> -Ereignis.  
  
8.  <xref:System.Windows.Forms.Control.MouseUp> -Ereignis.  
  
 Damit dies geschehen kann, können die verschiedenen Ereignisse in der-Klasse des Steuer Elements nicht deaktiviert werden.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick>-Ereignisse sind logisch übergeordnete Ereignisse eines-Steuer Elements. Sie können von anderen Benutzeraktionen, z. b. Tastenkombinationen, ausgelöst werden.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.MouseDoubleClick>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.MouseDoubleClick> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger in den Bereich des Steuerelements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger auf dem Steuerelement verbleibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine typische Verwendung von <xref:System.Windows.Forms.Control.MouseHover> ist die Anzeige einer QuickInfo, wenn der Mauszeiger an einem Steuerelement innerhalb eines angegebenen Bereichs um das Steuerelement (das "Hover-Rechteck") hält. Die für das ausgelöst dieses Ereignisses erforderliche Pause wird von der <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>-Eigenschaft in Millisekunden angegeben.  
  
 Das Ereignis "<xref:System.Windows.Forms.Control.MouseHover>" wird in Verbindung mit den Eigenschaften "<xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A>" und "<xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>" definiert und erkannt.  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger den Bereich des Steuerelements verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Mauszeiger über dem Steuerelement bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typische Verwendungen von <xref:System.Windows.Forms.Control.MouseMove> sind das Ändern der Farbe des Steuer Elements oder das Zeichnen eines erhöhten Rechtecks um das Steuerelement.  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Mauszeigers in Bildschirmkoordinaten ab.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der die Koordinaten des Mauszeigers relativ zur linken oberen Ecke des Bildschirms enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.MousePosition%2A>-Eigenschaft gibt einen <xref:System.Drawing.Point> zurück, der die Position des Mauszeigers zum Zeitpunkt der referenzierten Eigenschaft darstellt. Die Koordinaten geben die Position auf dem Bildschirm an, nicht relativ zum Steuerelement und werden unabhängig davon zurückgegeben, ob der Cursor über dem Steuerelement positioniert ist. Die Koordinaten der oberen linken Ecke des Bildschirms sind 0, 0.  
  
 Die <xref:System.Windows.Forms.Control.MousePosition%2A>-Eigenschaft ist identisch mit der Eigenschaft <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.TreeNode>-Bezeichnung in einen bearbeitbaren Zustand versetzt, wenn der Benutzer ALT + E drückt, während sich der Mauszeiger über dem Struktur Knoten befindet. Nachdem der Benutzer mit dem Bearbeiten der Bezeichnung abgeschlossen ist, können die Bezeichnungen erst wieder bearbeitet werden, wenn die Tastenkombination ALT + E gedrückt wurde. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.TreeView> für einen <xref:System.Windows.Forms.Form> verfügen. Die Strukturansicht sollte in der <xref:System.Windows.Forms.TreeView.Nodes%2A>-Auflistung auch mindestens eine <xref:System.Windows.Forms.TreeNode> aufweisen.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Die folgenden Ereignisse werden für die <xref:System.Windows.Forms.TabControl>-Klasse nur ausgelöst, wenn mindestens ein <xref:System.Windows.Forms.TabPage> in der <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>-Sammlung vorhanden ist: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> und <xref:System.Windows.Forms.Control.MouseMove>. Wenn in der Auflistung mindestens eine <xref:System.Windows.Forms.TabPage> vorhanden ist und der Benutzer mit dem Header des Registerkarten-Steuer Elements interagiert (wo die <xref:System.Windows.Forms.TabPage>-Namen angezeigt werden), löst der <xref:System.Windows.Forms.TabControl> das entsprechende Ereignis aus. Wenn sich die Benutzerinteraktion jedoch im Client Bereich der Registerkarte befindet, löst die <xref:System.Windows.Forms.TabPage> das entsprechende Ereignis aus.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Mausrad gedreht wird, während das Steuerelement fokussiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Verarbeitung des <xref:System.Windows.Forms.Control.MouseWheel>-Ereignisses ist es wichtig, die dem Mausrad zugeordneten Benutzeroberflächen Standards einzuhalten. Der <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType>-Eigenschafts Wert gibt den Betrag an, um den das Mausrad verschoben wurde. Die Benutzeroberfläche sollte scrollen, wenn das akkumulierte Delta plus oder minus 120 ist. Die Benutzeroberfläche sollte in der Anzahl der von der <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>-Eigenschaft zurückgegebenen logischen Zeilen für jeden erreichten Delta Wert einen Bildlauf durchführen. Sie können auch in weniger als 120 Einheiten Inkrementen einen Bildlauf durchführen. das Verhältnis sollte jedoch konstant bleiben, d. h., <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>-Zeilen, die pro 120 Delta Einheiten der Radbewegung gescrollt werden.  
  
 Weitere Informationen zum Verarbeiten von Mausrad Nachrichten finden Sie im Thema [WM_MOUSEWHEEL](https://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx) .  
  
 Mausereignisse treten in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung verschiedener Mausereignisse zum Zeichnen des Mauszeigers auf einem <xref:System.Windows.Forms.Panel> veranschaulicht. Ein Liniensegment wird dem <xref:System.Drawing.Drawing2D.GraphicsPath> für jedes eintreten <xref:System.Windows.Forms.Control.MouseMove> und <xref:System.Windows.Forms.Control.MouseDown>-Ereignisse hinzugefügt. Um die Grafik zu aktualisieren, wird die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode für die <xref:System.Windows.Forms.Panel> für jedes `MouseDown`-und `MouseUp`-Ereignis aufgerufen. Außerdem wird der grafische Pfad nach oben oder unten gescrollt, wenn das <xref:System.Windows.Forms.Control.MouseWheel>-Ereignis auftritt. Weitere Mausereignisse, wie z. b. <xref:System.Windows.Forms.Control.MouseHover>, werden ebenfalls auf dem Bildschirm identifiziert. Auch auf dem Bildschirm angezeigt werden zusätzliche Informationen über die Maus aus der <xref:System.Windows.Forms.SystemInformation>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Verschieben des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Move>-Ereignis verwendet, um die Position des Formulars in Bildschirm Koordinaten auf der Titelleiste des Formulars anzuzeigen.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Steuerelements ab oder legt diesen fest.</summary>
        <value>Der Name des Steuerelements. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Name%2A>-Eigenschaft kann zur Laufzeit verwendet werden, um das Objekt anhand des Namens anstelle des Typs und des programmgesteuerten namens auszuwerten. Da die <xref:System.Windows.Forms.Control.Name%2A>-Eigenschaft einen <xref:System.String>-Typ zurückgibt, kann Sie im Case-Style Logic-Anweisungen (`Select`-Anweisung in Visual Basic, `switch` C# -Anweisung in Visual und [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]) ausgewertet werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.Name%2A> eines-Steuer Elements in einem <xref:System.Windows.Forms.MessageBox> angezeigt, wenn das Steuerelement einem Formular hinzugefügt oder daraus entfernt wird.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">Ein <see cref="T:System.Drawing.Rectangle" />, das den für ungültig erklärten Bereich darstellt.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Invalidated" />-Ereignis aus, wobei ein angegebener Bereich des Steuerelements für ungültig erklärt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackColorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackColorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.UICuesEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ChangeUICues" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnChangeUICues%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Click" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.OnClick%2A>-Methode in einer abgeleiteten Klasse überschrieben wird. Fügen Sie den folgenden Code nach einer Formular Klasse in dieselbe Datei ein, um das Beispiel auszuführen. Fügen Sie dem Formular ein Textfeld vom Typ `SingleClickTextBox` hinzu.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 Im folgenden Codebeispiel wird eine der vielen Verwendungsmöglichkeiten des <xref:System.Windows.Forms.Control.Click>-Ereignisses und-Ereignis Handlers veranschaulicht.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.ControlEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ControlAdded" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, wenn dem Steuerelement ein untergeordnetes Steuerelement hinzugefügt wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnControlAdded%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Windows.Forms.Control.ControlAdded> verwendet, um ein-Steuerelement zu einem Formular hinzuzufügen, und der Name des hinzugefügten Steuer Elements wird in einem <xref:System.Windows.Forms.MessageBox> angezeigt.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.ControlEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ControlRemoved" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, wenn ein untergeordnetes Steuerelement aus dem Steuerelement entfernt wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnControlRemoved%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Windows.Forms.Control.ControlRemoved> verwendet, um ein-Steuerelement aus einem Formular zu entfernen, und der Name des entfernten Steuer Elements wird in einem <xref:System.Windows.Forms.MessageBox> angezeigt.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst die <see cref="M:System.Windows.Forms.Control.CreateControl" />-Methode aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.OnCreateControl%2A>-Methode wird aufgerufen, wenn das Steuerelement erstmalig erstellt wird.  
  
 Mit der <xref:System.Windows.Forms.Control.OnCreateControl%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCreateControl" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CursorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnCursorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DockChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDockChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DoubleClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDoubleClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.DoubleClick>-Ereignis einer <xref:System.Windows.Forms.ListBox> verwendet, um die im <xref:System.Windows.Forms.ListBox> aufgeführten Textdateien in ein <xref:System.Windows.Forms.TextBox>-Steuerelement zu laden.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" /> -Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragDrop" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragDrop%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragEnter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragLeave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragOver" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnDragOver%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.EnabledChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnEnabledChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Enter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Enter>-Ereignis verwendet, um die Vordergrund-und Hintergrundfarben einer <xref:System.Windows.Forms.TextBox> unter bestimmten Bedingungen zu ändern.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnFontChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnForeColorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Ein <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GiveFeedback" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnGiveFeedback%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.GotFocus" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnGotFocus%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleCreated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHandleCreated%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Ein <see cref="T:System.Windows.Forms.HelpEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.HelpRequested" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnHelpRequested%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnImeModeChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.InvalidateEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Invalidated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnInvalidated%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Ereignis <xref:System.Windows.Forms.Control.KeyDown> verwendet, um den Typ des Zeichens zu bestimmen, das in das Steuerelement eingegeben wird.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyPressEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyPress" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyPress%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Ereignis <xref:System.Windows.Forms.Control.KeyPress> verwendet, um zu verhindern, dass Zeichen in das Steuerelement eingegeben werden.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.KeyUp" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnKeyUp%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.KeyUp>-Ereignis mit der <xref:System.Windows.Forms.Help>-Klasse verwendet, um dem Benutzer eine Popup-Format Hilfe anzuzeigen.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Ein <see cref="T:System.Windows.Forms.LayoutEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Layout" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLayout%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass die <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />-Methode der Basisklasse aufgerufen wird, damit registrierte Delegaten das Ereignis empfangen und typische Andock-und Verankerungs Funktionen funktionieren. Abgeleitete Klassen sollten diese Methode für jede beliebige benutzerdefinierte Layoutlogik überschreiben.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Leave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Leave>-Ereignis verwendet, um ein-Steuerelement auf seinen vorherigen Zustand zurückzusetzen.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LocationChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLocationChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName* -`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.LostFocus" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnLostFocus%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MarginChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMarginChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseEnter" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseEnter%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseHover" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseHover%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden <xref:System.Windows.Forms.Control.OnMouseHover%2A> und <xref:System.Windows.Forms.Control.OnMouseMove%2A> in einer abgeleiteten Klasse überschrieben werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein neues Formular ein, und fügen Sie diese Klasse, die dieselbe Datei bildet, nach dem Formular ein. Fügen Sie dem Formular eine Schaltfläche vom Typ `FunButton` hinzu.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseLeave" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseLeave%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseMove" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseMove%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Methoden <xref:System.Windows.Forms.Control.OnMouseHover%2A> und <xref:System.Windows.Forms.Control.OnMouseMove%2A> in einer abgeleiteten Klasse überschrieben werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein neues Formular ein, und fügen Sie diese Klasse, die dieselbe Datei bildet, nach dem Formular ein. Fügen Sie dem Formular eine Schaltfläche vom Typ `FunButton` hinzu.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseUp" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseUp%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.MouseWheel" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMouseWheel%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Move" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnMove%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Move>-Ereignis verwendet, um die Position des Formulars in Bildschirm Koordinaten auf der Titelleiste des Formulars anzuzeigen.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die die Windows-Meldung darstellt.</param>
        <summary>Benachrichtigt das Steuerelement über Windows-Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.OnNotifyMessage%2A>-Methode wird aufgerufen, wenn das `EnableNotifyMessage`-Stilbit des Steuer Elements in <xref:System.Windows.Forms.ControlStyles> festgelegt ist. Mit dem `EnableNotifyMessage`-Stil in <xref:System.Windows.Forms.ControlStyles> kann das Steuerelement benachrichtigt werden, wenn die <xref:System.Windows.Forms.Control.WndProc%2A>-Methode eine Windows-Meldung empfängt. Mit dieser Methode können halb vertrauenswürdige Steuerelemente auf Windows-Nachrichten lauschen, ohne Sie zum Ändern der Nachricht zu aktivieren.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> in einer abgeleiteten Klasse überschrieben wird, ist das Aufrufen der <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />-Methode der Basisklasse nicht erforderlich, da keine anfängliche Implementierung vorhanden ist.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.PaddingChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnPaddingChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel kann der Benutzer ein Bild oder eine Bilddatei auf das Formular ziehen und an dem Punkt angezeigt werden, an dem Sie abgelegt wurde. Die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode wird überschrieben, um jedes Mal, wenn das Formular gezeichnet wird, das Bild neu zu zeichnen. Andernfalls wird das Bild nur bis zum nächsten Neuzeichnen beibehalten. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragEnter> bestimmt den Typ der Daten, die in das Formular gezogen werden, und stellt das entsprechende Feedback bereit. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragDrop> zeigt das Bild auf dem Formular an, wenn ein <xref:System.Drawing.Image> aus den Daten erstellt werden kann. Da die Werte <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Bildschirm Koordinaten sind, wird im Beispiel die <xref:System.Windows.Forms.Control.PointToClient%2A>-Methode verwendet, um Sie in Client Koordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" /> mit Informationen zum zu zeichnenden Steuerelement.</param>
        <summary>Zeichnet den Hintergrund des Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Windows.Forms.Control.OnPaintBackground%2A>-Methode können abgeleitete Klassen Windows-Hintergrund Lösch Anforderungen verarbeiten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Erbende Klassen sollten diese Methode überschreiben, um die Lösch Hintergrund Anforderung von Windows zu verarbeiten. Wenn <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> in einer abgeleiteten Klasse überschrieben wird, ist es nicht erforderlich, die <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> der Basisklasse aufzurufen.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackColorChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BackgroundImage" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.BindingContext" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ParentChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.CursorChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.EnabledChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Enabled" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.FontChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentFontChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.VisibleChanged" />-Ereignis aus, wenn sich der <see cref="P:System.Windows.Forms.Control.Visible" />-Eigenschaftswert des Containers ändert, zu dem das Steuerelement gehört.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Paint" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das `UserPaint`-Bit des <xref:System.Windows.Forms.ControlStyles> festgelegt ist, können Sie <xref:System.Windows.Forms.Control.OnPrint%2A> überschreiben, um eine geschichtete Darstellung durchzuführen. Weitere Informationen finden Sie unter <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Ein <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem der Zieh Vorgang begonnen hat, wird diese Methode wiederholt vom [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] aufgerufen, bis der Zieh Vorgang abgebrochen oder abgeschlossen ist.  
  
> [!NOTE]
>  Überschreiben Sie diese Methode, wenn Sie den Punkt ändern möchten, an dem der Zieh Vorgang abgebrochen wird oder bei dem eine Ablage auftritt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RegionChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.Windows.Forms.Control.OnRegionChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Resize" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnResize%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen. Die <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />-Methode kann während der Erstellung aufgerufen werden. Wenn Sie also <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> überschreiben, kann Sie aufgerufen werden, bevor der steuerungskonstruktor aufgerufen wird.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.SizeChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnSizeChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.StyleChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnStyleChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TabStopChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnTabStopChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.TextChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnTextChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Validated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnValidated%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.CancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.Validating" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnValidating%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.VisibleChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Die <xref:System.Windows.Forms.Control.OnVisibleChanged%2A>-Methode ermöglicht es abgeleiteten Klassen auch, das Ereignis zu verarbeiten, ohne einen Delegaten anzufügen. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist eine Ereignis erbende Methode, die ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster `On`*propertyName*`Changed`, die das entsprechende *propertyName*-`Changed`-Ereignis hervorrufen, wenn der *propertyName* -Wert geändert wird (*propertyName* stellt das der Name der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer abgeleiteten <xref:System.Windows.Forms.TextBox>-Klasse geändert, die Währungs Daten anzeigt. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine Klasse verfügen, die von der Klasse <xref:System.Windows.Forms.TextBox> abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welche Abstände innerhalb des Steuerelements verwendet werden.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Padding" />, das die internen Abstandsmerkmale des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Container wie <xref:System.Windows.Forms.GroupBox> und <xref:System.Windows.Forms.TabControl> ruft die <xref:System.Windows.Forms.Control.Padding%2A>-Eigenschaft ihre jeweiligen <xref:System.Windows.Forms.Control.DisplayRectangle%2A>-Eigenschaften ab oder legt Sie fest. Die <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType>-Eigenschaft ist gleich ihrer <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Steuerelemente erhalten Standardwerte für <xref:System.Windows.Forms.Control.Padding%2A>, die in angemessener Nähe zu den Richtlinien der Windows-Benutzeroberfläche gehören. Einige Anpassungen sind für bestimmte Anwendungen möglicherweise noch erforderlich.  
  
 Alle Steuerelemente, die <xref:System.Windows.Forms.Control.GetPreferredSize%2A> implementieren, werden um den Betrag in <xref:System.Windows.Forms.Control.Padding%2A> vergrößert, wenn <xref:System.Windows.Forms.Control.AutoSize%2A> `true` ist.  
  
 Die folgenden Steuerelemente verwenden nicht <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   Steuerelemente, die <xref:System.Windows.Forms.Control.AutoSize%2A> bis <xref:System.Windows.Forms.Control.GetPreferredSize%2A> nicht implementieren  
  
-   Benutzerdefinierte Steuerelemente, die direkt von <xref:System.Windows.Forms.Control> erben  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Abstand des Steuerelements geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.PaddingChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.PaddingChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement neu gezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.Paint>-Ereignis wird ausgelöst, wenn das Steuerelement neu gezeichnet wird. Sie übergibt eine Instanz von <xref:System.Windows.Forms.PaintEventArgs> an die Methoden, die das <xref:System.Windows.Forms.Control.Paint>-Ereignis verarbeiten.  
  
 Beim Erstellen eines neuen benutzerdefinierten Steuer Elements oder eines geerbten Steuer Elements mit einer anderen visuellen Darstellung müssen Sie Code zum Rendering des Steuer Elements bereitstellen, indem Sie die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode überschreiben. Weitere Informationen finden Sie unter Überschreiben [der OnPaint-Methode](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) und [benutzerdefiniertes Zeichnen und Rendern von Steuer](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md)Elementen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.PictureBox>-Steuerelement auf dem Formular erstellt und das <xref:System.Windows.Forms.Control.Paint>-Ereignis zum Zeichnen verwendet.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den übergeordneten Container des Steuerelements ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Control" />, das das übergeordnete Element oder das Container-Steuerelement des Steuerelements darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den <xref:System.Windows.Forms.Control.Parent%2A>-Eigenschafts Wert auf `null` festlegen, wird das Steuerelement aus dem <xref:System.Windows.Forms.Control.ControlCollection> seines aktuellen übergeordneten Steuer Elements entfernt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Windows.Forms.Control.Parent%2A>-Eigenschaft und die <xref:System.Windows.Forms.Control.FindForm%2A>-Methode verwendet, um Eigenschaften für das übergeordnete Steuerelement einer Schaltfläche und deren Form festzulegen.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschafts Wert zu erhalten. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Parent" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Parent%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzwingt die Anwendung von Layoutlogik auf untergeordnete Steuerelemente durch das Steuerelement.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt die Anwendung von Layoutlogik durch das Steuerelement auf sämtliche diesem untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode vor dem Aufruf der <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode aufgerufen wurde, wird das Ereignis <xref:System.Windows.Forms.Control.Layout> unterdrückt.  
  
 Die Eigenschaften <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> und <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> der erstellten <xref:System.Windows.Forms.LayoutEventArgs> sind auf `null` festgelegt, wenn beim Aufrufen der Methode <xref:System.Windows.Forms.Control.PerformLayout%2A> keine Werte angegeben wurden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode verwenden. Außerdem wird veranschaulicht, wie das <xref:System.Windows.Forms.Control.Layout>-Ereignis ausgelöst wird. In diesem Beispiel ruft der `Click`-Ereignishandler für `Button1` explizit <xref:System.Windows.Forms.Control.PerformLayout%2A> auf. Der `Click`-Ereignishandler für `Button2` ruft implizit <xref:System.Windows.Forms.Control.PerformLayout%2A> auf. <xref:System.Windows.Forms.Control.PerformLayout%2A> wird auch aufgerufen, wenn das Formular geladen wird. `Button3` gibt das Steuerelement in den Zustand zurück, in dem es sich beim Laden befand. In jedem Fall wird das Ereignis <xref:System.Windows.Forms.Control.Layout> ausgelöst.  
  
 Dies ist ein umfassendes Beispiel. Fügen Sie den folgenden Code in ein leeres Formular ein, um das Beispiel auszuführen.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">Ein <see cref="T:System.Windows.Forms.Control" />, das das zuletzt geänderte Steuerelement darstellt.</param>
        <param name="affectedProperty">Der Name der zuletzt geänderten Eigenschaft des Steuerelements.</param>
        <summary>Erzwingt die Anwendung von Layoutlogik durch das Steuerelement auf sämtliche diesem untergeordneten Steuerelemente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode vor dem Aufruf der <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode aufgerufen wurde, wird das Ereignis <xref:System.Windows.Forms.Control.Layout> unterdrückt.  
  
 Die Parameter "`affectedControl`" und "`affectedProperty`" können beide auf "`null`" festgelegt werden. Dadurch werden die Eigenschaften <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> und <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> der erstellten <xref:System.Windows.Forms.LayoutEventArgs> auf `null` festgelegt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Windows.Forms.Control.PerformLayout%2A>-Methode verwenden. Außerdem wird veranschaulicht, wie das <xref:System.Windows.Forms.Control.Layout>-Ereignis ausgelöst wird. In diesem Beispiel ruft der `Click`-Ereignishandler für `Button1` explizit <xref:System.Windows.Forms.Control.PerformLayout%2A> auf. Der `Click`-Ereignishandler für `Button2` ruft implizit <xref:System.Windows.Forms.Control.PerformLayout%2A> auf. <xref:System.Windows.Forms.Control.PerformLayout%2A> wird auch aufgerufen, wenn das Formular geladen wird. `Button3` gibt das Steuerelement in den Zustand zurück, in dem es sich beim Laden befand. In jedem Fall wird das Ereignis <xref:System.Windows.Forms.Control.Layout> ausgelöst.  
  
 Dies ist ein umfassendes Beispiel. Fügen Sie den folgenden Code in ein leeres Formular ein, um das Beispiel auszuführen.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Der zu konvertierende Bildschirmkoordinaten-<see cref="T:System.Drawing.Point" />.</param>
        <summary>Rechnet die Position des angegebenen Bildschirmpunkts in Clientkoordinaten um.</summary>
        <returns>Ein <see cref="T:System.Drawing.Point" />, der den konvertierten <see cref="T:System.Drawing.Point" />, <paramref name="p" />, in Clientkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel kann der Benutzer ein Bild oder eine Bilddatei auf das Formular ziehen und ihn an dem Punkt, an dem er abgelegt wird, anzeigen lassen. Die <xref:System.Windows.Forms.Control.OnPaint%2A>-Methode wird überschrieben, um jedes Mal, wenn das Formular gezeichnet wird, das Bild neu zu zeichnen. Andernfalls wird das Bild nur bis zum nächsten Neuzeichnen beibehalten. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragEnter> bestimmt den Typ der Daten, die in das Formular gezogen werden, und stellt das entsprechende Feedback bereit. Die Ereignis Behandlungsmethode <xref:System.Windows.Forms.Control.DragDrop> zeigt das Bild auf dem Formular an, wenn ein <xref:System.Drawing.Image> aus den Daten erstellt werden kann. Da die Werte <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> Bildschirm Koordinaten sind, wird im Beispiel die <xref:System.Windows.Forms.Control.PointToClient%2A>-Methode verwendet, um Sie in Client Koordinaten zu konvertieren.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Der zu konvertierende Clientkoordinaten-<see cref="T:System.Drawing.Point" />.</param>
        <summary>Rechnet die Position des angegebenen Clientpunkts in Bildschirmkoordinaten um.</summary>
        <returns>Ein <see cref="T:System.Drawing.Point" />, der den konvertierten <see cref="T:System.Drawing.Point" />, <paramref name="p" />, in Bildschirmkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit dem Namen Form1 ein, das mehrere Steuerelemente enthält. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.MouseDown>-, <xref:System.Windows.Forms.Control.MouseMove>-und <xref:System.Windows.Forms.Control.MouseUp>-Ereignisse mit den Ereignis Handlern verbunden sind, die im Beispiel definiert sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe eines rechteckigen Bereichs ab, in den das Steuerelement eingepasst werden kann.</summary>
        <value>Eine <see cref="T:System.Drawing.Size" />, die die Höhe und Breite in Pixel enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage : Message -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">Eine <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Meldung angibt.</param>
        <summary>Führt eine Vorverarbeitung der Tastatur- oder Eingabemeldungen in der Nachrichtenschleife aus, bevor sie gesendet werden.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.PreProcessControlState" />-Werte, je nachdem, ob <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> den Wert <see langword="true" /> oder <see langword="false" /> besitzt und ob <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> oder <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> den Wert <see langword="true" /> oder <see langword="false" /> besitzt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage : Message -&gt; bool&#xA;override this.PreProcessMessage : Message -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Meldung darstellt. Die möglichen Werte sind WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR und WM_SYSCHAR.</param>
        <summary>Führt eine Vorverarbeitung der Tastatur- oder Eingabemeldungen in der Nachrichtenschleife aus, bevor sie gesendet werden.</summary>
        <returns><see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> wird von der Nachrichten Schleife der Anwendung aufgerufen, um Eingabe Nachrichten vor der Verteilung vorzuverarbeiten. Mögliche Werte für den Parameter "`msg`" sind WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR und WM_SYSCHAR.  
  
 Beim Überschreiben von <xref:System.Windows.Forms.Control.PreProcessMessage%2A> sollte ein Steuerelement `true` zurückgeben, um anzugeben, dass die Nachricht verarbeitet wurde. Bei Nachrichten, die nicht vom Steuerelement verarbeitet werden, sollte das Ergebnis `base.PreProcessMessage` zurückgegeben werden. Steuerelemente Überschreiben in der Regel eine der spezialisierteren Methoden, z. b. <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> oder <xref:System.Windows.Forms.Control.ProcessDialogKey%2A>, anstatt <xref:System.Windows.Forms.Control.PreProcessMessage%2A> zu überschreiben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, für die der unmittelbare Aufrufer diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt vor dem <see cref="E:System.Windows.Forms.Control.KeyDown" />-Ereignis ein, wenn eine Taste gedrückt wird, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Tastenkombinationen, wie z. b. die Registerkarten-, Rückgabe-, ESC-und Pfeiltasten, werden in der Regel von einigen Steuerelementen ignoriert, da Sie nicht als EINGABETASTE gedrückt werden. Beispielsweise werden von einem <xref:System.Windows.Controls.Button>-Steuerelement standardmäßig die Pfeiltasten ignoriert. Wenn Sie die Pfeiltasten drücken, wird der Fokus in der Regel auf das vorherige oder das nächste Steuerelement verschoben. Die Pfeiltasten werden als Navigationsschlüssel betrachtet. Wenn Sie diese Tasten drücken, wird das <xref:System.Windows.Forms.Control.KeyDown>-Ereignis für ein <xref:System.Windows.Controls.Button> normalerweise nicht angehoben. Wenn Sie jedoch die Pfeiltasten für eine <xref:System.Windows.Controls.Button> drücken, wird das <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignis angehoben. Wenn Sie das <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignis für ein <xref:System.Windows.Controls.Button> behandeln und die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>-Eigenschaft auf `true` festlegen, können Sie das <xref:System.Windows.Forms.Control.KeyDown>-Ereignis beim Drücken der Pfeiltasten erhöhen. Wenn Sie jedoch die Pfeiltasten behandeln, wird der Fokus nicht mehr auf das vorherige oder das nächste Steuerelement verschoben.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.Button> veranschaulicht, die eine <xref:System.Windows.Forms.ContextMenuStrip> enthält. Wenn die <xref:System.Windows.Forms.Button> den Fokus besitzt und Sie die nach-oben-oder nach-unten-Taste drücken, wird die <xref:System.Windows.Forms.ContextMenuStrip> angezeigt. Der <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignishandler erkennt, wenn die nach-oben-oder nach-unten-Taste gedrückt wird, und legt die Eigenschaft <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> auf `true` fest. Dadurch wird das Ereignis <xref:System.Windows.Forms.Control.KeyDown> ausgelöst, sodass Sie die <xref:System.Windows.Forms.ContextMenuStrip> anzeigen können. Sie sollten keine Logik in den <xref:System.Windows.Forms.Control.PreviewKeyDown>-Ereignishandler einfügen, außer um die <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>-Eigenschaft festzulegen. Stattdessen sollten Sie die Logik in den <xref:System.Windows.Forms.Control.KeyDown>-Ereignishandler einfügen.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey : Message * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey : Message * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Befehlstaste.</summary>
        <returns><see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird während der Nachrichten Vorverarbeitung aufgerufen, um Befehlstasten zu verarbeiten. Befehlstasten sind Schlüssel, die immer Vorrang vor regulären Eingabe Schlüsseln haben. Beispiele für Befehlstasten sind Accelerators und Menü Verknüpfungen. Die Methode muss `true` zurückgeben, um anzugeben, dass Sie den Befehls Schlüssel verarbeitet hat, oder `false`, um anzugeben, dass es sich bei dem Schlüssel nicht um einen Befehls Schlüssel handelt. Diese Methode wird nur aufgerufen, wenn das Steuerelement in einer Windows Forms Anwendung oder als ActiveX-Steuerelement gehostet wird.  
  
 Die <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>-Methode bestimmt zunächst, ob das Steuerelement einen <xref:System.Windows.Forms.ContextMenu> aufweist, und ermöglicht, wenn dies der Fall ist, dem <xref:System.Windows.Forms.ContextMenu>, den Befehls Schlüssel zu verarbeiten. Wenn es sich bei dem Befehls Schlüssel nicht um eine Kontextmenü Verknüpfung handelt und das Steuerelement über ein übergeordnetes Element verfügt, wird der Schlüssel an die <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>-Methode des übergeordneten Elements Der Nettoeffekt ist, dass die Befehlstasten in der Steuerelement Hierarchie "Bubbled" sind. Zusätzlich zu dem Schlüssel, den der Benutzer gedrückt hat, gibt die Schlüsseldaten auch an, welche Modifizierertasten ggf. zur gleichen Zeit wie der Schlüssel gedrückt wurden. Modifizierertasten enthalten die Tasten UMSCHALT, STRG und alt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer und erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />-Methode in einer abgeleiteten Klasse überschrieben wird, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs der <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />-Methode der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein Dialogfeldzeichen.</summary>
        <returns><see langword="true" />, wenn das Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird während der Meldungs Vorverarbeitung aufgerufen, um Dialogfelder zu verarbeiten, z. b. Steuerelement-mnetmonics. Diese Methode wird nur aufgerufen, wenn die <xref:System.Windows.Forms.Control.IsInputChar%2A>-Methode angibt, dass das-Steuerelement das Zeichen nicht verarbeitet. Die <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>-Methode sendet das Zeichen einfach an die <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>-Methode des übergeordneten Elements oder gibt `false` zurück, wenn das Steuerelement über kein übergeordnetes Element verfügt. Die <xref:System.Windows.Forms.Form>-Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung von Dialog Zeichen auszuführen. Diese Methode wird nur aufgerufen, wenn das Steuerelement in einer Windows Forms Anwendung oder als ActiveX-Steuerelement gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />-Methode in einer abgeleiteten Klasse überschrieben wird, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es das Zeichen verarbeitet hat. Für Zeichen, die nicht vom-Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs der <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />-Methode der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Einer der <see cref="T:System.Windows.Forms.Keys" />-Werte, die die zu verarbeitende Taste darstellen.</param>
        <summary>Verarbeitet eine Tastatureingabe im Dialogfeld.</summary>
        <returns><see langword="true" />, wenn die Taste vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird während der Meldungs Vorverarbeitung aufgerufen, um Dialogfelder, z. b. Tabstopps, Rückgabe, ESC und Pfeiltasten, zu verarbeiten. Diese Methode wird nur aufgerufen, wenn die <xref:System.Windows.Forms.Control.IsInputKey%2A>-Methode angibt, dass das Steuerelement den Schlüssel nicht verarbeitet. Der <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> sendet das Zeichen einfach an die <xref:System.Windows.Forms.Control.ProcessDialogKey%2A>-Methode des übergeordneten Elements oder gibt `false` zurück, wenn das Steuerelement über kein übergeordnetes Element verfügt. Die <xref:System.Windows.Forms.Form>-Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung von Dialog Schlüsseln auszuführen. Diese Methode wird nur aufgerufen, wenn das Steuerelement in einer Windows Forms Anwendung oder als ActiveX-Steuerelement gehostet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />-Methode in einer abgeleiteten Klasse überschrieben wird, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs der <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />-Methode der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs : Message -&gt; bool&#xA;override this.ProcessKeyEventArgs : Message -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Verarbeitet eine Tastenmeldung und generiert die entsprechenden Steuerelementereignisse.</summary>
        <returns><see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Steuerelement eine Tastatur Meldung empfängt. Die-Methode ist dafür verantwortlich, die entsprechenden Schlüsselereignisse für die Nachricht zu erzeugen, indem Sie die <xref:System.Windows.Forms.Control.OnKeyPress%2A>-, <xref:System.Windows.Forms.Control.OnKeyDown%2A>-oder <xref:System.Windows.Forms.Control.OnKeyUp%2A>-Methode aufrufen. Der `m`-Parameter enthält die Fenster Meldung, die verarbeitet werden muss. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>-Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP und WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />-Methode in einer abgeleiteten Klasse überschrieben wird, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs der <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />-Methode der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage : Message -&gt; bool&#xA;override this.ProcessKeyMessage : Message -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Verarbeitet eine Tastaturmeldung.</summary>
        <returns><see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Steuerelement eine Tastatur Meldung empfängt. Die Methode bestimmt zunächst, ob das Steuerelement über ein übergeordnetes Element verfügt. Wenn dies der Fall ist, wird die <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>-Methode des übergeordneten Elements aufgerufen. Wenn die <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>-Methode des übergeordneten Elements die Nachricht nicht verarbeitet, wird die <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A>-Methode aufgerufen, um die entsprechenden Tastatur Ereignisse zu generieren. Der `m`-Parameter enthält die Fenster Meldung, die verarbeitet werden muss. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>-Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP und WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />-Methode überschreiben, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom-Steuerelement verarbeitet werden, sollte das Ergebnis der <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> der Basisklasse zurückgegeben werden. Steuerelemente müssen, falls immer, diese Methode überschreiben.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview : Message -&gt; bool&#xA;override this.ProcessKeyPreview : Message -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Eine als Verweis übergebene <see cref="T:System.Windows.Forms.Message" />, die die zu verarbeitende Fenstermeldung darstellt.</param>
        <summary>Zeigt eine Tastaturmeldung in der Vorschau an.</summary>
        <returns><see langword="true" />, wenn die Meldung vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einem untergeordneten Steuerelement aufgerufen, wenn das untergeordnete Steuerelement eine Tastatur Meldung empfängt. Das untergeordnete Steuerelement ruft diese Methode auf, bevor Tastatur Ereignisse für die Nachricht erzeugt werden. Wenn diese Methode `true` zurückgibt, betrachtet das untergeordnete Steuerelement die verarbeitete Nachricht und generiert keine Tastatur Ereignisse. Der `m`-Parameter enthält die Fenster Meldung, die in der Vorschau angezeigt wird. Mögliche Werte für die <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>-Eigenschaft sind WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP und WM_SYSKEYUP. Die <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>-Methode sendet das Zeichen einfach an die <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>-Methode des übergeordneten Elements oder gibt `false` zurück, wenn das Steuerelement über kein übergeordnetes Element verfügt. Die <xref:System.Windows.Forms.Form>-Klasse überschreibt diese Methode, um die tatsächliche Verarbeitung von Dialog Schlüsseln auszuführen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Wenn die <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />-Methode in einer abgeleiteten Klasse überschrieben wird, sollte ein Steuerelement <see langword="true" /> zurückgeben, um anzugeben, dass es den Schlüssel verarbeitet hat. Bei Schlüsseln, die nicht vom Steuerelement verarbeitet werden, sollte das Ergebnis des Aufrufs der <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />-Methode der Basisklasse zurückgegeben werden.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberSignature Language="C#" Value="protected virtual bool ProcessMnemonic (char charCode);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessMnemonic (charCode As Char) As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessMnemonic(char charCode);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Das zu verarbeitende Zeichen.</param>
        <summary>Verarbeitet ein mnemonisches Zeichen.</summary>
        <returns><see langword="true" />, wenn das Zeichen als mnemonisches Zeichen vom Steuerelement verarbeitet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, um einem Steuerelement die Möglichkeit zu geben, ein mnetmonisches Zeichen zu verarbeiten. Die-Methode sollte bestimmen, ob sich das Steuerelement in einem Zustand befindet, in dem mnetmonics verarbeitet werden soll, und ob das angegebene Zeichen ein mnetmonisches Zeichen darstellt. Wenn dies der Fall ist, sollte die-Methode die dem mnetmonischen zugeordnete Aktion ausführen und `true` zurückgeben. Wenn dies nicht der Wert ist, sollte die Methode `false` zurückgeben. Implementierungen dieser Methode verwenden häufig die <xref:System.Windows.Forms.Control.IsMnemonic%2A>-Methode, um zu bestimmen, ob das angegebene Zeichen mit einem mnetmonischen im Text des Steuer Elements übereinstimmt.  
  
 Beispiel:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Diese Standard Implementierung der <xref:System.Windows.Forms.Control.ProcessMnemonic%2A>-Methode gibt einfach `false` zurück, um anzugeben, dass das Steuerelement über kein mnetmonisches verfügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Erweiterung der Button-Klasse veranschaulicht, die die <xref:System.Windows.Forms.Control.ProcessMnemonic%2A>-Methode überschreibt, um benutzerdefiniertes Verhalten zu zeigen. Im Beispiel wird auch die Verwendung der Eigenschaften <xref:System.Windows.Forms.Control.CanSelect%2A> und <xref:System.Windows.Forms.Control.IsMnemonic%2A> veranschaulicht. Fügen Sie den folgenden Code nach einer Formular Klasse in dieselbe Datei ein, um dieses Beispiel auszuführen. Fügen Sie dem Formular eine Schaltfläche vom Typ `MnemonicButton` hinzu.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster für erbende Klassen, um diese Methode aufzurufen. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Produktnamen der Assembly ab, die das Steuerelement enthält.</summary>
        <value>Der Produktname der Assembly, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ProductName%2A>-Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft zu ändern, legen Sie den <xref:System.Reflection.AssemblyProductAttribute.Product%2A>-Eigenschafts Wert von <xref:System.Reflection.AssemblyProductAttribute> fest. Mit C# der folgenden Codezeile wird die <xref:System.Windows.Forms.Control.ProductName%2A>-Eigenschaft festgelegt.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, den Firmennamen, den Produktnamen und die Produktversion anzugeben. Wenn Sie diese Informationen bereitstellen, können Sie Windows Forms Features wie <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> verwenden, die das Schreiben von Anwendungen erleichtern, die dem "Certified for Windows"-Programm entsprechen. Weitere Informationen zum Certified for Windows-Programm finden Sie unter http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> angezeigt, das in einer <xref:System.Windows.Forms.Form> enthalten ist. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version der Assembly ab, die das Steuerelement enthält.</summary>
        <value>Die Dateiversion der Assembly, die das Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ProductVersion%2A>-Eigenschaft ist eine schreibgeschützte Eigenschaft. Um den Wert dieser Eigenschaft zu ändern, legen Sie den <xref:System.Reflection.AssemblyVersionAttribute.Version%2A>-Eigenschafts Wert von <xref:System.Reflection.AssemblyVersionAttribute> fest. Mit C# der folgenden Codezeile wird die <xref:System.Windows.Forms.Control.ProductVersion%2A>-Eigenschaft festgelegt.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Es wird dringend empfohlen, den Firmennamen, den Produktnamen und die Produktversion anzugeben. Wenn Sie diese Informationen bereitstellen, können Sie Windows Forms Features wie <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> verwenden, die das Schreiben von Anwendungen erleichtern, die dem "Certified for Windows"-Programm entsprechen. Weitere Informationen zum Certified for Windows-Programm finden Sie unter http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Informationen über die Anwendung in einem <xref:System.Windows.Forms.Label> angezeigt, das in einer <xref:System.Windows.Forms.Form> enthalten ist. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> und <xref:System.Windows.Forms.Control.ProductVersion%2A> festgelegt wurden.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das einen IME-Modus für Weitergabevorgänge darstellt.</summary>
        <value>Ein Objekt, das einen IME-Modus für Weitergabevorgänge darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="T:System.Windows.Forms.AccessibleObject" /> Hilfe für barrierefreie Anwendungen bereitstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Forms.HelpProvider>-Klasse, um Benutzern das Aufrufen von Hilfe für Ihr Barrierefreies Objekt zu ermöglichen, indem Sie die F1-Taste drücken. Wenn Sie die <xref:System.Windows.Forms.HelpProvider> verwenden, erhalten Sie umfassende Informationen in der <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Erstellung eines Barrierefreiheits fähigen Diagramm Steuer Elements mithilfe der Klassen <xref:System.Windows.Forms.AccessibleObject> und <xref:System.Windows.Forms.Control.ControlAccessibleObject>, um Barrierefreie Informationen verfügbar zu machen. Das-Steuerelement zeichnet zwei Kurven zusammen mit einer Legende. Die `ChartControlAccessibleObject`-Klasse, die von `ControlAccessibleObject` abgeleitet wird, wird in der <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>-Methode verwendet, um benutzerdefinierte Informationen für das Diagramm Steuerelement bereitzustellen. Da die Diagramm Legende kein tatsächliches <xref:System.Windows.Forms.Control>-basiertes Steuerelement ist, sondern stattdessen vom Diagramm Steuerelement gezeichnet wird, sind keine integrierten zugänglichen Informationen verfügbar. Aus diesem Grund überschreibt die `ChartControlAccessibleObject`-Klasse die <xref:System.Windows.Forms.AccessibleObject.GetChild%2A>-Methode, um die `CurveLegendAccessibleObject` zurückzugeben, die barrierefreie Informationen für jeden Teil der Legende darstellt. Wenn eine barrierefreie Anwendung dieses Steuerelement verwendet, kann das Steuerelement die erforderlichen zugänglichen Informationen bereitstellen.  
  
 Dieser Code Ausschnitt veranschaulicht die Behandlung des <xref:System.Windows.Forms.Control.QueryAccessibilityHelp>-Ereignisses. Das gesamte Codebeispiel finden Sie in der Übersicht über <xref:System.Windows.Forms.AccessibleObject>-Klasse.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während eines Drag &amp; Drop-Vorgangs ein. Dadurch kann die Quelle des Ziehvorgangs bestimmen, ob der Drag &amp; Drop-Vorgang abgebrochen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis wird ausgelöst, wenn während eines Drag & Drop-Vorgangs eine Änderung im Tastatur-oder Maustasten Zustand vorliegt. Das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ermöglicht der Zieh Quelle, zu bestimmen, ob der Drag & Drop-Vorgang abgebrochen werden soll.  
  
 Nachfolgend wird beschrieben, wie und wann Ereignisse für Drag &amp; Drop-Vorgänge ausgelöst werden.  
  
 Die <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode bestimmt das Steuerelement unter der aktuellen Cursorposition. Anschließend wird überprüft, ob das Steuerelement ein gültiges Ablage Ziel ist.  
  
 Wenn das Steuerelement ein gültiges Ablage Ziel ist, wird das <xref:System.Windows.Forms.Control.GiveFeedback>-Ereignis ausgelöst, wobei der Drag & Drop-Effekt angegeben ist. Eine Liste der Drag & Drop-Effekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
 Änderungen der Mauszeigerposition, des Tastaturzustands und des Zustands der Maustasten werden verfolgt.  
  
-   Wenn die Benutzeraktion das Fenster verlässt, wird das <xref:System.Windows.Forms.Control.DragLeave>-Ereignis ausgelöst.  
  
-   Wenn der Mauszeiger in ein anderes Steuerelement bewegt wird, wird das <xref:System.Windows.Forms.Control.DragEnter>-Ereignis für dieses Steuerelement ausgelöst.  
  
-   Wenn die Maus bewegt wird, ohne das Steuerelement zu verlassen, wird das <xref:System.Windows.Forms.Control.DragOver>-Ereignis ausgelöst.  
  
 Wenn sich der Tastatur-oder Maustasten Zustand ändert, wird das <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignis ausgelöst, und es wird bestimmt, ob der Zieh Vorgang fortgesetzt, die Daten abgelegt oder der Vorgang basierend auf dem Wert der Eigenschaft <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> der <xref:System.Windows.Forms.QueryContinueDragEventArgs> des Ereignisses abgebrochen werden soll.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Continue` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragOver> ausgelöst, um den Vorgang fortzusetzen. das Ereignis <xref:System.Windows.Forms.Control.GiveFeedback> wird mit dem neuen Effekt ausgelöst, sodass entsprechendes visuelles Feedback festgelegt werden kann. Eine Liste der gültigen Ablageeffekte finden Sie unter der <xref:System.Windows.Forms.DragDropEffects>-Enumeration.  
  
    > [!NOTE]
    >  Die Ereignisse "<xref:System.Windows.Forms.Control.DragOver>" und "<xref:System.Windows.Forms.Control.GiveFeedback>" werden gekoppelt, damit dem Benutzer beim Bewegen der Maus über das Ablage Ziel das aktuellste Feedback an der Position der Maus gegeben wird.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Drop` ist, wird der Wert des Ablage Effekts an die Quelle zurückgegeben, sodass die Quell Anwendung den entsprechenden Vorgang für die Quelldaten ausführen kann. Beispielsweise können Sie die Daten Ausschneiden, wenn es sich um einen Verschiebe Vorgang handelt.  
  
-   Wenn der Wert von <xref:System.Windows.Forms.DragAction> `Cancel` ist, wird das Ereignis <xref:System.Windows.Forms.Control.DragLeave> ausgelöst.  
  
 Standardmäßig legt das Ereignis "<xref:System.Windows.Forms.Control.QueryContinueDrag>" <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> auf `Cancel` in <xref:System.Windows.Forms.DragAction> fest, wenn die ESC-Taste gedrückt wurde, und legt <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> auf `Drop` in <xref:System.Windows.Forms.DragAction> fest, wenn die linke, mittlere oder Rechte Maustaste gedrückt wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Dieser Code Ausschnitt veranschaulicht die Verwendung des <xref:System.Windows.Forms.Control.QueryContinueDrag>-Ereignisses, um den Drag & Drop-Vorgang abzubrechen, wenn der Zieh Vorgang außerhalb der Begrenzungen des Formulars verschoben wird. Das gesamte Codebeispiel finden Sie in der <xref:System.Windows.Forms.Control.DoDragDrop%2A>-Methode.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Ziehereignis aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Tastenereignis aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Mausereignis aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Das auszulösende Ereignis.</param>
        <param name="e">Ein <see cref="T:System.Windows.Forms.PaintEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das entsprechende Paint-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt ein erneutes Erstellen des Handles für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RecreateHandle%2A>-Methode wird immer dann aufgerufen, wenn Parameter für ein neues Steuerelement erforderlich sind, aber die Verwendung eines Aufrufs von <xref:System.Windows.Forms.Control.UpdateStyles%2A> bis <xref:System.Windows.Forms.Control.CreateParams%2A> unzureichend ist. Diese Methode ruft auch <xref:System.Windows.Forms.Control.DestroyHandle%2A> und <xref:System.Windows.Forms.Control.CreateHandle%2A> auf und legt <xref:System.Windows.Forms.Control.RecreatingHandle%2A> auf `true` fest.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement gerade das zugehörige Handle neu erstellt.</summary>
        <value><see langword="true" />, wenn das Steuerelement gerade das Handle neu erstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RecreatingHandle%2A>-Eigenschaft gibt `true` zurück, wenn die <xref:System.Windows.Forms.Control.RecreateHandle%2A>-Methode noch im-Steuerelement ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Der zu konvertierende Bildschirmkoordinaten-<see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Berechnet die Größe und die Position des angegebenen Bildschirmrechtecks in Clientkoordinaten.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, der den konvertierten <see cref="T:System.Drawing.Rectangle" />, <paramref name="r" />, in Clientkoordinaten darstellt.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Der zu konvertierende Clientkoordinaten-<see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Berechnet die Größe und die Position des angegebenen Clientrechtecks in Bildschirmkoordinaten.</summary>
        <returns>Ein <see cref="T:System.Drawing.Rectangle" />, der den konvertierten <see cref="T:System.Drawing.Rectangle" />, <paramref name="p" />, in Bildschirmkoordinaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Member <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> und <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> verwendet werden. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular mit dem Namen **Form1** ein, das mehrere Steuerelemente enthält. Für dieses Beispiel ist es erforderlich, dass die <xref:System.Windows.Forms.Control.MouseDown>-, <xref:System.Windows.Forms.Control.MouseMove>-und <xref:System.Windows.Forms.Control.MouseUp>-Ereignisse mit den Ereignis Handlern verbunden sind, die im Beispiel definiert sind.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint * Message -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">Ein <see cref="T:System.IntPtr" />, der das Handle des Steuerelements darstellt, an das die Meldung zurückgesendet werden soll.</param>
        <param name="m">Eine <see cref="T:System.Windows.Forms.Message" />, die die Windows-Meldung darstellt, die zurückgesendet werden soll.</param>
        <summary>Reflektiert die angegebene Meldung an das Steuerelement, das an das angegebene Handle gebunden ist.</summary>
        <returns><see langword="true" />, wenn die Meldung reflektiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.ReflectMessage%2A>-Methode ist eine Infrastruktur Methode und sollte in der Regel nicht aus dem Code aufgerufen werden.  
  
 Wenn der `hWnd`-Parameter kein gültiges Steuerelement darstellt, gibt die <xref:System.Windows.Forms.Control.ReflectMessage%2A>-Methode `false` zurück.  
  
 Da Windows-Meldungen an das Fenster der obersten Ebene zurückgegeben werden, wird die <xref:System.Windows.Forms.Control.ReflectMessage%2A>-Methode verwendet, um die Rückgabe Nachricht an das Steuerelement zu übertragen, das die Nachricht gesendet hat.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, die diese Methode aufruft. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt, dass das Steuerelement seinen Clientbereich für ungültig erklärt und sich sowie alle untergeordneten Steuerelemente sofort selbst neu zeichnet.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.Refresh" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.Control.Refresh" />-Methode der Basisklasse aufruft, damit das Steuerelement und seine untergeordneten Steuerelemente ungültig und neu gezeichnet werden.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den dem Steuerelement zugeordneten Fensterbereich ab oder legt diesen fest.</summary>
        <value>Die dem Steuerelement zugeordnete Fenster-<see cref="T:System.Drawing.Region" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fensterbereich ist eine Auflistung von Pixeln innerhalb des Fensters, in dem das Betriebssystem das Zeichnen zulässt. Das Betriebssystem zeigt keinen Teil eines Fensters an, der sich außerhalb des Fenster Bereichs befindet. Die Koordinaten des Bereichs eines Steuer Elements sind relativ zur linken oberen Ecke des Steuer Elements, nicht zum Client Bereich des Steuer Elements.  
  
> [!NOTE]
>  Die Auflistung von Pixeln, die im Bereich enthalten sind, kann nicht zusammenhängend sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Windows.Forms.Control.Region%2A>-Eigenschaft durch Erstellen einer roundschaltfläche verwendet wird. Um das Beispiel auszuführen, fügen Sie den folgenden Code in ein Formular ein, das eine Schaltfläche mit dem Namen `roundButton` enthält. Für dieses Beispiel ist es erforderlich, dass das <xref:System.Windows.Forms.Control.Paint>-Ereignis mit dem Ereignishandler verbunden ist, der im Beispiel definiert ist.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschafts Wert festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.Forms.Control.Region" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.RegionChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.RegionChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="C#" Value="protected bool RenderRightToLeft { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property RenderRightToLeft As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool RenderRightToLeft { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist jetzt veraltet.</summary>
        <value><see langword="true" />, wenn das Steuerelement von rechts nach links gerendert wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Der DPI-Wert vor der Änderung.</param>
        <param name="deviceDpiNew">Der DPI-Wert nach der Änderung.</param>
        <summary>Stellt Konstanten für die Größenänderung des Steuerelements bereit, wenn ein DPI-Wert geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.BackColor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt dazu, dass in ein an <see cref="T:System.Windows.Forms.BindingSource" /> gebundenes Steuerelement alle Elemente in der Liste erneut eingelesen und ihre angezeigten Werte aktualisiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Cursor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Font" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.ForeColor" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.ImeMode" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt das Steuerelement zurück, um das <see cref="E:System.Windows.Forms.Control.MouseLeave" />-Ereignis zu behandeln.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaft auf den Standardwert zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaft auf den Standardwert (<see cref="F:System.String.Empty" />) zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise verwenden Sie diese Methode, wenn Sie einen Designer für die <xref:System.Windows.Forms.Control> erstellen oder ein eigenes Steuerelement erstellen, das die <xref:System.Windows.Forms.Control> einschließt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Ändern der Größe des Steuerelements ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.Size%2A> des Steuer Elements ändern möchten, können Sie den `sender`-Parameter der registrierten <xref:System.Windows.Forms.ControlEventHandler>-Methode in ein <xref:System.Windows.Forms.Control> umwandeln und dessen <xref:System.Windows.Forms.Control.Size%2A>-Eigenschaft (oder <xref:System.Windows.Forms.Control.Height%2A>-und <xref:System.Windows.Forms.Control.Width%2A>-Eigenschaften einzeln) erhalten.  
  
 Verwenden Sie zum Verarbeiten von benutzerdefinierten Layouts das Ereignis <xref:System.Windows.Forms.Control.Layout> anstelle des Ereignisses zum Ändern der Größe. Das <xref:System.Windows.Forms.Control.Layout>-Ereignis wird als Reaktion auf ein <xref:System.Windows.Forms.Control.Resize>-Ereignis ausgelöst, aber auch als Reaktion auf andere Änderungen, die das Layout des Steuer Elements beeinflussen.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.Resize>-Ereignis einer <xref:System.Windows.Forms.Form> behandelt. Wenn die Größe des Formulars geändert wird, stellt der Ereignishandler sicher, dass das Formular quadratisch bleibt (sein <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Width%2A> bleiben gleich). Stellen Sie zum Ausführen dieses Beispiels sicher, und ordnen Sie diese Ereignis Behandlungsmethode dem <xref:System.Windows.Forms.Control.Resize>-Ereignis des Formulars zu.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement beim Ändern seiner Größe sich selbst neu zeichnet, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Steuerelement beim Ändern seiner Größe sich selbst neu zeichnet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.Control.ResizeRedraw%2A>-Eigenschafts Wert entspricht dem Rückgabewert der <xref:System.Windows.Forms.Control.GetStyle%2A>-Methode, wenn der <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType>-Wert als Parameter übergeben wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nimmt die übliche Layoutlogik wieder auf.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die übliche Layoutlogik wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufrufen, wird ein sofortiges Layout erzwungen, wenn ausstehende Layoutanforderungen vorhanden sind.  
  
 Die Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> werden zusammen verwendet, um mehrere <xref:System.Windows.Forms.Control.Layout>-Ereignisse zu unterdrücken, während Sie mehrere Attribute des Steuer Elements anpassen. Beispielsweise würden Sie in der Regel die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode aufzurufen, die <xref:System.Windows.Forms.Control.Size%2A>-, <xref:System.Windows.Forms.Control.Location%2A>-, <xref:System.Windows.Forms.Control.Anchor%2A>-oder <xref:System.Windows.Forms.Control.Dock%2A>-Eigenschaft des Steuer Elements festlegen und dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufzurufen, damit die Änderungen wirksam werden.  
  
 Es dürfen keine ausstehenden Aufrufe von <xref:System.Windows.Forms.Control.SuspendLayout%2A> vorhanden sein, damit <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Schaltflächen zu einem Formular hinzugefügt. Im Beispiel wird das Hinzufügen der Schaltflächen mithilfe der Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> in Transaktionen abgewickelt.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout"><see langword="true" />, um ausstehende Layoutanforderungen auszuführen, andernfalls <see langword="false" />.</param>
        <summary>Nimmt die übliche Layoutlogik wieder auf und erzwingt optional ein sofortiges Layout für ausstehende Layoutanforderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufrufen, wird ein sofortiges Layout erzwungen, wenn ausstehende Layoutanforderungen vorhanden sind. Wenn der `performLayout`-Parameter auf `true` festgelegt ist, wird ein sofortiges Layout ausgelöst, wenn ausstehende Layoutanforderungen vorliegen.  
  
 Die Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> werden zusammen verwendet, um mehrere <xref:System.Windows.Forms.Control.Layout>-Ereignisse zu unterdrücken, während Sie mehrere Attribute des Steuer Elements anpassen. Beispielsweise würden Sie in der Regel die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode aufzurufen, die <xref:System.Windows.Forms.Control.Size%2A>-, <xref:System.Windows.Forms.Control.Location%2A>-, <xref:System.Windows.Forms.Control.Anchor%2A>-oder <xref:System.Windows.Forms.Control.Dock%2A>-Eigenschaft des Steuer Elements festlegen und dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufzurufen, damit die Änderungen wirksam werden.  
  
 Es dürfen keine ausstehenden Aufrufe von <xref:System.Windows.Forms.Control.SuspendLayout%2A> vorhanden sein, damit <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen wird.  
  
> [!NOTE]
>  Wenn Sie einem übergeordneten Steuerelement mehrere Steuerelemente hinzufügen, empfiehlt es sich, die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode vor dem Initialisieren der hinzu zufügenden Steuerelemente aufzurufen. Nachdem Sie dem übergeordneten Steuerelement die Steuerelemente hinzugefügt haben, können Sie die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode Dadurch wird die Leistung von Anwendungen mit vielen Steuerelementen erhöht.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem rechten Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem rechten Rand des Steuerelements und dem linken Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Windows.Forms.Control.Right%2A>-Eigenschaft entspricht der Summe des <xref:System.Windows.Forms.Control.Left%2A>-Eigenschafts Werts und des <xref:System.Windows.Forms.Control.Width%2A>-Eigenschafts Werts.  
  
 Die <xref:System.Windows.Forms.Control.Right%2A>-Eigenschaft ist schreibgeschützt. Sie können diesen Eigenschafts Wert indirekt ändern, indem Sie den Wert der <xref:System.Windows.Forms.Control.Left%2A>-oder <xref:System.Windows.Forms.Control.Width%2A>-Eigenschaften ändern oder die <xref:System.Windows.Forms.Control.SetBounds%2A>-, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>-, <xref:System.Windows.Forms.Control.UpdateBounds%2A>-oder <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>-Methode aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Elemente des Steuerelements für die Unterstützung von Gebietsschemas ausgerichtet sind, die von rechts nach links geschriebene Schriftarten verwenden, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Forms.RightToLeft" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft ist eine Ambient-Eigenschaft. Eine Ambient-Eigenschaft ist eine Steuerelement Eigenschaft, die, wenn Sie nicht festgelegt ist, vom übergeordneten Steuerelement abgerufen wird. Beispielsweise hat die <xref:System.Windows.Forms.Button> standardmäßig dieselbe <xref:System.Windows.Forms.Control.BackColor%2A> wie Ihr übergeordnetes <xref:System.Windows.Forms.Form>. Weitere Informationen zu Ambient-Eigenschaften finden Sie in der <xref:System.Windows.Forms.AmbientProperties>-Klasse oder in der Übersicht über die <xref:System.Windows.Forms.Control>-Klasse.  
  
 Die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft wird für internationale Anwendungen verwendet, bei denen die Sprache von rechts nach links geschrieben wird, z. b. Hebräisch oder Arabisch. Wenn diese Eigenschaft auf <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> festgelegt ist, werden Steuerelemente, die Text enthalten, von rechts nach links angezeigt.  
  
> [!NOTE]
>  Wenn der Wert der <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft zur Laufzeit geändert wird, wird nur unformatierter Text ohne Formatierung beibehalten.  
  
 Im folgenden finden Sie einige Beispiele dafür, wie Steuerelemente vom <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschafts Wert <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> beeinflusst werden:  
  
-   Vertikale Schiebe leisten werden auf der linken Seite und nicht auf der rechten Seite der scrollbaren Steuerelemente angezeigt (z. b. <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>, mehrzeilige <xref:System.Windows.Forms.TextBox> und <xref:System.Windows.Forms.RichTextBox>).  
  
-   Horizontale Schiebe leisten beginnen mit dem rechtsbündig ausgerichteten Bild Lauf Feld (Ziehpunkt).  
  
-   Die Element Ausrichtung des Kontrollkästchens, die von der `CheckAlign`-Eigenschaft gesteuert wird, wird für <xref:System.Windows.Forms.CheckBox>-und <xref:System.Windows.Forms.RadioButton>-Steuerelemente umgekehrt.  
  
-   Elemente in Listenfeld, Kombinations Feld und auf-ab-Steuerelementen sind rechtsbündig ausgerichtet.  
  
-   Die Schaltflächen "nach oben" und "nach unten" werden auf <xref:System.Windows.Forms.NumericUpDown>-und <xref:System.Windows.Forms.DomainUpDown>-Steuerelementen  
  
-   Die Menüs (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem> und <xref:System.Windows.Forms.ContextMenu>) werden rechtsbündig angezeigt.  
  
-   Die Ausrichtung von Symbolleisten-Schaltflächen in einem <xref:System.Windows.Forms.ToolBar>-Steuerelement oder die Ausrichtung von Text auf einem <xref:System.Windows.Forms.ToolBarButton> wird von der <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft nicht beeinflusst.  
  
-   <xref:System.Windows.Forms.AxHost> unterstützt die Ausrichtung von rechts nach links. die Auswirkung auf ein ActiveX-Steuerelement hängt jedoch davon ab, in welchem Umfang der Autor des Steuer Elements die Unterstützung für die Anzeige von rechts nach links implementiert hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der zugewiesene Wert ist keiner der <see cref="T:System.Windows.Forms.RightToLeft" />-Werte.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.RightToLeft" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist ein Ereignishandler, der ausgeführt wird, wenn sich der <xref:System.Windows.Forms.Control.Text%2A>-Eigenschafts Wert ändert. Die <xref:System.Windows.Forms.Control>-Klasse verfügt über mehrere Methoden mit dem Namensmuster *propertyName*`Changed`, die ausgelöst werden, wenn der entsprechende *propertyName* -Wert geändert wird (*propertyName* steht für den Namen der entsprechenden Eigenschaft).  
  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die aktuelle Ausrichtung in die entsprechende Ausrichtung für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Drawing.ContentAlignment" /> in das entsprechende <see cref="T:System.Drawing.ContentAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.HorizontalAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.HorizontalAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.LeftRightAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.LeftRightAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Drawing.ContentAlignment" /> in das entsprechende <see cref="T:System.Drawing.ContentAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Drawing.ContentAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.HorizontalAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.HorizontalAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.HorizontalAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</param>
        <summary>Konvertiert das angegebene <see cref="T:System.Windows.Forms.LeftRightAlignment" /> in das entsprechende <see cref="T:System.Windows.Forms.LeftRightAlignment" /> für die Unterstützung der Schriftrichtung von rechts nach links.</summary>
        <returns>Einer der <see cref="T:System.Windows.Forms.LeftRightAlignment" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.RightToLeft%2A>-Eigenschaft von <xref:System.Windows.Forms.RightToLeft> auf `No` festgelegt ist, ist der Rückgabewert gleich dem übergebenen `align`-Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skaliert das Steuerelement und alle untergeordneten Steuerelemente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Ein <see cref="T:System.Drawing.SizeF" />, das die horizontalen und vertikalen Skalierungsfaktoren enthält.</param>
        <summary>Skaliert das Steuerelement und alle untergeordneten Steuerelemente entsprechend dem angegebenen Skalierungsfaktor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Scale%2A>-Methode skaliert das Steuerelement mit der angegebenen Skalierung `factor`. Außerdem werden alle untergeordneten Steuerelemente rekursiv skaliert, wenn die <xref:System.Windows.Forms.Control.ScaleChildren%2A>-Eigenschaft `true` ist. Intern ruft diese Methode <xref:System.Windows.Forms.Control.ScaleControl%2A> auf, um die einzelnen Steuerelemente zu skalieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Das für die Skalierung zu verwendende Verhältnis.</param>
        <summary>Skaliert das Steuerelement und alle untergeordneten Steuerelemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Der Faktor für die horizontale Skalierung.</param>
        <param name="dy">Der Faktor für die vertikale Skalierung.</param>
        <summary>Skaliert das gesamte Steuerelement und alle untergeordneten Steuerelemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice : Bitmap -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Die zu skalierende Bitmap.</param>
        <summary>Skaliert, wenn DPI-Wert geändert wird, einen logischen Bitmapwert in den entsprechenden Wert in der Geräteeinheit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Skalierung der untergeordneten Steuerelemente bestimmt.</summary>
        <value><see langword="true" />, wenn untergeordnete Steuerelemente beim Aufrufen dieser <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" />-Methode für dieses Steuerelement skaliert werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Forms.Control.ScaleChildren%2A>-Eigenschaft `true` ist, ruft die <xref:System.Windows.Forms.Control.Scale%2A>-Methode rekursiv die <xref:System.Windows.Forms.Control.ScaleControl%2A>-Methode der einzelnen untergeordneten Steuerelemente auf.  
  
 Die Standard Implementierung von <xref:System.Windows.Forms.Control.ScaleChildren%2A> gibt immer `true` zurück. Abgeleitete Klassen können <xref:System.Windows.Forms.Control.ScaleChildren%2A> überschreiben, um `false` zurückzugeben, um anzugeben, dass die Skalierung für ihre untergeordneten Elemente nicht ausgeführt werden soll  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Der Faktor, um den die Höhe und die Breite des Steuerelements skaliert werden.</param>
        <param name="specified">Ein <see cref="T:System.Windows.Forms.BoundsSpecified" />-Wert, der die Begrenzungen des Steuerelements angibt und bei der Definition von Größe und Position verwendet wird.</param>
        <summary>Skaliert Speicherort, Größe, Textabstand und Rand eines Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Steuerelement die oberste Ebene ist, wird die Position des Steuer Elements nicht skaliert. Dabei werden weder untergeordnete Elemente noch die Größe der Steuerelemente mit automatischer Größe skaliert. Sie können die Skalierung in beliebiger Richtung weglassen, indem Sie den Wert des Parameters "`specified`" ändern.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Der Faktor für die horizontale Skalierung.</param>
        <param name="dy">Der Faktor für die vertikale Skalierung.</param>
        <summary>Diese Methode ist für diese Klasse nicht relevant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktiviert ein Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die <xref:System.Windows.Forms.Control.Select%2A>-Methode aktiviert das-Steuerelement, wenn das <xref:System.Windows.Forms.ControlStyles.Selectable?displayProperty=nameWithType>-Stilbit des Steuer Elements auf `true` festgelegt ist, es in einem anderen Steuerelement enthalten ist und alle übergeordneten Steuerelemente sichtbar und aktiviert sind.

Die Windows Forms-Steuerelemente in der folgenden Liste können nicht ausgewählt werden. Steuerelemente, die von Steuerelementen in der Liste abgeleitet sind, können ebenfalls nicht ausgewählt werden.
  
- <xref:System.Windows.Forms.Label>  
- <xref:System.Windows.Forms.Panel>  
- <xref:System.Windows.Forms.GroupBox>
- <xref:System.Windows.Forms.PictureBox>  
- <xref:System.Windows.Forms.ProgressBar>
- <xref:System.Windows.Forms.Splitter>
- <xref:System.Windows.Forms.LinkLabel> (wenn im-Steuerelement kein Link vorhanden ist)
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  

Im folgenden Codebeispiel wird der angegebene <xref:System.Windows.Forms.Control> ausgewählt, wenn er auswählbar ist.
  
[!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
[!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
[!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed"><see langword="true" />, um die Richtung für die Auswahl des Steuerelements anzugeben, andernfalls <see langword="false" />.</param>
        <param name="forward"><see langword="true" />, um sich in der Aktivierreihenfolge vorwärts zu bewegen, <see langword="false" />, um sich rückwärts zu bewegen.</param>
        <summary>Aktiviert ein untergeordnetes Steuerelement. Gibt optional die Richtung in der Aktivierreihenfolge für die Auswahl des Steuerelements an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`directed`" und "`forward`" werden von Steuerelementen im Containerformat verwendet. Wenn der `directed`-Parameter auf `true` festgelegt ist, wird der `forward`-Parameter ausgewertet, um zu bestimmen, welches Steuerelement ausgewählt werden soll. Wenn `forward` auf `true` festgelegt ist, wird das nächste Steuerelement in der Aktivier Reihenfolge ausgewählt. Wenn `false`, wird das vorherige Steuerelement in der Aktivier Reihenfolge ausgewählt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Das <see cref="T:System.Windows.Forms.Control" />, bei dem mit der Suche begonnen werden soll.</param>
        <param name="forward"><see langword="true" />, um sich in der Aktivierreihenfolge vorwärts zu bewegen, <see langword="false" />, um sich rückwärts zu bewegen.</param>
        <param name="tabStopOnly"><see langword="true" />, um Steuerelemente zu ignorieren, deren <see cref="P:System.Windows.Forms.Control.TabStop" />-Eigenschaft auf <see langword="false" /> festgelegt ist, andernfalls <see langword="false" />.</param>
        <param name="nested"><see langword="true" />, um geschachtelte untergeordnete (d. h. untergeordneten Steuerelementen untergeordnete) Steuerelemente einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="wrap"><see langword="true" />, um die Suche beim ersten Steuerelement der Aktivierreihenfolge fortzusetzen, nachdem das letzte Steuerelement erreicht wurde, andernfalls <see langword="false" />.</param>
        <summary>Aktiviert das nächste Steuerelement.</summary>
        <returns><see langword="true" />, wenn ein Steuerelement aktiviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.SelectNextControl%2A>-Methode aktiviert das nächste Steuerelement in der Aktivier Reihenfolge, wenn das `Selectable`-Stilbit des Steuer Elements auf `true` in <xref:System.Windows.Forms.ControlStyles> festgelegt ist, es in einem anderen Steuerelement enthalten ist und alle übergeordneten Steuerelemente sichtbar und aktiviert sind.  
  
 Die Windows Forms-Steuerelemente in der folgenden Liste können nicht ausgewählt werden. Steuerelemente, die von Steuerelementen in der Liste abgeleitet sind, können ebenfalls nicht ausgewählt werden.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (wenn im-Steuerelement kein Link vorhanden ist)  
  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
   
  
## Examples  
 Der folgende Code zeigt die <xref:System.Windows.Forms.Control.SelectNextControl%2A>-Methode, die in einem Formular verwendet wird, das über einige Steuerelemente verfügt. Jedes Mal, wenn Sie auf das Formular klicken, wird das nächste Steuerelement aktiviert. Die <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>-Eigenschaft ruft das derzeit aktive Steuerelement im Container Steuerelement ab.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 Das folgende Codebeispiel zeigt die <xref:System.Windows.Forms.Control.SelectNextControl%2A>-Methode, die in einem Formular verwendet wird, das über ein <xref:System.Windows.Forms.Button> und einige andere Steuerelemente verfügt. Wenn Sie auf die <xref:System.Windows.Forms.Button> klicken, wird das nächste Steuerelement nach dem Aktivieren von <xref:System.Windows.Forms.Button> aktiviert. Beachten Sie, dass Sie das übergeordnete Element des <xref:System.Windows.Forms.Button>-Steuer Elements erhalten müssen. Da <xref:System.Windows.Forms.Button> kein Container ist, würde das Aufrufen von <xref:System.Windows.Forms.Control.SelectNextControl%2A> direkt auf dem <xref:System.Windows.Forms.Button> die Aktivierung nicht ändern.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet das Steuerelement ans Ende der z-Reihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement wird an den Hintergrund der z-Reihenfolge verschoben. Wenn das Steuerelement ein untergeordnetes Element eines anderen Steuer Elements ist, wird das untergeordnete Steuerelement an den Hintergrund der z-Reihenfolge verschoben. Wenn das Steuerelement ein Steuerelement der obersten Ebene ist, funktioniert diese Methode nur dann ordnungsgemäß, wenn das Steuerelement aktiv ist. Ein Steuerelement der obersten Ebene ist ein Steuerelement, z. b. ein <xref:System.Windows.Forms.Form>, das kein untergeordnetes Element eines anderen Steuer Elements ist. Ein aktives Steuerelement ist ein sichtbares Steuerelement, das den Eingabefokus besitzt. Um die <xref:System.Windows.Forms.Control.SendToBack%2A>-Methode mit einem inaktiven Steuerelement der obersten Ebene zu verwenden, müssen Sie zuerst die <xref:System.Windows.Forms.Control.BringToFront%2A>-Methode für das-Steuerelement aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Einer der <see cref="T:System.Windows.Forms.AutoSizeMode" />-Werte.</param>
        <summary>Legt einen Wert fest, der angibt, wie sich ein Steuerelement verhält, wenn seine <see cref="P:System.Windows.Forms.Control.AutoSize" />-Eigenschaft aktiviert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die Begrenzungen des Steuerelements fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <summary>Legt die Begrenzungen des Steuerelements auf die angegebene Position und Größe fest.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <param name="specified">Eine bitweise Kombination der <see cref="T:System.Windows.Forms.BoundsSpecified" />-Werte. Für jeden nicht angegebenen Parameter wird der aktuelle Wert verwendet.</param>
        <summary>Legt die angegebenen Begrenzungen des Steuerelements auf die angegebene Position und Größe fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.Form> auf dem Bildschirm im <xref:System.Windows.Forms.Control.Layout>-Ereignis zentriert. Dadurch bleibt das Formular zentriert, wenn der Benutzer die Größe ändert. Für dieses Beispiel ist es erforderlich, dass Sie ein <xref:System.Windows.Forms.Form>-Steuerelement erstellt haben.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Der neue <see cref="P:System.Windows.Forms.Control.Left" />-Eigenschaftswert des Steuerelements.</param>
        <param name="y">Der neue <see cref="P:System.Windows.Forms.Control.Top" />-Eigenschaftswert des Steuerelements.</param>
        <param name="width">Der neue <see cref="P:System.Windows.Forms.Control.Width" />-Eigenschaftswert des Steuerelements.</param>
        <param name="height">Der neue <see cref="P:System.Windows.Forms.Control.Height" />-Eigenschaftswert des Steuerelements.</param>
        <param name="specified">Eine bitweise Kombination der <see cref="T:System.Windows.Forms.BoundsSpecified" />-Werte.</param>
        <summary>Legt die angegebenen Begrenzungen dieses Steuerelements fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel werden die Parameter, die den Begrenzungen entsprechen, die nicht im `specified`-Parameter enthalten sind, mit ihren aktuellen Werten übergeben. Beispielsweise können die Eigenschaften "<xref:System.Windows.Forms.Control.Height%2A>", "<xref:System.Windows.Forms.Control.Width%2A>" oder "<xref:System.Drawing.Point.X%2A>" oder "<xref:System.Drawing.Point.Y%2A>" der Eigenschaft "<xref:System.Windows.Forms.Control.Location%2A>" mit einem Verweis auf die aktuelle Instanz des Steuer Elements übermittelt werden. Alle übergebenen Werte werden jedoch berücksichtigt und auf das Steuerelement angewendet.  
  
 Der `boundsSpecified`-Parameter stellt die Elemente der Steuerelemente <xref:System.Windows.Forms.Control.Bounds%2A> dar, die von der Anwendung geändert wurden. Wenn Sie z. b. den <xref:System.Windows.Forms.Control.Size%2A> des Steuer Elements ändern, ist der `boundsSpecified`-Parameterwert der `Size`-Wert <xref:System.Windows.Forms.BoundsSpecified>. Wenn die <xref:System.Windows.Forms.Control.Size%2A> jedoch in Reaktion auf die festgelegte Eigenschaft <xref:System.Windows.Forms.Control.Dock%2A> angepasst wird, ist der Wert des `boundsSpecified`-Parameters der `None`-Wert <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  Auf Windows Server 2003-Systemen wird die Größe eines <xref:System.Windows.Forms.Form> durch die maximale Pixel Breite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.SetBoundsCore%2A>-Methode überschrieben, um sicherzustellen, dass das Steuerelement eine festgelegte Größe hat. Für dieses Beispiel ist es erforderlich, dass Sie über eine-Klasse verfügen, die entweder direkt oder indirekt von der <xref:System.Windows.Forms.Control>-Klasse abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />-Methode der Basisklasse aufruft, um zu erzwingen, dass die Begrenzungen des Steuer Elements geändert werden. Abgeleitete Klassen können der <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />-Methode Größenbeschränkungen hinzufügen.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die Breite des Clientbereichs in Pixel.</param>
        <param name="y">Die Höhe des Clientbereichs in Pixel.</param>
        <summary>Legt die Größe für den Clientbereich des Steuerelements fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Client Bereich beginnt am (0,0) Speicherort und erstreckt sich um den Speicherort (`x`, `y`).  
  
 In der Regel sollten Sie den <xref:System.Windows.Forms.Control.ClientSize%2A> des Steuer Elements nicht festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>-Methode überschrieben, um sicherzustellen, dass das Steuerelement quadratisch bleibt. Für dieses Beispiel ist es erforderlich, dass Sie über eine-Klasse verfügen, die entweder direkt oder indirekt von der <xref:System.Windows.Forms.Control>-Klasse abgeleitet ist.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass die <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />-Methode der Basisklasse aufgerufen wird, damit die Eigenschaft <see cref="P:System.Windows.Forms.Control.ClientSize" /> angepasst wird.  
  
Weitere Informationen zum Zeichnen von Steuerelementen finden Sie unter [Rendering eines Windows Forms-Steuer](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)Elements.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Das <see cref="T:System.Windows.Forms.ControlStyles" />-Bit, das festgelegt werden soll.</param>
        <param name="value"><see langword="true" />, um das angegebene Format auf das Steuerelement anzuwenden, andernfalls <see langword="false" />.</param>
        <summary>Legt ein angegebenes <see cref="T:System.Windows.Forms.ControlStyles" />-Flag auf <see langword="true" /> oder <see langword="false" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelement-Bitflags werden verwendet, um unterstütztes Verhalten zu kategorisieren. Ein Steuerelement kann einen Stil aktivieren, indem er die <xref:System.Windows.Forms.Control.SetStyle%2A>-Methode aufrufen und den entsprechenden <xref:System.Windows.Forms.ControlStyles>-Bit (oder Bits) und den booleschen Wert übergibt, um die Bit (e) auf festzulegen. Um den Wert zu bestimmen, der einem angegebenen <xref:System.Windows.Forms.ControlStyles>-Bit zugewiesen ist, verwenden Sie die <xref:System.Windows.Forms.Control.GetStyle%2A>-Methode, und übergeben Sie den <xref:System.Windows.Forms.ControlStyles>-Member zum Auswerten von.  
  
> [!CAUTION]
>  Das Festlegen der Steuerelemente des Steuer Elements kann das Verhalten des Steuer Elements erheblich verändern. Sehen Sie sich die <xref:System.Windows.Forms.ControlStyles>-enumerationsdokumentation an, um zu verstehen, wie sich die Änderung der Steuerelement Bits vor dem Aufrufen der <xref:System.Windows.Forms.Control.SetStyle%2A>-Methode  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die doppelte Pufferung für einen <xref:System.Windows.Forms.Form> aktiviert und die Stile aktualisiert, um die Änderungen widerzuspiegeln.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" />, um das Steuerelement als Steuerelement der obersten Ebene festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Legt das Steuerelement als Steuerelement der obersten Ebene fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Windows.Forms.Control.SetTopLevel%2A>-Methode einer <xref:System.Windows.Forms.Form> aufzurufen und den Wert `false` übergeben, ist das Formular erst sichtbar, wenn Sie <xref:System.Windows.Forms.Control.SetTopLevel%2A> erneut aufgerufen haben, und übergeben Sie den Wert `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="value" />-Parameter ist auf <see langword="true" /> festgelegt, und das Steuerelement ist ein ActiveX-Steuerelement.</exception>
        <exception cref="T:System.Exception">Der <see cref="M:System.Windows.Forms.Control.GetTopLevel" />-Rückgabewert ist ungleich dem <paramref name="value" />-Parameter, und die <see cref="P:System.Windows.Forms.Control.Parent" />-Eigenschaft ist nicht <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">, um das Steuerelement als Steuerelement der obersten Ebene festzulegen, wenn es einen beliebigen Typ als <see cref="T:System.Windows.Forms.Form" /> hat. Diese Berechtigung wird nur angefordert, wenn der Parameter "<paramref name="value" />" <see langword="true" /> ist und das Steuerelement kein ActiveX-Steuerelement ist. Zugeordnete Enumeration: <see langword="AllWindows" />-Wert <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" />, um das Steuerelement sichtbar zu machen, andernfalls <see langword="false" />.</param>
        <summary>Legt das Steuerelement auf den angegebenen sichtbaren Zustand fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise überschreiben Sie diese Methode, um das Sichtbarkeits Verhalten des Steuer Elements zu ändern.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />-Methode der Basisklasse aufruft, um die Sichtbarkeit des Steuer Elements zu erzwingen.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt dem Benutzer das Steuerelement an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzeige des Steuer Elements entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft auf `true`. Nachdem die <xref:System.Windows.Forms.Control.Show%2A>-Methode aufgerufen wurde, gibt die <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft den Wert `true` zurück, bis die <xref:System.Windows.Forms.Control.Hide%2A>-Methode aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Info Dialogfeld angezeigt, in dem vorübergehend ein blaues Quadrat auf der-Oberfläche gezeichnet wird. Für dieses Beispiel ist es erforderlich, dass Sie eine Klasse definiert haben, die von <xref:System.Windows.Forms.Form> abgeleitet ist `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="C#" Value="protected virtual bool ShowFocusCues { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowFocusCues As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowFocusCues { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Steuerelement Fokusrechtecke anzeigen soll.</summary>
        <value><see langword="true" />, wenn das Steuerelement Fokusrechtecke anzeigen soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu dieser Funktion finden Sie in den Themen [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)und [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.ShowFocusCues" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.ShowFocusCues" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen.</para></block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="C#" Value="protected bool ShowKeyboardCues { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ShowKeyboardCues As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ShowKeyboardCues { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich die Benutzeroberfläche in einem entsprechenden Zustand befindet, um Zugriffstasten anzuzeigen bzw. auszublenden.</summary>
        <value><see langword="true" />, wenn die Zugriffstasten sichtbar sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Steuerelementen, die im Windows Forms-Designer erstellt wurden, sind die Tastaturbeschleuniger standardmäßig sichtbar.  
  
 Weitere Informationen zu dieser Funktion finden Sie in den Themen [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)und [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Site des Steuerelements ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.ComponentModel.ISite" />, die <see cref="T:System.Windows.Forms.Control" /> zugeordnet ist, sofern vorhanden.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe und Breite des Steuerelements ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Drawing.Size" />, die die Höhe und Breite des Steuerelements in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Drawing.Size>-Klasse ein Werttyp ist (`Structure` in Visual Basic, `struct` C#in Visual), wird Sie als Wert zurückgegeben, was bedeutet, dass der Zugriff auf die-Eigenschaft eine Kopie der Größe des Steuer Elements zurückgibt. Das Anpassen der Eigenschaften "<xref:System.Drawing.Size.Width%2A>" oder "<xref:System.Drawing.Size.Height%2A>" der von dieser Eigenschaft zurückgegebenen <xref:System.Drawing.Size> wirkt sich nicht auf das <xref:System.Windows.Forms.Control.Width%2A> oder <xref:System.Windows.Forms.Control.Height%2A> des Steuer Elements aus. Um die <xref:System.Windows.Forms.Control.Width%2A> oder <xref:System.Windows.Forms.Control.Height%2A> des Steuer Elements anzupassen, müssen Sie die <xref:System.Windows.Forms.Control.Width%2A>-oder <xref:System.Windows.Forms.Control.Height%2A>-Eigenschaft des Steuer Elements festlegen oder die <xref:System.Windows.Forms.Control.Size%2A>-Eigenschaft mit einer neuen <xref:System.Drawing.Size> festlegen.  
  
> [!NOTE]
>  Um eine bessere Leistung zu gewährleisten, legen Sie die <xref:System.Drawing.Size> eines Steuer Elements nicht im Konstruktor fest. Die bevorzugte Methode besteht darin, die <xref:System.Windows.Forms.Control.DefaultSize%2A>-Eigenschaft zu überschreiben.  
  
> [!NOTE]
>  Auf Windows Server 2003-Systemen wird die Größe eines <xref:System.Windows.Forms.Form> durch die maximale Pixel Breite und Höhe des Monitors eingeschränkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.Button> zu einem Formular hinzugefügt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird die Schaltfläche in der unteren rechten Ecke des Formulars verankert, sodass die relative Position bei der Größenänderung des Formulars beibehalten wird. Anschließend wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt und die Größe der Schaltfläche auf die gleiche Größe wie die <xref:System.Drawing.Image> festgelegt. Im Beispiel wird dann der <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` festgelegt, und die Eigenschaft <xref:System.Windows.Forms.Control.TabIndex%2A> wird festgelegt. Schließlich fügt Sie einen Ereignishandler hinzu, der das <xref:System.Windows.Forms.Control.Click>-Ereignis der Schaltfläche behandelt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Size" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist vorzuziehen, das Ereignis "<xref:System.Windows.Forms.Control.Layout>" zu verwenden, um benutzerdefinierte Layouts zu verarbeiten. Das <xref:System.Windows.Forms.Control.Layout>-Ereignis wird als Reaktion auf <xref:System.Windows.Forms.Control.Resize>-Ereignisse ausgelöst, aber auch in anderen Situationen, in denen das Layout möglicherweise angewendet werden muss.  
  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Size%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.SizeChanged>-Ereignis veranschaulicht. Eine Instanz eines <xref:System.Windows.Forms.Button>-Steuer Elements wurde bereitgestellt, das sowohl horizontal als auch vertikal skaliert werden kann. Eine <xref:System.Windows.Forms.NumericUpDown>-Instanz stellt den horizontalen und vertikalen Skalierungs Wert bereit. Die <xref:System.Windows.Forms.Button>-Instanz mit dem Namen **OK** wird verwendet, um die Skalierungs Werte für die <xref:System.Windows.Forms.Button>-Steuerelement Instanz festzulegen. Wenn sich die Größe des Steuer Elements ändert, wird der Ereignishandler aufgerufen, der dem <xref:System.Windows.Forms.Control.SizeChanged>-Ereignis des-Steuer Elements zugeordnet ist. Dieser Ereignishandler zeigt ein Meldungs Feld an, das angibt, dass sich die Größe des Steuer Elements geändert hat.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="clientSize">Ein <see cref="T:System.Drawing.Size" />-Wert, der die Höhe und Breite des Clientbereichs des Steuerelements darstellt.</param>
        <summary>Bestimmt die Größe des gesamten Steuerelements anhand der Höhe und Breite seines Clientbereichs.</summary>
        <returns>Ein <see cref="T:System.Drawing.Size" />-Wert, der die Höhe und die Breite des gesamten Steuerelements darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich das Format des Steuerelements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.Control.StyleChanged>-Ereignis tritt auf, wenn <xref:System.Windows.Forms.ControlStyles>-Flags hinzugefügt oder geändert wurden.  
  
 Dieses Ereignis wird ausgelöst, wenn der Steuerelement Stil durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.StyleChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.StyleChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht vorübergehend die Layoutlogik für das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Layoutlogik des Steuer Elements wird angehalten, bis die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufgerufen wird.  
  
 Die Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> werden zusammen verwendet, um mehrere <xref:System.Windows.Forms.Control.Layout>-Ereignisse zu unterdrücken, während Sie mehrere Attribute des Steuer Elements anpassen. Beispielsweise würden Sie in der Regel die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode aufzurufen, die <xref:System.Windows.Forms.Control.Size%2A>-, <xref:System.Windows.Forms.Control.Location%2A>-, <xref:System.Windows.Forms.Control.Anchor%2A>-oder <xref:System.Windows.Forms.Control.Dock%2A>-Eigenschaft des Steuer Elements festlegen und dann die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode aufzurufen, damit die Änderungen wirksam werden.  
  
 Es dürfen keine ausstehenden Aufrufe von <xref:System.Windows.Forms.Control.SuspendLayout%2A> vorhanden sein, damit <xref:System.Windows.Forms.Control.ResumeLayout%2A> erfolgreich aufgerufen wird.  
  
> [!NOTE]
>  Wenn Sie einem übergeordneten Steuerelement mehrere Steuerelemente hinzufügen, empfiehlt es sich, die <xref:System.Windows.Forms.Control.SuspendLayout%2A>-Methode vor dem Initialisieren der hinzu zufügenden Steuerelemente aufzurufen. Nachdem Sie dem übergeordneten Steuerelement die Steuerelemente hinzugefügt haben, können Sie die <xref:System.Windows.Forms.Control.ResumeLayout%2A>-Methode Dadurch wird die Leistung von Anwendungen mit vielen Steuerelementen erhöht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Schaltflächen zu einem Formular hinzugefügt. Im Beispiel wird das Hinzufügen der Schaltflächen mithilfe der Methoden <xref:System.Windows.Forms.Control.SuspendLayout%2A> und <xref:System.Windows.Forms.Control.ResumeLayout%2A> in Transaktionen abgewickelt.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragDrop" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragEnter" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragLeave" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Ein <see cref="T:System.Windows.Forms.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Control.DragOver" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Systemfarben ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Drawing.SystemColors> entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.SystemColorsChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.SystemColorsChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Aktivierreihenfolge des Steuerelements in dessen Container ab oder legt diese fest.</summary>
        <value>Der Indexwert des Steuerelements in einer Gruppe von Steuerelementen in dessen Container. Die Steuerelemente im Container werden in die Aktivierreihenfolge aufgenommen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Registerkarten Index kann aus einer beliebigen gültigen Ganzzahl größer oder gleich 0 (null), niedrigeren Zahlen in der Aktivier Reihenfolge bestehen. Wenn mehr als ein Steuerelement desselben übergeordneten Steuer Elements denselben Registerkarten Index aufweist, bestimmt die z-Reihenfolge der Steuerelemente die Reihenfolge, in der die Steuerelemente durchlaufen werden.  
  
 Damit ein Steuerelement in der Aktivier Reihenfolge enthalten ist, muss die <xref:System.Windows.Forms.Control.TabStop%2A>-Eigenschaft auf `true` festgelegt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.Button> zu einem Formular hinzugefügt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird die Schaltfläche in der unteren rechten Ecke des Formulars verankert, sodass die relative Position bei der Größenänderung des Formulars beibehalten wird. Anschließend wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt und die Größe der Schaltfläche auf die gleiche Größe wie die <xref:System.Drawing.Image> festgelegt. Im Beispiel wird dann der <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` festgelegt, und die Eigenschaft <xref:System.Windows.Forms.Control.TabIndex%2A> wird festgelegt. Schließlich fügt Sie einen Ereignishandler hinzu, der das <xref:System.Windows.Forms.Control.Click>-Ereignis der Schaltfläche behandelt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.TabIndex" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.TabIndex%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.TabIndexChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.TabIndexChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Benutzer den Fokus mit der TAB-TASTE auf dieses Steuerelement setzen können, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der Fokus mit der TAB-TASTE auf dieses Steuerelement gesetzt werden kann, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.  
  
 <block subset="none" type="note"><para>  
 Diese Eigenschaft gibt immer <see langword="true" /> für eine Instanz der <see cref="T:System.Windows.Forms.Form" />-Klasse zurück.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer die Tab-Taste drückt, wird der Eingabefokus auf das nächste Steuerelement in der Aktivier Reihenfolge festgelegt. Steuerelemente mit dem <xref:System.Windows.Forms.Control.TabStop%2A>-Eigenschafts Wert `false` sind nicht in der Auflistung von Steuerelementen in der Aktivier Reihenfolge enthalten. Die Aktivier Reihenfolge kann durch Festlegen des <xref:System.Windows.Forms.Control.TabIndex%2A>-Eigenschafts Werts des Steuer Elements bearbeitet werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Windows.Forms.Button> zu einem Formular hinzugefügt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird die Schaltfläche in der unteren rechten Ecke des Formulars verankert, sodass die relative Position bei der Größenänderung des Formulars beibehalten wird. Anschließend wird die <xref:System.Windows.Forms.Control.BackgroundImage%2A> festgelegt und die Größe der Schaltfläche auf die gleiche Größe wie die <xref:System.Drawing.Image> festgelegt. Im Beispiel wird dann der <xref:System.Windows.Forms.Control.TabStop%2A> auf `true` festgelegt, und die Eigenschaft <xref:System.Windows.Forms.Control.TabIndex%2A> wird festgelegt. Schließlich fügt Sie einen Ereignishandler hinzu, der das <xref:System.Windows.Forms.Control.Click>-Ereignis der Schaltfläche behandelt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.ImageList> mit dem Namen `imageList1` verfügen.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.TabStop" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.TabStop%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Control.TabStopChanged>-Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, sollten Sie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> durch <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ersetzen oder die Nachricht an eine mehrzeilige <xref:System.Windows.Forms.TextBox> anhängen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Projekt ein, das eine Instanz eines Typs enthält, der von <xref:System.Windows.Forms.Control> erbt, z. b. <xref:System.Windows.Forms.Button> oder <xref:System.Windows.Forms.ComboBox>. Benennen Sie dann die Instanz `Control1`, und stellen Sie sicher, dass der Ereignishandler dem Ereignis <xref:System.Windows.Forms.Control.TabStopChanged> zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das Daten über das Steuerelement enthält, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Object" />, das Daten über das Steuerelement enthält. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Typen, die von der <xref:System.Object>-Klasse abgeleitet werden, können dieser Eigenschaft zugewiesen werden. Wenn die <xref:System.Windows.Forms.Control.Tag%2A>-Eigenschaft über den Windows Forms-Designer festgelegt wird, kann nur Text zugewiesen werden.  
  
 Die <xref:System.Windows.Forms.Control.Tag%2A>-Eigenschaft wird häufig verwendet, um Daten zu speichern, die eng mit dem Steuerelement verknüpft sind. Wenn Sie z. b. über ein Steuerelement verfügen, das Informationen zu einem Kunden anzeigt, können Sie ein <xref:System.Data.DataSet> speichern, das den Bestellverlauf des Kunden in der <xref:System.Windows.Forms.Control.Tag%2A>-Eigenschaft dieses Steuer Elements enthält, sodass schnell auf die Daten zugegriffen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular angezeigt und ein `Customer` in der <xref:System.Windows.Forms.Control.Tag%2A>-Eigenschaft gespeichert. Für dieses Beispiel ist es erforderlich, dass Sie eine Klasse definiert haben, die sich von <xref:System.Windows.Forms.Form> mit dem Namen `CustomerForm` ableitet, und dass Sie einen `Customer` definiert haben.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den diesem Steuerelement zugeordneten Text ab oder legt diesen fest.</summary>
        <value>Der diesem Steuerelement zugeordnete Text.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft des Steuer Elements wird von jeder abgeleiteten Klasse unterschiedlich verwendet. Beispielsweise wird die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft einer <xref:System.Windows.Forms.Form> in der Titelleiste am oberen Rand des Formulars angezeigt, ist in der Zeichen Anzahl relativ klein und zeigt in der Regel den Anwendungs-oder Dokumentnamen an. Die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft einer <xref:System.Windows.Forms.RichTextBox> kann jedoch sehr groß sein und kann zahlreiche nicht visuelle Zeichen enthalten, die zum Formatieren des Texts verwendet werden. Beispielsweise kann der in einer <xref:System.Windows.Forms.RichTextBox> angezeigte Text formatiert werden, indem die <xref:System.Drawing.Font>-Eigenschaften angepasst werden, oder durch das Hinzufügen von Leerzeichen oder Tabulator Zeichen, um den Text auszurichten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Windows.Forms.GroupBox> erstellt, und einige der allgemeinen Eigenschaften werden festgelegt. Im Beispiel wird ein <xref:System.Windows.Forms.TextBox> erstellt und dessen <xref:System.Windows.Forms.Control.Location%2A> innerhalb des Gruppen Felds festgelegt. Anschließend wird die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft des Gruppen Felds festgelegt und das Gruppenfeld an den oberen Rand des Formulars angedockt. Schließlich wird das Gruppenfeld deaktiviert, indem die <xref:System.Windows.Forms.Control.Enabled%2A>-Eigenschaft auf `false` festgelegt wird. Dies bewirkt, dass alle im Gruppenfeld enthaltenen Steuerelemente deaktiviert werden.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaft in einer abgeleiteten Klasse überschreiben, verwenden Sie die <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaft der Basisklasse, um die Basis Implementierung zu erweitern. Andernfalls müssen Sie die gesamte-Implementierung bereitstellen. Es ist nicht erforderlich, die <see langword="get" />-und <see langword="set" />-Accessoren der <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaft zu überschreiben. Sie können bei Bedarf nur eine überschreiben.</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Text" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Text%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Control.ForeColor%2A> einer <xref:System.Windows.Forms.TextBox> geändert, in der Währungs Daten angezeigt werden. Im Beispiel wird der Text in eine Dezimalzahl konvertiert und der <xref:System.Windows.Forms.Control.ForeColor%2A> in <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> geändert, wenn die Zahl negativ ist, und die <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, wenn die Zahl positiv ist. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die eine <xref:System.Windows.Forms.TextBox> enthält.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Abstand zwischen dem oberen Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Abstand zwischen dem unteren Rand des Steuerelements und dem oberen Rand des Clientbereichs des zugehörigen Containers in Pixel darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.Control.Top%2A>-Eigenschafts Wert entspricht der Eigenschaft <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> des <xref:System.Windows.Forms.Control.Location%2A>-Eigenschafts Werts des Steuer Elements.  
  
 Änderungen an den Eigenschafts Werten <xref:System.Windows.Forms.Control.Height%2A> und <xref:System.Windows.Forms.Control.Top%2A> bewirken, dass sich der <xref:System.Windows.Forms.Control.Bottom%2A>-Eigenschafts Wert des Steuer Elements ändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Steuerelement ab, dem kein anderes Windows Forms-Steuerelement übergeordnet ist. Dies ist i. d. R. das äußerste <see cref="T:System.Windows.Forms.Form" />, in dem das Steuerelement enthalten ist.</summary>
        <value>Das <see cref="T:System.Windows.Forms.Control" />, das das Steuerelement der obersten Ebene darstellt, das das aktuelle Steuerelement enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement der obersten Ebene ist als übergeordnetes Steuerelement definiert, das nicht von einem anderen Windows Forms-Steuerelement untergeordnet ist. Dies ist i. d. R. das äußerste <xref:System.Windows.Forms.Form>, in dem das Steuerelement enthalten ist. Wenn das Steuerelement z. b. in einem untergeordneten MDI-<xref:System.Windows.Forms.Form> enthalten ist, ist das Steuerelement der obersten Ebene das übergeordnete MDI (Multiple Document Interface)-<xref:System.Windows.Forms.Form>. Wenn das Steuerelement nicht einem <xref:System.Windows.Forms.Form> untergeordnet ist, gibt diese Eigenschaft `null` zurück.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster, um diesen Eigenschafts Wert zu erhalten. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass das Steuerelement die für ungültig erklärten Bereiche im Clientbereich neu zeichnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Führt alle ausstehenden Anforderungen zum Zeichnen aus.  
  
 Es gibt zwei Möglichkeiten, ein Formular und seinen Inhalt neu zu zeichnen:  
  
-   Sie können eine der über Ladungen der <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode mit der <xref:System.Windows.Forms.Control.Update%2A>-Methode verwenden.  
  
-   Sie können die <xref:System.Windows.Forms.Control.Refresh%2A>-Methode aufrufen, die das Steuerelement zwingt, sich selbst und alle untergeordneten Elemente neu zu zeichnen. Dies entspricht dem Festlegen der <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode auf `true` und deren Verwendung mit <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode steuert, was gezeichnet oder neu gezeichnet wird. Die <xref:System.Windows.Forms.Control.Update%2A>-Methode steuert, wann das Zeichnen oder Neuzeichnen auftritt. Wenn Sie die Methoden <xref:System.Windows.Forms.Control.Invalidate%2A> und <xref:System.Windows.Forms.Control.Update%2A> anstelle des Aufrufs von <xref:System.Windows.Forms.Control.Refresh%2A> verwenden, ist die neu gezeichnete Methode davon abhängig, welche Überladung von <xref:System.Windows.Forms.Control.Invalidate%2A> verwendet wird. Die <xref:System.Windows.Forms.Control.Update%2A>-Methode erzwingt, dass das Steuerelement sofort gezeichnet wird, aber die <xref:System.Windows.Forms.Control.Invalidate%2A>-Methode steuert, was gezeichnet wird, wenn Sie die <xref:System.Windows.Forms.Control.Update%2A>-Methode aufruft.  
  
 Weitere Informationen finden Sie im Thema [WM_PAINT](https://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert die Begrenzungen des Steuerelements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberSignature Language="C#" Value="protected void UpdateBounds ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der aktuellen Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die neue <xref:System.Windows.Forms.Control.Size%2A> des Steuer Elements von der vorherigen <xref:System.Drawing.Size> unterscheidet, wird das Ereignis <xref:System.Windows.Forms.Control.SizeChanged> ausgelöst. Ebenso wird das <xref:System.Windows.Forms.Control.LocationChanged>-Ereignis ausgelöst, wenn sich die <xref:System.Windows.Forms.Control.Location%2A> des-Steuer Elements ändert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die <see cref="P:System.Drawing.Point.X" />-Koordinate des Steuerelements.</param>
        <param name="y">Die <see cref="P:System.Drawing.Point.Y" />-Koordinate des Steuerelements.</param>
        <param name="width">Der <see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="height">Der <see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der angegebenen Größe und Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das neue <xref:System.Windows.Forms.Control.Size%2A> des Steuer Elements, wenn es sich vom vorherigen <xref:System.Drawing.Size> unterscheidet, wird das Ereignis <xref:System.Windows.Forms.Control.SizeChanged> ausgelöst. Ebenso gilt, dass die <xref:System.Windows.Forms.Control.Location%2A> des-Steuer Elements geändert wird, das <xref:System.Windows.Forms.Control.LocationChanged>-Ereignis ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die <see cref="P:System.Drawing.Point.X" />-Koordinate des Steuerelements.</param>
        <param name="y">Die <see cref="P:System.Drawing.Point.Y" />-Koordinate des Steuerelements.</param>
        <param name="width">Der <see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="height">Der <see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <param name="clientWidth">Die Client-<see cref="P:System.Drawing.Size.Width" /> des Steuerelements.</param>
        <param name="clientHeight">Die Client-<see cref="P:System.Drawing.Size.Height" /> des Steuerelements.</param>
        <summary>Aktualisiert die Begrenzungen des Steuerelements mit der angegebenen Größe, Position und Größe des Clients.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich die neue <xref:System.Windows.Forms.Control.Size%2A> des Steuer Elements von der vorherigen <xref:System.Drawing.Size> unterscheidet, wird das Ereignis <xref:System.Windows.Forms.Control.SizeChanged> ausgelöst. Ebenso wird das <xref:System.Windows.Forms.Control.LocationChanged>-Ereignis ausgelöst, wenn sich die <xref:System.Windows.Forms.Control.Location%2A> des-Steuer Elements ändert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt ein erneutes Anwenden der zugewiesenen Formate auf das Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Forms.Control.CreateParams%2A>-Methode auf, um die anzuwendenden Stile zu erhalten. Die Stile, die den Eigenschaften <xref:System.Windows.Forms.CreateParams.Style%2A> und <xref:System.Windows.Forms.CreateParams.ExStyle%2A> der <xref:System.Windows.Forms.CreateParams> zugewiesen sind, die der <xref:System.Windows.Forms.Control.CreateParams%2A>-Eigenschaft des Steuer Elements zugewiesen sind, werden erneut angewendet. Das Steuerelement wird neu gezeichnet, um die Stiländerungen bei Bedarf widerzuspiegeln.  
  
 Die <xref:System.Windows.Forms.Control.UpdateStyles%2A>-Methode hat keine Auswirkung, wenn der Wert der Eigenschaft <xref:System.Windows.Forms.Control.IsHandleCreated%2A> `false` ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die doppelte Pufferung für einen <xref:System.Windows.Forms.Form> aktiviert und die Stile aktualisiert, um die Änderungen widerzuspiegeln.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert das Steuerelement in der z-Reihenfolge des übergeordneten Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Control.UpdateZOrder%2A>-Methode aktualisiert die Position des-Steuer Elements in der z-Reihenfolge des übergeordneten Steuer Elements. Wenn dieses Steuerelement z. b. ein neu erstelltes Steuerelement ist, das einer <xref:System.Windows.Forms.Control.ControlCollection> hinzugefügt wurde, wird die z-Reihenfolge aktualisiert, und das neue Steuerelement wird dem Hintergrund hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Wartecursor für das aktuelle Steuerelement und alle untergeordneten Steuerelemente verwendet werden soll.</summary>
        <value><see langword="true" />, wenn der Wartecursor für das aktuelle Steuerelement und alle untergeordneten Steuerelemente verwendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie einen Warte Cursor, wenn Sie einen Vorgang ausführen, der eine beträchtliche Zeit in Anspruch nimmt. Beachten Sie jedoch, dass Vorgänge, die den UI-Thread blockieren, auch eine Cursor Änderung blockieren werden. Diese Eigenschaft sollte daher nur verwendet werden, wenn zeitaufwändige Vorgänge in einem anderen Thread durchgeführt werden. Wenn Sie den Cursor Global und sofort ändern möchten, sehen Sie sich die <xref:System.Windows.Forms.Cursor.Current%2A>-Eigenschaft an.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement die Überprüfung abgeschlossen hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
 Wenn die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft des <xref:System.ComponentModel.CancelEventArgs> im <xref:System.Windows.Forms.Control.Validating>-Ereignis Delegaten auf `true` festgelegt ist, werden alle Ereignisse, die normalerweise auftreten, nachdem das <xref:System.Windows.Forms.Control.Validating>-Ereignis unterdrückt wurde.  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) und im Abschnitt "Nachrichten Deadlocks" im Thema [Informationen zu Meldungen und Nachrichten Warteschlangen](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete-Klasse <xref:System.Windows.Forms.TextBox> verwendet und eine vom Benutzer eingegebene e-Mail-Adresse überprüft. Wenn die e-Mail-Adresse nicht im Standardformat vorliegt (was "@" and "" enthält), schlägt die Validierung fehl, ein Symbol "<xref:System.Windows.Forms.ErrorProvider>" wird angezeigt, und das Ereignis wird abgebrochen. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.TextBox>-und <xref:System.Windows.Forms.ErrorProvider>-Steuerelement in einem Formular erstellt wurde.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Steuerelement eine Validierung ausführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Fokus mithilfe der Tastatur (Tab, UMSCHALT + TAB usw.) ändern, indem Sie die Methoden <xref:System.Windows.Forms.Control.Select%2A> oder <xref:System.Windows.Forms.Control.SelectNextControl%2A> aufrufen, oder indem Sie die Eigenschaft <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> auf das aktuelle Formular festlegen, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Wenn Sie den Fokus mit der Maus oder durch Aufrufen der <xref:System.Windows.Forms.Control.Focus%2A>-Methode ändern, treten Fokus Ereignisse in der folgenden Reihenfolge auf:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Wenn die <xref:System.Windows.Forms.Control.CausesValidation%2A>-Eigenschaft auf `false` festgelegt ist, werden die Ereignisse <xref:System.Windows.Forms.Control.Validating> und <xref:System.Windows.Forms.Control.Validated> unterdrückt.  
  
 Wenn die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Eigenschaft des <xref:System.ComponentModel.CancelEventArgs> im <xref:System.Windows.Forms.Control.Validating>-Ereignis Delegaten auf `true` festgelegt ist, werden alle Ereignisse, die normalerweise auftreten, nachdem das <xref:System.Windows.Forms.Control.Validating>-Ereignis unterdrückt wurde.  
  
> [!CAUTION]
>  Versuchen Sie nicht, den Fokus innerhalb der Ereignishandler "<xref:System.Windows.Forms.Control.Enter>", "<xref:System.Windows.Forms.Control.GotFocus>", "<xref:System.Windows.Forms.Control.Leave>", "<xref:System.Windows.Forms.Control.LostFocus>", "<xref:System.Windows.Forms.Control.Validating>" oder "<xref:System.Windows.Forms.Control.Validated>" festzulegen. Dies kann dazu führen, dass Ihre Anwendung oder das Betriebssystem nicht mehr reagiert. Weitere Informationen finden Sie im Thema "`WM_KILLFOCUS`" im Abschnitt "Tastatureingabe Referenz" und im Abschnitt "Nachrichten Deadlocks" des Themas "about Messages and Message Queues" in der MSDN Library unter http://msdn.microsoft.com/library.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die abgeleitete-Klasse <xref:System.Windows.Forms.TextBox> verwendet und eine vom Benutzer eingegebene e-Mail-Adresse überprüft. Wenn die e-Mail-Adresse nicht im Standardformat vorliegt (was "@" and "" enthält), schlägt die Validierung fehl, ein Symbol "<xref:System.Windows.Forms.ErrorProvider>" wird angezeigt, und das Ereignis wird abgebrochen. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.TextBox>-und <xref:System.Windows.Forms.ErrorProvider>-Steuerelement in einem Formular erstellt wurde.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob das Steuerelement und alle untergeordneten Steuerelemente angezeigt werden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das Steuerelement und alle untergeordneten Steuerelemente angezeigt werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass das Steuerelement, auch wenn `Visible` auf `true` festgelegt ist, für den Benutzer möglicherweise nicht sichtbar ist, wenn es hinter anderen Steuerelementen verdeckt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die abgeleiteten Klassen <xref:System.Windows.Forms.VScrollBar> und <xref:System.Windows.Forms.HScrollBar> verwendet und deren <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaftswerte basierend auf der Größe eines <xref:System.Drawing.Image> in einem <xref:System.Windows.Forms.PictureBox>-Steuerelement festgelegt. Für dieses Beispiel ist es erforderlich, dass ein <xref:System.Windows.Forms.PictureBox> auf einem Formular erstellt wurde und dass <xref:System.Windows.Forms.HScrollBar>-und <xref:System.Windows.Forms.VScrollBar>-Steuerelemente auf dem <xref:System.Windows.Forms.PictureBox> erstellt wurden. Dieser Code sollte aufgerufen werden, wenn das Bild in das Bildfeld und das <xref:System.Windows.Forms.Control.Resize>-Ereignis des Formulars geladen wird.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Windows.Forms.Control.Visible" />-Eigenschaftswert geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschaft entweder durch eine programmgesteuerte Änderung oder eine Benutzerinteraktion geändert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Control.VisibleChanged>-Ereignis ausgelöst, wenn sich der <xref:System.Windows.Forms.Control.Visible%2A>-Eigenschafts Wert des <xref:System.Windows.Forms.Label>-Steuer Elements geändert hat.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Steuerelements ab bzw. legt diese fest.</summary>
        <value>Die Breite des Steuerelements in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen an den Eigenschafts Werten <xref:System.Windows.Forms.Control.Width%2A> und <xref:System.Windows.Forms.Control.Left%2A> bewirken, dass sich der <xref:System.Windows.Forms.Control.Right%2A>-Eigenschafts Wert des Steuer Elements ändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden drei <xref:System.Windows.Forms.Button>-Steuerelemente in einem Formular erstellt und ihre Größe und Position mithilfe der verschiedenen Größen bezogenen und standortbezogenen Eigenschaften festgelegt. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> verfügen, die über eine Breite und Höhe von mindestens 300 Pixel verfügt.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ist für diese Klasse nicht relevant.</summary>
        <value>Das NativeWindow, das innerhalb des Steuerelements enthalten ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist für diese Klasse nicht relevant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc : Message -&gt; unit&#xA;override this.WndProc : Message -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Die zu verarbeitende Windows-<see cref="T:System.Windows.Forms.Message" />.</param>
        <summary>Verarbeitet Windows-Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Nachrichten werden an die <xref:System.Windows.Forms.Control.WndProc%2A>-Methode gesendet, nachdem Sie durch die <xref:System.Windows.Forms.Control.PreProcessMessage%2A>-Methode gefiltert wurden.  
  
 Die <xref:System.Windows.Forms.Control.WndProc%2A>-Methode entspricht genau der `WindowProc`-Funktion von Windows. Weitere Informationen zum Verarbeiten von Windows-Meldungen finden Sie unter der [WindowProc-Funktion](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie die <xref:System.Windows.Forms.Control.WndProc%2A>-Methode überschreiben, um in der <xref:System.Windows.Forms.Message>-Struktur identifizierte Betriebssystem Meldungen zu verarbeiten. In diesem Beispiel wird die [WM_ACTIVATEAPP](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) -Betriebssystem Meldung behandelt, um zu erfahren, wann eine andere Anwendung aktiv wird. In den folgenden Themen finden Sie Informationen zu den verfügbaren Werten <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType> und <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType>. Tatsächliche Konstante Werte finden Sie in der Header Datei "Windows. h".  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Erbende Steuerelemente sollten die <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />-Methode der Basisklasse aufzurufen, um alle Nachrichten zu verarbeiten, die Sie nicht verarbeiten.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>
