<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="963b636ba134d79aed036f4f9ae7a441ac80bb57" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75175923" /></Metadata><TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Cursor = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt das Bild dar, das zum Zeichnen des Mauszeigers verwendet wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cursor ist ein kleines Bild, dessen Position auf dem Bildschirm von einem Zeigegerät gesteuert wird, z. b. mit einer Maus, einem Stift oder einem Trackball. Wenn der Benutzer das Zeigegerät verschiebt, verschiebt das Betriebssystem den Cursor entsprechend.  
  
 Verschiedene Cursor Formen werden verwendet, um den Benutzer darüber zu informieren, welche Operation die Maus hat. Wenn Sie z. b. Text bearbeiten oder auswählen, wird in der Regel ein <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> Cursor angezeigt. Ein warte Cursor wird häufig verwendet, um den Benutzer darüber zu informieren, dass gerade ein Prozess ausgeführt wird. Beispiele für Prozesse, auf die der Benutzer möglicherweise wartet, das Öffnen einer Datei, das Speichern einer Datei oder das Ausfüllen eines Steuer Elements, z. b. eine <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> oder <xref:System.Windows.Forms.TreeView> mit einer großen Datenmenge.  
  
 Alle Steuerelemente, die von der <xref:System.Windows.Forms.Control>-Klasse abgeleitet werden, haben eine <xref:System.Windows.Forms.Control.Cursor%2A>-Eigenschaft. Um den Cursor zu ändern, der mit dem Mauszeiger angezeigt wird, wenn er sich innerhalb der Begrenzungen des Steuer Elements befindet, weisen Sie der <xref:System.Windows.Forms.Control.Cursor%2A>-Eigenschaft des Steuer Elements einen <xref:System.Windows.Forms.Cursor> zu. Alternativ können Sie Cursor auf Anwendungsebene anzeigen, indem Sie der Eigenschaft <xref:System.Windows.Forms.Cursor.Current%2A> einen <xref:System.Windows.Forms.Cursor> zuweisen. Wenn z. b. der Zweck der Anwendung darin besteht, eine Textdatei zu bearbeiten, können Sie die <xref:System.Windows.Forms.Cursor.Current%2A>-Eigenschaft auf <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> festlegen, um einen Wait-Cursor über der Anwendung anzuzeigen, während die Datei lädt oder speichert, um zu verhindern, dass Mausereignisse verarbeitet werden. Wenn der Prozess beendet ist, legen Sie die <xref:System.Windows.Forms.Cursor.Current%2A>-Eigenschaft auf <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> fest, damit die Anwendung den entsprechenden Cursor über den einzelnen Steuerelement Typen anzeigt.  
  
> [!NOTE]
>  Wenn Sie <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> vor dem Zurücksetzen der Eigenschaft <xref:System.Windows.Forms.Cursor.Current%2A> auf den <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> Cursor zurücksetzen, wird die Anwendung mit dem lauschen auf Mausereignisse fortgesetzt und wird fortgesetzt, um die entsprechenden <xref:System.Windows.Forms.Cursor> für jedes Steuerelement in der Anwendung anzuzeigen.  
  
 Cursor Objekte können aus verschiedenen Quellen erstellt werden, z. b. dem Handle eines vorhandenen <xref:System.Windows.Forms.Cursor>, einer Standard <xref:System.Windows.Forms.Cursor> Datei, einer Ressource oder eines Datenstroms.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Cursor>-Klasse unterstützt keine animierten Cursor (. ANI-Dateien) oder Cursor mit anderen Farben als schwarz und weiß.  
  
 Wenn das Abbild, das Sie als Cursor verwenden, zu klein ist, können Sie die <xref:System.Windows.Forms.Cursor.DrawStretched%2A>-Methode verwenden, um zu erzwingen, dass das Bild die Begrenzungen des Cursors abschließt. Sie können den Cursor temporär ausblenden, indem Sie die <xref:System.Windows.Forms.Cursor.Hide%2A>-Methode aufrufen und Sie durch Aufrufen der <xref:System.Windows.Forms.Cursor.Show%2A>-Methode wiederherstellen.  
  
 Beginnend mit der .NET Framework 4.5.2 wird die Größe des <xref:System.Windows.Forms.Cursor> basierend auf der System-dpi-Einstellung geändert, wenn die Datei "App. config" den folgenden Eintrag enthält:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular angezeigt, das die Verwendung eines benutzerdefinierten Cursors veranschaulicht. Der benutzerdefinierte <xref:System.Windows.Forms.Cursor> ist in die Ressourcen Datei der Anwendung eingebettet. Für das Beispiel wird ein Cursor benötigt, der in einer Cursor Datei namens `MyCursor.cur`enthalten ist. Um dieses Beispiel mit der Befehlszeile zu kompilieren, fügen Sie das folgende Flag ein: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 Das folgende Codebeispiel zeigt Kundeninformationen in einem <xref:System.Windows.Forms.TreeView>-Steuerelement an. In den Stamm Struktur Knoten werden Kundennamen angezeigt, und die untergeordneten Struktur Knoten zeigen die Bestellnummern an, die den einzelnen Kunden zugewiesen sind. In diesem Beispiel werden 1.000-Kunden mit jeweils 15 Bestellungen angezeigt. Das erneute Zeichnen des <xref:System.Windows.Forms.TreeView> wird mithilfe der Methoden <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> und <xref:System.Windows.Forms.TreeView.EndUpdate%2A> unterdrückt, und ein warte Vorgang <xref:System.Windows.Forms.Cursor> wird angezeigt, während die <xref:System.Windows.Forms.TreeView> Objekte erstellt und zeichnet.<xref:System.Windows.Forms.TreeNode> Für dieses Beispiel ist es erforderlich, dass eine Cursor Datei namens `MyWait.cur` im Anwendungsverzeichnis vorhanden ist. Außerdem ist ein `Customer` Objekt erforderlich, das eine Auflistung von `Order` Objekten enthalten kann, und Sie haben eine Instanz eines <xref:System.Windows.Forms.TreeView>-Steuer Elements auf einer <xref:System.Windows.Forms.Form>erstellt.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Cursor" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : nativeint -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein <see cref="T:System.IntPtr" />, der das Windows-Handle des zu erstellenden Cursors darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Cursor" />-Klasse anhand des angegebenen Windows-Handles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie damit abgeschlossen sind, müssen Sie das Cursor Handle freigeben. Weitere Informationen zum Freigeben von Ressourcen finden [Sie unter Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus dem <xref:System.Windows.Forms.Cursor.Handle%2A>des <xref:System.Windows.Forms.Cursor.Current%2A> Cursors erstellt, dessen Position und das Clippingrechteck geändert werden. Das Ergebnis ist, dass der Cursor nach oben und nach links 50 Pixel wechselt, wenn der Code ausgeführt wird. Außerdem wird das Clippingrechteck des Cursors in die Begrenzungen des Formulars geändert (Standardmäßig ist dies der gesamte Bildschirm des Benutzers). Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> und eine <xref:System.Windows.Forms.Button> verfügen, um diesen Code aufzurufen, wenn darauf geklickt wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : System.IO.Stream -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Datenstream, aus dem der <see cref="T:System.Windows.Forms.Cursor" /> geladen werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Cursor" />-Klasse aus dem angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der durch `stream` angegebene Datenstrom muss eine Cursor Datei (. cur) enthalten.  
  
> [!NOTE]
>  Animierte Cursor (. ANI-Dateien) werden von der <xref:System.Windows.Forms.Cursor>-Klasse nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus einer <xref:System.IO.Stream> geladen, die von der <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A>-Methode einer <xref:System.Windows.Forms.OpenFileDialog>erstellt wurde. Wenn die-Methode aufgerufen wird, wird dem Benutzer eine <xref:System.Windows.Forms.OpenFileDialog> angezeigt. Die CUR-Datei ist ausgewählt, und das Dialogfeld wird geschlossen, die Datei wird geöffnet, und die zurückgegebene <xref:System.IO.Stream> wird zum Erstellen einer <xref:System.Windows.Forms.Cursor>verwendet.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Die zu ladende Cursordatei.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Cursor" />-Klasse aus der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `fileName`-Parameter muss auf eine Standard Cursor Datei (. cur) verweisen.  
  
> [!NOTE]
>  Animierte Cursor (. ANI-Dateien) werden von der <xref:System.Windows.Forms.Cursor>-Klasse nicht unterstützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt Kundeninformationen in einem <xref:System.Windows.Forms.TreeView>-Steuerelement an. In den Stamm Struktur Knoten werden Kundennamen angezeigt, und die untergeordneten Struktur Knoten zeigen die Bestellnummern an, die den einzelnen Kunden zugewiesen sind. In diesem Beispiel werden 1.000-Kunden mit jeweils 15 Bestellungen angezeigt. Das erneute Zeichnen des <xref:System.Windows.Forms.TreeView> wird mithilfe der Methoden <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> und <xref:System.Windows.Forms.TreeView.EndUpdate%2A> unterdrückt, und ein warte Vorgang <xref:System.Windows.Forms.Cursor> wird angezeigt, während die <xref:System.Windows.Forms.TreeView> Objekte erstellt und zeichnet.<xref:System.Windows.Forms.TreeNode> Für dieses Beispiel ist es erforderlich, dass Sie über ein `Customer` Objekt verfügen, das eine Auflistung von `Order`-Objekten enthalten kann. Außerdem ist es erforderlich, dass Sie eine Instanz eines <xref:System.Windows.Forms.TreeView>-Steuer Elements auf einer <xref:System.Windows.Forms.Form>erstellt haben.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : Type * string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor (type, resource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Die Ressource <see cref="T:System.Type" />.</param>
        <param name="resource">Der Name der Ressource.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Forms.Cursor" />-Klasse aus der angegebenen Ressource mit dem angegebenen Ressourcentyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden finden Sie ein Beispiel dafür, wie Sie einen Cursor als Ressource in Ihre Anwendung einbetten. Zum Einbetten der Ressource verweisen Sie auf den Ressourcennamen, gefolgt von einem Komma und dem vollständigen Assemblypfad. Weitere Informationen zum Laden des Cursors aus der eingebetteten Ressource finden Sie im Abschnitt "Beispiel".  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  Beim Kompilieren und beim Verweisen auf den Ressourcen Verweis im Code wird die Groß-/Kleinschreibung sowohl für die C# -als auch die-Visual Basic Compiler beachtet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular angezeigt, das die Verwendung eines benutzerdefinierten Cursors mithilfe des <xref:System.Windows.Forms.Cursor.%23ctor%2A>-Konstruktors veranschaulicht. Der benutzerdefinierte <xref:System.Windows.Forms.Cursor> ist in die Ressourcen Datei der Anwendung eingebettet. Für das Beispiel ist es erforderlich, dass ein Cursor in einer Cursor Datei mit dem Namen `MyCursor.cur`enthalten ist. Um dieses Beispiel mit der Befehlszeile zu kompilieren, fügen Sie das folgende Flag ein: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Cursor.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Begrenzungen ab, die das Auswahlrechteck für den Cursor darstellen, oder legt diese fest.</summary>
        <value>Das <see cref="T:System.Drawing.Rectangle" /> in Bildschirmkoordinaten, das das Auswahlrechteck für den <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein abgeschnitten-Cursor darf nur innerhalb seines clippingrechtecks verschoben werden. Im Allgemeinen lässt das System dies nur zu, wenn die Maus aktuell aufgezeichnet ist. Wenn der Cursor derzeit nicht abgeschnitten ist, enthält das resultierende Rechteck die Abmessungen des gesamten Bildschirms.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus dem <xref:System.Windows.Forms.Cursor.Handle%2A>des <xref:System.Windows.Forms.Cursor.Current%2A> Cursors erstellt, dessen Position und das Clippingrechteck geändert werden. Das Ergebnis ist, dass der Cursor nach oben und nach links 50 Pixel wechselt, wenn der Code ausgeführt wird. Außerdem wird das Clippingrechteck des Cursors in die Begrenzungen des Formulars geändert (Standardmäßig ist dies der gesamte Bildschirm des Benutzers). Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> und eine <xref:System.Windows.Forms.Button> verfügen, um diesen Code aufzurufen, wenn darauf geklickt wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Diese Eigenschaft wird für alle Fenster festgelegt. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberSignature Language="F#" Value="member this.CopyHandle : unit -&gt; nativeint" Usage="cursor.CopyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert das Handle dieses <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>Ein <see cref="T:System.IntPtr" />, der das Cursorhandle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das als Ergebnis des Aufrufs dieser Methode erstellte Handle muss verworfen werden, wenn Sie es nicht mehr benötigen, da es vom Garbage Collector nicht verworfen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Cursor.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Cursorobjekt ab, das den Mauscursor darstellt, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Windows.Forms.Cursor" />, der den Mauscursor darstellt. Der Standardwert ist <see langword="null" />, wenn der Mauscursor nicht angezeigt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen der <xref:System.Windows.Forms.Cursor.Current%2A>-Eigenschaft wird der aktuell angezeigte Cursor geändert. Die Anwendung lauscht möglicherweise weiterhin auf Mausereignisse. Verwenden Sie die <xref:System.Windows.Forms.Application.UseWaitCursor%2A>-Eigenschaft, um zu signalisieren, dass die Anwendung während eines Vorgangs mit langer Ausführungszeit nicht auf Mausereignisse reagieren sollte. In den meisten Fällen ist es jedoch besser, einen Hintergrund Thread zu verwenden, um einen Vorgang mit langer Ausführungsdauer zu verwalten und die Benutzeroberfläche für den Benutzer zugänglich zu machen. Weitere Informationen zur einfachen Implementierung einer Hintergrundaufgabe finden Sie unter <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für sichere Unterfenster, um diese Eigenschaft festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cursor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Veröffentlicht alle durch den <see cref="T:System.Windows.Forms.Cursor" /> verwendeten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.Cursor.Dispose%2A> auf, wenn Sie <xref:System.Windows.Forms.Cursor> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Windows.Forms.Cursor> nicht mehr verwendet werden kann. Nachdem Sie <xref:System.Windows.Forms.Cursor.Dispose%2A>aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Windows.Forms.Cursor> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Windows.Forms.Cursor> belegt hat. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
> [!NOTE]
>  Rufen Sie immer <xref:System.Windows.Forms.Cursor.Dispose%2A> auf, bevor Sie den letzten Verweis auf das <xref:System.Windows.Forms.Cursor> freigeben. Andernfalls werden die von ihr verwendeten Ressourcen erst freigegeben, wenn Sie vom Garbage Collector freigegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Für dieses Beispiel müssen ein <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor> an die-Methode übergeben werden, wenn es aufgerufen wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.Draw (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Die <see cref="T:System.Drawing.Graphics" />-Oberfläche, auf der der <see cref="T:System.Windows.Forms.Cursor" /> gezeichnet werden soll.</param>
        <param name="targetRect">Das <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen des <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</param>
        <summary>Zeichnet den Cursor auf der angegebenen Oberfläche innerhalb der angegebenen Begrenzungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeichnungs Befehl stammt aus der Grafik Oberfläche, die durch den `g`-Parameter dargestellt wird, aber ein <xref:System.Drawing.Graphics> enthält keine Informationen zum Rendervorgang eines bestimmten Bilds, daher wird der Anruf an die <xref:System.Windows.Forms.Cursor>übergeben. Die <xref:System.Windows.Forms.Cursor.Draw%2A>-Methode erstellt das Bild auf die angegebenen Dimensionen und ermöglicht es Ihnen, ein <xref:System.Drawing.Rectangle> anzugeben, in dem die <xref:System.Windows.Forms.Cursor>gezeichnet werden soll. Diese Methode wird normalerweise verwendet, wenn Sie den Cursor auf einer Grafik Oberfläche zeichnen möchten. Beispielsweise können Sie über ein Dialogfeld verfügen, das es dem Benutzer ermöglicht, Cursor aus einem <xref:System.Windows.Forms.ListBox>-Steuerelement oder einer Gruppe von <xref:System.Windows.Forms.RadioButton> Steuerelementen auszuwählen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor> Objekt verfügen, das beim Aufrufen an die-Methode übergeben wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawStretched : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.DrawStretched (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Die <see cref="T:System.Drawing.Graphics" />-Oberfläche, auf der der <see cref="T:System.Windows.Forms.Cursor" /> gezeichnet werden soll.</param>
        <param name="targetRect">Das <see cref="T:System.Drawing.Rectangle" />, das die Begrenzungen des <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</param>
        <summary>Zeichnet den Cursor in gestrecktem Format auf der angegebenen Oberfläche innerhalb der angegebenen Begrenzungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeichnungs Befehl stammt aus der durch den `g`-Parameter dargestellten Grafik Oberfläche, aber ein <xref:System.Drawing.Graphics>-Objekt enthält keine Informationen zum rendieren eines bestimmten Bilds, sodass es den Anruf an das <xref:System.Windows.Forms.Cursor>-Objekt übergibt. Die <xref:System.Windows.Forms.Cursor.DrawStretched%2A>-Methode dehnt das Bild aus, um die angegebene <xref:System.Drawing.Rectangle> auszufüllen, wenn der Cursor gezeichnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Für dieses Beispiel ist es erforderlich, dass Sie über eine <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor> Objekt verfügen, das beim Aufrufen an die-Methode übergeben wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cursor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Der zu vergleichende <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob dieser Cursor mit dem angegebenen <see cref="T:System.Windows.Forms.Cursor" /> übereinstimmt.</summary>
        <returns><see langword="true" />, wenn dieser Cursor dem angegebenen <see cref="T:System.Windows.Forms.Cursor" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus dem <xref:System.Windows.Forms.Cursor.Handle%2A>des <xref:System.Windows.Forms.Cursor.Current%2A> Cursors erstellt, dessen Position und das Clippingrechteck geändert werden. Das Ergebnis ist, dass der Cursor nach oben und nach links 50 Pixel wechselt, wenn der Code ausgeführt wird. Außerdem wird das Clippingrechteck des Cursors in die Begrenzungen des Formulars geändert (Standardmäßig ist dies der gesamte Bildschirm des Benutzers). Für dieses Beispiel sind eine <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Button> erforderlich, um diesen Code aufzurufen, wenn darauf geklickt wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="cursor.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cursor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Hashcode für den aktuellen <see cref="T:System.Windows.Forms.Cursor" /> ab.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Cursor.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle des Cursors ab.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, der das Cursorhandle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist keine Kopie des Handles. verwerfen Sie diese nicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus dem <xref:System.Windows.Forms.Cursor.Handle%2A>des <xref:System.Windows.Forms.Cursor.Current%2A> Cursors erstellt, dessen Position und das Clippingrechteck geändert werden. Das Ergebnis ist, dass der Cursor nach oben und nach links 50 Pixel wechselt, wenn der Code ausgeführt wird. Außerdem wird das Clippingrechteck des Cursors in die Begrenzungen des Formulars geändert (Standardmäßig ist dies der gesamte Bildschirm des Benutzers). Für dieses Beispiel sind eine <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Button> erforderlich, um diesen Code aufzurufen, wenn darauf geklickt wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Der Handlewert ist <see cref="F:System.IntPtr.Zero" />.</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberSignature Language="F#" Value="static member Hide : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blendet den Cursor aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Cursor.Show%2A>-und <xref:System.Windows.Forms.Cursor.Hide%2A> Methodenaufrufe müssen ausgeglichen werden. Für jeden aufzurufenden <xref:System.Windows.Forms.Cursor.Hide%2A>-Methode muss ein entsprechender aufrufungsmethode für die <xref:System.Windows.Forms.Cursor.Show%2A>-Methode vorhanden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Cursor ausgeblendet, wenn der Mauszeiger in den Client Bereich der Schaltfläche gelangt. Wenn der Mauszeiger den Client Bereich der Schaltfläche verlässt, wird der Cursor ebenfalls angezeigt. Dieses Beispiel erfordert eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Button> mit dem Namen `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">bei allen Fenstern wird diese Methode aufgerufen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.HotSpot : System.Drawing.Point" Usage="System.Windows.Forms.Cursor.HotSpot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursorhotspot ab.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" />, der den Cursorhotspot darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Forms.Cursor.HotSpot%2A> ist der <xref:System.Drawing.Point> im Cursor, der mit anderen Elementen auf dem Bildschirm interagiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">Ein zu vergleichender <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="right">Ein zu vergleichender <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Windows.Forms.Cursor" />-Klasse gleich sind.</summary>
        <returns><see langword="true" />, wenn zwei Instanzen der <see cref="T:System.Windows.Forms.Cursor" />-Klasse gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Dieses Beispiel erfordert, dass ein <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor>-Objekt an die-Methode übergeben werden, wenn es aufgerufen wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="System.Windows.Forms.Cursor.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">Ein zu vergleichender <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="right">Ein zu vergleichender <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Windows.Forms.Cursor" />-Klasse ungleich sind.</summary>
        <returns><see langword="true" />, wenn zwei Instanzen der <see cref="T:System.Windows.Forms.Cursor" />-Klasse ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Für dieses Beispiel müssen ein <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor> an die-Methode übergeben werden, wenn es aufgerufen wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Cursor.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Cursors ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Point" /> in Bildschirmkoordinaten, der die Position des Cursors darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Cursor.Position%2A>-Eigenschaft ist identisch mit der <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Cursor aus dem <xref:System.Windows.Forms.Cursor.Handle%2A>des <xref:System.Windows.Forms.Cursor.Current%2A> Cursors erstellt, dessen Position und das Clippingrechteck geändert werden. Das Ergebnis ist, dass der Cursor nach oben und nach links 50 Pixel wechselt, wenn der Code ausgeführt wird. Außerdem wird das Clippingrechteck des Cursors in die Begrenzungen des Formulars geändert (Standardmäßig ist dies der gesamte Bildschirm des Benutzers). Für dieses Beispiel sind eine <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Button> erforderlich, um diesen Code aufzurufen, wenn darauf geklickt wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberSignature Language="F#" Value="static member Show : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt den Cursor an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Cursor.Show%2A>-und <xref:System.Windows.Forms.Cursor.Hide%2A> Methodenaufrufe müssen ausgeglichen werden. Für jeden aufzurufenden <xref:System.Windows.Forms.Cursor.Hide%2A>-Methode muss ein entsprechender aufrufungsmethode für die <xref:System.Windows.Forms.Cursor.Show%2A>-Methode vorhanden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Cursor ausgeblendet, wenn der Mauszeiger in den Client Bereich der Schaltfläche gelangt. Wenn der Mauszeiger den Client Bereich der Schaltfläche verlässt, wird der Cursor ebenfalls angezeigt. Dieses Beispiel erfordert eine <xref:System.Windows.Forms.Form> mit einem <xref:System.Windows.Forms.Button> mit dem Namen `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Windows.Forms.Cursor.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Cursorobjekts ab.</summary>
        <value>Die <see cref="T:System.Drawing.Size" />, die die Breite und Höhe des <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird der angegebene Cursor auf dem Formular in der normalen Größe und im gestreckten Modus zweimal in der Größe gezeichnet. Dieses Beispiel erfordert, dass ein <xref:System.Windows.Forms.Form> und ein <xref:System.Windows.Forms.Cursor>-Objekt an die-Methode übergeben werden, wenn es aufgerufen wird.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Eine <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse.</param>
        <param name="context">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse.</param>
        <summary>Serialisiert das Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Cursor.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das Daten über <see cref="T:System.Windows.Forms.Cursor" /> enthält, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Object" />, das Daten über den <see cref="T:System.Windows.Forms.Cursor" /> enthält. Der Standardwert ist <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cursor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine lesbare Zeichenfolge ab, die diesen <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.String" />, der diesen <see cref="T:System.Windows.Forms.Cursor" /> darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
