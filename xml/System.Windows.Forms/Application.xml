<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cac7655894f0a1172d48e20fef8b393c9e1a03b6" /><Meta Name="ms.sourcegitcommit" Value="81833381d2d0b5a8c55f71b43f00769fd38298af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2019" /><Meta Name="ms.locfileid" Value="69572194" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt <see langword="static" />-Methoden und Eigenschaften für die Verwaltung einer Anwendung zur Verfügung, z. B. Methoden zum Starten und Beenden einer Anwendung, zum Verarbeiten von Windows-Meldungen sowie Eigenschaften für das Abrufen von Informationen zu einer Anwendung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application> -Klasse verfügt über Methoden zum Starten und Abbrechen von Anwendungen und Threads sowie zum Verarbeiten von Windows-Meldungen wie folgt:  
  
-   <xref:System.Windows.Forms.Application.Run%2A>startet eine Anwendungs Nachrichten Schleife für den aktuellen Thread und macht optional ein Formular sichtbar.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A>oder <xref:System.Windows.Forms.Application.ExitThread%2A> beendet eine Nachrichten Schleife.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A>verarbeitet Nachrichten, während sich das Programm in einer Schleife befindet.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A>Fügt der anwendungsnachrichtenpump einen Nachrichtenfilter hinzu, um Windows-Meldungen zu überwachen.  
  
-   <xref:System.Windows.Forms.IMessageFilter>Hiermit können Sie verhindern, dass ein Ereignis ausgelöst wird, oder spezielle Vorgänge ausführen, bevor Sie einen Ereignishandler aufrufen.  
  
 Diese Klasse verfügt <xref:System.Windows.Forms.Application.CurrentCulture%2A> über <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> die Eigenschaften und, um Kultur Informationen für den aktuellen Thread zu erhalten oder festzulegen.  
  
 Eine Instanz dieser Klasse kann nicht erstellt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Zahlen in einem Listenfeld auf einem Formular aufgelistet. Jedes Mal, wenn `button1`Sie auf klicken, fügt die Anwendung der Liste eine weitere Nummer hinzu.  
  
 Die `Main` -Methode <xref:System.Windows.Forms.Application.Run%2A> Ruft auf, um die Anwendung zu starten, die `listBox1` das `button1`Formular erstellt, und. Wenn der Benutzer auf `button1`klickt, `button1_Click` wird von der <xref:System.Windows.Forms.MessageBox>-Methode eine angezeigt. Wenn der Benutzer auf `No` das <xref:System.Windows.Forms.MessageBox>klickt, fügt `button1_Click` die-Methode der Liste eine Zahl hinzu. Wenn der Benutzer auf `Yes`klickt, ruft <xref:System.Windows.Forms.Application.Exit%2A> die Anwendung auf, um alle verbleibenden Nachrichten in der Warteschlange zu verarbeiten und dann zu beenden.  
  
> [!NOTE]
>  Bei teilweiser <xref:System.Windows.Forms.Application.Exit%2A> Vertrauenswürdigkeit schlägt der-Aufrufe fehl.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Die Implementierung der zu installierenden <see cref="T:System.Windows.Forms.IMessageFilter" />-Schnittstelle.</param>
        <summary>Fügt einen Meldungsfilter zum Überwachen von Windows-Meldungen beim Weiterleiten an das Ziel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie einen Nachrichtenfilter, um zu verhindern, dass bestimmte Ereignisse ausgelöst werden, oder um spezielle Vorgänge für ein Ereignis auszuführen, bevor es an einen Ereignishandler übermittelt wird. Nachrichtenfilter sind für einen bestimmten Thread eindeutig.  
  
 Um zu verhindern, dass eine Nachricht gesendet wird `value` , muss die Parameter Instanz, die Sie an diese Methode <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> übergeben, die Methode mit dem Code überschreiben, um die Nachricht zu verarbeiten. Die Methode muss `false`zurückgeben.  
  
> [!CAUTION]
>  Durch das Hinzufügen von Nachrichten filtern zum nachrichtenpump für eine Anwendung kann die Leistung beeinträchtigt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Nachrichtenfilter mit `TestMessageFilter`dem Namen erstellt. Mit diesem Filter werden alle Nachrichten im Zusammenhang mit der linken Maustaste blockiert. Bevor Sie einen Nachrichtenfilter verwenden können, müssen Sie eine Implementierung für die <xref:System.Windows.Forms.IMessageFilter> -Schnittstelle bereitstellen.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Aufrufer diese Anwendung beenden kann.</summary>
        <value><see langword="true" />, wenn der Aufrufer diese Anwendung beenden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `false` zurück, wenn Sie von einem <xref:System.Windows.Forms.Control> aufgerufen wird, der in einem Webbrowser gehostet wird. Daher kann die nicht <xref:System.Windows.Forms.Application>beenden. <xref:System.Windows.Forms.Control>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Anwendung gerade beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen die Ereignishandler an das `ApplicationExit` -Ereignis anfügen, um unbehandelte, erforderliche Aufgaben auszuführen, bevor die Ausführung der Anwendung beendet wird. Sie können Dateien schließen, die von dieser Anwendung geöffnet wurden, oder Objekte verwerfen, die von Garbage Collection nicht freigegeben wurden.  
  
 Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie alle Ereignishandler trennen, die `ApplicationExit` an dieses Ereignis im Ereignishandler selbst angefügt sind. Wenn Sie diese Handler nicht trennen, bleiben Sie an das Ereignis angefügt und verbrauchen weiterhin Arbeitsspeicher.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Formulare angezeigt, und die Anwendung wird beendet, wenn beide Formulare geschlossen sind. Wenn die Anwendung gestartet und beendet wird, wird die Position der einzelnen Formulare gespeichert. In diesem Beispiel wird die `ApplicationExit` Verwendung des-Ereignisses erläutert, um zu ermitteln, wann die Formular Positionen in der Datei `FileStream` persistent gespeichert werden sollen und wann die geschlossen werden soll.  
  
 Die Klasse `MyApplicationContext` erbt von <xref:System.Windows.Forms.ApplicationContext> und verfolgt, wann jedes Formular geschlossen ist, und beendet den aktuellen Thread, wenn beide vorhanden sind. Die-Klasse speichert die Position der einzelnen Formulare, wenn Sie geschlossen wird. Wenn das `ApplicationExit` -Ereignis auftritt, schreibt die-Klasse die Positionen der einzelnen für den Benutzer in die Datei. Die Formular Positionsdaten werden in einer Datei mit dem `appdata.txt` Namen gespeichert, die an dem von <xref:System.Windows.Forms.Application.UserAppDataPath%2A>festgelegten Speicherort erstellt wird. Die `Main` -Methode `Application.Run(context)` Ruft auf, um die Anwendung <xref:System.Windows.Forms.ApplicationContext>mit dem zu starten.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der Übersicht <xref:System.Windows.Forms.ApplicationContext> über die-Klasse. Das <xref:System.Windows.Forms.ApplicationContext> gesamte Codelisting finden Sie unter.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten ab, die von allen Benutzern gemeinsam genutzt werden.</summary>
        <value>Der Pfad für die Anwendungsdaten, der von allen Benutzern gemeinsam genutzt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein Pfad vorhanden ist, wird ein Pfad im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>prüft zunächst, ob die Assembly, die die Haupt ausführbare Datei `AssemblyInformationalVersion` enthält, über das-Attribut verfügt. Wenn dieses Attribut vorhanden ist, wird es sowohl <xref:System.Windows.Forms.Application.ProductVersion%2A> für als auch <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>für verwendet. Wenn dieses Attribut nicht vorhanden ist, verwenden beide Eigenschaften stattdessen die Version der ausführbaren Datei.  
  
 Je nachdem, ob die Windows Forms Anwendung mithilfe [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]von bereitgestellt wird, unterscheidet sich der Pfad. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]Anwendungen werden in einem Anwendungscache pro Benutzer im Verzeichnis "c:\Dokumente und Einstellungen\\*Benutzername* " gespeichert. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remote Daten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Registrierungsschlüssel für die Anwendungsdaten ab, die von allen Benutzern gemeinsam genutzt werden.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.RegistryKey" />, der den Registrierungsschlüssel für die Anwendungsdaten darstellt, die von allen Benutzern gemeinsam genutzt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel nicht vorhanden ist, wird er im folgenden Format erstellt:  
  
 Localmachine\software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den der Anwendung zugeordneten Firmennamen ab.</summary>
        <value>Der Firmenname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kulturinformationen für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Globalization.CultureInfo" />, die die Kulturinformationen für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Diese Eigenschaft wird für alle Fenster festgelegt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Eingabesprache für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.InputLanguage" />, die die aktuelle Eingabesprache für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verarbeitet alle Windows-Meldungen, die sich derzeit in der Meldungswarteschlange befinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Windows Form ausführen, wird das neue Formular erstellt, das dann auf die Verarbeitung von Ereignissen wartet. Jedes Mal, wenn das Formular ein Ereignis behandelt, verarbeitet es den gesamten Code, der diesem Ereignis zugeordnet ist. Alle anderen Ereignisse warten in der Warteschlange. Während der Code das Ereignis behandelt, antwortet Ihre Anwendung nicht. Beispielsweise wird das Fenster nicht neu gezeichnet, wenn ein anderes Fenster oben gezogen wird.  
  
 Wenn Sie im <xref:System.Windows.Forms.Application.DoEvents%2A> Code aufzurufen, kann die Anwendung die anderen Ereignisse verarbeiten. Wenn Sie z. b. ein Formular haben, das einem <xref:System.Windows.Forms.ListBox> hinzugefügt wird, und dem Code hinzufügen <xref:System.Windows.Forms.Application.DoEvents%2A> , wird das Formular neu gezeichnet, wenn ein anderes Fenster darauf gezogen wird. Wenn Sie aus <xref:System.Windows.Forms.Application.DoEvents%2A> dem Code entfernen, wird das Formular erst neu gezeichnet, wenn der Click-Ereignishandler der Schaltfläche die Ausführung abgeschlossen hat. Weitere Informationen zu Messaging finden Sie unter [User Input in Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 Anders als bei Visual Basic 6,0 <xref:System.Windows.Forms.Application.DoEvents%2A> wird die-Methode von <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> der-Methode nicht aufgerufen.  
  
 In der Regel verwenden Sie diese Methode in einer-Schleife, um Nachrichten zu verarbeiten.  
  
> [!CAUTION]
>  Das Aufrufen dieser Methode bewirkt, dass der aktuelle Thread angehalten wird, während alle wartenden Fenster Meldungen verarbeitet werden. Wenn eine Meldung bewirkt, dass ein Ereignis ausgelöst wird, werden möglicherweise andere Bereiche des Anwendungs Codes ausgeführt. Dies kann dazu führen, dass Ihre Anwendung unerwartete Verhalten aufweist, die schwer zu Debuggen sind. Wenn Sie Vorgänge oder Berechnungen durchführen, die sehr lange dauern, ist es häufig vorzuziehen, diese Vorgänge in einem neuen Thread auszuführen. Weitere Informationen zur asynchronen Programmierung finden Sie unter [asynchronen Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.Windows.Forms.Application.DoEvents%2A> der-Methode veranschaulicht. Wenn das Beispiel ausgeführt wird, kann ein Benutzer Grafikdateien aus einer <xref:System.Windows.Forms.OpenFileDialog>auswählen. Die ausgewählten Dateien werden im Formular angezeigt. Die <xref:System.Windows.Forms.Application.DoEvents%2A> -Methode erzwingt das Neuzeichnen des Formulars für jede geöffnete Grafikdatei. Fügen Sie zum Ausführen dieses Beispiels den folgenden Code in ein Formular ein, <xref:System.Windows.Forms.PictureBox> das `PictureBox1`eine benannte <xref:System.Windows.Forms.OpenFileDialog> , `OpenFileDialog1`eine benannte und eine Schalt `fileButton`Fläche mit dem Namen enthält. Ruft die `InitializePictureBox` Methoden `InitializeOpenFileDialog` und aus dem Konstruktor oder `Load` der Methode des Formulars auf.  
  
> [!NOTE]
>  Wenn Sie in Visual Studio dem Formular mithilfe <xref:System.Windows.Forms.OpenFileDialog> eines Zieh Vorgangs einen hinzufügen, müssen Sie die folgende `InitializeOpenFileDialog` Methode ändern, indem Sie die Zeile entfernen, mit der eine neue Instanz von <xref:System.Windows.Forms.OpenFileDialog>erstellt wird.  
  
 Das Beispiel erfordert auch, dass <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> das <xref:System.Windows.Forms.OpenFileDialog> -Ereignis <xref:System.Windows.Forms.Button> des-Steuer <xref:System.Windows.Forms.FileDialog.FileOk> Elements und des-Ereignisses mit den Ereignis Handlern verbunden sind, die im Beispiel definiert sind. Wenn das Beispiel ausgeführt wird, klicken Sie auf die Schaltfläche, um das Dialogfeld anzuzeigen.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert visuelle Stile für die Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode aktiviert visuelle Stile für die Anwendung. Visuelle Stile sind die Farben, Schriftarten und anderen visuellen Elemente, die ein Betriebssystemdesign bilden. Steuerelemente werden mit visuellen Stilen gezeichnet, wenn Sie vom-Steuerelement und dem Betriebssystem unterstützt werden. Um einen Effekt zu haben <xref:System.Windows.Forms.Application.EnableVisualStyles> , muss vor dem Erstellen von Steuerelementen in der Anwendung aufgerufen werden <xref:System.Windows.Forms.Application.EnableVisualStyles> . in der Regel ist die `Main` erste Zeile in der Funktion. Ein separates Manifest ist nicht erforderlich, um visuelle Stile beim Aufrufen <xref:System.Windows.Forms.Application.EnableVisualStyles>von zu aktivieren.  
  
> [!NOTE]
>  Vor dem .NET Framework 2,0 musste die `FlatStyle` -Eigenschaft einiger Steuerelemente, wie z. b. Steuerelemente, die von <xref:System.Windows.Forms.ButtonBase>abgeleitet werden <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> , auf festgelegt werden, damit die Steuerelemente mit visuellen Stilen gezeichnet werden. In Anwendungen, die mit dem .NET Framework 2,0 geschrieben wurden, ist dies nicht mehr erforderlich.  
  
> [!NOTE]
>  Diese Methode hat keine Auswirkung auf Steuerelemente, die in Internet Explorer gehostet werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> Aufrufen von `Main` in der-Funktion veranschaulicht, um visuelle Stile für die Anwendung zu aktivieren.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Anwendung in einen modalen Zustand übergeht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Application.EnterThreadModal> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> empfiehlt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> es sich, durch zu ersetzen oder die Nachricht <xref:System.Windows.Forms.TextBox>an eine mehrzeilige anfügen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einen Windows Forms ein, und stellen Sie sicher, dass der <xref:System.Windows.Forms.Application.EnterThreadModal> Ereignishandler dem-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Erfordert <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> die Berechtigung zum lauschen auf das Ereignis.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad einschließlich des Namens der ausführbaren Datei ab, die zum Starten der Anwendung verwendet wurde.</summary>
        <value>Der Pfad und der Name der ausführbaren Datei, die zum Starten der Anwendung verwendet wurde.  
  
Dieser Pfad weicht ab, je nachdem, ob die Windows Forms-Anwendung mit [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]Anwendungen werden in einem Anwendungscache pro Benutzer im Verzeichnis "c:\Dokumente und Einstellungen\\*Benutzername* " gespeichert. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remote Daten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum erhalten des Pfads. Zugehörige Enumeration:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application.Exit%2A> -Methode beendet alle laufenden Nachrichten Schleifen für alle Threads und schließt alle Fenster der Anwendung. Diese Methode erzwingt nicht zwangsläufig, dass die Anwendung beendet wird. Die <xref:System.Windows.Forms.Application.Exit%2A> -Methode wird in der Regel innerhalb einer Nachrichten Schleife aufgerufen und <xref:System.Windows.Forms.Application.Run%2A> erzwingt, dass zurückgegeben wird. Um nur eine Nachrichten Schleife für den aktuellen Thread zu beenden, <xref:System.Windows.Forms.Application.ExitThread%2A>wird aufgerufen.  
  
 <xref:System.Windows.Forms.Application.Exit%2A>löst die folgenden Ereignisse aus und führt die zugeordneten bedingten Aktionen aus:  
  
-   Ein <xref:System.Windows.Forms.Form.FormClosing> -Ereignis wird für jedes Formular ausgelöst, das <xref:System.Windows.Forms.Application.OpenForms%2A> durch die-Eigenschaft dargestellt wird. Dieses Ereignis kann abgebrochen werden, indem <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> die-Eigenschaft <xref:System.Windows.Forms.FormClosingEventArgs> des- `true`Parameters auf festgelegt wird.  
  
-   Wenn einer der weiteren Handler das Ereignis abbricht, wird <xref:System.Windows.Forms.Application.Exit%2A> ohne weitere Aktion zurückgegeben. Andernfalls wird für <xref:System.Windows.Forms.Form.FormClosed> jedes geöffnete Formular ein-Ereignis ausgelöst, dann werden alle laufenden Nachrichten Schleifen und-Formulare geschlossen.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Application.Exit%2A> -Methode gibt nicht das <xref:System.Windows.Forms.Form.Closed> - <xref:System.Windows.Forms.Form.Closing> Ereignis und das-Ereignis aus [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], die als veraltet eingestuft werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Zahlen in einem Listenfeld auf einem Formular aufgelistet. Jedes Mal, wenn `button1`Sie auf klicken, fügt die Anwendung der Liste eine weitere Nummer hinzu.  
  
 Die `Main` -Methode <xref:System.Windows.Forms.Application.Run%2A> Ruft auf, um die Anwendung zu starten, die `listBox1`das Formular `button1`, und erstellt. Wenn der Benutzer klickt `button1`, fügt `button1_Click` die-Methode dem Listenfeld die Zahlen 1 bis 3 hinzu und zeigt <xref:System.Windows.Forms.MessageBox>einen an. Wenn der Benutzer auf **Nein** klickt <xref:System.Windows.Forms.MessageBox>, wird der `button1_Click` Liste von der-Methode eine weitere Zahl hinzugefügt. Wenn der Benutzer auf **Ja**klickt, ruft <xref:System.Windows.Forms.Application.Exit%2A>die Anwendung auf, um alle verbleibenden Nachrichten in der Warteschlange zu verarbeiten und dann den Vorgang zu beenden.  
  
 Das Beispiel erfordert, `listBox1` dass `button1` und instanziiert und in einem Formular abgelegt wurden.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Gibt zurück, ob ein <see cref="T:System.Windows.Forms.Form" /> innerhalb der Anwendung das Beenden abgebrochen hat.</param>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Für die Berechtigung zum Beenden eines laufenden Anwendungs Threads. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verlässt die Nachrichtenschleife für den aktuellen Thread und schließt alle Fenster des Threads.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die Nachrichten Schleife des aktuellen Threads zu beenden. Diese Methode bewirkt, <xref:System.Windows.Forms.Application.Run%2A> dass der-Aufrufe für den aktuellen Thread zurückgibt. Um die gesamte Anwendung zu beenden, <xref:System.Windows.Forms.Application.Exit%2A>wird aufgerufen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer zum Aufruf von nicht verwaltetem Code. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Die zu filternde Windows-Ereignismeldung.</param>
        <summary>Führt etwaige Filter für eine Fenstermeldung aus und gibt eine Kopie der geänderten Meldung zurück.</summary>
        <returns><see langword="true" />, wenn die Filter verarbeitet wurden, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Modus mit hohem DPI-Wert für die Anwendung ab.</summary>
        <value>Einer der Enumerationswerte, der den hohen dpi-Modus angibt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Anwendung die Verarbeitung beendet und gerade in den Leerlauf wechselt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Aufgaben haben, die Sie ausführen müssen, bevor der Thread in den Leerlauf wechselt, fügen Sie diese an dieses Ereignis an.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Application.Idle> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> empfiehlt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> es sich, durch zu ersetzen oder die Nachricht <xref:System.Windows.Forms.TextBox>an eine mehrzeilige anfügen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Windows Form ein, und stellen Sie sicher, dass der Ereignis <xref:System.Windows.Forms.Application.Idle> Handler dem-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, bevor die Anwendung einen modalen Zustand verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Application.LeaveThreadModal> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> empfiehlt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> es sich, durch zu ersetzen oder die Nachricht <xref:System.Windows.Forms.TextBox>an eine mehrzeilige anfügen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einen Windows Forms ein, und stellen Sie sicher, dass der <xref:System.Windows.Forms.Application.LeaveThreadModal> Ereignishandler dem-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten eines lokalen Benutzers ab, der kein Roaming verwendet.</summary>
        <value>Der Pfad für die Anwendungsdaten eines lokalen Benutzers, der kein Roaming verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein lokaler Benutzer ist ein Benutzerprofil, dessen Benutzerprofil auf dem System gespeichert ist, auf dem sich der Benutzer angemeldet hat. Wenn kein Pfad vorhanden ist, wird ein Pfad im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Ein typischer Basispfad lautet "c:\Dokumente\\und Einstellungen*Benutzername*\Lokale Einstellungen\Anwendungsdaten". Dieser Pfad ist jedoch unterschiedlich, wenn die Windows Forms Anwendung mithilfe [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]von bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]erstellt ein eigenes Anwendungsdatenverzeichnis, das von allen anderen Anwendungen isoliert ist. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remote Daten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Formulare angezeigt, und die Anwendung wird beendet, wenn beide Formulare geschlossen sind. Wenn die Anwendung gestartet und beendet wird, wird die Position der einzelnen Formulare gespeichert. Obwohl in diesem Beispiel die Verwendung <xref:System.Windows.Forms.Application.UserAppDataPath%2A> der-Eigenschaft zum Speichern von Anwendungsdaten für den <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> Benutzer veranschaulicht wird, kann stattdessen verwendet werden.  
  
 Die `MyApplicationContext` Klasse erbt von <xref:System.Windows.Forms.ApplicationContext> und verfolgt, wenn jedes Formular geschlossen ist, und beendet den aktuellen Thread, wenn beide vorhanden sind. Die-Klasse speichert die Positionen der einzelnen Formulare für den Benutzer. Die Formular Positionsdaten werden in einer Datei mit dem `Appdata.txt` Namen gespeichert, die an dem von <xref:System.Windows.Forms.Application.UserAppDataPath%2A>festgelegten Speicherort erstellt wird. Die `Main` -Methode `Application.Run(context)` Ruft auf, um die Anwendung <xref:System.Windows.Forms.ApplicationContext>mit dem zu starten.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der Übersicht <xref:System.Windows.Forms.ApplicationContext> über die-Klasse. Zum Zweck der über sichtlichkeit wird Code nicht angezeigt. Das <xref:System.Windows.Forms.ApplicationContext> gesamte Codelisting finden Sie unter.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für diesen Thread eine Nachrichtenschleife vorhanden ist.</summary>
        <value><see langword="true" />, wenn eine Nachrichtenschleife vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Hosting von Windows Forms in anderen Umgebungen (z. b. nicht verwaltete Anwendungen) gibt diese `false`Eigenschaft immer zurück. Verwenden <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> Sie, um Windows Forms anzuweisen, wenn die Host Umgebung noch über eine aktive Nachrichten Schleife verfügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert OLE für den aktuellen Thread.</summary>
        <returns>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, `Microsoft.Win32` bevor Sie eine Methode aufrufen, die OLE erfordert. <xref:System.Windows.Forms.Application.OleRequired%2A>prüft zunächst, ob OLE für den aktuellen Thread initialisiert wurde. Wenn dies nicht der Fall ist, wird der Thread für OLE initialisiert.  
  
> [!NOTE]
>  Wenn ein Thread OLE-Methoden nicht direkt aufruft, müssen Sie diese Methode nicht aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">Eine <see cref="T:System.Exception" />, die die ausgelöste Ausnahme darstellt.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Application.ThreadException" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen <xref:System.Windows.Forms.Application.OnThreadException%2A> Sie auf, um eine Ausnahme zu erhalten, die die Verarbeitung der Anwendung stoppt.  
  
 Die <xref:System.Windows.Forms.Application> -Klasse verfügt <xref:System.Windows.Forms.Application.ThreadException> über ein-Ereignis. Sie können einen Ereignishandler an dieses Ereignis anfügen, um eine beliebige benutzerdefinierte Verarbeitung durchzuführen, die Sie für unbehandelte Ausnahmen benötigen. Wenn Sie keinen Ereignishandler anfügen, <xref:System.Windows.Forms.Application.OnThreadException%2A> führt das Standardverhalten aus. dabei wird ein Dialogfeld angezeigt, in dem der Benutzer informiert wird, dass ein Fehler aufgetreten ist.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A>implementiert nur das Standard Ausnahme Verhalten für nicht behandelte Ausnahmen, die bei Threads auftreten, die sich im Besitz Windows Forms befinden. Nicht behandelte Ausnahmen für andere Threads werden vom <xref:System.AppDomain.UnhandledException> -Ereignis behandelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung offener Formulare ab, die sich im Besitz der Anwendung befinden.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.FormCollection" />, die alle gerade offenen Formulare enthält, die dieser Anwendung zugeordnet sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application.OpenForms%2A> -Eigenschaft stellt eine schreibgeschützte Auflistung von Formularen dar, die sich im Besitz der Anwendung befinden. Diese Auflistung kann anhand der Indexposition oder durch <xref:System.Windows.Forms.Control.Name%2A> <xref:System.Windows.Forms.Form>sucht werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Der <see cref="T:System.Security.Permissions.UIPermissionWindow" /> Aufrufer muss über die Berechtigung für den Zugriff auf alle <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> Fenster verfügen, wie durch den Wert der-Enumeration definiert.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den dieser Anwendung zugeordneten Produktnamen ab.</summary>
        <value>Der Produktname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName`wird aus den Metadaten der Assembly entnommen, die das Hauptformular der aktuellen Anwendung enthält. Sie können diesen Wert festlegen, <xref:System.Reflection.AssemblyProductAttribute> indem Sie in Ihrem Assemblymanifest festlegen. Weitere Informationen finden Sie unter [Assemblymanifest](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Anwendung zugeordnete Produktversion ab.</summary>
        <value>Die Produktversion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel wird eine Versionsnummer als *Haupt Zahl*angezeigt. *neben Nummer*. ** Buildnummer. *Nummer des privaten Teils*. Sie können Sie explizit festlegen, indem Sie die Assemblyversion innerhalb des Assemblymanifests festlegen. Weitere Informationen finden Sie unter [Assemblymanifest](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>prüft zunächst, ob die Assembly, die die Haupt ausführbare Datei `AssemblyInformationalVersion` enthält, über das-Attribut verfügt. Wenn dieses Attribut vorhanden ist, wird es sowohl <xref:System.Windows.Forms.Application.ProductVersion%2A> für als auch <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>für verwendet. Wenn dieses Attribut nicht vorhanden ist, verwenden beide Eigenschaften stattdessen die Version der ausführbaren Datei.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.EventArgs" />-Objekte, die an das <see cref="E:System.Windows.Forms.Application.Idle" />-Ereignis zu übergeben sind.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Application.Idle" />-Ereignis in gehosteten Szenarien aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, wenn Windows Forms in einer anderen Umgebung (z. b. in einer nicht verwalteten Anwendung) gehostet wird. Sie sollten anrufen <xref:System.Windows.Forms.Application.RaiseIdle%2A> , wenn die Host Anwendung in den Leerlauf wechselt. Dadurch können einige Windows Forms-Steuerelemente und-Komponenten wichtige Hintergrundaufgaben ausführen, während der Benutzer nicht mit der Anwendung interagiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Die aufzurufende Methode, wenn es Windows Forms überprüfen muss, ob die Hostumgebung weiterhin Meldungen sendet.</param>
        <summary>Registriert einen Rückruf für die Prüfung, ob die Nachrichtenschleife in gehosteten Umgebungen ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, wenn Windows Forms in einer anderen Umgebung (z. b. in einer nicht verwalteten Anwendung) gehostet wird. In gehosteten Umgebungen gibt <xref:System.Windows.Forms.Application.MessageLoop%2A> die Eigenschaft immer false zurück, wenn Windows Forms keine Nachrichten verarbeitet. Verwenden Sie diesen Rückruf, um Windows Forms zu informieren, ob die Host Umgebung weiterhin Nachrichten verarbeitet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Die Implementierung von <see cref="T:System.Windows.Forms.IMessageFilter" />, die aus der Anwendung entfernt werden soll.</param>
        <summary>Entfernt einen Meldungsfilter aus dem Nachrichtensystem der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen Nachrichtenfilter entfernen, wenn Sie keine Windows-Meldungen mehr erfassen möchten, bevor Sie gesendet werden.  
  
   
  
## Examples  
 Bevor Sie einen Nachrichtenfilter verwenden können, müssen Sie eine Implementierung für die <xref:System.Windows.Forms.IMessageFilter> -Schnittstelle bereitstellen. Mit der folgenden Klasse wird ein Nachrichtenfilter `TestMessageFilter`mit dem Namen erstellt. Mit diesem Filter werden alle Nachrichten im Zusammenhang mit der linken Maustaste blockiert.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Anwendung Steuerelemente mit visuellen Stilen zeichnet.</summary>
        <value><see langword="true" />, wenn visuelle Stile für Steuerelemente im Clientbereich von Anwendungsfenstern aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein benutzerdefiniertes Steuerelement zeichnen, verwenden Sie diese Eigenschaft, um zu entscheiden, ob das Steuerelement mit oder ohne visuelle Stile gezeichnet werden soll, damit seine Darstellung mit anderen Steuerelementen in der Anwendung konsistent ist.  
  
 In der folgenden Tabelle sind die vier Bedingungen aufgeführt, die <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> für die `true`Rückgabe von vorhanden sein müssen.  
  
|Bedingung|Beschreibung|  
|---------------|-----------------|  
|Das Betriebssystem unterstützt visuelle Stile.|Verwenden Sie die <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> -Eigenschaft der <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> -Klasse, um diese Bedingung separat zu überprüfen.|  
|Der Benutzer hat visuelle Stile im Betriebssystem aktiviert.|Verwenden Sie die <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> -Eigenschaft der <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> -Klasse, um diese Bedingung separat zu überprüfen.|  
|Visuelle Stile sind in der Anwendung aktiviert.|Visuelle Stile können in einer Anwendung durch Aufrufen der <xref:System.Windows.Forms.Application.EnableVisualStyles> -Methode oder mithilfe des Anwendungsmanifests aktiviert werden. Das Manifest gibt an, dass Version 6 von „ComCtl32.dll“ oder höher zum Zeichnen von Steuerelementen verwendet werden wird.|  
|Visuelle Stile werden verwendet, um den Client Bereich von Anwendungs Fenstern zu zeichnen.|Verwenden Sie die <xref:System.Windows.Forms.Application.VisualStyleState%2A> -Eigenschaft der <xref:System.Windows.Forms.Application> -Klasse und überprüfen Sie, ob sie den Wert <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> oder <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>aufweist, um diese Bedingung separat zu überprüfen.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Anwendung und startet sofort eine neue Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der häufigste Grund für den Aufruf `Restart` von ist das Starten einer neuen Version der Anwendung, die Sie [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] mithilfe der-Methode `Update` oder `UpdateAsync` der-Methode heruntergeladen haben.  
  
 Anwendungen werden in dem Kontext neu gestartet, in dem Sie anfänglich ausgeführt wurden. Wenn Ihre Anwendung mit einer URL gestartet wurde, die direkt auf die ausführbare Hauptdatei der Anwendung verweist, wird Sie mit der gleichen URL neu gestartet. Wenn es sich bei Ihrer [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Anwendung um eine-Anwendung handelt, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]wird Sie mit neu gestartet.  
  
 Wenn bei der ersten Ausführung der Anwendung ursprünglich Befehlszeilenoptionen zur Verfügung standen, <xref:System.Windows.Forms.Application.Restart%2A> startet die Anwendung mit denselben Optionen erneut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Code stellt keine Windows Forms-Anwendung dar. Diese Methode kann in diesem Kontext nicht aufgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Erfordert <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> die-Berechtigung.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Ausführung einer Standardmeldungsschleife einer Anwendung für den aktuellen Thread ohne Formular.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einer Win32-basierten oder Windows Forms Anwendung ist eine Nachrichten Schleife eine Routine im Code, die Benutzer Ereignisse verarbeitet, z. b. Mausklicks und Tastatureingaben. Jede aktive, Windows-basierte Anwendung benötigt eine aktive Nachrichten Schleife, die als Hauptnachrichten Schleife bezeichnet wird. Wenn die Hauptnachrichten Schleife geschlossen wird, wird die Anwendung beendet. In Windows Forms wird diese Schleife geschlossen, wenn die <xref:System.Windows.Forms.Application.Exit%2A> -Methode aufgerufen wird, oder wenn <xref:System.Windows.Forms.Application.ExitThread%2A> die-Methode für den Thread aufgerufen wird, der die Hauptnachrichten Schleife ausgeführt hat.  
  
 Die meisten Windows Forms Entwickler müssen diese Version der-Methode nicht verwenden. Sie sollten die <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> -Überladung verwenden, um eine Anwendung mit einem Hauptformular zu starten, damit die Anwendung beendet wird, wenn das Hauptformular geschlossen wird. Verwenden Sie für alle anderen Situationen die <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> -Überladung, die die <xref:System.Windows.Forms.ApplicationContext> Bereitstellung eines Objekts für eine bessere Kontrolle über die Lebensdauer der Anwendung unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für diesen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">Ein <see cref="T:System.Windows.Forms.ApplicationContext" />, in dem die Anwendung ausgeführt wird.</param>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread mit einem <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichten Schleife wird ausgeführt <xref:System.Windows.Forms.Application.Exit%2A> , <xref:System.Windows.Forms.Application.ExitThread%2A> bis oder aufgerufen wird <xref:System.Windows.Forms.Application.ThreadExit> , oder das-Ereignis wird für das Kontext Objekt ausgelöst.  
  
   
  
## Examples  
 Das Beispiel zeigt zwei Formulare an und beendet die Anwendung, wenn beide Formulare geschlossen sind. Wenn die Anwendung gestartet und beendet wird, wird die Position der einzelnen Formulare gespeichert. In diesem Beispiel wird veranschaulicht, wie <xref:System.Windows.Forms.ApplicationContext>ein zusammen mit der `Application.Run(context)` -Methode verwendet wird, um beim Starten der Anwendung mehrere Formulare anzuzeigen.  
  
 Die Klasse `MyApplicationContext` erbt von <xref:System.Windows.Forms.ApplicationContext> und verfolgt, wenn jedes Formular geschlossen ist, und beendet den aktuellen Thread, wenn beide vorhanden sind. Die-Klasse speichert die Positionen der einzelnen Formulare für den Benutzer. Die Formular Positionsdaten werden in einer Datei mit dem `Appdata.txt` Namen gespeichert, die an dem von <xref:System.Windows.Forms.Application.UserAppDataPath%2A>festgelegten Speicherort erstellt wird. Die `Main` -Methode `Application.Run(context)` Ruft auf, um die Anwendung <xref:System.Windows.Forms.ApplicationContext>mit dem zu starten.  
  
 Der Code für das `AppForm1` - `AppForm2` Formular und das-Formular wird aus Gründen der Kürze nicht angezeigt. Informationen zum <xref:System.Windows.Forms.ApplicationContext> gesamten Codelisting finden Sie unter Übersicht über die-Klasse.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für diesen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Ein <see cref="T:System.Windows.Forms.Form" />, das das anzuzeigende Formular darstellt.</param>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread und zeigt das angegebene Formular an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel Ruft die Hauptfunktion einer Anwendung diese Methode auf und übergibt ihr das Hauptfenster der Anwendung.  
  
 Diese Methode fügt dem `mainForm` -Parameter für das <xref:System.Windows.Forms.Form.Closed> -Ereignis einen Ereignishandler hinzu. Der-Ereignishandler <xref:System.Windows.Forms.Application.ExitThread%2A> Ruft auf, um die Anwendung zu bereinigen.  
  
> [!NOTE]
>  Vor <xref:System.Windows.Forms.Control.Dispose%2A> der Rückgabe dieser <xref:System.Windows.Forms.Form> Methode wird die-Methode der-Klasse aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Zahlen in einem Listenfeld auf einem Formular aufgelistet. Jedes Mal, wenn `button1`Sie auf klicken, fügt die Anwendung der Liste eine weitere Nummer hinzu.  
  
 Die `Main` -Methode <xref:System.Windows.Forms.Application.Run%2A> Ruft auf, um die Anwendung zu starten, die `listBox1`das Formular `button1`, und erstellt. Wenn der Benutzer klickt `button1`, fügt `button1_Click` die-Methode dem Listenfeld die Zahlen 1 bis 3 hinzu und zeigt <xref:System.Windows.Forms.MessageBox>einen an. Wenn der Benutzer auf **Nein** klickt <xref:System.Windows.Forms.MessageBox>, wird der `button1_Click` Liste von der-Methode eine weitere Zahl hinzugefügt. Wenn der Benutzer auf **Ja**klickt, ruft <xref:System.Windows.Forms.Application.Exit%2A> die Anwendung auf, um alle verbleibenden Nachrichten in der Warteschlange zu verarbeiten und dann zu beenden.  
  
 Das Beispiel erfordert, `listBox1` dass `button1` und erstellt und in einem Formular abgelegt wurden.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für den aktuellen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Formatzeichenfolge ab, die den Beschriftungen der Fenster auf oberster Ebene zugewiesen wird, wenn diese mit einem Warnbanner angezeigt werden, oder legt diese fest.</summary>
        <value>Die Formatzeichenfolge, die den Beschriftungen der Fenster auf oberster Ebene zugewiesen wird.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Diese Eigenschaft wird für alle Fenster festgelegt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert, der für neue Steuerelemente verwendet werden soll. Bei <see langword="true" /> verwenden neue Steuerelemente, die <c>UseCompatibleTextRendering</c> unterstützen, die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]-basierte <see cref="T:System.Drawing.Graphics" />-Klasse zur Textdarstellung; bei <see langword="false" /> verwenden neue Steuerelemente die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]-basierte <see cref="T:System.Windows.Forms.TextRenderer" />-Klasse.</param>
        <summary>Legt für die gesamte Anwendung die Voreinstellung für die <c>UseCompatibleTextRendering</c>-Eigenschaft fest, die in bestimmten Steuerelementen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Windows Forms Steuerelemente können Ihren Text entweder mithilfe der <xref:System.Windows.Forms.TextRenderer> -Klasse, die auf der [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Grafikbibliothek basiert, oder mithilfe <xref:System.Drawing.Graphics> der-Klasse, die auf der [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Grafikbibliothek basiert, renderingzeichen renderingzeichen darstellen. Diese Änderung wurde in [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] aufgrund von Leistungs-und Lokalisierungs [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]Problemen in vorgenommen. Verwenden <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Sie, um den Standardwert `UseCompatibleTextRendering` der-Eigenschaft für Steuerelemente festzulegen, die diese unterstützen.  
  
 Die `UseCompatibleTextRendering` [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] <xref:System.Windows.Forms.TextRenderer> - Eigenschaft[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] soll visuelle Kompatibilität zwischen Windows Forms Steuerelementen bereitstellen, die Text mithilfe der-Klasse rendern, und Anwendungen, die benutzerdefiniertes Text Rendering mithilfe des <xref:System.Drawing.Graphics>-Klasse. [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] In den meisten Fällen [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] `false`wird empfohlen, auf den Standardwert festzulegen,wenndieAnwendungnichtvonoderaktualisiertwird.`UseCompatibleTextRendering`  
  
 Die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] - <xref:System.Windows.Forms.TextRenderer> basierte Klasse wurde in eingeführt [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] , um die Leistung zu verbessern, Text besser aussehen zu lassen und die Unterstützung für Internationale Schriftarten zu verbessern. In früheren Versionen von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]wurde die-basierte <xref:System.Drawing.Graphics> -Klasse verwendet, um das [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] gesamte Text Rendering auszuführen. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]berechnet den Zeichenabstand und das Wort Umbruch [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]von. In einer Windows Forms Anwendung, die die <xref:System.Drawing.Graphics> -Klasse zum Rendering von Text verwendet, kann dies dazu führen, dass <xref:System.Windows.Forms.TextRenderer> der Text für Steuerelemente, die verwenden, von dem anderen Text in der Anwendung abweicht. Um diese Inkompatibilität zu beheben, können Sie die `UseCompatibleTextRendering` -Eigenschaft `true`auf festlegen. Wenn Sie `UseCompatibleTextRendering` für `true` alle unterstützten Steuerelemente in der Anwendung auf festlegen <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> möchten, müssen Sie die `true`-Methode mit dem-Parameter aufrufen.  
  
 Sie sollten diese Methode niemals aufzurufen, wenn Ihr Windows Forms Code in einer anderen Anwendung (z. b. Internet Explorer) gehostet wird. Ruft diese Methode nur in eigenständigen Windows Forms Anwendungen auf.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Informationen zum Festlegen des Standardwerts `UseCompatibleTextRendering` für [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] in oder höher finden <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>Sie unter.  
  
 In [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] oder höher <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> wird automatisch ein-Rückruf in der Program.cs-Datei generiert. Um den Standardtext Rendering zu ändern, ändern Sie den generierten Code.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können diese Methode nur aufrufen, bevor das erste Fenster von der Windows Forms-Anwendung erstellt wurde.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">Einer der Enumerationswerte, der den festzulegenden Modus mit hohem DPI-Wert angibt.</param>
        <summary>Legt den Modus mit hohem DPI-Wert des Prozesses fest.</summary>
        <returns><see langword="true" />, wenn der Modus mit hohem DPI-Wert festgelegt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Windows.Forms.PowerState" />, der den Energieaktivitätsmodus angibt, in den das System wechseln soll.</param>
        <param name="force"><see langword="true" />, um den Standbymodus sofort zu erzwingen, <see langword="false" />, damit Windows veranlasst wird, an jede Anwendung eine Unterbrechungsanforderung zu senden.</param>
        <param name="disableWakeEvent"><see langword="true" />, damit bei einem Aktivierungsereignis die Wiederherstellung eines aktiven Systemenergiezustands deaktiviert wird, <see langword="false" />, damit bei einem Aktivierungsereignis die Wiederherstellung eines aktiven Systemenergiezustands aktiviert wird.</param>
        <summary>Versetzt das System in den Standbymodus oder Ruhezustand oder fordert an, dass das System in den Standbymodus oder Ruhezustand versetzt wird.</summary>
        <returns><see langword="true" />, wenn das System gerade in den Ruhezustand versetzt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Anwendung nicht innerhalb von 20 Sekunden auf eine Anhalteanforderung antwortet, bestimmt Windows, dass Sie sich in einem nicht reagierenden Zustand befindet und dass die Anwendung entweder in den Standbymodus versetzt oder beendet werden kann. Wenn eine Anwendung auf eine Suspend-Anforderung antwortet, kann Sie jedoch jede Zeit beanspruchen, die benötigt wird, um Ressourcen zu bereinigen und aktive Prozesse zu beenden.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist die Anwendung an, wie auf unbehandelte Ausnahmen reagiert werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden Ereignishandler für Ausnahmen festgelegt, die bei Windows Forms Threads und Ausnahmen auftreten, die in anderen Threads auftreten. Dadurch wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> festgelegt, dass alle Ausnahmen von der Anwendung behandelt werden, unabhängig von den Einstellungen in der Benutzer Konfigurationsdatei der Anwendung. Das <xref:System.Windows.Forms.Application.ThreadException> Ereignis wird verwendet, um Benutzeroberflächen-Thread Ausnahmen zu <xref:System.AppDomain.UnhandledException> behandeln, und das-Ereignis, um nicht-UI-Thread Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> eine Anwendung nicht beenden kann, protokolliert das Beispiel einfach den Fehler im Anwendungs Ereignisprotokoll vor der Beendigung.  
  
 In diesem Beispiel wird davon ausgegangen, dass <xref:System.Windows.Forms.Button> Sie zwei `button1` - `button2`Steuerelemente, <xref:System.Windows.Forms.Form> und für die-Klasse definiert haben.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Ein <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />-Wert, in dem beschrieben wird, wie sich die Anwendung verhalten soll, wenn eine Ausnahme ausgelöst, aber nicht abgefangen wird.</param>
        <summary>Weist die Anwendung an, wie auf unbehandelte Ausnahmen reagiert werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist oft nicht möglich, alle Ausnahmen abzufangen, die von Windows Forms ausgelöst werden. Mit dieser Methode können Sie die Anwendung anweisen, ob Sie alle nicht behandelten Ausnahmen abfangen soll, die von Windows Forms-Komponenten ausgelöst werden, und den Betrieb fortsetzen, oder ob Sie für den Benutzer verfügbar gemacht werden und die Ausführung anhalten soll.  
  
 Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> aufgerufen, bevor Sie das Hauptformular der Anwendung mit der <xref:System.Windows.Forms.Application.Run%2A> -Methode instanziieren.  
  
 Verwenden Sie zum Abfangen von Ausnahmen, die in nicht erstellten Threads auftreten und deren <xref:System.AppDomain.UnhandledException> Besitzer Windows Forms ist, den-Ereignishandler.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Ereignishandler für Ausnahmen festgelegt, die bei Windows Forms Threads und Ausnahmen auftreten, die in anderen Threads auftreten. Dadurch wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> festgelegt, dass alle Ausnahmen von der Anwendung behandelt werden, unabhängig von den Einstellungen in der Benutzer Konfigurationsdatei der Anwendung. Das <xref:System.Windows.Forms.Application.ThreadException> Ereignis wird verwendet, um Benutzeroberflächen-Thread Ausnahmen zu <xref:System.AppDomain.UnhandledException> behandeln, und das-Ereignis, um nicht-UI-Thread Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> eine Anwendung nicht beenden kann, protokolliert das Beispiel einfach den Fehler im Anwendungs Ereignisprotokoll vor der Beendigung.  
  
 In diesem Beispiel wird davon ausgegangen, dass <xref:System.Windows.Forms.Button> Sie zwei `button1` - `button2`Steuerelemente, <xref:System.Windows.Forms.Form> und für die-Klasse definiert haben.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können den Ausnahmemodus nicht festlegen, nachdem die Anwendung das erste Fenster erstellt hat.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Ein <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />-Wert, in dem beschrieben wird, wie sich die Anwendung verhalten soll, wenn eine Ausnahme ausgelöst, aber nicht abgefangen wird.</param>
        <param name="threadScope"><see langword="true" />, um den Threadausnahmemodus festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Weist die Anwendung an, wie auf nicht behandelte Ausnahmen reagiert werden soll, und wendet optional threadspezifisches Verhalten an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist oft nicht möglich, alle Ausnahmen abzufangen, die von Windows Forms ausgelöst werden. Mit dieser Methode können Sie die Anwendung anweisen, ob Sie alle nicht behandelten Ausnahmen abfangen soll, die von Windows Forms-Komponenten ausgelöst werden, und den Betrieb fortsetzen, oder ob Sie für den Benutzer verfügbar gemacht werden und die Ausführung anhalten soll.  
  
 Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> aufgerufen, bevor Sie das Hauptformular der Anwendung mit der <xref:System.Windows.Forms.Application.Run%2A> -Methode instanziieren.  
  
 Wenn `threadScope`den Wert hat,wirdderThreadAusnahmeModusfestgelegt.`true` Der Thread Ausnahme Modus überschreibt den Ausnahme Modus der Anwendung `mode` , wenn nicht auf <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>festgelegt ist.  
  
 Wenn `threadScope`den Wert hat,wirdderAnwendungsAusnahmeModusfestgelegt.`false` Der Anwendungs Ausnahme Modus wird für alle Threads mit dem <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> -Modus verwendet. Das Festlegen des Ausnahme Modus der Anwendung wirkt sich nicht auf die Einstellung des aktuellen Threads aus.  
  
 Verwenden Sie zum Abfangen von Ausnahmen, die in nicht erstellten Threads auftreten und deren <xref:System.AppDomain.UnhandledException> Besitzer Windows Forms ist, den-Ereignishandler.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Ereignishandler für Ausnahmen festgelegt, die bei Windows Forms Threads und Ausnahmen auftreten, die in anderen Threads auftreten. Dadurch wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> festgelegt, dass alle Ausnahmen von der Anwendung behandelt werden, unabhängig von den Einstellungen in der Benutzer Konfigurationsdatei der Anwendung. Das <xref:System.Windows.Forms.Application.ThreadException> Ereignis wird verwendet, um Benutzeroberflächen-Thread Ausnahmen zu <xref:System.AppDomain.UnhandledException> behandeln, und das-Ereignis, um nicht-UI-Thread Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> eine Anwendung nicht beenden kann, protokolliert das Beispiel einfach den Fehler im Anwendungs Ereignisprotokoll vor der Beendigung.  
  
 In diesem Beispiel wird davon ausgegangen, dass <xref:System.Windows.Forms.Button> Sie zwei `button1` - `button2`Steuerelemente, <xref:System.Windows.Forms.Form> und für die-Klasse definiert haben.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können den Ausnahmemodus nicht festlegen, nachdem die Anwendung das erste Fenster erstellt hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad ohne den Namen der ausführbaren Datei ab, die zum Starten der Anwendung verwendet wurde.</summary>
        <value>Der Pfad für die ausführbare Datei, die die Anwendung gestartet hat.  
  
Dieser Pfad weicht ab, je nachdem, ob die Windows Forms-Anwendung mit [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]Anwendungen werden in einem Anwendungscache pro Benutzer im Verzeichnis "c:\Dokumente und Einstellungen\\*Benutzername* " gespeichert. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remote Daten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft abgerufen und der Wert in einem Textfeld angezeigt. Das Beispiel setzt voraus `textBox1` , dass in einem Formular abgelegt wurde.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum erhalten des Pfads. Zugehörige Enumeration:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Auslösen einer nicht abgefangenen Threadausnahme ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ermöglicht der Windows Forms Anwendung, anderweitig nicht behandelte Ausnahmen zu behandeln, die in Windows Forms Threads auftreten. Fügen Sie die Ereignishandler an das <xref:System.Windows.Forms.Application.ThreadException> -Ereignis an, um diese Ausnahmen zu behandeln, sodass Ihre Anwendung in einem unbekannten Zustand bleibt. Wenn möglich, sollten Ausnahmen von einem strukturierten Ausnahme Behandlungs Block behandelt werden.  
  
 Durch Festlegen <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>von können Sie ändern, ob dieser Rückruf für nicht behandelte Windows Forms Thread Ausnahmen verwendet wird. Verwenden Sie zum Abfangen von Ausnahmen, die in nicht erstellten Threads auftreten und deren <xref:System.AppDomain.UnhandledException> Besitzer Windows Forms ist, den-Ereignishandler.  
  
> [!NOTE]
>  Um sicherzustellen, dass keine Aktivierungen dieses Ereignisses übersehen werden, müssen Sie einen Handler anfügen <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>, bevor Sie den Befehl ausführen.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Ereignishandler für Ausnahmen festgelegt, die bei Windows Forms Threads und Ausnahmen auftreten, die in anderen Threads auftreten. Dadurch wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> festgelegt, dass alle Ausnahmen von der Anwendung behandelt werden, unabhängig von den Einstellungen in der Benutzer Konfigurationsdatei der Anwendung. Das <xref:System.Windows.Forms.Application.ThreadException> Ereignis wird verwendet, um Benutzeroberflächen-Thread Ausnahmen zu <xref:System.AppDomain.UnhandledException> behandeln, und das-Ereignis, um nicht-UI-Thread Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> eine Anwendung nicht beenden kann, protokolliert das Beispiel einfach den Fehler im Anwendungs Ereignisprotokoll vor der Beendigung.  
  
 In diesem Beispiel wird davon ausgegangen, dass <xref:System.Windows.Forms.Button> Sie zwei `button1` - `button2`Steuerelemente, <xref:System.Windows.Forms.Form> und für die-Klasse definiert haben.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">, damit der unmittelbare Aufrufer beim Hinzufügen eines Handlers zu diesem Ereignis nicht verwalteten Code aufruft. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Thread gerade beendet wird. Wenn der Hauptthread für eine Anwendung beendet werden soll, wird zuerst dieses Ereignis und anschließend ein <see cref="E:System.Windows.Forms.Application.ApplicationExit" />-Ereignis ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen die Ereignishandler an das <xref:System.Windows.Forms.Application.ThreadExit> -Ereignis anfügen, um unbehandelte, erforderliche Tasks auszuführen, bevor die Ausführung des Threads beendet wird. Schließen Sie die von diesem Thread geöffneten Dateien, oder löschen Sie Objekte, die vom Garbage Collector nicht freigegeben wurden.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Members veranschaulicht. Im Beispiel meldet ein Ereignishandler das Vorkommen des <xref:System.Windows.Forms.Application.ThreadExit> Ereignisses. Mit diesem Bericht können Sie lernen, wann das Ereignis auftritt und Sie beim Debuggen unterstützen können. Wenn Sie mehrere Ereignisse oder Ereignisse, die häufig auftreten, melden möchten, <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> empfiehlt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> es sich, durch zu ersetzen oder die Nachricht <xref:System.Windows.Forms.TextBox>an eine mehrzeilige anfügen.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einen Windows Forms ein, und stellen Sie sicher, dass der <xref:System.Windows.Forms.Application.ThreadExit> Ereignishandler dem-Ereignis zugeordnet ist.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hebt die Registrierung des mit <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> vorgenommenen Nachrichtenschleifenrückrufs auf.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten eines Benutzers ab.</summary>
        <value>Der Pfad für die Anwendungsdaten eines Benutzers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein Pfad vorhanden ist, wird ein Pfad im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Die in diesem Pfad gespeicherten Daten sind Teil des Benutzerprofils, das für das Roaming aktiviert ist. Ein Roamingbenutzer arbeitet auf mehr als einem Computer in einem Netzwerk. Das Benutzerprofil für einen Roamingbenutzer wird auf einem Server im Netzwerk aufbewahrt und auf ein System geladen, wenn sich der Benutzer anmeldet. Damit ein Benutzerprofil für das Roaming infrage kommen kann, muss das Betriebssystem Roamingprofile unterstützen, und es muss aktiviert sein.  
  
 Ein typischer Basispfad lautet "c:\Dokumente\\und Einstellungen*Benutzername*\Anwendungsdaten". Dieser Pfad ist jedoch unterschiedlich, wenn die Windows Forms Anwendung mithilfe [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]von bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]erstellt ein eigenes Anwendungsdatenverzeichnis, das von allen anderen Anwendungen isoliert ist. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remote Daten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Formulare angezeigt, und die Anwendung wird beendet, wenn beide Formulare geschlossen sind. Wenn die Anwendung gestartet und beendet wird, wird die Position der einzelnen Formulare gespeichert. In diesem Beispiel wird die <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Verwendung der-Eigenschaft zum Speichern von Anwendungsdaten für den Benutzer veranschaulicht.  
  
 Die Klasse `MyApplicationContext` erbt von <xref:System.Windows.Forms.ApplicationContext> und verfolgt, wenn jedes Formular geschlossen ist, und beendet den aktuellen Thread, wenn beide vorhanden sind. Die-Klasse speichert die Positionen der einzelnen Formulare für den Benutzer. Die Formular Positionsdaten werden in einer Datei mit dem `Appdata.txt` Namen gespeichert, die an dem von <xref:System.Windows.Forms.Application.UserAppDataPath%2A>festgelegten Speicherort erstellt wird. Die `Main` -Methode `Application.Run(context)` Ruft auf, um die Anwendung <xref:System.Windows.Forms.ApplicationContext>mit dem zu starten.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der Übersicht <xref:System.Windows.Forms.ApplicationContext> über die-Klasse. Zum Zweck der über sichtlichkeit wird Code nicht angezeigt. Das <xref:System.Windows.Forms.ApplicationContext> gesamte Codelisting finden Sie unter.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Registrierungsschlüssel für die Anwendungsdaten eines Benutzers ab.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.RegistryKey" />, der den Registrierungsschlüssel für die Anwendungsdaten des Benutzers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel nicht vorhanden ist, wird er im folgenden Format erstellt:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Die in diesem Schlüssel gespeicherten Daten sind Teil des Benutzerprofils, das für das Roaming aktiviert ist. Ein Roamingbenutzer arbeitet auf mehr als einem Computer in einem Netzwerk. Das Benutzerprofil für einen Roamingbenutzer wird auf einem Server im Netzwerk aufbewahrt und auf ein System geladen, wenn sich der Benutzer anmeldet. Damit ein Benutzerprofil für das Roaming infrage kommen kann, muss das Betriebssystem Roamingprofile unterstützen, und es muss aktiviert sein.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob visuelle Stile für die Anwendung aktiviert sind.</summary>
        <value><see langword="true" />, wenn visuelle Stile aktiviert sind. <see langword="false" />andernfalls.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die visuellen Stile können durch Aufrufen <xref:System.Windows.Forms.Application.EnableVisualStyles>von aktiviert werden.

Die visuellen Stile werden nicht aktiviert, wenn Sie vom Betriebssystem nicht unterstützt werden oder das Design auf der Betriebssystemebene deaktiviert ist.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob der Wartecursor für alle offenen Formulare der Anwendung verwendet wird.</summary>
        <value><see langword="true" />, wenn der Wartecursor für alle offenen Formulare verwendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true`festgelegt ist, wird die <xref:System.Windows.Forms.Control.UseWaitCursor%2A> -Eigenschaft aller geöffneten Formulare in der Anwendung auf `true`festgelegt. Dieser Befehl wird erst zurückgegeben, wenn diese Eigenschaft für alle Formulare festgelegt wurde. Verwenden Sie diese Eigenschaft, wenn Sie über einen Vorgang mit langer Laufzeit verfügen und in allen Anwendungs Formularen angeben möchten, dass der Vorgang noch verarbeitet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie visuelle Stile für Anwendungsfenster übernommen werden.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese <xref:System.Windows.Forms.Application.VisualStyleState%2A> Eigenschaft bestimmt, ob visuelle Stile in Client Bereichen oder nicht-Client Bereichen von Anwendungs Fenstern aktiviert sind. Im Allgemeinen sollte diese Eigenschaft im Konstruktor oder <xref:System.Windows.Forms.Form.Load> Ereignishandler des Haupt Formulars festgelegt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Application.VisualStyleState%2A> -Eigenschaft auf einen <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> der-Werte im <xref:System.Windows.Forms.Control.Click> -Ereignishandler für <xref:System.Windows.Forms.Button> ein-Steuerelement festgelegt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> -Enumeration bereitgestellt wird.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
