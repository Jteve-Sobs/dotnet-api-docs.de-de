<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28c0e715149bda84de593d0811549daf5e8f8dbe" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58456034" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt <see langword="static" />-Methoden und Eigenschaften für die Verwaltung einer Anwendung zur Verfügung, z. B. Methoden zum Starten und Beenden einer Anwendung, zum Verarbeiten von Windows-Meldungen sowie Eigenschaften für das Abrufen von Informationen zu einer Anwendung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application> -Klasse verfügt über Methoden zum Starten und Beenden von Anwendungen und Threads sowie Windows-Meldungen, wie folgt verarbeitet:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> Startet eine Nachrichtenschleife einer Anwendung für den aktuellen Thread und wahlweise ein Formular an.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> oder <xref:System.Windows.Forms.Application.ExitThread%2A> beendet eine Nachrichtenschleife.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> verarbeitet Nachrichten, während Ihr Programm in einer Schleife befindet.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Fügt einen Nachrichtenfilter für die meldungsverschiebung Anwendung, um Windows-Nachrichten zu überwachen.  
  
-   <xref:System.Windows.Forms.IMessageFilter> Sie können beenden ein Ereignis ausgelöst wird, oder bestimmte Vorgänge durchführen, bevor ein Ereignishandler aufgerufen.  
  
 Diese Klasse verfügt über <xref:System.Windows.Forms.Application.CurrentCulture%2A> und <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> Eigenschaften zum Abrufen oder Festlegen der kulturinformationen für den aktuellen Thread.  
  
 Sie können keine Instanz dieser Klasse erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Zahlen in ein Listenfeld, das in einem Formular aufgeführt. Bei jedem Klicken auf `button1`, die Anwendung der Liste eine andere Zahl hinzugefügt.  
  
 Die `Main` Methodenaufrufe <xref:System.Windows.Forms.Application.Run%2A> zum Starten der Anwendung, der das Formular erstellt, `listBox1` und `button1`. Wenn der Benutzer klickt `button1`, `button1_Click` Methode zeigt ein <xref:System.Windows.Forms.MessageBox>. Wenn der Benutzer klickt `No` auf die <xref:System.Windows.Forms.MessageBox>, `button1_Click` Methode der Liste eine Zahl hinzugefügt. Wenn der Benutzer klickt `Yes`, die Anwendung ruft <xref:System.Windows.Forms.Application.Exit%2A> zum Verarbeiten aller verbleibender Nachrichten in der Warteschlange und klicken Sie dann auf, um den Vorgang abzubrechen.  
  
> [!NOTE]
>  Der Aufruf von <xref:System.Windows.Forms.Application.Exit%2A> fehl bei teilweiser Vertrauenswürdigkeit.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Die Implementierung der zu installierenden <see cref="T:System.Windows.Forms.IMessageFilter" />-Schnittstelle.</param>
        <summary>Fügt einen Meldungsfilter zum Überwachen von Windows-Meldungen beim Weiterleiten an das Ziel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie einen Nachrichtenfilter, um zu verhindern, dass bestimmte Ereignisse ausgelöst wird oder besondere Vorgänge für ein Ereignis aus, bevor sie an einen Ereignishandler übergeben wird. Nachrichtenfilter gelten nur für einen bestimmten Thread.  
  
 Um zu verhindern, dass eine Nachricht gesendet wird, die `value` muss Parameterinstanz, die Sie an diese Methode übergeben, überschreiben die <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> -Methode durch den Code zur Verarbeitung der Nachricht. Die Methode muss `false`zurückgeben.  
  
> [!CAUTION]
>  Hinzufügen von Nachrichtenfilter für die meldungsverschiebung für eine Anwendung kann die Leistung beeinträchtigt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Nachrichtenfilter namens `TestMessageFilter`. Dieser Filter wird blockiert, alle Nachrichten, die in Bezug auf die linke Maustaste gedrückt wird. Bevor Sie einen Nachrichtenfilter verwenden können, müssen Sie angeben, eine Implementierung für die <xref:System.Windows.Forms.IMessageFilter> Schnittstelle.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Aufrufer diese Anwendung beenden kann.</summary>
        <value><see langword="true" />, wenn der Aufrufer diese Anwendung beenden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `false` , wenn er aufgerufen wird eine <xref:System.Windows.Forms.Control> in einem Webbrowser gehostet werden. Daher die <xref:System.Windows.Forms.Control> kann nicht beendet werden die <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Anwendung gerade beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen die Ereignishandler zum Anfügen der `ApplicationExit` Ereignis, um nicht behandelte, führen Sie erforderliche Aufgaben aus, bevor die Anwendung beendet wird. Sie können die von dieser Anwendung oder Freigeben von Objekten, die Garbagecollection nicht freigegeben wurden geöffneten Dateien schließen.  
  
 Da dies ein statisches Ereignis ist, müssen Sie an diesem Ereignis im angefügten Ereignishandler trennen die `ApplicationExit` -Ereignishandler selbst. Wenn Sie diese Handler nicht trennen werden, sie an das Ereignis angefügt bleibt und weiterhin Arbeitsspeicher beanspruchen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt zwei Formen und die Anwendung wird beendet, wenn beide Formen geschlossen werden. Wenn die Anwendung startet und beendet wird, wird die Position jedes Formulars gespeichert. Dieses Beispiel veranschaulicht die Verwendung der `ApplicationExit` Ereignis wissen, wenn die Position des Formulars auf die Datei beibehalten werden soll, und wenn die `FileStream` geschlossen werden soll.  
  
 Die Klasse `MyApplicationContext` erbt <xref:System.Windows.Forms.ApplicationContext> und verfolgt, wenn jedes Formular wird geschlossen, und den aktuellen Thread beendet wird, wenn beide sind. Die Klasse speichert die Position jedes Formulars auf, wenn es geschlossen wird. Wenn die `ApplicationExit` Ereignis auftritt, die die Klasse die Positionen der einzelnen für den Benutzer in die Datei schreibt. Daten aus dem Formular Position befindet sich in einer Datei mit dem Titel `appdata.txt` , erstellt wird, an dem Speicherort, der bestimmt, indem <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Die `Main` Methodenaufrufe `Application.Run(context)` zum Starten der Anwendung erhält die <xref:System.Windows.Forms.ApplicationContext>.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.ApplicationContext> Übersicht über die Klasse. Finden Sie unter <xref:System.Windows.Forms.ApplicationContext> für das gesamte Codebeispiel.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten ab, die von allen Benutzern gemeinsam genutzt werden.</summary>
        <value>Der Pfad für die Anwendungsdaten, der von allen Benutzern gemeinsam genutzt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Pfad nicht vorhanden ist, wird eine im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> erste sieht aus, um festzustellen, ob die Assembly, die die zentrale ausführbare Datei enthält die `AssemblyInformationalVersion` Attribut darauf. Wenn dieses Attribut vorhanden ist, wird es verwendet für beide <xref:System.Windows.Forms.Application.ProductVersion%2A> und <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Wenn dieses Attribut nicht vorhanden ist, verwenden Sie stattdessen beide Eigenschaften die Version der ausführbaren Datei.  
  
 Der Pfad unterscheiden sich je nachdem, ob die Windows Forms-Anwendung bereitgestellt wird mithilfe von [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Anwendungen befinden sich in einem Anwendungscache pro Benutzer, in der C:\Documents and Settings\\*Benutzername* Verzeichnis. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remotedaten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Registrierungsschlüssel für die Anwendungsdaten ab, die von allen Benutzern gemeinsam genutzt werden.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.RegistryKey" />, der den Registrierungsschlüssel für die Anwendungsdaten darstellt, die von allen Benutzern gemeinsam genutzt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel nicht vorhanden ist, wird es im folgenden Format erstellt:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den der Anwendung zugeordneten Firmennamen ab.</summary>
        <value>Der Firmenname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kulturinformationen für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Globalization.CultureInfo" />, die die Kulturinformationen für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Festlegen dieser Eigenschaft. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Eingabesprache für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.InputLanguage" />, die die aktuelle Eingabesprache für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verarbeitet alle Windows-Meldungen, die sich derzeit in der Meldungswarteschlange befinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Windows-Formular ausführen, wird das neue Formular, das dann zu behandelnden Ereignisse wartet. Jedes Mal das Formular ein Ereignis behandelt wird, wird alle diesem Ereignis zugeordneten Code verarbeitet. Alle anderen Ereignisse werden in der Warteschlange warten. Während der Code das Ereignis behandelt, reagiert die Anwendung nicht. Das Fenster ist z. B. nicht neu aufgebaut, wenn ein anderes Fenster im Vordergrund gezogen wird.  
  
 Wenn Sie aufrufen <xref:System.Windows.Forms.Application.DoEvents%2A> in Ihrem Code Ihrer Anwendung kann die anderen Ereignisse behandelt. Angenommen, Sie haben ein Formular, mit dem Hinzufügen von Daten in einem <xref:System.Windows.Forms.ListBox> und fügen <xref:System.Windows.Forms.Application.DoEvents%2A> an Ihrem Code, das Formular neu aufgebaut, wenn ein anderes Fenster darüber gezogen wird. Wenn Sie entfernen <xref:System.Windows.Forms.Application.DoEvents%2A> aus Ihrem Code das Formular nicht neu aufgebaut, bis zum Abschluss der Click-Ereignishandler der Schaltfläche ausführen. Weitere Informationen zu messaging, finden Sie unter [Benutzereingaben in Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 Im Gegensatz zu Visual Basic 6.0 die <xref:System.Windows.Forms.Application.DoEvents%2A> Methode ruft nicht die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode.  
  
 In der Regel verwenden Sie diese Methode in einer Schleife zum Verarbeiten von Nachrichten an.  
  
> [!CAUTION]
>  Das Aufrufen dieser Methode wird der aktuelle Thread angehalten werden soll, während alle wartenden fenstermeldungen verarbeitet werden. Wenn eine Nachricht bewirkt, ein Ereignis dass ausgelöst wird, können andere Bereiche des Anwendungscodes führen. Dadurch kann Ihre Anwendung zu unerwarteten Verhaltensweisen, die schwer zu debuggen sind. Wenn Sie ausführen, Vorgänge oder Berechnungen, die eine lange Zeit in Anspruch nehmen, ist es oft besser, diese Vorgänge in einem neuen Thread ausführen. Weitere Informationen zur asynchronen Programmierung finden Sie unter [Asynchronous Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.Application.DoEvents%2A> Methode. Wenn das Beispiel ausgeführt wird, kann ein Benutzer auswählen Graphics-Dateien aus einem <xref:System.Windows.Forms.OpenFileDialog>. Die ausgewählten Dateien werden in der Form angezeigt. Die <xref:System.Windows.Forms.Application.DoEvents%2A> Methode erzwingt das Neuzeichnen des Formulars für jede geöffnete Grafikdatei. Um dieses Beispiel auszuführen, fügen Sie in den folgenden Code in ein Formular mit einem <xref:System.Windows.Forms.PictureBox> mit dem Namen `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> mit dem Namen `OpenFileDialog1`, und eine Schaltfläche mit dem Namen `fileButton`. Rufen Sie die `InitializePictureBox` und `InitializeOpenFileDialog` Methoden aus den Konstruktor des Formulars oder `Load` Methode.  
  
> [!NOTE]
>  In Visual Studio, wenn Sie beim Hinzufügen einer <xref:System.Windows.Forms.OpenFileDialog> zu Ihrem Formular mithilfe eines Ziehvorgangs, müssen Sie Folgendes ändern `InitializeOpenFileDialog` Methode durch das Entfernen der Zeile, die erstellt eine neue Instanz der <xref:System.Windows.Forms.OpenFileDialog>.  
  
 Im Beispiel erfordert außerdem, dass die <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> Ereignis die <xref:System.Windows.Forms.Button> Steuerelement und die <xref:System.Windows.Forms.FileDialog.FileOk> Ereignis die <xref:System.Windows.Forms.OpenFileDialog> verbunden sind, an die Ereignishandler, die im Beispiel definiert. Wenn das Beispiel ausgeführt wird, wird anzuzeigen Sie das Dialogfeld durch Klicken auf die Schaltfläche.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert visuelle Stile für die Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht die visuelle Stile für die Anwendung. Visuelle Stile sind die Farben, Schriftarten und andere visuelle Elemente, die ein Betriebssystem-Design zu bilden. Steuerelemente werden mit visuellen Stilen gezeichnet werden, wenn das Steuerelement und das Betriebssystem unterstützt. Damit eine Wirkung <xref:System.Windows.Forms.Application.EnableVisualStyles> muss vor dem Erstellen von Steuerelementen in der Anwendung, aufgerufen werden in der Regel <xref:System.Windows.Forms.Application.EnableVisualStyles> ist die erste Zeile in der `Main` Funktion. Ein eigenes Manifest ist nicht erforderlich, visuelle Stile aktiviert, beim Aufrufen von <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Vor .NET Framework 2.0 die `FlatStyle` Eigenschaft einige Steuerelemente, z.B. Steuerelemente, die abgeleitet <xref:System.Windows.Forms.ButtonBase>, musste festgelegt werden, um <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> in der Reihenfolge für die Steuerelemente, mit visuellen Stilen gezeichnet werden soll. In Anwendungen mit .NET Framework 2.0 geschrieben wurden ist dies nicht mehr erforderlich.  
  
> [!NOTE]
>  Diese Methode hat keine Auswirkungen auf die Steuerelemente in Internet Explorer gehostet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht den Aufruf <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> in die `Main` Funktion, um visuelle Stile für die Anwendung zu aktivieren.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor die Anwendung in einen modalen Zustand übergeht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung des neuen Elements. Im Beispiel meldet sich ein Ereignishandler für das Vorhandensein der <xref:System.Windows.Forms.Application.EnterThreadModal> Ereignis. In diesem Bericht können Sie entnehmen, wann das Ereignis tritt auf, können Sie beim Debuggen unterstützen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, beachten Sie, und Ersetzen Sie dabei <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einer Windows Forms, und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Application.EnterThreadModal> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Erfordert <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> Berechtigung, auf das Ereignis zu überwachen.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad einschließlich des Namens der ausführbaren Datei ab, die zum Starten der Anwendung verwendet wurde.</summary>
        <value>Der Pfad und der Name der ausführbaren Datei, die zum Starten der Anwendung verwendet wurde.  
  
Dieser Pfad weicht ab, je nachdem, ob die Windows Forms-Anwendung mit [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Anwendungen befinden sich in einem Anwendungscache pro Benutzer, in der C:\Documents and Settings\\*Benutzername* Verzeichnis. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remotedaten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Abrufen des Pfads an. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application.Exit%2A> Methode alle aktiven Nachrichtenschleifen für alle Threads beendet, und schließt alle Fenster der Anwendung. Diese Methode erzwingt nicht unbedingt die Anwendung zu beenden. Die <xref:System.Windows.Forms.Application.Exit%2A> Methode wird in der Regel innerhalb einer Meldungsschleife und erzwingt, dass aufgerufen <xref:System.Windows.Forms.Application.Run%2A> zurückgegeben. Um eine Nachrichtenschleife für nur den aktuellen Thread zu beenden, rufen Sie <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> die folgenden Ereignisse ausgelöst und die zugeordneten bedingten Aktionen ausführt:  
  
-   Ein <xref:System.Windows.Forms.Form.FormClosing> Ereignis wird ausgelöst, für jedes Formular dargestellt, durch die <xref:System.Windows.Forms.Application.OpenForms%2A> Eigenschaft. Dieses Ereignis kann abgebrochen werden, indem die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft ihre <xref:System.Windows.Forms.FormClosingEventArgs> Parameter `true`.  
  
-   Wenn einem oder mehreren der Handler klicken Sie dann das Ereignis abbricht <xref:System.Windows.Forms.Application.Exit%2A> gibt keine weitere Aktion zurück. Andernfalls ein <xref:System.Windows.Forms.Form.FormClosed> Ereignis wird ausgelöst, für jedes Formular, und klicken Sie dann alle ausgeführten Nachrichtenschleifen und Formulare geschlossen werden.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Application.Exit%2A> Methode löst keine der <xref:System.Windows.Forms.Form.Closed> und <xref:System.Windows.Forms.Form.Closing> -Ereignisse, die veraltet sind [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Zahlen in ein Listenfeld, das in einem Formular aufgeführt. Bei jedem Klicken auf `button1`, die Anwendung der Liste eine andere Zahl hinzugefügt.  
  
 Die `Main` Methodenaufrufe <xref:System.Windows.Forms.Application.Run%2A> zum Starten der Anwendung, der das Formular erstellt, `listBox1`, und `button1`. Wenn der Benutzer klickt `button1`, `button1_Click` Methode addiert Zahlen bis zu drei in das Listenfeld, und zeigt eine <xref:System.Windows.Forms.MessageBox>. Wenn der Benutzer klickt **keine** auf die <xref:System.Windows.Forms.MessageBox>, `button1_Click` Methode der Liste eine andere Zahl hinzugefügt. Wenn der Benutzer klickt **Ja**, die Anwendung ruft <xref:System.Windows.Forms.Application.Exit%2A>, um alle verbleibenden Nachrichten in der Warteschlange verarbeiten, und klicken Sie dann auf, um den Vorgang abzubrechen.  
  
 Im Beispiel erfordert, dass `listBox1` und `button1` instanziiert und in einem Formular platziert wurden.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Gibt zurück, ob ein <see cref="T:System.Windows.Forms.Form" /> innerhalb der Anwendung das Beenden abgebrochen hat.</param>
        <summary>Weist alle Nachrichtensysteme an, die Verarbeitung zu beenden, und schließt alle Anwendungsfenster, sobald die Meldungen verarbeitet wurden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Für die Berechtigung zum Beenden eines laufenden Thread der Anwendung. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verlässt die Nachrichtenschleife für den aktuellen Thread und schließt alle Fenster des Threads.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die Nachrichtenschleife des aktuellen Threads zu beenden. Diese Methode bewirkt, dass den Aufruf von <xref:System.Windows.Forms.Application.Run%2A> für den aktuellen Thread zurückgegeben. Um die gesamte Anwendung zu beenden, rufen Sie <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Die zu filternde Windows-Ereignismeldung.</param>
        <summary>Führt etwaige Filter für eine Fenstermeldung aus und gibt eine Kopie der geänderten Meldung zurück.</summary>
        <returns><see langword="true" />, wenn die Filter verarbeitet wurden, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Anwendung die Verarbeitung beendet und gerade in den Leerlauf wechselt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Tasks besitzen, die Sie ausführen müssen, bevor der Thread im Leerlauf ist, fügen Sie sie an dieses Ereignis.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung des neuen Elements. Im Beispiel meldet sich ein Ereignishandler für das Vorhandensein der <xref:System.Windows.Forms.Application.Idle> Ereignis. In diesem Bericht können Sie entnehmen, wann das Ereignis tritt auf, können Sie beim Debuggen unterstützen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, beachten Sie, und Ersetzen Sie dabei <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in ein Windows-Formular, und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Application.Idle> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, bevor die Anwendung einen modalen Zustand verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung des neuen Elements. Im Beispiel meldet sich ein Ereignishandler für das Vorhandensein der <xref:System.Windows.Forms.Application.LeaveThreadModal> Ereignis. In diesem Bericht können Sie entnehmen, wann das Ereignis tritt auf, können Sie beim Debuggen unterstützen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, beachten Sie, und Ersetzen Sie dabei <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einer Windows Forms, und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Application.LeaveThreadModal> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten eines lokalen Benutzers ab, der kein Roaming verwendet.</summary>
        <value>Der Pfad für die Anwendungsdaten eines lokalen Benutzers, der kein Roaming verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein lokaler Benutzer ist eine, deren Benutzerprofil auf dem System gespeichert ist, auf denen der Benutzer angemeldet. Wenn Sie ein Pfad nicht vorhanden ist, wird eine im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Ein typischer Basispfad ist C:\Documents and Settings\\*Benutzername*\Local Daten. Dieser Pfad unterscheiden sich, aber wenn die Windows Forms-Anwendung mithilfe von [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] erstellt eine eigene Anwendungsdatenverzeichnis, die von allen anderen Anwendungen isoliert ist. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remotedaten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt zwei Formen und die Anwendung wird beendet, wenn beide Formen geschlossen werden. Wenn die Anwendung startet und beendet wird, wird die Position jedes Formulars gespeichert. Obwohl dieses Beispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Eigenschaft zum Speichern von Anwendungsdaten für den Benutzer, die <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> kann stattdessen verwendet werden.  
  
 Die `MyApplicationContext` Klasse erbt von <xref:System.Windows.Forms.ApplicationContext> und nachverfolgt, wenn jedes Formular wird geschlossen, und den aktuellen Thread beendet wird, wenn beide sind. Die Klasse speichert die Positionen jedes Formular für den Benutzer. Daten aus dem Formular Position befindet sich in einer Datei mit dem Titel `Appdata.txt` , erstellt wird, an dem Speicherort, der bestimmt, indem <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Die `Main` Methodenaufrufe `Application.Run(context)` zum Starten der Anwendung erhält die <xref:System.Windows.Forms.ApplicationContext>.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.ApplicationContext> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.ApplicationContext> für das gesamte Codebeispiel.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für diesen Thread eine Nachrichtenschleife vorhanden ist.</summary>
        <value><see langword="true" />, wenn eine Nachrichtenschleife vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Hosten von Windows Forms in anderen Umgebungen, wie z. B. nicht verwalteten Anwendungen wird diese Eigenschaft gibt immer zurück `false`. Verwendung <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> anweisen von Windows Forms, wenn die hostumgebung immer noch eine aktive Nachrichtenschleife hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert OLE für den aktuellen Thread.</summary>
        <returns>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf einer `Microsoft.Win32` -Methode, die von OLE benötigt. <xref:System.Windows.Forms.Application.OleRequired%2A> zuerst überprüft, um festzustellen, ob OLE für den aktuellen Thread initialisiert wurde. Wenn dies nicht der Fall ist, initialisiert den Thread für OLE.  
  
> [!NOTE]
>  Wenn ein Thread OLE-Methoden direkt aufruft, müssen Sie nicht, diese Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">Eine <see cref="T:System.Exception" />, die die ausgelöste Ausnahme darstellt.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Application.ThreadException" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Forms.Application.OnThreadException%2A> zum Auslösen einer Ausnahme, die Verarbeitung der Anwendung angehalten wird.  
  
 Die <xref:System.Windows.Forms.Application> -Klasse verfügt über eine <xref:System.Windows.Forms.Application.ThreadException> Ereignis. Sie können einen Ereignishandler hinzuzufügen, zu der dieses Ereignis, um die erforderliche benutzerdefinierte Verarbeitung auszuführen, die Sie für nicht behandelte Ausnahmen. Wenn Sie einen Ereignishandler keinen Anfügen <xref:System.Windows.Forms.Application.OnThreadException%2A> führt das Standardverhalten, das umfasst das Anzeigen eines Dialogfelds, um den Benutzer zu informieren, dass ein Fehler aufgetreten ist.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> nur für Threads, die im Besitz von Windows Forms-Ausnahme-Standardverhalten für nicht behandelte Ausnahmen, die auftreten, implementiert wird. Nicht behandelte Ausnahmen in anderen Threads erfolgt mit der <xref:System.AppDomain.UnhandledException> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung offener Formulare ab, die sich im Besitz der Anwendung befinden.</summary>
        <value>Eine <see cref="T:System.Windows.Forms.FormCollection" />, die alle gerade offenen Formulare enthält, die dieser Anwendung zugeordnet sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.Application.OpenForms%2A> Eigenschaft stellt eine schreibgeschützte Auflistung der Formulare, die von der Anwendung dar. Diese Auflistung kann durchsucht werden, nach Indexposition oder durch die <xref:System.Windows.Forms.Control.Name%2A> von der <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aufrufer muss über die Berechtigung zum Zugriff auf alle Fenster, gemäß der <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> Wert, der die <see cref="T:System.Security.Permissions.UIPermissionWindow" /> Enumeration.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den dieser Anwendung zugeordneten Produktnamen ab.</summary>
        <value>Der Produktname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` stammt aus den Metadaten der Assembly, die das Hauptformular der aktuellen Anwendung enthält. Sie können sie festlegen, durch Festlegen von <xref:System.Reflection.AssemblyProductAttribute> innerhalb des Assemblymanifests. Weitere Informationen finden Sie unter [Assemblymanifest](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Anwendung zugeordnete Produktversion ab.</summary>
        <value>Die Produktversion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel eine Versionsnummer zeigt als *Hauptversionsnummer*. *kleinere Anzahl*. *Buildnummer*. *Einzelteilnummer*. Sie können es explizit festlegen, indem Sie die Version der Assembly innerhalb des Assemblymanifests festlegen. Weitere Informationen finden Sie unter [Assemblymanifest](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> erste sieht aus, um festzustellen, ob die Assembly, die die zentrale ausführbare Datei enthält die `AssemblyInformationalVersion` Attribut darauf. Wenn dieses Attribut vorhanden ist, wird es verwendet für beide <xref:System.Windows.Forms.Application.ProductVersion%2A> und <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Wenn dieses Attribut nicht vorhanden ist, verwenden Sie stattdessen beide Eigenschaften die Version der ausführbaren Datei.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.EventArgs" />-Objekte, die an das <see cref="E:System.Windows.Forms.Application.Idle" />-Ereignis zu übergeben sind.</param>
        <summary>Löst das <see cref="E:System.Windows.Forms.Application.Idle" />-Ereignis in gehosteten Szenarien aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, wenn Sie Windows Forms in einer anderen Umgebung, z. B. eine nicht verwaltete Anwendung zu hosten. Rufen Sie <xref:System.Windows.Forms.Application.RaiseIdle%2A> bei die hostanwendung in den Leerlauf wechselt. Dies ermöglicht einige Windows Forms-Steuerelemente und Komponenten, um wichtige Hintergrundarbeit zu erledigen, während der Benutzer nicht mit der Anwendung interagiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Die aufzurufende Methode, wenn es Windows Forms überprüfen muss, ob die Hostumgebung weiterhin Meldungen sendet.</param>
        <summary>Registriert einen Rückruf für die Prüfung, ob die Nachrichtenschleife in gehosteten Umgebungen ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, wenn Sie Windows Forms in einer anderen Umgebung, z. B. eine nicht verwaltete Anwendung zu hosten. In einer gehosteten Umgebung die <xref:System.Windows.Forms.Application.MessageLoop%2A> Eigenschaft gibt immer "false", wenn Nachrichten nicht in Windows Forms verarbeitet wird. Verwenden Sie diesen Rückruf, um Windows Forms mitteilen, ob die hostumgebung weiterhin Nachrichten verarbeitet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Die Implementierung von <see cref="T:System.Windows.Forms.IMessageFilter" />, die aus der Anwendung entfernt werden soll.</param>
        <summary>Entfernt einen Meldungsfilter aus dem Nachrichtensystem der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen Nachrichtenfilter entfernen, wenn Sie nicht mehr um Windows-Nachrichten zu erfassen, bevor sie gesendet werden soll.  
  
   
  
## Examples  
 Bevor Sie einen Nachrichtenfilter verwenden können, müssen Sie angeben, eine Implementierung für die <xref:System.Windows.Forms.IMessageFilter> Schnittstelle. Die folgende Klasse erstellt einen Nachrichtenfilter namens `TestMessageFilter`. Dieser Filter wird blockiert, alle Nachrichten, die in Bezug auf die linke Maustaste gedrückt wird.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Anwendung Steuerelemente mit visuellen Stilen zeichnet.</summary>
        <value><see langword="true" />, wenn visuelle Stile für Steuerelemente im Clientbereich von Anwendungsfenstern aktiviert sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein benutzerdefiniertes Steuerelement zeichnen, verwenden Sie diese Eigenschaft entscheiden, ob zum Zeichnen des Steuerelements mit oder ohne visuelle Stile, sodass seine Darstellung mit anderen Steuerelementen in der Anwendung konsistent ist.  
  
 Die folgende Tabelle zeigt die vier Bedingungen, die vorhanden sein müssen, für die <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> zurückzugebenden `true`.  
  
|Bedingung|Beschreibung |  
|---------------|-----------------|  
|Das Betriebssystem unterstützt visuelle Stile.|Verwenden Sie die <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> -Eigenschaft der <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> -Klasse, um diese Bedingung separat zu überprüfen.|  
|Der Benutzer hat visuelle Stile im Betriebssystem aktiviert.|Verwenden Sie die <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> -Eigenschaft der <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> -Klasse, um diese Bedingung separat zu überprüfen.|  
|Visuelle Stile aktiviert sind in der Anwendung|Visuelle Stile können in einer Anwendung durch Aufrufen der <xref:System.Windows.Forms.Application.EnableVisualStyles> -Methode oder mithilfe des Anwendungsmanifests aktiviert werden. Das Manifest gibt an, dass Version 6 von „ComCtl32.dll“ oder höher zum Zeichnen von Steuerelementen verwendet werden wird.|  
|Visuelle Stile werden verwendet, das den Clientbereich von Anwendungsfenstern zu zeichnen.|Verwenden Sie die <xref:System.Windows.Forms.Application.VisualStyleState%2A> -Eigenschaft der <xref:System.Windows.Forms.Application> -Klasse und überprüfen Sie, ob sie den Wert <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> oder <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>aufweist, um diese Bedingung separat zu überprüfen.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Anwendung und startet sofort eine neue Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die häufigste Ursache für den Aufruf `Restart` besteht darin, eine neue Version der Anwendung zu starten, die Sie über heruntergeladen haben [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] mithilfe der `Update` oder `UpdateAsync` Methode.  
  
 Anwendungen werden im Kontext neu gestartet, in denen sie ursprünglich ausgeführt wurden. Wenn Ihre Anwendung über eine URL, die direkt auf der Hauptausführungsdatei der Anwendung gestartet wurde, wird sie mit der gleichen URL gestartet werden. Wenn Ihre Anwendung ist eine [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Anwendung ist, wird er neu gestartet, mit [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Wenn die Anwendung mit Befehlszeilenoptionen ursprünglich bereitgestellt wurde, bei der ersten Ausführung, <xref:System.Windows.Forms.Application.Restart%2A> startet die Anwendung erneut mit den gleichen Optionen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Code stellt keine Windows Forms-Anwendung dar. Diese Methode kann in diesem Kontext nicht aufgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Erfordert <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> Berechtigung.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Ausführung einer Standardmeldungsschleife einer Anwendung für den aktuellen Thread ohne Formular.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einer Win32-basierte oder Windows Forms-Anwendung eine Meldungsschleife ist eine Routine in Code, der Benutzerereignisse wie Mausklicks und Tastaturbefehle verarbeitet. Jede ausgeführte Windows-basierte Anwendung erfordert eine aktive Nachrichtenschleife, die primäre Meldungsschleife aufgerufen. Wenn der primäre Meldungsschleife geschlossen wird, wird die Anwendung beendet. In Windows Forms wird diese Schleife wird geschlossen, wenn die <xref:System.Windows.Forms.Application.Exit%2A> -Methode aufgerufen wird, oder wenn die <xref:System.Windows.Forms.Application.ExitThread%2A> Methode wird aufgerufen, für den Thread, der die Hauptmeldungsschleife ausgeführt wird.  
  
 Die meisten Windows Forms-Entwickler müssen sich nicht auf diese Version der Methode zu verwenden. Verwenden Sie die <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> -Überladung verwenden, um eine Anwendung mit einem Hauptformular zu starten, damit die Anwendung beendet wird, wenn das Hauptformular geschlossen wird. Verwenden Sie für alle anderen Fälle den <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> überladen, die Bereitstellung unterstützt, eine <xref:System.Windows.Forms.ApplicationContext> -Objekt für eine bessere Kontrolle über die Lebensdauer der Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für diesen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">Ein <see cref="T:System.Windows.Forms.ApplicationContext" />, in dem die Anwendung ausgeführt wird.</param>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread mit einem <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichtenschleife ausgeführt wird, bis <xref:System.Windows.Forms.Application.Exit%2A> oder <xref:System.Windows.Forms.Application.ExitThread%2A> aufgerufen wird oder die <xref:System.Windows.Forms.Application.ThreadExit> -Ereignis für das Kontextobjekt, das ausgelöst wird.  
  
   
  
## Examples  
 Das Beispiel zeigt zwei Formen und die Anwendung wird beendet, wenn beide Formen geschlossen werden. Wenn die Anwendung startet und beendet wird, wird die Position jedes Formulars gespeichert. In diesem Beispiel wird veranschaulicht, wie ein <xref:System.Windows.Forms.ApplicationContext>, zusammen mit den `Application.Run(context)` Methode, um mehrere Formulare angezeigt wird, wenn die Anwendung gestartet wird.  
  
 Die Klasse `MyApplicationContext` erbt <xref:System.Windows.Forms.ApplicationContext> und nachverfolgt, wenn jedes Formular wird geschlossen, und den aktuellen Thread beendet wird, wenn beide sind. Die Klasse speichert die Positionen jedes Formular für den Benutzer. Daten aus dem Formular Position befindet sich in einer Datei mit dem Titel `Appdata.txt` , erstellt wird, an dem Speicherort, der bestimmt, indem <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Die `Main` Methodenaufrufe `Application.Run(context)` zum Starten der Anwendung erhält die <xref:System.Windows.Forms.ApplicationContext>.  
  
 Der Code für die `AppForm1` und `AppForm2` Forms wird in Kürze nicht angezeigt. Finden Sie unter den <xref:System.Windows.Forms.ApplicationContext> Übersicht über die Klasse für das gesamte Codebeispiel.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für diesen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Ein <see cref="T:System.Windows.Forms.Form" />, das das anzuzeigende Formular darstellt.</param>
        <summary>Beginnt die Ausführung einer Standardnachrichtenschleife einer Anwendung für den aktuellen Thread und zeigt das angegebene Formular an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die main-Funktion einer Anwendung ruft diese Methode auf und übergeben das Hauptfenster der Anwendung.  
  
 Diese Methode fügt einen Ereignishandler an das `mainForm` -Parameter für die <xref:System.Windows.Forms.Form.Closed> Ereignis. Der Ereignishandler ruft <xref:System.Windows.Forms.Application.ExitThread%2A> , um die Anwendung zu bereinigen.  
  
> [!NOTE]
>  Die <xref:System.Windows.Forms.Control.Dispose%2A> Methode der <xref:System.Windows.Forms.Form> Klasse wird vor der Rückkehr dieser Methode aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Zahlen in ein Listenfeld, das in einem Formular aufgeführt. Bei jedem Klicken auf `button1`, die Anwendung der Liste eine andere Zahl hinzugefügt.  
  
 Die `Main` Methodenaufrufe <xref:System.Windows.Forms.Application.Run%2A> zum Starten der Anwendung, der das Formular erstellt, `listBox1`, und `button1`. Wenn der Benutzer klickt `button1`, `button1_Click` Methode addiert Zahlen bis zu drei in das Listenfeld, und zeigt eine <xref:System.Windows.Forms.MessageBox>. Wenn der Benutzer klickt **keine** auf die <xref:System.Windows.Forms.MessageBox>, `button1_Click` Methode der Liste eine andere Zahl hinzugefügt. Wenn der Benutzer klickt **Ja**, die Anwendung ruft <xref:System.Windows.Forms.Application.Exit%2A> zum Verarbeiten aller verbleibender Nachrichten in der Warteschlange und klicken Sie dann auf, um den Vorgang abzubrechen.  
  
 Im Beispiel erfordert, dass `listBox1` und `button1` erstellt und in einem Formular platziert wurden.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine Hauptnachrichtenschleife wird für den aktuellen Thread bereits ausgeführt.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Formatzeichenfolge ab, die den Beschriftungen der Fenster auf oberster Ebene zugewiesen wird, wenn diese mit einem Warnbanner angezeigt werden, oder legt diese fest.</summary>
        <value>Die Formatzeichenfolge, die den Beschriftungen der Fenster auf oberster Ebene zugewiesen wird.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für alle Fenster zum Festlegen dieser Eigenschaft. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert, der für neue Steuerelemente verwendet werden soll. Bei <see langword="true" /> verwenden neue Steuerelemente, die <c>UseCompatibleTextRendering</c> unterstützen, die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]-basierte <see cref="T:System.Drawing.Graphics" />-Klasse zur Textdarstellung; bei <see langword="false" /> verwenden neue Steuerelemente die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]-basierte <see cref="T:System.Windows.Forms.TextRenderer" />-Klasse.</param>
        <summary>Legt für die gesamte Anwendung die Voreinstellung für die <c>UseCompatibleTextRendering</c>-Eigenschaft fest, die in bestimmten Steuerelementen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmte Windows Forms-Steuerelemente können den Text mithilfe Rendern der <xref:System.Windows.Forms.TextRenderer> -Klasse, die basierend auf den [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Grafikbibliothek, oder die <xref:System.Drawing.Graphics> -Klasse, die basierend auf den [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Grafikbibliothek. Diese Änderung wurde vorgenommen, der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] aufgrund von Leistungs- und Lokalisierung von Problemen mit [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Verwendung <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> standardmäßig den Wert festlegen die `UseCompatibleTextRendering` -Eigenschaft für Steuerelemente, die dies unterstützen.  
  
 Die `UseCompatibleTextRendering` Eigenschaft soll visual Kompatibilität zwischen Windows Forms-Steuerelemente bieten, Rendern Text mit der <xref:System.Windows.Forms.TextRenderer> Klasse und [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] und [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] Anwendungen, die benutzerdefinierte Textrendering mit der <xref:System.Drawing.Graphics>Klasse. In den meisten Fällen, wenn Ihre Anwendung nicht von aktualisiert wird [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] oder [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], es wird empfohlen, Sie lassen `UseCompatibleTextRendering` legen Sie auf den Standardwert `false`.  
  
 Die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basierend <xref:System.Windows.Forms.TextRenderer> Klasse wurde eingeführt, der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] stellen Sie zur Verbesserung der Leistung Text besser aussehen, und die Unterstützung für internationale Schriftarten. In früheren Versionen von der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basierend <xref:System.Drawing.Graphics> Klasse wurde verwendet, um die gesamte Textrendering auszuführen. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] berechnet Zeichenabstand und Wortumbruch anders als [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. In einer Windows Forms-Anwendung, verwendet der <xref:System.Drawing.Graphics> Klasse, um Text gerendert wird, kann dies dazu führen, dass des Texts für Steuerelemente, mit denen <xref:System.Windows.Forms.TextRenderer> sich von den anderen Text in der Anwendung angezeigt werden. Um diese Inkompatibilität zu beheben, können Sie legen die `UseCompatibleTextRendering` Eigenschaft `true`. Festzulegende `UseCompatibleTextRendering` zu `true` rufen Sie für alle unterstützten Steuerelemente in der Anwendung, die <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Methode mit einem Parameter des `true`.  
  
 Diese Methode sollte nie aufgerufen werden, wenn Ihre Windows Forms-Code in einer anderen Anwendung, z. B. Internet Explorer gehostet wird. Rufen Sie diese Methode nur in eigenständigen Windows Forms-Anwendungen.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Den Standardwert für die festzulegende `UseCompatibleTextRendering` in [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] oder höher finden Sie unter <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 In [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] oder höher, einen Aufruf von <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> wird automatisch generiert, in der Datei "Program.cs". Um die Text-Rendering-Standardeinstellung zu ändern, ändern Sie den generierten Code.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können diese Methode nur aufrufen, bevor das erste Fenster von der Windows Forms-Anwendung erstellt wurde.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Windows.Forms.PowerState" />, der den Energieaktivitätsmodus angibt, in den das System wechseln soll.</param>
        <param name="force"><see langword="true" />, um den Standbymodus sofort zu erzwingen, <see langword="false" />, damit Windows veranlasst wird, an jede Anwendung eine Unterbrechungsanforderung zu senden.</param>
        <param name="disableWakeEvent"><see langword="true" />, damit bei einem Aktivierungsereignis die Wiederherstellung eines aktiven Systemenergiezustands deaktiviert wird, <see langword="false" />, damit bei einem Aktivierungsereignis die Wiederherstellung eines aktiven Systemenergiezustands aktiviert wird.</param>
        <summary>Versetzt das System in den Standbymodus oder Ruhezustand oder fordert an, dass das System in den Standbymodus oder Ruhezustand versetzt wird.</summary>
        <returns><see langword="true" />, wenn das System gerade in den Ruhezustand versetzt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Anwendung nicht auf eine unterbrechungsanforderung innerhalb von 20 Sekunden reagiert, bestimmt Windows an, dass es in einem nicht reagierenden Zustand befindet und die Anwendung kann entweder eingegeben haben, um den Standbymodus oder beendet wird. Sobald eine Anwendung auf eine unterbrechungsanforderung antwortet, allerdings dauert es alle Zeit, die sie zum Bereinigen von Ressourcen und aktive Prozesse beenden muss.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist die Anwendung an, wie auf unbehandelte Ausnahmen reagiert werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird legt-Ereignishandlern für Ausnahmen, die auftreten, in Windows Forms-Threads und Ausnahmen, die auf anderen Threads auftreten. Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , damit alle Ausnahmen, die von der Anwendung, unabhängig von den Einstellungen in der Anwendungskonfigurationsdatei Benutzer behandelt werden. Er verwendet den <xref:System.Windows.Forms.Application.ThreadException> Ereignis, um die Behandlung von Ausnahmen für UI-Thread, und die <xref:System.AppDomain.UnhandledException> Ereignis, um nicht-UI-Thread-Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> nicht verhindern, dass eine Anwendung beendet wird, im Beispiel wird der Fehler protokolliert im Ereignisprotokoll Anwendung vor dem Beenden.  
  
 In diesem Beispiel wird davon ausgegangen, dass Sie zwei definiert haben <xref:System.Windows.Forms.Button> Steuerelemente `button1` und `button2`auf Ihre <xref:System.Windows.Forms.Form> Klasse.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Ein <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />-Wert, in dem beschrieben wird, wie sich die Anwendung verhalten soll, wenn eine Ausnahme ausgelöst, aber nicht abgefangen wird.</param>
        <summary>Weist die Anwendung an, wie auf unbehandelte Ausnahmen reagiert werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist oft nicht möglich, alle von Windows Forms ausgelösten Ausnahmen abzufangen. Mit dieser Methode können Sie Ihre Anwendung anweisen, ob es sollten alle unbehandelte von Windows Forms-Komponenten ausgelöste Ausnahmen abzufangen und den Betrieb fortzusetzen, oder ob sie den Benutzer verfügbar gemacht werden und die Ausführung unterbrochen wird.  
  
 Rufen Sie <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> vor dem Instanziieren Sie des Hauptformulars der Anwendung mithilfe der <xref:System.Windows.Forms.Application.Run%2A> Methode.  
  
 Zum Abfangen von Ausnahmen in Threads, die nicht erstellt, und im Besitz von Windows Forms, verwenden Sie die <xref:System.AppDomain.UnhandledException> -Ereignishandler.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird legt-Ereignishandlern für Ausnahmen, die auftreten, in Windows Forms-Threads und Ausnahmen, die auf anderen Threads auftreten. Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , damit alle Ausnahmen, die von der Anwendung, unabhängig von den Einstellungen in der Anwendungskonfigurationsdatei Benutzer behandelt werden. Er verwendet den <xref:System.Windows.Forms.Application.ThreadException> Ereignis, um die Behandlung von Ausnahmen für UI-Thread, und die <xref:System.AppDomain.UnhandledException> Ereignis, um nicht-UI-Thread-Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> nicht verhindern, dass eine Anwendung beendet wird, im Beispiel wird der Fehler protokolliert im Ereignisprotokoll Anwendung vor dem Beenden.  
  
 In diesem Beispiel wird davon ausgegangen, dass Sie zwei definiert haben <xref:System.Windows.Forms.Button> Steuerelemente `button1` und `button2`auf Ihre <xref:System.Windows.Forms.Form> Klasse.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können den Ausnahmemodus nicht festlegen, nachdem die Anwendung das erste Fenster erstellt hat.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Ein <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />-Wert, in dem beschrieben wird, wie sich die Anwendung verhalten soll, wenn eine Ausnahme ausgelöst, aber nicht abgefangen wird.</param>
        <param name="threadScope"><see langword="true" />, um den Threadausnahmemodus festzulegen, andernfalls <see langword="false" />.</param>
        <summary>Weist die Anwendung an, wie auf nicht behandelte Ausnahmen reagiert werden soll, und wendet optional threadspezifisches Verhalten an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist oft nicht möglich, alle von Windows Forms ausgelösten Ausnahmen abzufangen. Mit dieser Methode können Sie Ihre Anwendung anweisen, ob es sollten alle unbehandelte von Windows Forms-Komponenten ausgelöste Ausnahmen abzufangen und den Betrieb fortzusetzen, oder ob sie den Benutzer verfügbar gemacht werden und die Ausführung unterbrochen wird.  
  
 Rufen Sie <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> vor dem Instanziieren Sie des Hauptformulars der Anwendung mithilfe der <xref:System.Windows.Forms.Application.Run%2A> Methode.  
  
 Wenn `threadScope` ist `true`, der Threadausnahmemodus festgelegt ist. Der Threadausnahmemodus überschreibt den Anwendungsmodus für die Ausnahme, wenn `mode` ist nicht festgelegt, um <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Wenn `threadScope` ist `false`, der Anwendungsmodus für die Ausnahme festgelegt ist. Der Anwendungsmodus für die Ausnahme wird verwendet, für alle Threads, die die <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> Modus. Festlegen des Anwendungsmodus für die Ausnahme wirkt sich nicht auf die Einstellung des aktuellen Threads aus.  
  
 Zum Abfangen von Ausnahmen in Threads, die nicht erstellt, und im Besitz von Windows Forms, verwenden Sie die <xref:System.AppDomain.UnhandledException> -Ereignishandler.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird legt-Ereignishandlern für Ausnahmen, die auftreten, in Windows Forms-Threads und Ausnahmen, die auf anderen Threads auftreten. Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , damit alle Ausnahmen, die von der Anwendung, unabhängig von den Einstellungen in der Anwendungskonfigurationsdatei Benutzer behandelt werden. Er verwendet den <xref:System.Windows.Forms.Application.ThreadException> Ereignis, um die Behandlung von Ausnahmen für UI-Thread, und die <xref:System.AppDomain.UnhandledException> Ereignis, um nicht-UI-Thread-Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> nicht verhindern, dass eine Anwendung beendet wird, im Beispiel wird der Fehler protokolliert im Ereignisprotokoll Anwendung vor dem Beenden.  
  
 In diesem Beispiel wird davon ausgegangen, dass Sie zwei definiert haben <xref:System.Windows.Forms.Button> Steuerelemente `button1` und `button2`auf Ihre <xref:System.Windows.Forms.Form> Klasse.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie können den Ausnahmemodus nicht festlegen, nachdem die Anwendung das erste Fenster erstellt hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad ohne den Namen der ausführbaren Datei ab, die zum Starten der Anwendung verwendet wurde.</summary>
        <value>Der Pfad für die ausführbare Datei, die die Anwendung gestartet hat.  
  
Dieser Pfad weicht ab, je nachdem, ob die Windows Forms-Anwendung mit [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] bereitgestellt wird. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Anwendungen befinden sich in einem Anwendungscache pro Benutzer, in der C:\Documents and Settings\\*Benutzername* Verzeichnis. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remotedaten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft ruft und ihr Wert in einem Textfeld angezeigt. Im Beispiel erfordert, dass `textBox1` in einem Formular platziert wurde.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Abrufen des Pfads an. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Auslösen einer nicht abgefangenen Threadausnahme ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Ereignis können Ihre Windows Forms-Anwendung zu behandeln, die andernfalls nicht behandelte Ausnahmen, die in Windows Forms-Threads auftreten. Fügen Sie Ihre Ereignishandler an das <xref:System.Windows.Forms.Application.ThreadException> Ereignis, um diese Ausnahmen zu behandeln, die Ihre Anwendung in einem unbekannten Zustand versetzen. Wenn möglich, sollten die Ausnahmen von einem strukturierten Block zur Ausnahmebehandlung behandelt werden.  
  
 Sie können ändern, ob dieser Rückruf für unbehandelte Ausnahmen der Windows Forms-Thread verwendet wird, durch Festlegen von <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Zum Abfangen von Ausnahmen in Threads, die nicht erstellt, und im Besitz von Windows Forms, verwenden Sie die <xref:System.AppDomain.UnhandledException> -Ereignishandler.  
  
> [!NOTE]
>  Um sicherzustellen, dass keine Aktivierungen für dieses Ereignis fehlen, müssen Sie einen Handler anfügen, vor dem Aufruf <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird legt-Ereignishandlern für Ausnahmen, die auftreten, in Windows Forms-Threads und Ausnahmen, die auf anderen Threads auftreten. Wird <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , damit alle Ausnahmen, die von der Anwendung, unabhängig von den Einstellungen in der Anwendungskonfigurationsdatei Benutzer behandelt werden. Er verwendet den <xref:System.Windows.Forms.Application.ThreadException> Ereignis, um die Behandlung von Ausnahmen für UI-Thread, und die <xref:System.AppDomain.UnhandledException> Ereignis, um nicht-UI-Thread-Ausnahmen zu behandeln. Da <xref:System.AppDomain.UnhandledException> nicht verhindern, dass eine Anwendung beendet wird, im Beispiel wird der Fehler protokolliert im Ereignisprotokoll Anwendung vor dem Beenden.  
  
 In diesem Beispiel wird davon ausgegangen, dass Sie zwei definiert haben <xref:System.Windows.Forms.Button> Steuerelemente `button1` und `button2`auf Ihre <xref:System.Windows.Forms.Form> Klasse.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den unmittelbaren Aufrufer, nicht verwalteten Code aufrufen, wenn dieses Ereignis einen Handler hinzugefügt werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Thread gerade beendet wird. Wenn der Hauptthread für eine Anwendung beendet werden soll, wird zuerst dieses Ereignis und anschließend ein <see cref="E:System.Windows.Forms.Application.ApplicationExit" />-Ereignis ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen die Ereignishandler zum Anfügen der <xref:System.Windows.Forms.Application.ThreadExit> Ereignis ausführen nicht behandelt, die erforderlichen Aufgaben aus, bevor der Thread beendet wird. Schließen Sie Dateien, die von diesem Thread oder Freigeben von Objekten, die der Garbage Collector nicht freigegeben wurden geöffnet.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung des neuen Elements. Im Beispiel meldet sich ein Ereignishandler für das Vorhandensein der <xref:System.Windows.Forms.Application.ThreadExit> Ereignis. In diesem Bericht können Sie entnehmen, wann das Ereignis tritt auf, können Sie beim Debuggen unterstützen. Um den Bericht über mehrere Ereignisse oder Ereignisse, die häufig auftreten, beachten Sie, und Ersetzen Sie dabei <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> mit <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder die Nachricht anfügen, um ein mehrzeiliges <xref:System.Windows.Forms.TextBox>.  
  
 Um den Beispielcode auszuführen, fügen Sie ihn in einer Windows Forms, und stellen Sie sicher, dass der Ereignishandler zugeordnet ist die <xref:System.Windows.Forms.Application.ThreadExit> Ereignis.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hebt die Registrierung des mit <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> vorgenommenen Nachrichtenschleifenrückrufs auf.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad für die Anwendungsdaten eines Benutzers ab.</summary>
        <value>Der Pfad für die Anwendungsdaten eines Benutzers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Pfad nicht vorhanden ist, wird eine im folgenden Format erstellt:  
  
 *Basispfad*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Daten, die in diesem Pfad ist Teil des Benutzerprofils, die für das roaming aktiviert ist. Ein Roamingbenutzer funktioniert auf mehr als einen Computer in einem Netzwerk. Das Benutzerprofil für einen Roamingbenutzer wird auf einem Server im Netzwerk gespeichert und auf ein System geladen wird, wenn der Benutzer anmeldet. Für ein Benutzerprofil berücksichtigt werden, für das roaming von das Betriebssystem Roamingprofile unterstützen, und muss aktiviert sein.  
  
 Ein typischer Basispfad ist C:\Documents and Settings\\*Benutzername*\Application Data. Dieser Pfad unterscheiden sich, aber wenn die Windows Forms-Anwendung mithilfe von [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] erstellt eine eigene Anwendungsdatenverzeichnis, die von allen anderen Anwendungen isoliert ist. Weitere Informationen finden Sie unter [zugreifen auf lokale und Remotedaten in ClickOnce-Anwendungen](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt zwei Formen und die Anwendung wird beendet, wenn beide Formen geschlossen werden. Wenn die Anwendung startet und beendet wird, wird die Position jedes Formulars gespeichert. Dieses Beispiel veranschaulicht die Verwendung der <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Eigenschaft zum Speichern von Anwendungsdaten für den Benutzer.  
  
 Die Klasse `MyApplicationContext` erbt <xref:System.Windows.Forms.ApplicationContext> und nachverfolgt, wenn jedes Formular wird geschlossen, und den aktuellen Thread beendet wird, wenn beide sind. Die Klasse speichert die Positionen jedes Formular für den Benutzer. Daten aus dem Formular Position befindet sich in einer Datei mit dem Titel `Appdata.txt` , erstellt wird, an dem Speicherort, der bestimmt, indem <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Die `Main` Methodenaufrufe `Application.Run(context)` zum Starten der Anwendung erhält die <xref:System.Windows.Forms.ApplicationContext>.  
  
 Dieser Code ist ein Auszug aus dem Beispiel in der <xref:System.Windows.Forms.ApplicationContext> Übersicht über die Klasse. Code wird im Rahmen der Übersichtlichkeit nicht angezeigt. Finden Sie unter <xref:System.Windows.Forms.ApplicationContext> für das gesamte Codebeispiel.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Registrierungsschlüssel für die Anwendungsdaten eines Benutzers ab.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.RegistryKey" />, der den Registrierungsschlüssel für die Anwendungsdaten des Benutzers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel nicht vorhanden ist, wird es im folgenden Format erstellt:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Daten in dieser Schlüssel ist Teil des Benutzerprofils, die für das roaming aktiviert ist. Ein Roamingbenutzer funktioniert auf mehr als einen Computer in einem Netzwerk. Das Benutzerprofil für einen Roamingbenutzer wird auf einem Server im Netzwerk gespeichert und auf ein System geladen wird, wenn der Benutzer anmeldet. Für ein Benutzerprofil berücksichtigt werden, für das roaming von das Betriebssystem Roamingprofile unterstützen, und muss aktiviert sein.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob der Wartecursor für alle offenen Formulare der Anwendung verwendet wird.</summary>
        <value><see langword="true" />, wenn der Wartecursor für alle offenen Formulare verwendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf festgelegt ist `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> -Eigenschaft aller geöffneten Formulare der Anwendung wird festgelegt `true`. Dieser Aufruf wird erst zurückgegeben, in allen Formularen diese Eigenschaft festgelegt wurde. Verwenden Sie diese Eigenschaft, wenn Sie einen lang andauernden Vorgang haben und in allen Anwendungsformularen angeben möchten, dass der Vorgang noch verarbeitet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie visuelle Stile für Anwendungsfenster übernommen werden.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies <xref:System.Windows.Forms.Application.VisualStyleState%2A> Eigenschaft bestimmt, ob visuelle Stile in Client-Bereiche oder Bereiche von nicht-Clientbereiche von Anwendungsfenstern aktiviert sind. In der Regel sollte diese Eigenschaft festgelegt werden, das Hauptformular-Konstruktor oder <xref:System.Windows.Forms.Form.Load> -Ereignishandler.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Windows.Forms.Application.VisualStyleState%2A> Eigenschaft eines der <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> Werte innerhalb der <xref:System.Windows.Forms.Control.Click> -Ereignishandler für ein <xref:System.Windows.Forms.Button> Steuerelement. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> Enumeration.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>