<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49621aee4057663c845ec4206a2a5f9991d31faf" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78778709" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Reihe von Methoden bereit, um die Verwaltung der Kompilierung einer ASP.NET-Anwendung zu vereinfachen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Compilation.BuildManager>-Klasse verwaltet den Prozess der Kompilierung von Assemblys und Seiten für eine Anwendung. Es handelt sich um eine versiegelte Klasse, die nicht vererbt werden kann.  
  
 <xref:System.Web.Compilation.BuildManager> enthält statische Member, die Informationen zu den kompilierten Assemblys bereitstellen.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dependency">Eine Zeichenfolge, die einen Abhängigkeit darstellt.</param>
        <summary>Gibt eine Zeichenfolge an, die eine Abhängigkeit darstellt, die der Build-Manager verwendet, um zu ermitteln, ob ein sauberer Build erforderlich ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode muss während der `Application_PreStartInit` Phase der Anwendung aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="dependency" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.InvalidOperationException">Die Methode war nach der <see langword="Application_PreStartInit" />-Phase der Anwendung aufgerufen worden.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddReferencedAssembly (assembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">Die Assembly, die hinzugefügt werden soll.</param>
        <summary>Fügt dem Satz der Assemblys der Anwendung, auf die verwiesen wird, eine Assembly hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Hinzufügen der Assembly zur Datei "Web. config" auf Anwendungsebene. Die-Methode muss während der `Application_PreStartInit` Phase der Anwendung aufgerufen werden.  
  
 Die <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A>-Methode gibt den Satz von Assemblys zurück, die aus Konfigurationsdateien und Assemblys bestimmt werden, die mit dieser Methode hinzugefügt wurden.  
  
 Wenn versucht wird, eine Assembly hinzuzufügen, die bereits hinzugefügt wurde, wird der doppelte Eintrag ignoriert.  
  
 Diese Methode muss aufgerufen werden, bevor das `Application_Start`-Ereignis in der Datei Global. asax auftritt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="assembly" />-Parameter ist <see langword="null" /> oder leer.</exception>
        <exception cref="T:System.InvalidOperationException">Die Methode wurde nicht aufgerufen, bevor das <see langword="Application_Start" />-Ereignis in der Datei Global.asax aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static bool? BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Batchkompilierung aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Batchkompilierung immer aktiviert ist, <see langword="false" />, wenn die Batchkompilierung nie aktiviert ist, oder <see langword="null" />, wenn die Kompilierungseinstellung von der Konfigurationsdatei bestimmt wird. Standardwert: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht es Ihnen, die Batch Kompilierung Programm gesteuert zu aktivieren oder zu deaktivieren. Dies entspricht dem `batch`-Attribut des `compilation`-Elements in der Datei "Web. config". Weitere Informationen finden Sie unter [compilation-Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/s10awwz0(v=vs.100)).  
  
 Die-Eigenschaft kann nur in der `PreApplicationStart`-Methode festgelegt werden. Weitere Informationen zur `PreApplicationStart`-Methode finden Sie unter <xref:System.Web.PreApplicationStartMethodAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft wurde nicht in der <see langword="PreApplicationStart" />-Methode festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste mit aus dem Verzeichnis App_Code erstellten Assemblys ab.</summary>
        <value>Eine <see cref="T:System.Collections.IList" />-Auflistung, die die aus dem Verzeichnis App_Code erstellten Assemblys enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der zu erstellenden Datei.</param>
        <summary>Erstellt eine zwischengespeicherte Datei.</summary>
        <returns>Das <see cref="T:System.IO.Stream" />-Objekt für die neue Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode und der <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A>-Methode können Sie die Zwischenspeicherung durchführen, die über Anwendungs Domänen Neustarts in teilweise vertrauenswürdigen Umgebungen hinweg bestehen bleibt. Sie wird vom MVC-Framework zum Zwischenspeichern der Ergebnisse der Controller Suche verwendet.  
  
 Zum Zwischenspeichern von Daten schreiben Sie in das <xref:System.IO.Stream> Objekt, das von dieser Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad der Datei, von der eine Instanz erstellt werden soll.</param>
        <param name="requiredBaseType">Der Basistyp, der das zu erstellende Objekt definiert.</param>
        <summary>Verarbeitet eine Datei auf Grundlage ihres virtuellen Pfads und erstellt eine Instanz des Ergebnisses.</summary>
        <returns>Das <see cref="T:System.Object" />, das die Instanz der verarbeiteten Datei darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A>-Methode funktioniert für kompilierte und nicht kompilierte Seiten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Buildabhängigkeitssatz vom ASP.NET-Cache zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">Der Kontext der Anforderung.</param>
        <param name="virtualPath">Der virtuelle Pfad, für den der Buildabhängigkeitssatz bestimmt werden soll.</param>
        <summary>Gibt für einen virtuellen Pfad einen Buildabhängigkeitssatz zurück, wenn sich der Pfad im ASP.NET-Cache befindet.</summary>
        <returns>Ein <see cref="T:System.Web.Compilation.BuildDependencySet" />-Objekt, das im Cache gespeichert ist, oder <see langword="null" />, wenn das <see cref="T:System.Web.Compilation.BuildDependencySet" />-Objekt nicht aus dem Cache abgerufen werden kann.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="virtualPath" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">Der Kontext der Anforderung.</param>
        <param name="virtualPath">Der virtuelle Pfad, für den der Buildabhängigkeitssatz bestimmt werden soll.</param>
        <param name="ensureIsUpToDate"><see langword="true" /> gibt an, dass nur ein aktueller Buildabhängigkeitssatz zurückgegeben werden soll. <see langword="false" /> gibt an, dass jeder verfügbare Buildabhängigkeitssatz zurückgegeben werden soll, auch wenn er nicht aktuell ist. Der Standardwert lautet <see langword="true" />.</param>
        <summary>Gibt einen Buildabhängigkeitssatz für einen virtuellen Pfad zurück, falls sich der Pfad im ASP.NET-Cache befindet, auch wenn der Inhalt nicht aktuell ist.</summary>
        <returns>Ein <see cref="T:System.Web.Compilation.BuildDependencySet" />-Objekt, das im Cache gespeichert ist, oder <see langword="null" />, wenn das <see cref="T:System.Web.Compilation.BuildDependencySet" />-Objekt nicht aus dem Cache abgerufen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `ensureIsUpToDate` Parameterwert auf `true`festgelegt ist, verhält sich die <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType>-Methoden Überladung wie die <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> Methoden Überladung. Beide über Ladungen geben einen aktuellen buildabhängensatz zurück, wenn ein solcher vorhanden ist, andernfalls geben Sie `null`zurück.  
  
 Die <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType>-Methoden Überladung enthält jedoch die-Option, um alle verfügbaren buildabhängigkeits Sätze, sogar eine veraltete, zurückzugeben. Wenn der `ensureIsUpToDate` Parameterwert auf `false`festgelegt ist, gibt die Methode jeden verfügbaren buildabhängensatz zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad, der in eine Assembly integriert werden soll.</param>
        <summary>Kompiliert eine Datei mit dem angegebenen virtuellen Pfad in eine Assembly.</summary>
        <returns>Ein aus dem angegebenen virtuellen Pfad kompiliertes <see cref="T:System.Reflection.Assembly" />-Objekt, das entweder im Arbeitsspeicher oder auf der Festplatte zwischengespeichert wird.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad der zu erstellenden Datei.</param>
        <summary>Kompiliert eine Datei unter Angabe des virtuellen Pfads und gibt eine benutzerdefinierte Zeichenfolge zurück, die der Buildanbieter im Cache speichert.</summary>
        <returns>Eine Zeichenfolge, wie sie von der <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />-Methode zurückgegeben wird, die im Arbeitsspeicher oder auf der Festplatte zwischengespeichert wird.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad, der in einen Typ integriert werden soll.</param>
        <summary>Kompiliert eine Datei mit dem angegebenen virtuellen Pfad und gibt den kompilierten Typ zurück.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das den Typ darstellt, der durch Kompilieren des virtuellen Pfads generiert wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Beim Kompilieren des virtuellen Pfads ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Objekt ab, das den kompilierten Typ für die Datei Global.asax darstellt.</summary>
        <returns>Ein Objekt, das den kompilierten Typ für die Datei Global.asax darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme wird ausgelöst, wenn diese Methode aufgerufen wird, bevor die Datei "Global. asax" kompiliert wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, diese Methode aufzurufen, bevor die Seite Global.asax kompiliert wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad.</param>
        <param name="throwIfNotFound"><see langword="true" /> löst einen Fehler aus, wenn der virtuelle Pfad nicht vorhanden ist, andernfalls <see langword="false" />. Wenn der virtuelle Pfad nicht vorhanden ist und <paramref name="throwIfNotFound" /><see langword="false" /> ist, wird von dieser Methode <see langword="null" /> zurückgegeben.</param>
        <summary>Ruft eine Objektfactory für den angegebenen virtuellen Pfad ab.</summary>
        <returns>Die Objektfactory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt ein-Objekt zurück, das es Ihnen ermöglicht, einen Typ durch Kompilieren des virtuellen Pfads zu generieren. Es wird ein Objekt zurückgegeben, unabhängig davon, ob die Website vorkompiliert ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Der virtuelle Pfad ist nicht vorhanden.  
  
 Oder  
  
 Eine Ausnahme auf höherer Ebene war bereits vorhanden, als diese Methode aufgerufen wurde.  
  
 Oder  
  
 Diese Methode wurde aufgerufen, während der Kompilierungsprozess Dateien der obersten Ebene erstellt hat.  
  
 Oder  
  
 Dies ist eine vorkompilierte Anwendung, und der virtuelle Pfad wurde nicht im Cache gefunden.  
  
 Oder  
  
 Ein Zirkelverweis wurde erkannt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von Assemblyverweisen zurück, auf die alle Seitenkompilierungen verweisen müssen.</summary>
        <returns>Eine <see cref="T:System.Collections.ICollection" />-Auflistung von Assemblyverweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Auflistung von Assemblys, die von der <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A>-Methode zurückgegeben wird, enthält Assemblys [, die im](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bfyb45k1(v=vs.100)) Assemblyelement der Datei Web. config, Assemblys, die aus benutzerdefiniertem Code im App_Code Verzeichnis erstellt wurden, und Assemblys in anderen Ordnern  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> wird in .NET Framework Version 3,5 eingeführt.  Weitere Informationen finden Sie unter [.NET Framework-Versionen und -Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht einen Typ in den Assemblys der obersten Ebene oder in Assemblys, die in der Konfiguration definiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Assembly der obersten Ebene verweist auf die Datei "Global. asax" oder auf eine Datei, die sich im Verzeichnis "App_GlobalResources", "App_WebReferences", "App_Code" oder "App_Browsers" befindet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des Typs.</param>
        <param name="throwOnError"><see langword="true" />, um eine Ausnahme auszulösen, wenn ein <see cref="T:System.Type" />-Objekt für den Typnamen nicht generiert werden kann, andernfalls <see langword="false" />.</param>
        <summary>Sucht einen Typ in den Assemblys der obersten Ebene oder in Assemblys, die in der Konfiguration definiert sind, und löst bei Fehlern eine Ausnahme aus (optional).</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das den angeforderten <paramref name="typeName" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Assembly der obersten Ebene verweist auf die Datei "Global. asax" oder auf eine Datei, die sich im Verzeichnis "App_GlobalResources", "App_WebReferences", "App_Code" oder "App_Browsers" befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> ist ungültig.  
  
Oder 
 <paramref name="typeName" /> ist mehrdeutig.  
  
Oder 
 <paramref name="typeName" /> konnte nicht gefunden werden, und <paramref name="throwOnError" /> ist <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des Typs.</param>
        <param name="throwOnError"><see langword="true" />, um eine Ausnahme auszulösen, wenn ein <see cref="T:System.Type" /> für den Typnamen nicht generiert werden kann, andernfalls <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" />, wenn für den <paramref name="typeName" /> Groß- und Kleinschreibung unterschieden werden, andernfalls <see langword="false" />.</param>
        <summary>Sucht unter Beachtung der Groß- und Kleinschreibung  einen Typ in den Assemblys der obersten Ebene oder in  Assemblys, die in der Konfiguration definiert wurden, und löst bei Fehlern eine Ausnahme aus (optional).</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das den angeforderten <paramref name="typeName" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Assembly der obersten Ebene verweist auf die Datei "Global. asax" oder auf eine Datei, die sich im Verzeichnis "App_GlobalResources", "App_WebReferences", "App_Code" oder "App_Browsers" befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> ist ungültig.  
  
Oder 
 <paramref name="typeName" /> ist mehrdeutig.  
  
Oder 
 <paramref name="typeName" /> konnte nicht gefunden werden, und <paramref name="throwOnError" /> ist <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Der virtuelle Pfad, der für das Bestimmen der Abhängigkeiten verwendet wird.</param>
        <summary>Stellt eine Auflistung virtueller Pfadabhängigkeiten für einen angegebenen virtuellen Pfad bereit.</summary>
        <returns>Eine <see cref="T:System.Collections.ICollection" />-Auflistung der von virtuellen Pfaden dargestellten Dateien, die Abhängigkeiten für den virtuellen Pfad zwischenspeichern.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung vorkompiliert wird.</summary>
        <value><see langword="true" />, wenn die Anwendung vorkompiliert ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob die Anwendung als aktualisierbar vorkompiliert wird.</summary>
        <value><see langword="true" />, wenn die Anwendung als aktualisierbar vorkompiliert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der zu lesenden Datei.</param>
        <summary>Liest eine zwischengespeicherte Datei.</summary>
        <returns>Das <see cref="T:System.IO.Stream" />-Objekt für die Datei oder <see langword="null" />, wenn die Datei nicht vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode und der <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A>-Methode können Sie die Zwischenspeicherung durchführen, die über Anwendungs Domänen Neustarts in teilweise vertrauenswürdigen Umgebungen hinweg bestehen bleibt. Sie wird vom MVC-Framework zum Zwischenspeichern der Ergebnisse der Controller Suche verwendet.  
  
 Zum Abrufen von zwischengespeicherten Daten lesen Sie das <xref:System.IO.Stream> Objekt, das von dieser Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zielversion von .NET Framework für die aktuelle Website ab.</summary>
        <value>Die Zielversion von .NET Framework für die aktuelle Website.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft unterstützt die ASP.net-Funktion für die fest Zuweisungs Ziel Versionen, mit der Sie die neueste Version von Visual Studio verwenden können, um Anwendungen zu entwickeln, die mit früheren Versionen der .NET Framework ausgeführt werden. Ein Buildanbieter kann diese Eigenschaft verwenden, um sicherzustellen, dass der Anbieter Code generiert, der für die Zielversion des .NET Framework geeignet ist. Beispielsweise können Sie unterschiedliche Codes generieren, je nachdem, ob eine Website auf die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] oder die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]abzielt. Weitere Informationen zu fest Zuweisungs Ziel-Zielanwendungen finden Sie unter .NET Framework fest Zuweisungs [Ziel für ASP.NET-Webprojekte](https://docs.microsoft.com/previous-versions/aspnet/bb398791(v=vs.100)).  
  
 Wenn die Website keine Web. config-Datei hat, geht ASP.net davon aus, dass es sich bei der Ziel Framework-Version um die Version handelt, die dem IIS-Anwendungs Pool zugeordnet ist, unter dem die Website ausgeführt wird. Bei einer Dateisystem-Website, die in Visual Studio ausgeführt wird, ist die Standard Framework-Version die aktuelle Version der .NET Framework.  
  
 Wenn die Website über eine Web. config-Datei verfügt, bestimmt ASP.NET das Ziel Framework durch Untersuchen der Datei "Web. config".  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>Websites, die auf das .NET Framework 2,0 abzielen  
 Webanwendungen, die auf die [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] abzielen, werden so kompiliert, als ob das Ziel das [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]wäre. Der Buildprozess unterscheidet nicht zwischen der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] und der [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], da die Datei "Web. config" keine Compilerversion oder das Ziel Framework angibt, wenn eine dieser Versionen als Ziel verwendet wird. (Für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]wird in der Datei "Web. config" die Compilerversion angegeben, und für die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]wird in der Datei "Web. config" das Ziel Framework angegeben.) Daher gibt diese Eigenschaft für Webanwendungen, die auf das [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]abzielen, einen zielframeworkmoniker zurück, der die [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]angibt.  
  
 Dies führt normalerweise nicht zu Problemen. Visual Studio verhindert, dass Sie Verweise auf [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] Funktionen in einem Projekt erstellen, das für die [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]vorgesehen ist. Beispielsweise stellt Visual Studio keine Element Vorlagen für WCF-Dienste in einem Projekt bereit, das auf [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]ausgerichtet ist, da WCF mit dem [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] eingeführt wurde und nicht mit dem [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]kompatibel ist.  
  
 Wenn Sie beabsichtigen, eine Website in einer [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] Laufzeitumgebung bereitzustellen, und Sie ein anderes Tool als Visual Studio verwenden, um auf Features zu verweisen, die nur mit [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]kompatibel sind, kann das Projekt ohne Fehler oder Warnungen erstellt werden. Die Anwendung generiert jedoch möglicherweise Fehler, wenn die Website auf dem [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
