<Type Name="AsyncResult" FullName="System.Runtime.Remoting.Messaging.AsyncResult">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc0d37c6403e708442c5d9a420583a08ac46d972" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48711417" /></Metadata><TypeSignature Language="C#" Value="public class AsyncResult : IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit AsyncResult extends System.Object implements class System.IAsyncResult, class System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.AsyncResult" />
  <TypeSignature Language="VB.NET" Value="Public Class AsyncResult&#xA;Implements IAsyncResult, IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsyncResult : IAsyncResult, System::Runtime::Remoting::Messaging::IMessageSink" />
  <TypeSignature Language="F#" Value="type AsyncResult = class&#xA;    interface IAsyncResult&#xA;    interface IMessageSink" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Messaging.IMessageSink</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt die Ergebnisse eines asynchronen Vorgangs für einen Delegaten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Messaging.AsyncResult> Klasse zusammen mit asynchronen Methodenaufrufen Verwenden von Delegaten verwendet wird. Die <xref:System.IAsyncResult> zurückgegeben, aus des Delegaten die `BeginInvoke` Methode umgewandelt werden kann, um eine <xref:System.Runtime.Remoting.Messaging.AsyncResult>. Die <xref:System.Runtime.Remoting.Messaging.AsyncResult> hat die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> Eigenschaft, die der Delegat enthält Objekt, auf dem der asynchrone Aufruf ausgelöst wurde.  
  
 Weitere Informationen zu `BeginInvoke` und asynchrone Aufrufe, die mithilfe von Delegaten finden Sie unter [asynchrone Programmierung mithilfe von Delegaten](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> die abzurufende Eigenschaft eine <xref:System.Threading.WaitHandle>, und Warten eines asynchronen Aufrufs für einen Delegaten auf. Das <xref:System.Threading.WaitHandle> wird bei Beendigung des asynchronen Aufrufs signalisiert, und durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode kann darauf gewartet werden.  
  
 Das Beispiel besteht aus zwei Klassen, die Klasse, die die Methode enthält, die asynchron aufgerufen wird, und die Klasse enthält die `Main` -Methode, die den Aufruf ausführt.  
  
 Weitere Informationen und Beispiele von asynchronen Aufrufen von Methoden mit Delegaten finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md">Asynchrone Programmierung mithilfe von Delegaten</related>
  </Docs>
  <Members>
    <Member MemberName="AsyncDelegate">
      <MemberSignature Language="C#" Value="public virtual object AsyncDelegate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncDelegate As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncDelegate { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncDelegate : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Delegatobjekt ab, für das der asynchrone Aufruf ausgelöst wurde.</summary>
        <value>Das Delegatobjekt, für das der asynchrone Aufruf ausgelöst wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> Eigenschaft auf die tatsächliche Klasse des benutzerdefinierten Delegaten umgewandelt werden kann.  
  
 Wenn der Delegat, der verwendet wurde, um den asynchronen Aufruf des Typs ist z. B. `MyDelegate`, der Delegat, der von dieser Eigenschaft zurückgegeben wird, muss in umgewandelt werden `MyDelegate`. Die Callback-Methode können Sie dann Aufrufen des Delegaten `EndInvoke` Methode mit der richtigen Signatur, um die Ergebnisse des asynchronen Methodenaufrufs zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> Eigenschaft, um den Delegaten abzurufen, die verwendet wurde, um den asynchronen Aufruf, um aufzurufen `EndInvoke`. Das Beispiel Umwandlungen der <xref:System.IAsyncResult>, dies ist der einzige Parameter der Rückrufmethode darstellt, zu einer <xref:System.Runtime.Remoting.Messaging.AsyncResult> Objekt.  
  
 Das Beispiel besteht aus zwei Klassen, die Klasse, die die Methode enthält, die asynchron aufgerufen wird, und die Klasse enthält die `Main` -Methode, die den Aufruf ausführt.  
  
 Für Weitere Informationen über die Funktionsweise dieses Rückrufs-Beispiel funktioniert, und weitere Beispiele von asynchronen Aufrufen von Methoden finden Sie unter Verwendung von Delegaten [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberSignature Language="F#" Value="abstract member AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl&#xA;override this.AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl" Usage="asyncResult.AsyncProcessMessage (msg, replySink)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">Die <see cref="T:System.Runtime.Remoting.Messaging.IMessage" />-Schnittstelle der Anforderung.</param>
        <param name="replySink">Die <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />-Schnittstelle der Antwort.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />-Schnittstelle.</summary>
        <returns>Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage%2A> Methode der <xref:System.Runtime.Remoting.Messaging.IMessageSink> -Schnittstelle ist nicht relevant für die <xref:System.Runtime.Remoting.Messaging.AsyncResult> Klasse. Implementierung von <xref:System.Runtime.Remoting.Messaging.AsyncResult> löst eine <xref:System.NotSupportedException>. Erhalten Sie stattdessen eine <xref:System.Runtime.Remoting.Messaging.AsyncResult> durch Umwandeln der <xref:System.IAsyncResult> Schnittstelle, die von einem asynchronen Aufruf mit einem Delegaten zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public virtual object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das als letzter Parameter eines <see langword="BeginInvoke" />-Methodenaufrufs angegeben ist.</summary>
        <value>Das Objekt, das als letzter Parameter eines <see langword="BeginInvoke" />-Methodenaufrufs angegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu den `BeginInvoke` -Methode finden Sie unter [asynchrone Programmierung mithilfe von Delegaten](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A> Eigenschaft wird verwendet, um Informationen an eine Rückrufmethode übergeben. Der letzte Parameter von der `BeginInvoke` Methodenaufruf ist eine Formatzeichenfolge, die die Callback-Methode, die zum Formatieren einer ausgabemeldung verwendet.  
  
 Das Beispiel besteht aus zwei Klassen, die Klasse, die die Methode enthält, die asynchron aufgerufen wird, und die Klasse enthält die `Main` -Methode, die den Aufruf ausführt.  
  
 Für Weitere Informationen über die Funktionsweise dieses Rückrufs-Beispiel funktioniert, und weitere Beispiele von asynchronen Aufrufen von Methoden finden Sie unter Verwendung von Delegaten [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncWaitHandle">
      <MemberSignature Language="C#" Value="public virtual System.Threading.WaitHandle AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Threading::WaitHandle ^ AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncWaitHandle : System.Threading.WaitHandle" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.WaitHandle" /> ab, das Win32-Synchronisierungshandles kapselt und die Implementierung verschiedener Synchronisierungsschemas ermöglicht.</summary>
        <value>Ein <see cref="T:System.Threading.WaitHandle" />, das Win32-Synchronisierungshandles kapselt und die Implementierung verschiedener Synchronisierungsschemas ermöglicht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.WaitHandle> zurückgegeben, die von dieser Methode wird automatisch signalisiert, wenn der asynchrone Vorgang abgeschlossen wurde.  
  
 Das Wait-Handle wird nicht automatisch geschlossen, wenn Sie aufrufen `EndInvoke` auf der Delegat, der verwendet wurde, um den asynchronen Methodenaufruf. Wenn Sie alle Verweise auf das Wait-Handle freigeben, werden Systemressourcen frei, sobald das Wait-Handle von der Garbage Collection zurückgefordert wird. Um Systemressourcen freizugeben, sobald Sie mit der Verwendung des Wait-Handles fertig sind, rufen Sie die <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> Methode. Garbagecollection arbeitet effizienter, wenn verwerfbare Objekte explizit geschlossen oder freigegeben werden.  
  
> [!CAUTION]
>  Die <xref:System.Threading.WaitHandle> innerhalb der <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> Eigenschaft kann verwendet werden, um den aktuellen Thread blockieren, bis der asynchrone Aufruf abgeschlossen ist. Jedoch <xref:System.Threading.WaitHandle> ignoriert die <xref:System.AsyncCallback>, wenn während der angegeben wurde der `BeginInvoke` aufrufen. Aus diesem Grund kann eine Situation, in dem Herunterfahren der Anwendung vor dem Eintreten der <xref:System.AsyncCallback> wurde ausgeführt, selbst wenn eine <xref:System.Threading.WaitHandle> wird verwendet, zu blockieren, bis zum Abschluss asynchronen Aufrufs. Ein Beispiel einer solchen Situation finden Sie im Beispiel für die <xref:System.Runtime.Remoting.Messaging.AsyncResult> Klasse, und entfernen Sie die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Anweisung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> die abzurufende Eigenschaft eine <xref:System.Threading.WaitHandle>, und Warten eines asynchronen Aufrufs für einen Delegaten auf. Das <xref:System.Threading.WaitHandle> wird bei Beendigung des asynchronen Aufrufs signalisiert, und durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode kann darauf gewartet werden.  
  
 Das Beispiel besteht aus zwei Klassen, die Klasse, die die Methode enthält, die asynchron aufgerufen wird, und die Klasse enthält die `Main` -Methode, die den Aufruf ausführt.  
  
 Weitere Informationen und Beispiele von asynchronen Aufrufen von Methoden mit Delegaten finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
    <Member MemberName="CompletedSynchronously">
      <MemberSignature Language="C#" Value="public virtual bool CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CompletedSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedSynchronously : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="BeginInvoke" />-Aufruf synchron abgeschlossen wurde.</summary>
        <value><see langword="true" />, wenn der <see langword="BeginInvoke" />-Aufruf synchron abgeschlossen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es erkannt wird, die die `BeginInvoke` -Aufruf abgeschlossen wurde, synchron in den <xref:System.AsyncCallback> Delegaten, es ist jedoch wahrscheinlich, dass der Thread, der BeginInvoke wird aufgerufen, der aktuelle Thread befindet. Die meisten Anbieter von der <xref:System.IAsyncResult> Schnittstelle verwenden die Funktion nicht und gibt den Standardwert `false`.  
  
 Aktuelle Implementierung von <xref:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously%2A> gibt immer `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeCalled">
      <MemberSignature Language="C#" Value="public bool EndInvokeCalled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndInvokeCalled" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberSignature Language="VB.NET" Value="Public Property EndInvokeCalled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndInvokeCalled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EndInvokeCalled : bool with get, set" Usage="System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see langword="EndInvoke" /> für das aktuelle <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" /> aufgerufen wurde, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn <see langword="EndInvoke" /> für das aktuelle <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" /> aufgerufen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReplyMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage GetReplyMessage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage GetReplyMessage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReplyMessage () As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ GetReplyMessage();" />
      <MemberSignature Language="F#" Value="abstract member GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.GetReplyMessage " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Antwortmeldung für den asynchronen Aufruf ab.</summary>
        <returns>Eine Remotemeldung, die eine Antwort auf einen Methodenaufruf für ein Remoteobjekt darstellen soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> Methode kann ein Objekt nach dem Zurückgeben der <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> Methode wird aufgerufen. Die <xref:System.Runtime.Remoting.Messaging.IMessage> Rückgabewert umgewandelt werden kann, um eine <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>.  
  
 Allerdings müssen Sie nicht beide Methoden direkt aufzurufen. Sie sind für die Verwendung von .NET Framework-Remoteinfrastruktur vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public virtual bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Server den Aufruf abgeschlossen hat.</summary>
        <value><see langword="true" />, nachdem der Server den Aufruf abgeschlossen hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Server muss nicht vom Client bereitgestellte Ressourcen außerhalb der vereinbarten verwenden für die gemeinsame Nutzung Semantik nach wird die <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> Eigenschaft `true`. Daher wird der Client die Ressourcen nach dem Zerstören der <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> -Eigenschaft gibt `true`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.IAsyncResult.IsCompleted%2A> Eigenschaft der <xref:System.Runtime.Remoting.Messaging.AsyncResult> zurückgegebenes `BeginInvoke` ermitteln, wenn ein asynchroner Aufruf abgeschlossen ist. Dieses Verfahren ist empfehlenswert, wenn der asynchrone Aufruf aus einem Thread für die Benutzeroberfläche erfolgt. Durch das Abrufen der Beendigung kann die Verarbeitung vom aufrufenden Thread fortgesetzt werden, während der asynchrone Aufruf für einen <xref:System.Threading.ThreadPool>-Thread ausgeführt wird.  
  
 Das Beispiel besteht aus zwei Klassen, die Klasse, die die Methode enthält, die asynchron aufgerufen wird, und die Klasse enthält die `Main` -Methode, die den Aufruf ausführt.  
  
 Weitere Informationen und Beispiele von asynchronen Aufrufen von Methoden mit Delegaten finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#4](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
[!code-csharp[AsyncDelegateExamples#4](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
[!code-vb[AsyncDelegateExamples#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSink : System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die nächste Meldungssenke in der Senkenkette ab.</summary>
        <value>Eine <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />-Schnittstelle, die die nächste Meldungssenke in der Senkenkette darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Implementierung von <xref:System.Runtime.Remoting.Messaging.AsyncResult.NextSink%2A> gibt `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMessageCtrl">
      <MemberSignature Language="C#" Value="public virtual void SetMessageCtrl (System.Runtime.Remoting.Messaging.IMessageCtrl mc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMessageCtrl(class System.Runtime.Remoting.Messaging.IMessageCtrl mc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMessageCtrl (mc As IMessageCtrl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMessageCtrl(System::Runtime::Remoting::Messaging::IMessageCtrl ^ mc);" />
      <MemberSignature Language="F#" Value="abstract member SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit&#xA;override this.SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit" Usage="asyncResult.SetMessageCtrl mc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mc" Type="System.Runtime.Remoting.Messaging.IMessageCtrl" />
      </Parameters>
      <Docs>
        <param name="mc">Das <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> für den aktuellen Remotemethodenaufruf.</param>
        <summary>Legt ein <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> für den aktuellen Remotemethodenaufruf fest, das das Steuern asynchroner Meldungen nach der Meldungsverteilung ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen nicht aufrufen, die <xref:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberSignature Language="F#" Value="abstract member SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.SyncProcessMessage msg" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Eine Antwortmeldung auf einen Methodenaufruf für ein Remoteobjekt.</param>
        <summary>Verarbeitet eine von einem Methodenaufruf für ein Remoteobjekt zurückgegebene Antwortmeldung synchron.</summary>
        <returns>Gibt <see langword="null" />zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> Methode implementiert die <xref:System.Runtime.Remoting.Messaging.IMessageSink> Schnittstelle. Sie müssen sich nicht, diese Methode direkt aufzurufen. Es ist für die Verwendung durch die Remotinginfrastruktur von .NET Framework vorgesehen.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> Ruft der Consumercode <xref:System.AsyncCallback> delegieren. Außerdem wird die <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> vom zurückgegebene Instanz der <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> Methode. Wenn die `msg` Parameter ist vom Typ <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>, dasselbe Objekt wird zurückgegeben, indem <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>. Andernfalls wird eine Antwortnachricht, die eine Ausnahme Remoting enthält zurückgegeben.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> ändert außerdem den Rückgabewert von der <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>