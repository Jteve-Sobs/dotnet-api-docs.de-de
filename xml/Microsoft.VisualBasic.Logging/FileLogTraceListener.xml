<Type Name="FileLogTraceListener" FullName="Microsoft.VisualBasic.Logging.FileLogTraceListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c3dda8dbc945755a81e528980b8ccc08173297de" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55318977" /></Metadata><TypeSignature Language="C#" Value="public class FileLogTraceListener : System.Diagnostics.TraceListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileLogTraceListener extends System.Diagnostics.TraceListener" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
  <TypeSignature Language="VB.NET" Value="Public Class FileLogTraceListener&#xA;Inherits TraceListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileLogTraceListener : System::Diagnostics::TraceListener" />
  <TypeSignature Language="F#" Value="type FileLogTraceListener = class&#xA;    inherit TraceListener" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.TraceListener</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen einfachen Listener bereit, der Protokollausgaben an eine Datei weiterleitet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse bietet automatisierte Wartungsfunktionen für die Archivierung von Protokolldateien bei Bedarf auf täglich oder pro Anwendung. Diese automatische Archivierung Funktionalität reduziert die Wartung Aufgaben von Entwicklern und Administratoren.  
  
 Eine Instanz von <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> können hinzugefügt werden, um die <xref:System.Diagnostics.Debug.Listeners%2A?displayProperty=nameWithType> oder <xref:System.Diagnostics.Trace.Listeners%2A?displayProperty=nameWithType> Sammlungen, um die Protokollausgabe an eine Textdatei umleiten. Instanzen dieser Klasse können auch hinzugefügt werden, um `My.Application.Log` oder `My.Log` (für Web-Anwendungen) in Visual Basic-Anwendungen. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Ändern, wohin "My.Application.log" Informationen schreibt](~/docs/visual-basic/developing-apps/programming/log-info/walkthrough-changing-where-my-application-log-writes-information.md)`.`  
  
 Die wichtigsten Funktionen dieser Klasse werden zu können:  
  
1.  *Archivierung Funktionalität*. Die Protokolldateien, die von dieser Klasse generiert werden entsprechend dem Basisnamen und dem Datum, zusammen mit einer Zahl in die Protokolldatei von aufeinander folgenden Versionen des Protokolls zu unterscheiden, mit dem Namen. Neue Protokolldateien werden auf einen Bedarf erstellt.  
  
     Ist die explizite Form des Dateinamens `baseName`[-`dateStamp`] [-`version`] log, wobei:  
  
    -   Die `baseName` Teil ist der grundlegende Protokollname, gemäß der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> Eigenschaft.  
  
    -   Die `dateStamp` Teil weist das Format "JJJJ-MM-DD", und wird angezeigt, wenn <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> ist <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> oder <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
    -   Wenn mehr als eine Protokolldatei, mit dem gleichen erforderlich ist `baseName` und `dateStamp`, wird die `version` Webpart, ein positiver `Integer`, an den Dateinamen hinzugefügt wird.  
  
2.  *Mehrere Klasseninstanzen*. Wenn eine Instanz von der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse schreibt in eine Datei, die verwendet wird:  
  
    -   Die Klasse gibt die Datei frei, wenn sie von einer anderen Instanz verwendet wird die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse im gleichen Prozess.  
  
    -   Die Klasse erstellt eine neue Protokolldatei, die mit dem nächsten verfügbaren Namen aus, wenn die Datei von einem anderen Prozess verwendet wird.  
  
3.  *Threadsicherheit*. Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse threadsicher ist. Dadurch können Sie problemlos in das Protokoll aus mehreren Threads Schreiben von Nachrichten ohne Verwendung von Sperren.  
  
 **Speicherort der Protokolldatei.**  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> Eigenschaft akzeptiert einen <xref:Microsoft.VisualBasic.Logging.LogFileLocation> Enumeration für eine der üblichen Verzeichnisse an, die Protokolldatei geschrieben.  
  
-   Um das Protokoll an einen anderen Speicherort zu schreiben, legen die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> Eigenschaft auf diesen Speicherort.  
  
 **Name der Protokolldatei.**  
  
-   Der Basisname der Protokolldatei wird gemäß der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> Eigenschaft.  
  
-   Name der aktuellen Protokolldatei gelesen werden kann, aus der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Eigenschaft. Es wird von verschiedenen weiteren Eigenschaften und den aktuellen Status der Protokolle im Dateisystem abgeleitet werden.  
  
 **Protokollverwaltung**  
  
-   Die mindesthäufigkeit für die Erstellung neuer Protokolldateien richtet sich nach der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> Eigenschaft. Wenn der Wert ist <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> oder <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>, eine neue Protokolldatei wird jeden Tag oder Woche mindestens einmal erstellt und einen Datumsstempel in den <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Name.  
  
-   Die maximale Größe (in Bytes) der Protokolldatei richtet sich nach der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A> Eigenschaft. Wenn die Größe der Protokolldatei diese Größe überschreitet, zusätzliche Meldungen, die in das Protokoll geschrieben werden, verworfenen und, je nach den <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> -Eigenschaft, die eine Ausnahme ausgelöst wird.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A> Eigenschaft bestimmt, wie viel freier Speicherplatz (in Byte) verfügbar sein muss. Dies trägt dazu bei, die die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse werden nicht alle verfügbaren Speicherplatz zu nutzen. Verwenden der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> schreibt Eigenschaft, um das Verhalten des Protokolls anzugeben, bei weniger als <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A> freien Bytes verfügbar.  
  
 **Protokolldatei-Ausgabeeinstellungen**  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush%2A> Eigenschaft gibt an, ob es sich bei der zugrunde liegenden Stream in die Protokolldatei automatisch nach jedem Schreibvorgang entleert werden soll.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append%2A> Eigenschaft gibt an, ob Nachrichten in der aktuellen Protokolldatei, anfügen, wenn zugelassen wird, oder in eine neue Protokolldatei schreiben.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft gibt an, die Zeichenfolge, zum Begrenzen der Felder in einer protokollmeldung verwendet.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding%2A> Eigenschaft gibt an, die beim Erstellen einer neuen Protokolldatei zu verwendende Codierung.  
  
 **Protokolldatei-Ausgabe**  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> und <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> Methoden Meldungen in die Protokolldatei schreiben. Überprüfen Sie diese Methoden die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> Eigenschaft zusammen mit der alle vorhandenen Protokolle mit den gleichen Basisnamen, um zu bestimmen, ob ein neues Protokoll erstellt werden soll.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> Methode leert die Nachrichten, die derzeit in den Ausgabepuffer, in der Protokolldatei.  
  
-   Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> Methode schließt die Protokolldatei, damit es von anderen Prozessen verwendet werden kann.  
  
 **Aktivieren der Ausgabe**  
  
 Sie müssen die Ablaufverfolgung oder Debuggen verwenden Sie einen Ablaufverfolgungslistener aktivieren. Die folgende Syntax ist compilerspezifisch. Wenn Sie den Compiler als C#- oder Visual Basic verwenden, finden Sie in der Dokumentation zum Compiler.  
  
-   Fügen Sie zum Debuggen in c# aktivieren die `/d:DEBUG` Flag, um die Befehlszeile des Compilers beim Kompilieren des Codes, oder Sie fügen `#define DEBUG` am Anfang der Datei. Fügen Sie in Visual Basic die `/d:DEBUG=True` Flag zur Befehlszeile Compilers.  
  
-   Fügen Sie zum Aktivieren der Ablaufverfolgung in c# die `/d:TRACE` Flag, um die Befehlszeile des Compilers beim Kompilieren des Codes hinzufügen oder `#define TRACE` am Anfang der Datei. Fügen Sie in Visual Basic die `/d:TRACE=True` Flag zur Befehlszeile Compilers.  
  
 Bearbeiten Sie die Konfigurationsdatei für Ihre Anwendung, zum Festlegen der Ebene des Listeners. In dieser Datei können Sie einen Listener hinzufügen, legen Sie deren Typ und legen Sie die Parameter, einen Listener zu entfernen oder deaktivieren Sie die Listener, die für die zuvor von der Anwendung festgelegt. Die Konfigurationsdatei sollte wie im folgenden Beispiel formatiert werden.  
  
 Für dieses Beispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
```xml  
<configuration>  
    <system.diagnostics>  
        <sharedListeners>  
            <add name="FileLog"  
                type="Microsoft.VisualBasic.Logging.FileLogTraceListener,   
                      Microsoft.VisualBasic, Version=8.0.0.0,   
                      Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a,   
                      processorArchitecture=MSIL"   
                initializeData="FileLogWriter"/>  
        </sharedListeners>  
    </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
    <related type="Article" href="https://msdn.microsoft.com/library/ecc74f95-743c-450d-93f6-09a30db0fe4a">Exemplarische Vorgehensweise: Ändern des Ortes, in den "My.Application.Log" Informationen schreibt</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />-Klasse und legt den Namen fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileLogTraceListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileLogTraceListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />-Klasse mit dem Standardnamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt fest, der den Instanznamen der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse FileLogTraceListener fest.  
  
 Es stehen die Namen der Instanz über die <xref:System.Diagnostics.TraceListener.Name%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.Log" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileLogTraceListener (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileLogTraceListener(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.Logging.FileLogTraceListener : string -&gt; Microsoft.VisualBasic.Logging.FileLogTraceListener" Usage="new Microsoft.VisualBasic.Logging.FileLogTraceListener name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="String" />. Der Name des Instanzobjekts.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />-Klasse mit dem angegebenen Namen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt fest, der den Instanznamen der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> -Klasse `name`.  
  
 Sie können auf zugreifen, den Instanznamen der <xref:System.Diagnostics.TraceListener.Name%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.Log" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public bool Append { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Append" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append" />
      <MemberSignature Language="VB.NET" Value="Public Property Append As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Append { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Append : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Append" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob die Ausgabe an die aktuelle Datei angefügt oder in eine neue Datei geschrieben werden soll.</summary>
        <value>Ein <see langword="Boolean" />-Wert, wobei <see langword="True" /> angibt, dass die Ausgabe an die aktuelle Datei angefügt wird, wohingegen die Ausgabe bei <see langword="False" /> in eine neue Datei geschrieben wird. Die Standardeinstellung für diese Eigenschaft ist <see langword="True" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append%2A> Eigenschaft `False`, wird die Ausgabe in eine neue Datei geschrieben. Wenn die Eigenschaft ist `True`, die Ausgabe wird an die aktuelle Datei angefügt, es sei denn:  
  
-   Die Ausgabedatei ist von einem anderen Prozess gesperrt. In diesem Fall wird eine neue Protokolldatei erstellt, mit einer Versionsnummer, die in eingebunden ist die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Name.  
  
-   Die aktuelle Größe ist größer als die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A> Eigenschaft ermöglicht. In diesem Fall werden zusätzliche Nachrichten verworfen, und, je nach den <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> -Eigenschaft, die eine Ausnahme ausgelöst wird.  
  
-   Der Name der vorhandenen gemäß dem vom angegebenen Protokoll-Creation-Zeitplan nicht mehr aktuell ist die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> Eigenschaft. In diesem Fall wird eine neue Protokolldatei erstellt, und der Datumsstempel in den <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Name.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob beim Schreiben in den Protokolldateistream der Puffer entleert wird.</summary>
        <value>Ein <see langword="Boolean" />-Wert, wobei <see langword="True" /> angibt, dass der Stream nach jedem Schreibvorgang entleert wird. Andernfalls werden die Protokolleinträge im Puffer gespeichert und können effizienter geschrieben werden. Die Standardeinstellung für diese Eigenschaft ist <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `False` Einstellung für die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush%2A> Eigenschaft bietet die beste Leistung für die meisten Anwendungen aus, da es sehr viel effizienter, mehrere Nachrichten gleichzeitig in die Protokolldatei zu schreiben ist. Sie können die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> Methode zum Leeren der Nachrichten, die derzeit in der Protokolldatei den Ausgabepuffer. Sie können auch die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> -Methode, die implizit den Stream, entleert vor dem Schließen der Protokolldatei.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
      </Docs>
    </Member>
    <Member MemberName="BaseFileName">
      <MemberSignature Language="C#" Value="public string BaseFileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseFileName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseFileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseFileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BaseFileName : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basisnamen für die Protokolldateien ab, der zum Erstellen des vollständigen Protokolldateinamens verwendet wird, oder legt diesen fest.</summary>
        <value><see langword="String" />. Der Basisname für die Protokolldateien. Der Standardwert ist der Produktname der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> Eigenschaft bestimmt den Basisnamen für die Protokolldateien, die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse schreibt in.  
  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Eigenschaft gibt den Namen der aktuellen vollständigen Protokolldatei. Es wird gemäß den Protokollpfad der Basisname, das Datum und eine Zahl zur Unterscheidung von anderen Versionen des Protokolls generiert. Neue Protokolldateien werden auf einen Bedarf erstellt.  
  
 Ist die explizite Form der Name der vollständigen Protokolldatei `path` \\ `baseName`[-`dateStamp`] [-`iteration`] .log, wobei  
  
-   Die `path` Teil richtet sich nach der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> Eigenschaft und, wenn dieser Eigenschaftswert, um festgelegt ist <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>, <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> Eigenschaft.  
  
-   Die `baseName` Teil ist der grundlegende Protokollname, gemäß der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> Eigenschaft.  
  
-   Die `dateStamp` Teil weist das Format "JJJJ-MM-DD", und wird angezeigt, wenn <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> nastaven NA hodnotu <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> oder <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
-   Wenn mehr als eine Protokolldatei, mit dem gleichen erforderlich ist `baseName` und `dateStamp`, wird die `iteration` Webpart, ein positiver `Integer`, an den Dateinamen hinzugefügt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
        <altmember cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileLogTraceListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den der aktuellen Protokolldatei zugrunde liegenden Stream und gibt alle Ressourcen frei, die dem aktuellen Stream zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen nicht aufrufen, die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> Methode explizit, da die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse verwaltet den zugrunde liegenden Datenstrom.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomLocation">
      <MemberSignature Language="C#" Value="public string CustomLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CustomLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CustomLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CustomLocation : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Verzeichnis der Protokolldateien ab oder legt dieses fest, wenn die <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />-Eigenschaft auf <see cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" /> festgelegt ist.</summary>
        <value>Ein <see langword="String" />, der den Namen des Protokolldateiverzeichnisses angibt. Die Standardeinstellung für diese Eigenschaft ist das Anwendungsdatenverzeichnis des Benutzers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> -Eigenschaft festgelegt ist, wird auch die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> Eigenschaft <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>.  
  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> Eigenschaft wird eine Ausnahme ausgelöst, wenn das Verzeichnis nicht aufgelöst werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public string Delimiter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Delimiter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Delimiter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiter : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Trennzeichen ab, das zum Begrenzen der Felder in einer Protokollmeldung verwendet wird, oder legt dieses fest.</summary>
        <value>Ein <see langword="String" />, der das für die Felder in einer Protokollmeldung verwendete Trennzeichen ist. Die Standardeinstellung für diese Eigenschaft ist das Tabstoppzeichen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft können Sie das Standardtrennzeichen zu ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiskSpaceExhaustedBehavior">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property DiskSpaceExhaustedBehavior As DiskSpaceExhaustedOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior { Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption get(); void set(Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption value); };" />
      <MemberSignature Language="F#" Value="member this.DiskSpaceExhaustedBehavior : Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt die Vorgehensweise, wenn beim Schreiben in die Protokolldatei weniger freier Speicherplatz vorhanden ist, als die <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />-Eigenschaft angibt.</summary>
        <value><see cref="T:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption" />. Bestimmt die Vorgehensweise, wenn beim Schreiben in die Protokolldatei weniger freier Speicherplatz vorhanden ist, als die <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />-Eigenschaft angibt, oder wenn die Größe der Protokolldatei den höchstzulässigen Wert der <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />-Eigenschaft überschreitet. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.DiscardMessages" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> -Eigenschaftensatz auf <xref:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.DiscardMessages>, die protokollmeldungen werden automatisch verworfen, wenn nicht genügend reservierten Speicherplatz vorhanden ist. Dies ist das Standardverhalten, und es verhindert, dass einfache Anwendungen fehlschlagen, wenn der Datenträger zu voll wird.  
  
 Stabilere Anwendungen können festlegen, die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> Eigenschaft <xref:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.ThrowException>, und fügen `Try...Catch` -Blöcke bei Code, der in das Protokoll schreibt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileLogTraceListener.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Bei <see langword="True" /> werden sowohl verwaltete als auch nicht verwaltete Ressourcen, bei <see langword="False" /> nur nicht verwaltete Ressourcen freigegeben.</param>
        <summary>Schließt den zugrunde liegenden Stream und gibt optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `disposing`-Parameter `True` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden.  
  
Diese Methode ruft die <see langword="Dispose" /> -Methode der Basisklasse <see langword="Dispose" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Codierung ab, die beim Erstellen einer neuen Protokolldatei verwendet werden soll, oder legt diese fest.</summary>
        <value><see cref="T:System.Text.Encoding" />, die Codierung, die beim Erstellen einer neuen Protokolldatei verwendet werden soll. Der Standardwert dieser Eigenschaft ist <see cref="T:System.Text.UTF8Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Text in einer vorhandenen Protokolldatei angefügt wird, die Codierung für diese Datei verwendet, anstatt die Codierung gemäß der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.Text.UTF8Encoding" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileLogTraceListener.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entleert den zugrunde liegenden Stream, der in die aktuelle Protokolldatei schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> Methode, um alle gepufferten Daten in der aktuellen Protokolldatei zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullLogFileName">
      <MemberSignature Language="C#" Value="public string FullLogFileName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullLogFileName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullLogFileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullLogFileName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullLogFileName : string" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Namen der aktuellen Protokolldatei ab.</summary>
        <value>Ein <see langword="String" />, der vollständige Name der aktuellen Protokolldatei.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> Eigenschaft gibt den Namen der aktuellen vollständigen Protokolldatei. Es wird gemäß den Protokollpfad der Basisname, das Datum und eine Zahl zur Unterscheidung von anderen Versionen des Protokolls generiert. Neue Protokolldateien werden auf einen Bedarf erstellt.  
  
 Ist die explizite Form der vollständigen Protokolldateinamens `path` \\ `baseName`[-`dateStamp`] [-`iteration`] log, in denen:  
  
-   Die `path` Teil richtet sich nach der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> Eigenschaft und, wenn dieser Eigenschaftswert, um festgelegt ist <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>, <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> Eigenschaft.  
  
-   Die `baseName` Teil ist der grundlegende Protokollname, gemäß der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> Eigenschaft.  
  
-   Die `dateStamp` Teil weist das Format JJJJ-MM-TT und wird angezeigt, wenn <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> ist <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> oder <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
-   Wenn mehr als eine Protokolldatei, mit dem gleichen erforderlich ist `baseName` und `dateStamp`, wird die `iteration` Webpart, ein positiver `Integer`, an den Dateinamen hinzugefügt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
        <altmember cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="GetSupportedAttributes">
      <MemberSignature Language="C#" Value="protected override string[] GetSupportedAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string[] GetSupportedAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.GetSupportedAttributes" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetSupportedAttributes () As String()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::String ^&gt; ^ GetSupportedAttributes();" />
      <MemberSignature Language="F#" Value="override this.GetSupportedAttributes : unit -&gt; string[]" Usage="fileLogTraceListener.GetSupportedAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die vom Ablaufverfolgungslistener unterstützten benutzerdefinierten XML-Konfigurationsattribute ab.</summary>
        <returns>Ein <see langword="String" />-Array, das die von diesem Listener erkannten XML-Konfigurationsattribute enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die benutzerdefinierten Attribute für die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> kann verwendet werden, in der XML-Konfigurationsdatei zum Steuern des Verhaltens einer Instanz von der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> Klasse. Andere Attribute verwenden, wird eine Konfigurationsausnahme.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.TraceSource.GetSupportedAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IncludeHostName">
      <MemberSignature Language="C#" Value="public bool IncludeHostName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeHostName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeHostName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeHostName { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeHostName : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Hostname des protokollierenden Computers in die Ausgabe aufgenommen werden soll.</summary>
        <value><see langword="Boolean" />. Verwenden Sie <see langword="True" />, um den Hostbezeichner aufzunehmen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die Eigenschaft so konfigurieren Sie das Verhalten der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> und <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.LogFileLocation Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.LogFileLocation Location" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As LogFileLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::LogFileLocation Location { Microsoft::VisualBasic::Logging::LogFileLocation get(); void set(Microsoft::VisualBasic::Logging::LogFileLocation value); };" />
      <MemberSignature Language="F#" Value="member this.Location : Microsoft.VisualBasic.Logging.LogFileLocation with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.LogFileLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Speicherort für die Protokolldateien ab, oder legt diesen fest.</summary>
        <value><see cref="T:Microsoft.VisualBasic.Logging.LogFileLocation" />, gibt den Speicherort für die Protokolldatei an. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.LocalUserApplicationDirectory" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> -Eigenschaft zum Festlegen des protokollpfads auf eine der vordefinierten Pfade bestimmt, indem die <xref:Microsoft.VisualBasic.Logging.LogFileLocation> -Enumerationswerte fest.  
  
|**Location-Wert**|**Pfad**|  
|------------------------|--------------|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.CommonApplicationDirectory>|Der Pfad für die Anwendungsdaten, die von allen Benutzern, mit dem Format verwendet wird:<br /><br /> `BasePath`\\`CompanyName`\\`ProductName`\\`ProductVersion`<br /><br /> Ein typischer Wert für `BasePath` ist:<br /><br /> C:\Documents and Settings\All Users\Application Daten<br /><br /> Die Werte der `CompanyName`, `ProductName`, und `ProductVersion` stammen aus der Assembly.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.ExecutableDirectory>|Der Pfad für die ausführbare Datei, die die Anwendung gestartet hat.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.LocalUserApplicationDirectory>|Der Pfad für die Anwendungsdaten eines Benutzers, mit dem Format:<br /><br /> `BasePath`\\`CompanyName`\\`ProductName`\\`ProductVersion`<br /><br /> Ein typischer Wert für `BasePath` ist:<br /><br /> C:\Dokumente und Einstellungen\\`username`\Anwendungsdaten<br /><br /> Die Werte der `CompanyName`, `ProductName`, und `ProductVersion` stammen aus der Assembly.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.TempDirectory>|Der Pfad des temporären Ordners des aktuellen Systems.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>|Wenn die Zeichenfolge angegebenen <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> ist nicht leer ist, und klicken Sie dann das als Pfad verwenden; verwenden Sie andernfalls den Pfad für die Anwendungsdaten eines Benutzers.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.LogFileLocation" />
      </Docs>
    </Member>
    <Member MemberName="LogFileCreationSchedule">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption LogFileCreationSchedule { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption LogFileCreationSchedule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      <MemberSignature Language="VB.NET" Value="Public Property LogFileCreationSchedule As LogFileCreationScheduleOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption LogFileCreationSchedule { Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption get(); void set(Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption value); };" />
      <MemberSignature Language="F#" Value="member this.LogFileCreationSchedule : Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt das Datum, das in die Namen der Protokolldateien eingefügt werden soll.</summary>
        <value><see cref="T:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption" />. Dies gibt das Datum an, das in die Namen der Protokolldateien eingefügt werden soll. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.None" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zuweisen eines der <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption> -Enumerationswerte fest, um die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> Eigenschaft, um das Datum, die in den Namen der Protokolldateien enthalten anzugeben.  
  
 Das Format des Datums ist JJJJ-MM-TT. Weitere Informationen zum Format der Namen der Protokolldatei, finden Sie unter <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
|**LogFileCreationSchedule-Wert**|**Das Datum in der Name der Protokolldatei**|  
|---------------------------------------|-----------------------------------|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily>|Schließt das aktuelle Datum in den Namen der Protokolldatei ein.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.None>|Schließt kein Datum in den Namen der Protokolldatei ein.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>|Schließt den ersten Tag der laufenden Woche in den Namen der Protokolldatei ein.<br /><br /> Die Woche beginnt am Samstag.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      </Docs>
    </Member>
    <Member MemberName="MaxFileSize">
      <MemberSignature Language="C#" Value="public long MaxFileSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxFileSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxFileSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxFileSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxFileSize : int64 with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die höchstzulässige Größe der Protokolldatei (in Bytes) ab oder legt diese fest.</summary>
        <value><see langword="Long" />. Dies ist die höchstzulässige Protokolldateigröße, in Bytes. Der Standardwert ist 5000000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um sicherzustellen, dass die Protokolldateien nicht zu groß ist.  
  
 Wenn die Größe (in Byte) Protokolldatei ist größer als der Wert dieser Eigenschaft, wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> -Klasse versucht, einer Nachricht in das Protokoll zu schreiben, die Nachricht verworfen und der Fehler ist entweder automatische oder eine Ausnahme wird ausgelöst, abhängig vom Wert der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A>Eigenschaft. Andernfalls ist die Nachricht in das Protokoll geschrieben, wenn die Menge des freien Speicherplatzes (in Bytes) ist kleiner als <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt ein, wenn die Eigenschaft wird auf einen Wert unter 1000 festgelegt wird.</exception>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      </Docs>
    </Member>
    <Member MemberName="ReserveDiskSpace">
      <MemberSignature Language="C#" Value="public long ReserveDiskSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReserveDiskSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ReserveDiskSpace As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReserveDiskSpace { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ReserveDiskSpace : int64 with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den freien Speicherplatz in Bytes ab, der benötigt wird, um Meldungen in die Protokolldatei zu schreiben, oder legt diesen fest.</summary>
        <value><see langword="Long" />. Dies ist die erforderliche Menge an freiem Speicherplatz. Der Standardwert ist 10000000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um sicherzustellen, dass die Protokolldateien den Datenträger nicht vollständig ausfüllt.  
  
 Wenn Speicherplatz, den Umfang des freien Speicherplatzes (in Byte) ist kleiner als der Wert dieser Eigenschaft, wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> -Klasse versucht, einer Nachricht in das Protokoll zu schreiben, die Nachricht verworfen und der Fehler ist entweder automatische oder eine Ausnahme wird ausgelöst, abhängig vom Wert der < C2 > <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A>  Eigenschaft. Andernfalls wird die Nachricht in das Protokoll, geschrieben, ist die Größe der Protokolldatei (in Bytes) größer als <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tritt ein, wenn die Eigenschaft wird auf einen Wert unter 0 festgelegt wird.</exception>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceData">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Ablaufverfolgungsdaten in die Ausgabedatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> Methoden sollen nicht von Anwendungscode aufgerufen werden. Diese Methoden werden aufgerufen, von einem Mitglied der <xref:System.Diagnostics.Debug>, <xref:System.Diagnostics.Trace>, und <xref:System.Diagnostics.TraceSource> Klassen zum Schreiben von auszugebenden Ablaufverfolgungsdaten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj -&gt; unit" Usage="fileLogTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" />-Objekt mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Name der Ablaufverfolgungsquelle, die diese Methode aufgerufen hat.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Enumerationswerte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="data">Die auszugebenden Ablaufverfolgungsdaten.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, ein Datenobjekt und Ereignisinformationen in die Ausgabedatei oder den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode:  
  
1.  Formatiert die Daten und Kontext Informationen für die Ausgabe an.  
  
2.  Eine neue Protokolldatei erstellt, bei Bedarf.  
  
3.  Schreibt die Informationen in die Protokolldatei an.  
  
 Weitere Informationen zum Erstellen neuer Protokolldateien finden Sie unter <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Die folgende Tabelle listet die Ausgabe-Felder in der Reihenfolge, in die sie angezeigt werden. Die Felder werden getrennt von der Zeichenfolge, die die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft gibt an, und gefolgt von einem Zeilenabschluss.  
  
|**Feld**|**Ausgabe-Bedingung**|**Beschreibung**|  
|---------------|--------------------------|---------------------|  
|`source`|Immer|Der Wert von `name`.|  
|`severity`|Immer|Der Name der Enumeration-Wert des `eventType`.|  
|`id`|Immer|Eine Zeichenfolgendarstellung von `id`.|  
|`message`|Immer|Eine Zeichenfolgendarstellung von `data`.|  
|`callStack`|Wenn die <xref:System.Diagnostics.TraceOptions.Callstack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.Callstack%2A> Eigenschaft `eventCache`.|  
|`CorrelationID`|Wenn die <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`DateTime`|Wenn die <xref:System.Diagnostics.TraceOptions.DateTime> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.DateTime%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ProcessID`|Wenn die <xref:System.Diagnostics.TraceOptions.ProcessId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ThreadID`|Wenn die <xref:System.Diagnostics.TraceOptions.ThreadId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`Timestamp`|Wenn die <xref:System.Diagnostics.TraceOptions.Timestamp> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`HostName`|Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> Eigenschaft `True`.|Der Name des Computers.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, params object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, ParamArray data As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, ... cli::array &lt;System::Object ^&gt; ^ data);" />
      <MemberSignature Language="F#" Value="override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj[] -&gt; unit" Usage="fileLogTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" />-Objekt mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Name der Ablaufverfolgungsquelle, die diese Methode aufgerufen hat.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Enumerationswerte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="data">Ein Objektarray, das in Form von Daten ausgegeben werden soll.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, ein Array von Datenobjekten und Ereignisinformationen in die Ausgabedatei oder den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode:  
  
1.  Formatiert die Daten und Kontext Informationen für die Ausgabe an,  
  
2.  Eine neue Protokolldatei erstellt, bei Bedarf,  
  
3.  Schreibt die Informationen in die Protokolldatei an.  
  
 Weitere Informationen zum Erstellen neuer Protokolldateien finden Sie unter <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Diese Tabelle listet die Ausgabe-Felder in der Reihenfolge, in die sie angezeigt werden. Die Felder werden getrennt von der Zeichenfolge, die die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft gibt an, und gefolgt von einem Zeilenabschluss.  
  
|**Feld**|**Ausgabe-Bedingung**|**Beschreibung**|  
|---------------|--------------------------|---------------------|  
|`source`|Immer|Der Wert von `name`.|  
|`severity`|Immer|Der Name der Enumeration-Wert des `eventType`.|  
|`id`|Immer|Eine Zeichenfolgendarstellung von `id`.|  
|`message`|Immer|Die Zeichenfolge, die mit der Zeichenfolgendarstellung der einzelnen Elemente im `data`, jeweils getrennt durch <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A>.|  
|`callStack`|Wenn die <xref:System.Diagnostics.TraceOptions.Callstack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.Callstack%2A> Eigenschaft `eventCache`.|  
|`CorrelationID`|Wenn die <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`DateTime`|Wenn die <xref:System.Diagnostics.TraceOptions.DateTime> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.DateTime%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ProcessID`|Wenn die <xref:System.Diagnostics.TraceOptions.ProcessId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ThreadID`|Wenn die <xref:System.Diagnostics.TraceOptions.ThreadId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`Timestamp`|Wenn die <xref:System.Diagnostics.TraceOptions.Timestamp> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`HostName`|Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> Eigenschaft `True`.|Der Name des Computers.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceEvent">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Ablaufverfolgungs- und Ereignisdaten in die Ausgabedatei oder den Ausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> Methoden sollen nicht von Anwendungscode aufgerufen werden. Diese Methoden werden aufgerufen, von einem Mitglied der <xref:System.Diagnostics.Debug>, <xref:System.Diagnostics.Trace>, und <xref:System.Diagnostics.TraceSource> Klassen zum Schreiben von auszugebenden Ablaufverfolgungsdaten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string -&gt; unit" Usage="fileLogTraceListener.TraceEvent (eventCache, source, eventType, id, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" />-Objekt mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Name der Ablaufverfolgungsquelle, die diese Methode aufgerufen hat.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Enumerationswerte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="message">Eine zu schreibende Meldung.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, eine Meldung und Ereignisinformationen in die Ausgabedatei oder den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode:  
  
1.  Formatiert die Daten und Kontext Informationen für die Ausgabe an.  
  
2.  Eine neue Protokolldatei erstellt, bei Bedarf.  
  
3.  Schreibt die Informationen in die Protokolldatei an.  
  
 Weitere Informationen zum Erstellen neuer Protokolldateien finden Sie unter <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Diese Tabelle listet die Ausgabe-Felder in der Reihenfolge, in der sie angezeigt werden. Die Felder werden getrennt von der Zeichenfolge, die die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft gibt an, und gefolgt von einem Zeilenabschluss.  
  
|**Feld**|**Ausgabe-Bedingung**|**Beschreibung**|  
|---------------|--------------------------|---------------------|  
|`source`|Immer|Der Wert von `name`.|  
|`severity`|Immer|Der Name der Enumeration-Wert des `eventType`.|  
|`id`|Immer|Eine Zeichenfolgendarstellung von `id`.|  
|`message`|Immer|Der Wert von `message`.|  
|`callStack`|Wenn die <xref:System.Diagnostics.TraceOptions.Callstack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.Callstack%2A> Eigenschaft `eventCache`.|  
|`CorrelationID`|Wenn die <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`DateTime`|Wenn die <xref:System.Diagnostics.TraceOptions.DateTime> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.DateTime%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ProcessID`|Wenn die <xref:System.Diagnostics.TraceOptions.ProcessId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ThreadID`|Wenn die <xref:System.Diagnostics.TraceOptions.ThreadId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`Timestamp`|Wenn die <xref:System.Diagnostics.TraceOptions.Timestamp> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`HostName`|Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> Eigenschaft `True`.|Der Name des Computers.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string * obj[] -&gt; unit" Usage="fileLogTraceListener.TraceEvent (eventCache, source, eventType, id, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" />-Objekt mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Name der Ablaufverfolgungsquelle, die diese Methode aufgerufen hat.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Enumerationswerte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="format">Eine Formatzeichenfolge mit 0 oder mehr Formatelementen, die Objekten im <paramref name="args" />-Array entsprechen.</param>
        <param name="args">Ein <see langword="Object" />-Array mit 0 oder mehr zu formatierenden Objekten.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, ein formatiertes Array von Objekten und Ereignisinformationen in die Ausgabedatei oder den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode:  
  
1.  Formatiert die Daten und Kontext Informationen für die Ausgabe an.  
  
2.  Erstellt ein neues eine neue Protokolldatei, bei Bedarf.  
  
3.  Schreibt die Informationen in die Protokolldatei an.  
  
 Weitere Informationen zum Erstellen von neuen Protokolldatei finden Sie unter <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Diese Tabelle listet die Ausgabe-Felder in der Reihenfolge, in der sie angezeigt werden. Die Felder werden getrennt von der Zeichenfolge, die die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> Eigenschaft gibt an, und gefolgt von einem Zeilenabschluss.  
  
|**Feld**|**Ausgabe-Bedingung**|**Beschreibung**|  
|---------------|--------------------------|---------------------|  
|`source`|Immer|Der Wert von `name`.|  
|`severity`|Immer|Der Name der Enumeration-Wert des `eventType`.|  
|`id`|Immer|Eine Zeichenfolgendarstellung von `id`.|  
|`message`|Immer|Die Daten in `args` mit formatiert die `format` Zeichenfolge und mit der invarianten Kultur für zeichenfolgenkonvertierungen.|  
|`callStack`|Wenn die <xref:System.Diagnostics.TraceOptions.Callstack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.Callstack%2A> Eigenschaft `eventCache`.|  
|`CorrelationID`|Wenn die <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`DateTime`|Wenn die <xref:System.Diagnostics.TraceOptions.DateTime> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.DateTime%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ProcessID`|Wenn die <xref:System.Diagnostics.TraceOptions.ProcessId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`ThreadID`|Wenn die <xref:System.Diagnostics.TraceOptions.ThreadId> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> Eigenschaft `eventCache`.|  
|`Timestamp`|Wenn die <xref:System.Diagnostics.TraceOptions.Timestamp> Flag wird festgelegt, der <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> Eigenschaft.|Die Zeichenfolgendarstellung der <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> Eigenschaft `eventCache`. Die invariante Kultur wird für die zeichenfolgenkonvertierung verwendet.|  
|`HostName`|Wenn die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> Eigenschaft `True`.|Der Name des Computers.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.Write : string -&gt; unit" Usage="fileLogTraceListener.Write message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><see langword="String" />. Die benutzerdefinierte Meldung, die geschrieben werden soll.</param>
        <summary>Schreibt eine wörtliche Meldung ohne weitere Kontextinformationen auf den Datenträger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Write%2A> -Methode schreibt eine bestimmte Nachricht in die Protokolldatei, ohne zusätzliche Kontextinformationen.  
  
 Verwenden Sie eine der der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> Methoden, die Kontextinformationen in die Protokollausgabe aufgenommen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.WriteLine : string -&gt; unit" Usage="fileLogTraceListener.WriteLine message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><see langword="String" />. Die benutzerdefinierte Meldung, die geschrieben werden soll.</param>
        <summary>Schreibt eine wörtliche Meldung ohne weitere Kontextinformationen, gefolgt vom aktuellen Zeilenabschlusszeichen, in die Datei</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.WriteLine%2A> -Methode schreibt eine bestimmte Nachricht in die Protokolldatei, ohne zusätzliche Kontextinformationen.  
  
 Verwenden Sie eine der der <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> Methoden, die Kontextinformationen in die Protokollausgabe aufgenommen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>