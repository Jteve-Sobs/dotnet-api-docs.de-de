<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9b2639e239210ebe728a40503f974e5c84411b76" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52740622" /></Metadata><TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den auf einem Oracle-Server gespeicherten Datentyp <see langword="LOB" /> (Large Object Binary) dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.OracleClient.OracleLob> unterscheidet sich von einem <xref:System.Data.OracleClient.OracleBFile> , da die Daten auf dem Server statt in einer physischen Datei im Betriebssystem gespeichert ist. Es kann ein Objekt mit Lese-/ Schreibzugriff, auch sein, im Gegensatz zu einer <xref:System.Data.OracleClient.OracleBFile>, die immer schreibgeschützt ist.  
  
 Ein <xref:System.Data.OracleClient.OracleLob> möglicherweise eines der folgenden <xref:System.Data.OracleClient.OracleType> -Datentypen.  
  
|OracleType-Datentyp|Beschreibung |  
|--------------------------|-----------------|  
|`Blob`|Ein Oracle `BLOB` -Datentyp, der Binärdaten mit einer maximalen Größe von 4 Gigabyte (GB) enthält. Wird einem <xref:System.Array> vom Typ <xref:System.Byte> zugeordnet.|  
|`Clob`|Ein Oracle `CLOB` -Datentyp, der basierend auf dem Standardzeichensatz enthält, die auf dem Server, mit einer maximalen Größe von 4 GB festgelegt. Wird <xref:System.String> zugeordnet.|  
|`NClob`|Ein Oracle `NCLOB` -Datentyp, der Zeichendaten enthält auf Grundlage des nationalen Zeichensatzes auf dem Server mit einer maximalen Größe von 4 GB. Wird <xref:System.String> zugeordnet.|  
  
 Ein .NET Entwickler von Anwendungen kann die Oracle abrufen `LOB` Werte in grundlegende .NET Datentypen, z. B. <xref:System.Array> des Typs <xref:System.Byte> und <xref:System.String>, oder die spezielle <xref:System.Data.OracleClient.OracleLob> -Datentyp. Die <xref:System.Data.OracleClient.OracleLob> Klasse unterstützt das Lesen von Daten aus und Schreiben in Oracle `LOB` in der Oracle-Datenbank.  
  
 Im folgenden sind die wesentlichen Merkmale von einer <xref:System.Data.OracleClient.OracleLob> -Datentyp, der sie von .NET Grunddatentypen zu unterscheiden:  
  
-   Nach dem Abrufen von Oracle `LOB` Wert aus der Oracle-Datenbank in der <xref:System.Data.OracleClient.OracleLob> -Klasse, die Sie ändern die `LOB` Daten in einer geöffneten Transaktion und die Änderungen werden direkt in der Datenbank wiedergegeben. Wenn Sie Oracle abrufen `LOB` -Wert in ein <xref:System.Array> vom Typ <xref:System.Byte> oder <xref:System.String> und aktualisieren Sie diese Arrays, die Änderungen werden nicht in der Datenbank wiedergegeben.  
  
-   Bei Verwendung der <xref:System.Data.OracleClient.OracleLob> Klasse, um eine Gruppe von Zugriff auf eine `LOB` Wert nur dieses Blocks ist von der Oracle-Datenbank an den Client übergeben. Bei Verwendung der <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> Methode, um eine Gruppe von einem `LOB` Wert, der gesamte Inhalt des Werts aus der Oracle-Datenbank übergeben werden, an den Client.  
  
 Zum Abrufen einer <xref:System.Data.OracleClient.OracleLob> Objekt, rufen Sie die <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> Methode.  
  
 Kann ein <xref:System.Data.OracleClient.OracleLob> ist NULL, die mit diesem Format:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Diese Technik dient in erster Linie zum Testen, ob eine `LOB` vom Server zurückgegebenen NULL ist, wie dieses Beispiel veranschaulicht:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Ein NULL-Wert `LOB` verhält sich ähnlich wie eine 0 (null) Bytes bestehende `LOB` , <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist, und gibt immer 0 (null) Bytes zurück.  
  
 Auswählen einer `LOB` Spalte einen null-Wert mit gibt <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 Sie müssen eine Transaktion vor dem Abrufen eines temporäres beginnen `LOB`. Andernfalls die <xref:System.Data.OracleClient.OracleDataReader> möglicherweise Daten später abzurufen.  
  
 Sie können auch eine temporäre öffnen `LOB` in Oracle, indem Sie die DBMS_LOB. CREATETEMPORARY aufrufen Verfahren und die Bindung einer `LOB` output-Parameter. Auf der Clientseite, einen temporären `LOB` verhält sich wie eine Tabelle-basierte `LOB`. Um beispielsweise den temporären aktualisieren `LOB`, es muss in einer Transaktion eingeschlossen werden.  
  
 Im folgende C#-Beispiel wird veranschaulicht, wie Sie zum Öffnen eines temporäres `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Die geerbte <xref:System.IO.Stream.WriteByte%2A> Methode schlägt fehl, wenn mit Zeichendaten verwendet und ein <xref:System.InvalidOperationException> ausgelöst. Verwenden Sie stattdessen die <xref:System.Data.OracleClient.OracleLob.Write%2A>-Methode.  
>   
>  Temporäre `LOB`s werden nur geschlossen, wenn die Verbindung geschlossen wird, aber mit pooling und ausgelastet, temporäre `LOB`s jedoch nicht geschlossen. Dies kann aufgelöst werden, indem Sie verwerfen die temporäre `LOB`, durch den Aufruf `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">Das <see langword="LOB" />, aus dem Daten angefügt werden sollen.</param>
        <summary>Fügt Daten aus dem angegebenen <see langword="LOB" /> am aktuellen <see langword="LOB" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
 Alle Daten aus der Quelle `LOB` wird am Ende des aktuellen angefügt `LOB`. Die Position des weder `LOB` ausgewertet oder geändert werden, während dieses Vorgangs.  
  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Angenommen, Sie aus einem Anfügen einer <xref:System.Data.OracleClient.OracleType.NClob>, das Ziel <xref:System.Data.OracleClient.OracleLob> zudem muss eine <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" /> ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" />-Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verhindert, dass beim Ausführen mehrerer Schreibvorgänge serverseitige Trigger ausgelöst werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verhindert, dass beim Ausführen mehrerer Lesevorgänge serverseitige Trigger ausgelöst werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Öffnet die `LOB` in <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> Modus; aus diesem Grund die `LOB` können nur gelesen werden, nicht geschrieben, bis die entsprechenden Aufruf von <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Zum Ausführen von Batch-Schreibvorgänge auf den `LOB`, rufen Sie <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mit <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 Aufrufen von <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mehr als einmal in der gleichen Transaktion derzeit löst die Oracle "ORA-22293: LOB, die in der gleichen Transaktion bereits geöffnet" Fehler. Darüber hinaus, wenn Sie erhalten die `LOB` unter Verwendung eines anderen <xref:System.Data.OracleClient.OracleDataReader>, und der ursprüngliche Aufrufer nicht aufgerufen der <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> -Methode, den gleichen Fehler wird generiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> Methode, wenn Sie fertig sind mit den <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Der Modus (einer der <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />-Werte), in dem zwischen diesem <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />-Aufruf und dem entsprechenden <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" />-Aufruf auf das <see langword="LOB" /> zugegriffen werden kann.</param>
        <summary>Verhindert, dass serverseitige Trigger ausgelöst werden, während im angegebenen Zugriffsmodus mehrere Lese- und Schreibvorgänge ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
 Aufrufen von <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mehr als einmal in der gleichen Transaktion derzeit löst die Oracle "ORA-22293: LOB, die in der gleichen Transaktion bereits geöffnet" Fehler. Darüber hinaus, wenn Sie erhalten die `LOB` unter Verwendung eines anderen <xref:System.Data.OracleClient.OracleDataReader>, und der ursprüngliche Aufrufer nicht aufgerufen der <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> -Methode, den gleichen Fehler wird generiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> Methode, wenn Sie fertig sind mit den <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="LOB" />-Stream gelesen werden kann.</summary>
        <value><see langword="true" />, wenn der <see langword="LOB" />-Stream Lesevorgänge unterstützt, andernfalls <see langword="false" />, wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Suchvorgänge vorwärts und rückwärts ausgeführt werden können.</summary>
        <value><see langword="false" /> wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist, andernfalls <see langword="true" />. Für <see cref="F:System.Data.OracleClient.OracleLob.Null" /> immer <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt immer True zurück, unabhängig davon, ob das <see langword="LOB" /> Schreibvorgänge unterstützt.</summary>
        <value>Gibt immer <see langword="true" /> zurück, unabhängig davon, ob ein geöffnetes oder nicht freigegebenes <see langword="LOB" /> Schreibvorgänge unterstützt. <see langword="false" />, wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie muss eine lokale Transaktion gestartet haben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Mindestanzahl von Bytes angibt, die während einer Lese-/Schreiboperation vom Server abgerufen oder an diesen gesendet werden soll.</summary>
        <value>Die Mindestanzahl abzurufender oder zu sendender Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von der <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> Eigenschaft ist nicht die Einstellung der .NET Framework-Datenanbieter für Oracle. Stattdessen wird der Wert, den der Oracle aufrufen-Schnittstelle (OCI) verwendet, bei der Kommunikation mit dem Server. Verwendung <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> um sicherzustellen, dass die clientseitige Segmente über die gleiche Größe aufweisen. Lesen oder Schreiben in kleinere Blöcke keine Daten zwischengespeichert, und führt einen weniger optimierten Roundtrip an den Server aus, da eine volle Paket nicht empfangen oder gesendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt, das auf dasselbe Oracle-<see langword="LOB" /> wie das ursprüngliche <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt verweist.</summary>
        <returns>Ein neues <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt, das auf dasselbe Oracle-<see langword="LOB" /> wie das ursprüngliche <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften der neuen <xref:System.Data.OracleClient.OracleLob> Objekt ursprünglich haben die gleichen Werte wie das ursprüngliche Objekt. Nach der <xref:System.Data.OracleClient.OracleLob.Clone%2A> abgeschlossen ist, jede <xref:System.Data.OracleClient.OracleLob> Objekt ist unabhängig von der anderen. Z. B. Ändern des Werts der <xref:System.Data.OracleClient.OracleLob.Position%2A> -Eigenschaft im ursprünglichen <xref:System.Data.OracleClient.OracleLob> ändert sich nicht auf den Wert der <xref:System.Data.OracleClient.OracleLob.Position%2A> auf die Kopie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="oracleLob.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den aktuellen Stream und gibt alle dem Stream zugeordneten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von dieser Instanz von <see cref="T:System.Data.OracleClient.OracleConnection" /> verwendete <see cref="T:System.Data.OracleClient.OracleLob" /> ab.</summary>
        <value>Die Verbindung mit einer Datenquelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">Der Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Kopiert aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Angenommen, Sie beim Kopieren aus einer <xref:System.Data.OracleClient.OracleType.NClob>, das Ziel <xref:System.Data.OracleClient.OracleLob> zudem muss eine <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Der Zieloffset liegt hinter dem Ende des Ziel- `LOB`, wird die `LOB` , in dem die Daten kopiert werden, ist erweitert. Der Abstand zwischen dem Ende der `LOB` und der Zieloffset, nach dem Ende wird mit Nullen aufgefüllt `BLOB` -Datentypen und Leerzeichen für `CLOB` und `NCLOB` -Datentypen.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, jedoch nicht aktualisiert werden die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` aktualisiert werden. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
>   
>  Die `CopyTo` Methode löscht den Inhalt des Ziels nicht `OracleLob` vor dem Ausführen des Kopiervorgangs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <paramref name="destination" />-Parameter angegebene <see cref="T:System.Data.OracleClient.OracleLob" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">Das Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <param name="destinationOffset">Der Offset, an den kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Anzahl von Bytes sein.</param>
        <summary>Kopiert die angegebene Datenmenge aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Angenommen, Sie beim Kopieren aus einer <xref:System.Data.OracleClient.OracleType.NClob>, das Ziel <xref:System.Data.OracleClient.OracleLob> zudem muss eine <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Der Zieloffset liegt hinter dem Ende des Ziel- `LOB`, wird die `LOB` , in dem die Daten kopiert werden, ist erweitert. Der Abstand zwischen dem Ende des `LOB` und Zieloffset hinter mit Nullen aufgefüllt `BLOB` -Datentypen und Leerzeichen für `CLOB` und `NCLOB` -Datentypen.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
>   
>  Die `CopyTo` Methode löscht den Inhalt des Ziels nicht `OracleLob` vor dem Ausführen des Kopiervorgangs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <paramref name="destination" />-Parameter angegebene <see cref="T:System.Data.OracleClient.OracleLob" /> ist voll.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="destinationOffset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
- oder -  
Ein im <paramref name="destinationOffset" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.  
  
- oder -  
Sie müssen <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen als gerade Anzahl von Bytes angeben.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">Der Offset, von dem kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="destination">Der Ziel-<see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">Der Zieloffset, an den kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="amount">Die zu kopierende Datenmenge in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Kopiert die angegebene Datenmenge vom angegebenen Quelloffset dieses <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Angenommen, Sie beim Kopieren aus einer <xref:System.Data.OracleClient.OracleType.NClob>, das Ziel <xref:System.Data.OracleClient.OracleLob> zudem muss eine <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Der Zieloffset liegt hinter dem Ende des Ziel- `LOB`, wird die `LOB` , in dem die Daten kopiert werden, ist erweitert. Der Abstand zwischen dem Ende des `LOB` und Zieloffset hinter mit Nullen aufgefüllt `BLOB` -Datentypen und Leerzeichen für `CLOB` und `NCLOB` -Datentypen.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
>   
>  Die `CopyTo` Methode löscht den Inhalt des Ziels nicht `OracleLob` vor dem Ausführen des Kopiervorgangs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <paramref name="destination" />-Parameter angegebene <see cref="T:System.Data.OracleClient.OracleLob" /> ist voll.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein in den Parametern <paramref name="amount" />, <paramref name="sourceOffset" /> oder <paramref name="destinationOffset" /> angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
- oder -  
Ein im <paramref name="amount" />-Parameter, im <paramref name="sourceOffset" />-Parameter oder im <paramref name="destinationOffset" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="oracleLob.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vom Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht, nach dem Ausführen mehrerer Schreibvorgänge serverseitige Trigger ausgelöst werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> Methode vor dem Beginn Ausführen von Schreibvorgängen auf den <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht Daten aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Daten aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der gelöschten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> Daten werden nicht abgeschnitten werden. Die `LOB` Länge bleibt unverändert für eine `BLOB` -Datentyp, und die gelöschten Daten durch 0 x 00 ersetzt werden. `CLOB` und `NCLOB` Datentypen durch Leerzeichen ersetzt werden.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Der Offset, ab dem gelöscht werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="amount">Die zu löschende Datenmenge in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Löscht die angegebene Datenmenge aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der gelöschten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Summe der Werte in der `offset` und `amount` Parameter können größer sein als die Größe des der <xref:System.Data.OracleClient.OracleLob>. Aus diesem Grund Angabe eines Werts, der größer als die von der zurückgegebene der <xref:System.Data.OracleClient.OracleLob.Length%2A> Eigenschaft erfolgreich ausgeführt wird, jedoch <xref:System.Data.OracleClient.OracleLob.Erase%2A> löscht nur bis zum Ende der <xref:System.Data.OracleClient.OracleLob>. (Auf ähnliche Weise verwendet werden, wenn ein negativer Wert, um übergeben wird `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> erfolgreich ausgeführt wird, aber nur gelöscht werden, beginnend ab dem Anfang der <xref:System.Data.OracleClient.OracleLob>.) Dieses Verhalten unterscheidet sich von der die <xref:System.Data.OracleClient.OracleLob.Read%2A> und <xref:System.Data.OracleClient.OracleLob.Write%2A> Methoden und bietet der Vorteil, dass Sie alle Daten aus dem Wert zu löschen, die durch angegebene `offset` ohne einen zusätzlichen Roundtrip an dem Server aus, um zu überprüfen, ob die tatsächliche Größe.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> Daten werden nicht abgeschnitten werden. Die `LOB` Länge bleibt unverändert für eine `BLOB` -Datentyp, und die gelöschten Daten durch 0 x 00 ersetzt werden. `CLOB` und `NCLOB` Datentypen durch Leerzeichen ersetzt werden.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  In dieser Version, die ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird derzeit nicht unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist in dieser Version nicht funktionsfähig.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Anwendung die <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />-Methode aufgerufen hat.</summary>
        <value><see langword="true" />, wenn eine Anwendung die <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />-Methode aufgerufen hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung eines Oracle 8.0.5-Servers, einer Oracle "ORA-00600: Interner Fehlercode:" wird ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Data.OracleClient.OracleLob" /> ein <see cref="F:System.Data.OracleClient.OracleBFile.Null" />-Stream ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Data.OracleClient.OracleLob" /> ein <see cref="F:System.Data.OracleClient.OracleBFile.Null" />-Stream ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Data.OracleClient.OracleLob" /> ein temporäres <see langword="LOB" /> ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Data.OracleClient.OracleLob" /> ein temporäres <see langword="LOB" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgende Beispiel veranschaulicht das Erstellen einen temporären `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des <see cref="T:System.Data.OracleClient.OracleLob" /> zurückgibt.</summary>
        <value>Die Größe des <see cref="T:System.Data.OracleClient.OracleLob" /> in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe der <xref:System.Data.OracleClient.OracleLob> wird immer in Bytes für alle Datentypen zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den <see langword="LOB" />-Datentyp zurückgibt.</summary>
        <value>Einer der <see cref="T:System.Data.OracleClient.OracleType" />-<see langword="LOB" />-Datentypen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.OracleClient.OracleLob> möglicherweise einen der folgenden <xref:System.Data.OracleClient.OracleType> -Datentypen.  
  
|OracleType-Datentyp|Beschreibung |  
|--------------------------|-----------------|  
|`Blob`|Ein Oracle-`BLOB`-Datentyp, der Binärdaten mit einer maximalen Größe von 4 Gigabyte enthält. Wird einem <xref:System.Array> vom Typ <xref:System.Byte> zugeordnet.|  
|`Clob`|Ein Oracle-`CLOB`-Datentyp für Zeichendaten, die auf dem Standardzeichensatz des Servers beruhen und eine maximale Größe von 4 Gigabyte haben können. Wird <xref:System.String> zugeordnet.|  
|`NClob`|Ein Oracle `NCLOB` -Datentyp, der Zeichendaten enthält auf Grundlage des nationalen Zeichensatzes auf dem Server mit einer maximalen Größe von 4 Gigabyte. Wird <xref:System.String> zugeordnet.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein NULL-<see cref="T:System.Data.OracleClient.OracleLob" />-Objekt dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann ein <xref:System.Data.OracleClient.OracleLob> ist NULL, die mit diesem Format:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Diese Technik dient in erster Linie zum Testen, ob eine `LOB` vom Server zurückgegebenen NULL ist, wie dieses Beispiel veranschaulicht:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Ein NULL-Wert `LOB` verhält sich ähnlich wie ein 0-Byte `LOB` , <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist, und gibt immer 0 (null) Bytes zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Leseposition im <see cref="T:System.Data.OracleClient.OracleLob" />-Stream ab.</summary>
        <value>Die aktuelle Position innerhalb des <see cref="T:System.Data.OracleClient.OracleLob" />-Streams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Stream muss zum Abrufen oder Festlegen der Position Suchvorgänge unterstützen. Verwenden der <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> Eigenschaft, um zu bestimmen, ob der Stream Suchvorgänge unterstützt.  
  
 An einem beliebigen Speicherort über die Länge des Streams hinaus Suchvorgänge werden unterstützt. Suchen auf eine ungerade Position für `CLOB` und `NCLOB` Datentypen wird ebenfalls unterstützt. Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Data.OracleClient.OracleLob.Read%2A> Eigenschaft.  
  
 Die <xref:System.Data.OracleClient.OracleLob.Position%2A> Eigenschaft ist nicht mitverfolgen die Anzahl von Bytes aus dem Stream, die verwendet wurden übersprungen, oder beides.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray. Nach dem Beenden dieser Methode enthält der Puffer das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" />), die durch aus der aktuellen Quelle gelesene Bytes ersetzt wurden.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="count">Die maximale Anzahl an Bytes, die aus dem aktuellen Stream gelesen werden sollen. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Liest eine Folge von Bytes aus dem aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und verschiebt die Position im Stream um die Anzahl der gelesen Bytes nach vorn.</summary>
        <returns>Die Gesamtanzahl der in den Puffer gelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.OracleClient.OracleLob.Read%2A> Methode liest maximal `count` Bytes aus dem aktuellen stream und speichert diese im `buffer` beginnend bei `offset`. Die aktuelle Position im Stream wird durch die Anzahl der gelesenen Bytes verschoben. Wenn eine Ausnahme auftritt, bleibt die aktuelle Position im Stream jedoch unverändert. <xref:System.Data.OracleClient.OracleLob.Read%2A> Gibt die Anzahl der gelesenen Bytes. Der Rückgabewert ist 0 (null) nur dann, wenn die aktuelle Position am Ende des Streams ist. <xref:System.Data.OracleClient.OracleLob.Read%2A> blockiert, bis mindestens ein Byte an Daten gelesen werden kann, die keine Daten verfügbar sind.<xref:System.Data.OracleClient.OracleLob.Read%2A> Gibt 0 zurück, wenn Sie versuchen, das Lesen aus einer `LOB` Wenn die aktuelle Position ist am Ende der `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> kann weniger Bytes als angefordert zurückgeben, selbst wenn Sie nicht das Ende des Streams erreicht wurde.  
  
 Die .NET Framework-Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten im Unicode-Format. Aus diesem Grund den Zugriff auf `CLOB` und `NCLOB` Datentypen immer umgegangen mit der Anzahl von Bytes, in dem jedes Zeichen 2 Bytes beträgt. Angenommen, eine Zeichenfolge mit drei Zeichen als gespeichert wird ein `NCLOB` auf einem Oracle-Server, in dem der Zeichensatz ist 4 Bytes pro Zeichen, und führen Sie, eine `Read` -Vorgang, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl es ist als 12 Bytes auf dem Server gespeichert.  
  
 Im folgende C#-Beispiel wird veranschaulicht, wie zum Lesen <xref:System.Data.OracleClient.OracleLob> Objekte.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 Kann ein <xref:System.Data.OracleClient.OracleLob> ist NULL, die mit diesem Format:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Diese Technik dient in erster Linie zum Testen, ob eine `LOB` vom Server zurückgegebene Wert NULL aufweist, wie im folgende Beispiel veranschaulicht.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Ein NULL-Wert `LOB` verhält sich ähnlich wie ein 0-Byte `LOB` , <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist, und gibt immer 0 (null) Bytes zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="offset" />-Parameter oder im <paramref name="count" />-Parameter angegebener Wert ist nicht positiv.  
  
- oder -  
Die Summe des offset-Parameters und des count-Parameters ist größer als die Pufferlänge.  
  
- oder -  
Ein im <paramref name="amount" />-Parameter oder im <paramref name="offset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein Byteoffset relativ zum Ursprung. Wenn <paramref name="offset" /> negativ ist, liegt die neue Position um die durch <paramref name="origin" /> angegebene Anzahl von Bytes vor der durch <paramref name="offset" /> angegebenen Position. Wenn <paramref name="offset" /> 0 (null) ist, ist die neue Position die durch <paramref name="origin" /> angegebene Position. Wenn <paramref name="offset" /> positiv ist, liegt die neue Position um die durch <paramref name="origin" /> angegebene Anzahl von Bytes hinter der durch <paramref name="offset" /> angegebenen Position.</param>
        <param name="origin">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</param>
        <summary>Legt die Position im aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream fest.</summary>
        <returns>Die neue Position innerhalb des aktuellen Streams.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `offset` ist negativ, die neue muss vor der Position der angegebenen Position `origin` durch die Anzahl der Bytes, die angegeben `offset`. Wenn `offset` ist 0 (null), die neue Position muss der angegebenen Position `origin`. Wenn `offset` positiv ist, wird die neue Position gelten die vom angegebenen Position `origin` durch die Anzahl der Bytes, die angegeben `offset`.  
  
 An einem beliebigen Speicherort über die Länge des Streams hinaus Suchvorgänge werden unterstützt. Suchen auf eine ungerade Position für `CLOB` und `NCLOB` Datentypen wird ebenfalls unterstützt. Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Data.OracleClient.OracleLob.Read%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="origin" />-Parameter enthält keinen gültigen Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die resultierende Position liegt hinter der Länge des Werts.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die gewünschte Länge des aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Streams in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Legt die Länge des <see cref="T:System.Data.OracleClient.OracleLob" />-Streams auf einen Wert fest, der kleiner als die aktuelle Länge ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erhöhen Sie die Länge des der <xref:System.Data.OracleClient.OracleLob> Datenstrom ein Fehler auftritt, und gibt "Meldung: ORA-22926: angegebene trim Länge ist größer als die aktuelle LOB-Werts" aus dem Oracle-Server.  
  
 Ein Stream muss unterstützen sowohl Schreib- und Lesevorgänge für <xref:System.Data.OracleClient.OracleLob.SetLength%2A> -Funktion.  
  
 Die .NET Framework-Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten im Unicode-Format. Aus diesem Grund den Zugriff auf `CLOB` und `NCLOB` Datentypen immer umgegangen mit der Anzahl von Bytes, in dem jedes Zeichen 2 Bytes beträgt. Angenommen, eine Zeichenfolge mit drei Zeichen als gespeichert wird ein `NCLOB` auf einem Oracle-Server, in dem der Zeichensatz ist 4 Bytes pro Zeichen, und führen Sie, eine `SetLength` -Vorgang, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl es ist als 12 Bytes auf dem Server gespeichert.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="value" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.  
  
- oder -  
Ein im <paramref name="value" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Streamwertentsprechung der Common Language Runtime für den zugrunde liegenden Wert ab.</summary>
        <value>Für <see cref="F:System.Data.OracleClient.OracleType.Blob" /> ein Array vom Typ <see langword="Byte[]" />. Für <see cref="F:System.Data.OracleClient.OracleType.Clob" /> und <see cref="F:System.Data.OracleClient.OracleType.NClob" /> ein <see langword="String" />. Für NULL-Daten <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für <xref:System.Data.OracleClient.OracleType.Blob> Datentypen <xref:System.Data.OracleClient.OracleLob.Value%2A> gibt die gesamten zugrunde liegenden Daten als Array vom Typ zusammenhängenden `Byte[]`. Für <xref:System.Data.OracleClient.OracleType.Clob> und <xref:System.Data.OracleClient.OracleType.NClob> Datentypen <xref:System.Data.OracleClient.OracleLob.Value%2A> gibt alle Daten als eine `String` -Datentyp. Für null-Daten <xref:System.Data.OracleClient.OracleLob.Value%2A> gibt <xref:System.DBNull>. Vergleichen Sie die zurückgegebenen Werte an, Sie unterscheiden zwischen leeren Daten, null-Daten und Daten.  
  
> [!NOTE]
>  Ein Vorteil der Verwendung von `LOB` Datentypen ist die Möglichkeit, große Mengen von Daten in Blöcke auf dem Client abzurufen. Wenn Sie jedoch verwenden, <xref:System.Data.OracleClient.OracleLob.Value%2A>, rufen Sie alle Daten für die `LOB` Spalte als einem zusammenhängenden Block, der deutlich Aufwand der Anwendung erhöhen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray. Diese Methode kopiert die in <paramref name="count" /> angegebene Anzahl von Bytes aus dem <paramref name="buffer" /> in den aktuellen Stream.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="count">Die Anzahl an Bytes, die in den aktuellen Stream geschrieben werden sollen. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Schreibt eine Folge von Bytes in den aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und verschiebt die aktuelle Position in diesem Stream um die Anzahl der geschrieben Bytes nach vorn.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang erfolgreich ist, setzt sich die Position im Stream um die Anzahl der geschriebenen Bytes. Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.  
  
 Schreiben hinter dem Ende `LOB` zulässig ist, und vergrößert die `LOB` durch die Anzahl der geschriebenen Bytes.  
  
 Die .NET Framework-Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten im Unicode-Format. Aus diesem Grund den Zugriff auf `CLOB` und `NCLOB` Datentypen immer umgegangen mit der Anzahl von Bytes, in dem jedes Zeichen 2 Bytes beträgt. Angenommen, eine Zeichenfolge mit drei Zeichen als gespeichert wird ein `NCLOB` auf einem Oracle-Server, in dem der Zeichensatz ist 4 Bytes pro Zeichen, und führen Sie, eine `Write` -Vorgang, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl es ist als 12 Bytes auf dem Server gespeichert.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
 Im folgende C#-Beispiel wird veranschaulicht, wie zum Schreiben in <xref:System.Data.OracleClient.OracleLob> Objekte.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="offset" />-Parameter oder im <paramref name="count" />-Parameter angegebener Wert ist nicht positiv.  
  
- oder -  
Die Summe des <paramref name="offset" />-Parameters und des <paramref name="count" />-Parameters ist größer als die <paramref name="buffer" />-Länge.  
  
- oder -  
Ein im <paramref name="count" />-Parameter oder im <paramref name="offset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
- oder -  
Sie müssen <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen als gerade Anzahl von Bytes angeben.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Das Byte, das in den Stream geschrieben werden soll.</param>
        <summary>Schreibt ein Byte an die aktuelle Position im <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und erhöht die aktuelle Position im Stream um ein Byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang erfolgreich ist, erhöht sich die Position im Stream um ein Byte. Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.  
  
 Schreiben hinter dem Ende der `LOB` zulässig ist, und vergrößert die `LOB` um ein Byte.  
  
 Zum Schreiben in die `LOB`, müssen Sie abgerufen haben die `LOB` mit der FOR UPDATE-Klausel in der SQL SELECT-Anweisung, und Sie müssen sich auf eine lokale Transaktion gestartet.  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` möglicherweise erfolgreich, aber nicht aktualisiert die `LOB` auf dem Server. In diesem Fall jedoch die lokale Kopie der `LOB` wird aktualisiert. Aus diesem Grund höher Lesevorgänge auf dem <xref:System.Data.OracleClient.OracleLob> -Objekt kann die Ergebnisse des Schreibvorgangs zurückzugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>