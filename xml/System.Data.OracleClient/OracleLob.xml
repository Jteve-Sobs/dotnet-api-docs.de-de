<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6e8147107a865c2823c16f71a256387508a40def" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76948089" /></Metadata><TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den auf einem Oracle-Server gespeicherten Datentyp <see langword="LOB" /> (Large Object Binary) dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Data.OracleClient.OracleLob> unterscheidet sich von einer <xref:System.Data.OracleClient.OracleBFile> darin, dass die Daten auf dem Server gespeichert werden und nicht in einer physischen Datei im Betriebssystem. Es kann sich auch um ein Lese-/Schreib-Objekt handeln, im Gegensatz zu einem <xref:System.Data.OracleClient.OracleBFile>, das immer schreibgeschützt ist.  
  
 Eine <xref:System.Data.OracleClient.OracleLob> kann einer dieser <xref:System.Data.OracleClient.OracleType> Datentypen sein.  
  
|OracleType-Datentyp|BESCHREIBUNG|  
|--------------------------|-----------------|  
|`Blob`|Ein Oracle `BLOB`-Datentyp, der Binärdaten mit einer maximalen Größe von 4 Gigabyte (GB) enthält. Wird einem <xref:System.Array> vom Typ <xref:System.Byte> zugeordnet.|  
|`Clob`|Ein Oracle `CLOB`-Datentyp, der Zeichendaten auf Grundlage des Standardzeichensatzes auf dem Server mit einer maximalen Größe von 4 GB enthält. Wird <xref:System.String> zugeordnet.|  
|`NClob`|Ein Oracle-`NCLOB` Datentyp, der Zeichendaten enthält, basierend auf dem nationalen Zeichensatz auf dem Server mit einer maximalen Größe von 4 GB. Wird <xref:System.String> zugeordnet.|  
  
 Ein .NET-Anwendungsentwickler kann die Oracle-`LOB` Werte in grundlegende .NET-Datentypen abrufen, z. b. <xref:System.Array> vom Typ <xref:System.Byte> und <xref:System.String>oder den spezialisierten <xref:System.Data.OracleClient.OracleLob> Datentyp. Die <xref:System.Data.OracleClient.OracleLob>-Klasse unterstützt das Lesen von Daten aus und das Schreiben in den Oracle-`LOB` in der Oracle-Datenbank.  
  
 Im folgenden sind die Hauptmerkmale eines <xref:System.Data.OracleClient.OracleLob>-Datentyps aufgeführt, der ihn von grundlegenden .NET-Datentypen unterscheidet:  
  
-   Nachdem Sie den Wert von Oracle `LOB` aus der Oracle-Datenbank in die <xref:System.Data.OracleClient.OracleLob>-Klasse abgerufen haben, können Sie die `LOB` Daten in einer geöffneten Transaktion ändern, und die Änderungen werden direkt in der Datenbank widergespiegelt. Wenn Sie den Wert von Oracle `LOB` in eine <xref:System.Array> vom Typ <xref:System.Byte> oder <xref:System.String> abrufen und diese Arrays aktualisieren, werden die Änderungen nicht in der Datenbank widergespiegelt.  
  
-   Wenn Sie die <xref:System.Data.OracleClient.OracleLob>-Klasse verwenden, um auf einen Block eines `LOB` Werts zuzugreifen, wird nur dieser Block von der Oracle-Datenbank an den Client übermittelt. Wenn Sie die <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A>-Methode verwenden, um auf einen Block eines `LOB` Werts zuzugreifen, wird der gesamte Inhalt des Werts von der Oracle-Datenbank an den Client übermittelt.  
  
 Rufen Sie zum Abrufen eines <xref:System.Data.OracleClient.OracleLob> Objekts die <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A>-Methode auf.  
  
 Sie können einen <xref:System.Data.OracleClient.OracleLob> erstellen, der mit diesem Format NULL ist:  
  
```csharp
OracleLob myLob = OracleLob.Null;  
```

```vb
Dim myLob As OracleLob = OracleLob.Null
```
  
 Dieses Verfahren wird hauptsächlich verwendet, um zu testen, ob eine vom Server zurückgegebene `LOB` NULL ist, wie in diesem Beispiel veranschaulicht:  
  
```csharp
if (myLob == OracleLob.Null)  
```

```vb
If (myLob = OracleLob.Null) Then
```
  
 Ein NULL-`LOB` verhält sich ähnlich wie ein 0-Byte-`LOB`, da <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist und immer 0 (null) Bytes zurückgibt.  
  
 Beim Auswählen einer `LOB` Spalte, die einen NULL-Wert enthält, wird <xref:System.Data.OracleClient.OracleLob.Null>zurückgegeben.  
  
 Sie müssen eine Transaktion starten, bevor Sie eine temporäre `LOB`erhalten. Andernfalls kann das <xref:System.Data.OracleClient.OracleDataReader> später keine Daten mehr abrufen.  
  
 Sie können auch einen temporären `LOB` in Oracle öffnen, indem Sie die DBMS_LOB aufrufen. Gespeicherte System Prozedur "deatetemporary" und Binden eines `LOB` Output-Parameters. Auf der Clientseite verhält sich ein temporäres `LOB` wie eine Tabellen basierte `LOB`. Um z. b. die temporäre `LOB`zu aktualisieren, muss Sie in eine Transaktion eingeschlossen werden.  
  
Im folgenden Beispiel wird veranschaulicht, wie Sie einen temporären `LOB`öffnen:
  
```csharp
var connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
var tempLob = (OracleLob)command.Parameters[0].Value;  
var tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close(); 
```  
  
> [!NOTE]
>  Die geerbte <xref:System.IO.Stream.WriteByte%2A> Methode schlägt fehl, wenn Sie mit Zeichendaten verwendet wird, und es wird eine <xref:System.InvalidOperationException> ausgelöst. Verwenden Sie stattdessen die <xref:System.Data.OracleClient.OracleLob.Write%2A>-Methode.  
>   
>  Temporäre `LOB`s werden nur geschlossen, wenn die Verbindung geschlossen wird, aber mit Pooling und unter Last werden temporäre `LOB`s nicht geschlossen. Dies kann behoben werden, indem die temporären `LOB`durch Aufrufen von `tempLob.Dispose()`verworfen werden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">Das <see langword="LOB" />, aus dem Daten angefügt werden sollen.</param>
        <summary>Fügt Daten aus dem angegebenen <see langword="LOB" /> am aktuellen <see langword="LOB" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
 Alle Daten aus der Quell `LOB` werden an das Ende der aktuellen `LOB`angefügt. Die Position von keinem `LOB` wird während dieses Prozesses ausgewertet oder geändert.  
  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Wenn Sie z. b. aus einer <xref:System.Data.OracleClient.OracleType.NClob>anhängen, muss der Ziel <xref:System.Data.OracleClient.OracleLob> auch ein <xref:System.Data.OracleClient.OracleType.NClob>sein.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" /> ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Quell-<see cref="T:System.Data.OracleClient.OracleLob" />-Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verhindert, dass beim Ausführen mehrerer Schreibvorgänge serverseitige Trigger ausgelöst werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verhindert, dass beim Ausführen mehrerer Lesevorgänge serverseitige Trigger ausgelöst werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Öffnet die `LOB` im <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> Modus. Daher kann der `LOB` nur aus gelesen werden, bis der entsprechende <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>aufgerufen wird. Um Batch Schreibvorgänge in die `LOB`auszuführen, wenden Sie <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mit <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>an.  
  
 Wenn <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mehrmals innerhalb derselben Transaktion aufgerufen wird, wird der Oracle-Fehler "ORA-22293: Lob ist bereits in derselben Transaktion geöffnet" ausgelöst. Wenn Sie die `LOB` mit einem anderen <xref:System.Data.OracleClient.OracleDataReader>abrufen und der ursprüngliche Aufrufer nicht die <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>-Methode aufgerufen hat, wird derselbe Fehler generiert. Daher müssen Sie die <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>-Methode abrufen, wenn Sie mit der Verwendung der <xref:System.Data.OracleClient.OracleLob>fertig sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Der Modus (einer der <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />-Werte), in dem zwischen diesem <see langword="LOB" />-Aufruf und dem entsprechenden <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />-Aufruf auf das <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> zugegriffen werden kann.</param>
        <summary>Verhindert, dass serverseitige Trigger ausgelöst werden, während im angegebenen Zugriffsmodus mehrere Lese- und Schreibvorgänge ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
 Wenn <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> mehrmals innerhalb derselben Transaktion aufgerufen wird, wird der Oracle-Fehler "ORA-22293: Lob ist bereits in derselben Transaktion geöffnet" ausgelöst. Wenn Sie die `LOB` mit einem anderen <xref:System.Data.OracleClient.OracleDataReader>abrufen und der ursprüngliche Aufrufer nicht die <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>-Methode aufgerufen hat, wird derselbe Fehler generiert. Daher müssen Sie die <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>-Methode abrufen, wenn Sie mit der Verwendung der <xref:System.Data.OracleClient.OracleLob>fertig sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="LOB" />-Stream gelesen werden kann.</summary>
        <value><see langword="true" />, wenn der <see langword="LOB" />-Stream Lesevorgänge unterstützt, andernfalls <see langword="false" />, wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Suchvorgänge vorwärts und rückwärts ausgeführt werden können.</summary>
        <value><see langword="false" /> wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist, andernfalls <see langword="true" />. Für <see langword="true" /> immer <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt immer True zurück, unabhängig davon, ob das <see langword="LOB" /> Schreibvorgänge unterstützt.</summary>
        <value>Gibt immer <see langword="true" /> zurück, unabhängig davon, ob ein geöffnetes oder nicht freigegebenes <see langword="LOB" /> Schreibvorgänge unterstützt. <see langword="false" />, wenn ein <see langword="LOB" /> geschlossen oder freigegeben ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Mindestanzahl von Bytes angibt, die während einer Lese-/Schreiboperation vom Server abgerufen oder an diesen gesendet werden soll.</summary>
        <value>Die Mindestanzahl abzurufender oder zu sendender Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von der <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>-Eigenschaft zurückgegebene Wert ist keine Einstellung der .NET Framework Datenanbieter für Oracle. Stattdessen ist es der Wert, den die Oracle callinterface (OCI) bei der Kommunikation mit dem Server verwendet. Verwenden Sie <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>, um sicherzustellen, dass Client seitige Blöcke dieselbe Größe haben. Beim Lesen oder schreiben in kleineren Blöcken werden Daten nicht zwischengespeichert, und es wird ein weniger optimierter Roundtrip zum Server verursacht, da kein vollständiges Paket empfangen oder gesendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt, das auf dasselbe Oracle-<see langword="LOB" /> wie das ursprüngliche <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt verweist.</summary>
        <returns>Ein neues <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt, das auf dasselbe Oracle-<see langword="LOB" /> wie das ursprüngliche <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften des neuen <xref:System.Data.OracleClient.OracleLob> Objekts haben zunächst die gleichen Werte wie die des ursprünglichen Objekts. Nach Abschluss des <xref:System.Data.OracleClient.OracleLob.Clone%2A> ist jedes <xref:System.Data.OracleClient.OracleLob> Objekt jedoch unabhängig vom anderen. Wenn Sie z. b. den Wert der <xref:System.Data.OracleClient.OracleLob.Position%2A>-Eigenschaft für den ursprünglichen <xref:System.Data.OracleClient.OracleLob> ändern, wird der Wert von <xref:System.Data.OracleClient.OracleLob.Position%2A> in der Kopie nicht geändert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="oracleLob.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den aktuellen Stream und gibt alle dem Stream zugeordneten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von dieser Instanz von <see cref="T:System.Data.OracleClient.OracleConnection" /> verwendete <see cref="T:System.Data.OracleClient.OracleLob" /> ab.</summary>
        <value>Die Verbindung mit einer Datenquelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">Der Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Kopiert aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Wenn Sie z. b. aus einer <xref:System.Data.OracleClient.OracleType.NClob>kopieren, muss der Ziel <xref:System.Data.OracleClient.OracleLob> auch ein <xref:System.Data.OracleClient.OracleType.NClob>sein.  
  
 Wenn der Ziel Offset hinter dem Ende des Ziel `LOB`liegt, wird der `LOB`, auf den die Daten kopiert werden, erweitert. Der Abstand zwischen dem Ende der `LOB` und dem Ziel Offset über das Ende hinaus wird mit Nullen für `BLOB` Datentypen und Leerzeichen für `CLOB` und `NCLOB` Datentypen aufgefüllt.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
>   
>  Die `CopyTo`-Methode löscht den Inhalt der Ziel `OracleLob` nicht, bevor der Kopiervorgang durchgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <see cref="T:System.Data.OracleClient.OracleLob" />-Parameter angegebene <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">Das Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <param name="destinationOffset">Der Offset, an den kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Anzahl von Bytes sein.</param>
        <summary>Kopiert die angegebene Datenmenge aus diesem <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Wenn Sie z. b. aus einer <xref:System.Data.OracleClient.OracleType.NClob>kopieren, muss der Ziel <xref:System.Data.OracleClient.OracleLob> auch ein <xref:System.Data.OracleClient.OracleType.NClob>sein.  
  
 Wenn der Ziel Offset hinter dem Ende des Ziel `LOB`liegt, wird der `LOB`, auf den die Daten kopiert werden, erweitert. Der Abstand zwischen dem Ende `LOB` und dem Ziel Offset über das Ende hinaus wird mit Nullen für `BLOB` Datentypen und Leerzeichen für `CLOB` und `NCLOB` Datentypen aufgefüllt.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
>   
>  Die `CopyTo`-Methode löscht den Inhalt der Ziel `OracleLob` nicht, bevor der Kopiervorgang durchgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <see cref="T:System.Data.OracleClient.OracleLob" />-Parameter angegebene <paramref name="destination" /> ist voll.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="destinationOffset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
Oder 
Ein im <paramref name="destinationOffset" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.  
  
Oder 
Sie müssen <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen als gerade Anzahl von Bytes angeben.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">Der Offset, von dem kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="destination">Der Ziel-<see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">Der Zieloffset, an den kopiert werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="amount">Die zu kopierende Datenmenge in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Kopiert die angegebene Datenmenge vom angegebenen Quelloffset dieses <see cref="T:System.Data.OracleClient.OracleLob" /> in ein Ziel-<see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der kopierten Bytes. Dabei werden Füllzeichenbytes ausgelassen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegenden Datentypen müssen immer identisch sein. Wenn Sie z. b. aus einer <xref:System.Data.OracleClient.OracleType.NClob>kopieren, muss der Ziel <xref:System.Data.OracleClient.OracleLob> auch ein <xref:System.Data.OracleClient.OracleType.NClob>sein.  
  
 Wenn der Ziel Offset hinter dem Ende des Ziel `LOB`liegt, wird der `LOB`, auf den die Daten kopiert werden, erweitert. Der Abstand zwischen dem Ende `LOB` und dem Ziel Offset über das Ende hinaus wird mit Nullen für `BLOB` Datentypen und Leerzeichen für `CLOB` und `NCLOB` Datentypen aufgefüllt.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
>   
>  Die `CopyTo`-Methode löscht den Inhalt der Ziel `OracleLob` nicht, bevor der Kopiervorgang durchgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das im <see cref="T:System.Data.OracleClient.OracleLob" />-Parameter angegebene <paramref name="destination" /> ist voll.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein in den Parametern <paramref name="amount" />, <paramref name="sourceOffset" /> oder <paramref name="destinationOffset" /> angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
Oder 
Ein im <paramref name="amount" />-Parameter, im <paramref name="sourceOffset" />-Parameter oder im <paramref name="destinationOffset" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="oracleLob.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vom Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht, nach dem Ausführen mehrerer Schreibvorgänge serverseitige Trigger ausgelöst werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>-Methode auf, bevor Sie mit der Ausführung von Schreibvorgängen für die <xref:System.Data.OracleClient.OracleLob>beginnen  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht Daten aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Daten aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der gelöschten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 die Daten werden von <xref:System.Data.OracleClient.OracleLob.Erase%2A> nicht abgeschnitten. Die `LOB` Länge bleibt für einen `BLOB` Datentyp unverändert, und die gelöschten Daten werden durch 0x00 ersetzt. die Datentypen `CLOB` und `NCLOB` werden durch Leerzeichen ersetzt.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Der Offset, ab dem gelöscht werden soll. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="amount">Die zu löschende Datenmenge in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Löscht die angegebene Datenmenge aus diesem <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Die Anzahl der gelöschten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Summe der Werte in den Parametern `offset` und `amount` kann größer sein als die Größe des <xref:System.Data.OracleClient.OracleLob>. Daher ist die Angabe eines Werts größer als der, der von der <xref:System.Data.OracleClient.OracleLob.Length%2A>-Eigenschaft zurückgegeben wird, erfolgreich. Allerdings <xref:System.Data.OracleClient.OracleLob.Erase%2A> nur bis zum Ende des <xref:System.Data.OracleClient.OracleLob>. (Ähnlich, wenn ein negativer Wert an `offset`übermittelt wird, ist <xref:System.Data.OracleClient.OracleLob.Erase%2A> erfolgreich, aber erst ab dem Anfang der <xref:System.Data.OracleClient.OracleLob>zu löschen.) Dieses Verhalten unterscheidet sich von dem der <xref:System.Data.OracleClient.OracleLob.Read%2A>-und <xref:System.Data.OracleClient.OracleLob.Write%2A> Methoden und bietet den Vorteil, dass alle Daten aus dem von `offset` angegebenen Wert gelöscht werden können, ohne dass ein zusätzlicher Roundtrip zum Server durchführt, um die tatsächliche Größe zu überprüfen.  
  
 die Daten werden von <xref:System.Data.OracleClient.OracleLob.Erase%2A> nicht abgeschnitten. Die `LOB` Länge bleibt für einen `BLOB` Datentyp unverändert, und die gelöschten Daten werden durch 0x00 ersetzt. die Datentypen `CLOB` und `NCLOB` werden durch Leerzeichen ersetzt.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  In dieser Version kann ein Schreibvorgang für eine schreibgeschützte `LOB` erfolgreich sein, aber die `LOB` auf dem Server nicht aktualisieren. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Derzeit nicht unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Version ist diese Methode nicht funktionsfähig.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Anwendung die <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />-Methode aufgerufen hat.</summary>
        <value><see langword="true" />, wenn eine Anwendung die <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />-Methode aufgerufen hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Oracle 8.0.5-Server verwendet wird, wird die Ausnahme "Ora-00600: interner Fehlercode" ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Data.OracleClient.OracleLob" /> ein <see cref="F:System.Data.OracleClient.OracleBFile.Null" />-Stream ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Data.OracleClient.OracleLob" /> ein <see cref="F:System.Data.OracleClient.OracleBFile.Null" />-Stream ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Data.OracleClient.OracleLob" /> ein temporäres <see langword="LOB" /> ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Data.OracleClient.OracleLob" /> ein temporäres <see langword="LOB" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Beispiel wird veranschaulicht, wie ein temporäres `LOB`erstellt wird.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des <see cref="T:System.Data.OracleClient.OracleLob" /> zurückgibt.</summary>
        <value>Die Größe des <see cref="T:System.Data.OracleClient.OracleLob" /> in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des <xref:System.Data.OracleClient.OracleLob> wird immer in Bytes für alle Datentypen zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den <see langword="LOB" />-Datentyp zurückgibt.</summary>
        <value>Einer der <see cref="T:System.Data.OracleClient.OracleType" />-<see langword="LOB" />-Datentypen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Data.OracleClient.OracleLob> kann einer der folgenden <xref:System.Data.OracleClient.OracleType> Datentypen sein.  
  
|OracleType-Datentyp|BESCHREIBUNG|  
|--------------------------|-----------------|  
|`Blob`|Ein Oracle-`BLOB`-Datentyp, der Binärdaten mit einer maximalen Größe von 4 Gigabyte enthält. Wird einem <xref:System.Array> vom Typ <xref:System.Byte> zugeordnet.|  
|`Clob`|Ein Oracle-`CLOB`-Datentyp für Zeichendaten, die auf dem Standardzeichensatz des Servers beruhen und eine maximale Größe von 4 Gigabyte haben können. Wird <xref:System.String> zugeordnet.|  
|`NClob`|Ein Oracle-`NCLOB` Datentyp, der Zeichendaten enthält, basierend auf dem nationalen Zeichensatz auf dem Server mit einer maximalen Größe von 4 Gigabyte. Wird <xref:System.String> zugeordnet.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein NULL-<see cref="T:System.Data.OracleClient.OracleLob" />-Objekt dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen <xref:System.Data.OracleClient.OracleLob> erstellen, der mit diesem Format NULL ist:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Dieses Verfahren wird hauptsächlich verwendet, um zu testen, ob eine vom Server zurückgegebene `LOB` NULL ist, wie in diesem Beispiel veranschaulicht:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Ein NULL-`LOB` verhält sich ähnlich wie ein NULL Byte `LOB` in, dass <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist und immer 0 (null) Bytes zurückgibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Leseposition im <see cref="T:System.Data.OracleClient.OracleLob" />-Stream ab.</summary>
        <value>Die aktuelle Position innerhalb des <see cref="T:System.Data.OracleClient.OracleLob" />-Streams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Stream muss das Suchen oder Festlegen der Position unterstützen. Verwenden Sie die Eigenschaft <xref:System.Data.OracleClient.OracleLob.CanSeek%2A>, um zu bestimmen, ob der Stream Suchvorgänge unterstützt.  
  
 Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt. Die Suche nach einer ungeraden Position für `CLOB`-und `NCLOB`-Datentypen wird ebenfalls unterstützt. Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Data.OracleClient.OracleLob.Read%2A>-Eigenschaft.  
  
 Die <xref:System.Data.OracleClient.OracleLob.Position%2A>-Eigenschaft verfolgt nicht die Anzahl der Bytes aus dem Datenstrom, die verbraucht, ausgelassen oder beides sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Bytes. Nach dem Beenden dieser Methode enthält der Puffer das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" />), die durch aus der aktuellen Quelle gelesene Bytes ersetzt wurden.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="count">Die maximale Anzahl von Bytes, die vom aktuellen Datenstrom gelesen wird. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Liest eine Folge von Bytes aus dem aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und verschiebt die Position im Stream um die Anzahl der gelesen Bytes nach vorn.</summary>
        <returns>Die Gesamtanzahl der in den Puffer eingelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.OracleClient.OracleLob.Read%2A>-Methode liest maximal `count` Bytes aus dem aktuellen Stream und speichert Sie in `buffer`, beginnend bei `offset`. Die aktuelle Position innerhalb des Streams wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert. <xref:System.Data.OracleClient.OracleLob.Read%2A> gibt die Anzahl der gelesenen Bytes zurück. Der Rückgabewert ist nur 0 (null), wenn sich die Position derzeit am Ende des Streams befindet. <xref:System.Data.OracleClient.OracleLob.Read%2A> wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind.<xref:System.Data.OracleClient.OracleLob.Read%2A> gibt 0 zurück, wenn Sie versuchen, aus einem `LOB` zu lesen, wenn sich die aktuelle Position am Ende `LOB`befindet. <xref:System.Data.OracleClient.OracleLob.Read%2A> können weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.  
  
 Der .NET Framework Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten als Unicode. Wenn Sie auf `CLOB`-und `NCLOB` Datentypen zugreifen, befassen Sie sich daher immer mit der Anzahl von Bytes, wobei jedes Zeichen 2 Bytes beträgt. Wenn beispielsweise eine Text Zeichenfolge, die drei Zeichen enthält, als `NCLOB` auf einem Oracle-Server gespeichert wird, bei dem der Zeichensatz 4 Bytes pro Zeichen beträgt, und Sie einen `Read` Vorgang ausführen, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl Sie als 12 Bytes auf dem Server gespeichert ist.  
  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.Data.OracleClient.OracleLob>-Objekte gelesen wird.  
  
```csharp
public static void ReadLobExample(OracleCommand command)  
{  
    int actual = 0;  
  
    // Select some data.  
    // Table Schema:  
    //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
    //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
    command.CommandText = "SELECT * FROM TableWithLobs";  
    OracleDataReader reader = command.ExecuteReader();  
    using(reader)  
    {  
        // Obtain the first row of data.  
        reader.Read();  
        // Obtain the LOBs (all 3 varieties).  
        OracleLob BLOB = reader.GetOracleLob(1);  
        OracleLob CLOB  = reader.GetOracleLob(2);  
        OracleLob NCLOB = reader.GetOracleLob(3);  
  
        // Example - Reading binary data (in chunks).  
        var buffer = new byte[100];  
        while((actual = BLOB.Read(buffer, 0, buffer.Length)) > 0)  
            Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
        // Example - Reading CLOB/NCLOB data (in chunks).  
        // Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
        // However, because the OracleLob object inherits directly from the.NET stream object,   
        // all the existing classes that manipulate streams can also be used. For example, the   
        // .NET StreamReader makes converting the raw bytes into actual characters easier.  
        var streamreader = new StreamReader(CLOB, Encoding.Unicode);  
        var cbuffer = new char[100];  
        while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
            Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
        //Example - Reading data (all at once).  
        //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
        //call OracleLob.Value to obtain a contiguous allocation of all the data.  
        Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
    }  
}  
```  
  
 Sie können einen <xref:System.Data.OracleClient.OracleLob> erstellen, der mit diesem Format NULL ist:  
  
```csharp
OracleLob myLob = OracleLob.Null;  
```

  
 Diese Technik wird in erster Linie verwendet, um zu testen, ob eine vom Server zurückgegebene `LOB` NULL ist, wie im folgenden Beispiel veranschaulicht.  
  
```csharp
if (myLob == OracleLob.Null)  
```  
  
 Ein NULL-`LOB` verhält sich ähnlich wie ein NULL Byte `LOB` in, dass <xref:System.Data.OracleClient.OracleLob.Read%2A> erfolgreich ist und immer 0 (null) Bytes zurückgibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="offset" />-Parameter oder im <paramref name="count" />-Parameter angegebener Wert ist nicht positiv.  
  
Oder 
Die Summe des offset-Parameters und des count-Parameters ist größer als die Pufferlänge.  
  
Oder 
Ein im <paramref name="amount" />-Parameter oder im <paramref name="offset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein Byteoffset relativ zum Ursprung. Wenn <paramref name="offset" /> negativ ist, liegt die neue Position um die durch <paramref name="origin" /> angegebene Anzahl von Bytes vor der durch <paramref name="offset" /> angegebenen Position. Wenn <paramref name="offset" /> 0 (null) ist, ist die neue Position die durch <paramref name="origin" /> angegebene Position. Wenn <paramref name="offset" /> positiv ist, liegt die neue Position um die durch <paramref name="origin" /> angegebene Anzahl von Bytes hinter der durch <paramref name="offset" /> angegebenen Position.</param>
        <param name="origin">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</param>
        <summary>Legt die Position im aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream fest.</summary>
        <returns>Legt die neue Position im aktuellen Stream fest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `offset` negativ ist, muss die neue Position der durch `origin` angegebenen Anzahl von Bytes vor der durch `offset`angegebenen Position vorangestellt werden. Wenn `offset` NULL ist, muss die neue Position die durch `origin`angegebene Position sein. Wenn `offset` positiv ist, muss die neue Position der durch `origin` angegebenen Anzahl von Bytes entsprechend der durch `offset`angegebenen Position folgen.  
  
 Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt. Die Suche nach einer ungeraden Position für `CLOB`-und `NCLOB`-Datentypen wird ebenfalls unterstützt. Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Data.OracleClient.OracleLob.Read%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="origin" />-Parameter enthält keinen gültigen Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die resultierende Position liegt hinter der Länge des Werts.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die gewünschte Länge des aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Streams in Bytes. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Legt die Länge des <see cref="T:System.Data.OracleClient.OracleLob" />-Streams auf einen Wert fest, der kleiner als die aktuelle Länge ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Versuch, die Länge des <xref:System.Data.OracleClient.OracleLob> Streams zu vergrößern, schlägt fehl und gibt "Message: ORA-22926: die angegebene Trim-Länge ist größer als die Länge des aktuellen LOB-Werts" vom Oracle-Server an.  
  
 Ein Stream muss sowohl das Schreiben als auch das Suchen nach <xref:System.Data.OracleClient.OracleLob.SetLength%2A> unterstützen, um zu funktionieren.  
  
 Der .NET Framework Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten als Unicode. Wenn Sie auf `CLOB`-und `NCLOB` Datentypen zugreifen, befassen Sie sich daher immer mit der Anzahl von Bytes, wobei jedes Zeichen 2 Bytes beträgt. Wenn beispielsweise eine Text Zeichenfolge, die drei Zeichen enthält, als `NCLOB` auf einem Oracle-Server gespeichert wird, bei dem der Zeichensatz 4 Bytes pro Zeichen beträgt, und Sie einen `SetLength` Vorgang ausführen, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl Sie als 12 Bytes auf dem Server gespeichert ist.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` ist möglicherweise erfolgreich, aktualisiert jedoch nicht die `LOB` auf dem Server. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="value" />-Parameter für einen <see langword="CLOB" />-Datentyp oder einen <see langword="NCLOB" />-Datentyp angegebener Wert ist ungerade.  
  
Oder 
Ein im <paramref name="value" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Streamwertentsprechung der Common Language Runtime für den zugrunde liegenden Wert ab.</summary>
        <value>Für <see cref="F:System.Data.OracleClient.OracleType.Blob" /> ein Array vom Typ <see langword="Byte[]" />. Für <see cref="F:System.Data.OracleClient.OracleType.Clob" /> und <see cref="F:System.Data.OracleClient.OracleType.NClob" /> ein <see langword="String" />. Für NULL-Daten <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei <xref:System.Data.OracleClient.OracleType.Blob>-Datentypen gibt <xref:System.Data.OracleClient.OracleLob.Value%2A> die gesamten zugrunde liegenden Daten als ein zusammenhängendes Array vom Typ `Byte[]`zurück. Bei <xref:System.Data.OracleClient.OracleType.Clob>-und <xref:System.Data.OracleClient.OracleType.NClob> Datentypen gibt <xref:System.Data.OracleClient.OracleLob.Value%2A> alle Daten als `String` Datentyp zurück. Bei NULL-Daten gibt <xref:System.Data.OracleClient.OracleLob.Value%2A> <xref:System.DBNull>zurück. Wenn Sie die zurückgegebenen Werte vergleichen, können Sie zwischen leeren Daten, NULL-Daten und Daten unterscheiden.  
  
> [!NOTE]
>  Ein Vorteil der Verwendung von `LOB` Datentypen ist die Möglichkeit, große Datenmengen in Blöcken auf dem Client abzurufen. Wenn Sie jedoch <xref:System.Data.OracleClient.OracleLob.Value%2A>verwenden, erhalten Sie alle Daten für die `LOB` Spalte als einen zusammenhängenden Block, der den Anwendungs Aufwand erheblich erhöhen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Bytes. Diese Methode kopiert die in <paramref name="count" /> angegebene Anzahl von Bytes aus dem <paramref name="buffer" /> in den aktuellen Stream.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <param name="count">Die Anzahl der Byte, die in den aktuellen Datenstrom geschrieben wird. Bei <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen muss dies eine gerade Zahl sein.</param>
        <summary>Schreibt eine Folge von Bytes in den aktuellen <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und verschiebt die aktuelle Position in diesem Stream um die Anzahl der geschrieben Bytes nach vorn.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang erfolgreich ist, wird die Position im Stream um die Anzahl der geschriebenen Bytes fortgesetzt. Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.  
  
 Das Schreiben über das Ende der `LOB` ist zulässig und vergrößert die `LOB` um die Anzahl der geschriebenen Bytes.  
  
 Der .NET Framework Datenanbieter für Oracle verarbeitet alle `CLOB` und `NCLOB` Daten als Unicode. Wenn Sie auf `CLOB`-und `NCLOB` Datentypen zugreifen, befassen Sie sich daher immer mit der Anzahl von Bytes, wobei jedes Zeichen 2 Bytes beträgt. Wenn beispielsweise eine Text Zeichenfolge, die drei Zeichen enthält, als `NCLOB` auf einem Oracle-Server gespeichert wird, bei dem der Zeichensatz 4 Bytes pro Zeichen beträgt, und Sie einen `Write` Vorgang ausführen, geben Sie die Länge der Zeichenfolge als 6 Bytes an, obwohl Sie als 12 Bytes auf dem Server gespeichert ist.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
 Im folgenden Beispiel wird veranschaulicht, wie in <xref:System.Data.OracleClient.OracleLob>-Objekte geschrieben wird:
  
```csharp
public static void WriteLobExample(OracleCommand command)  
{  
    // Note: Updating LOB data requires a transaction.  
    command.Transaction = command.Connection.BeginTransaction();  
    // Select some data.  
    //    Table Schema:  
    //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
    //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
    command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
    OracleDataReader reader = command.ExecuteReader();  
    using(reader)  
    {  
        // Obtain the first row of data.  
        reader.Read();  
        // Obtain both LOBs.  
        OracleLob BLOB1 = reader.GetOracleLob(1);  
        OracleLob BLOB2 = reader.GetOracleLob(2);  
        // Perform any desired operations on the LOB, (read, position, and so on).  
        // ...  
        // Example - Writing binary data (directly to the backend).  
        // To write, you can use any of the stream classes, or write raw binary data using   
        // the OracleLob write method. Writing character vs. binary is the same;  
        // however note that character is always in terms of Unicode byte counts  
        // (for example: even number of bytes - 2 bytes for every Unicode character).  
        var buffer = new byte[100];  
        buffer[0] = 0xCC;  
        buffer[1] = 0xDD;  
        BLOB1.Write(buffer, 0, 2);  
        BLOB1.Position = 0;  
        Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
        
        // Example - Copying data into another LOB.  
        long actual = BLOB1.CopyTo(BLOB2);  
        Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
        
        // Commit the transaction now that everything succeeded.  
        // Note: On error, Transaction.Dispose is called (from the using statement)  
        // and will automatically roll-back the pending transaction.  
        command.Transaction.Commit();  
    }  
}  
```  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` ist möglicherweise erfolgreich, aktualisiert jedoch nicht die `LOB` auf dem Server. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein im <paramref name="offset" />-Parameter oder im <paramref name="count" />-Parameter angegebener Wert ist nicht positiv.  
  
Oder 
Die Summe des <paramref name="offset" />-Parameters und des <paramref name="count" />-Parameters ist größer als die <paramref name="buffer" />-Länge.  
  
Oder 
Ein im <paramref name="count" />-Parameter oder im <paramref name="offset" />-Parameter angegebener Wert ist kleiner als 0 (null) oder größer als 4 Gigabyte.  
  
Oder 
Sie müssen <see langword="CLOB" />-Datentypen und <see langword="NCLOB" />-Datentypen als gerade Anzahl von Bytes angeben.</exception>
        <exception cref="T:System.InvalidOperationException">Die Operation befindet sich nicht innerhalb einer Transaktion, das <see cref="T:System.Data.OracleClient.OracleLob" />-Objekt ist NULL, oder die Verbindung ist geschlossen.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Objekt war geschlossen oder freigegeben.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Es ist ein Oracle-Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Das Byte, das in den Stream geschrieben werden soll.</param>
        <summary>Schreibt ein Byte an die aktuelle Position im <see cref="T:System.Data.OracleClient.OracleLob" />-Stream und erhöht die aktuelle Position im Stream um ein Byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schreibvorgang erfolgreich ist, wechselt die Position im Stream um ein Byte. Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.  
  
 Das Schreiben über das Ende der `LOB` ist zulässig und vergrößert die `LOB` um ein Byte.  
  
 Um in den `LOB`zu schreiben, müssen Sie die `LOB` mithilfe der for Update-Klausel in der SQL-SELECT-Anweisung abgerufen haben, und Sie müssen eine lokale Transaktion gestartet haben.  
  
> [!NOTE]
>  Ein Schreibvorgang für eine schreibgeschützte `LOB` ist möglicherweise erfolgreich, aktualisiert jedoch nicht die `LOB` auf dem Server. In diesem Fall wird jedoch die lokale Kopie des `LOB` aktualisiert. Daher können spätere Lesevorgänge für das <xref:System.Data.OracleClient.OracleLob> Objekt die Ergebnisse des Schreibvorgangs zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
