<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a1f159d1f8a69b263062579cf3ad2a360eed09e" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83947909" /></Metadata><TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet Zustände und die Logik für Übergänge zwischen Zuständen für Steuerelemente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Windows.VisualStateManager> können Sie Zustände für ein Steuerelement angeben, das Aussehen eines Steuer Elements, wenn es sich in einem bestimmten Zustand befindet, und wenn sich ein Steuerelement ändert. Beispielsweise kann ein <xref:System.Windows.Controls.Button> etwas anders aussehen, wenn es gedrückt wird, als wenn es nicht gedrückt wird. Zwei Zustände, die die <xref:System.Windows.Controls.Button> definiert, entsprechen, wenn Sie gedrückt wird (`"Pressed"`), und wenn dies nicht der Fall ist (`"Normal"`). Die Darstellung eines-Steuer Elements, wenn es sich in einem-Zustand befindet, wird durch einen-<xref:System.Windows.VisualState>definiert. Eine <xref:System.Windows.VisualState> die eine Auflistung von <xref:System.Windows.Media.Animation.Storyboard> Objekten enthält, die angeben, wie sich das Erscheinungsbild des Steuer Elements ändert, wenn sich das Steuerelement in diesem Zustand befindet. Sie fügen einem Steuerelement visuelle Zustände hinzu, indem Sie die `VisualStateManager.VisualStateGroups` angefügte-Eigenschaft für das Steuerelement festlegen. Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von <xref:System.Windows.VisualState> Objekten, die sich gegenseitig ausschließen. Das heißt, dass sich das Steuerelement in jedem <xref:System.Windows.VisualStateGroup>immer in genau einem Zustand von befindet.  
  
 Mit der <xref:System.Windows.VisualStateManager> können Sie auch angeben, wann ein Steuerelement in einen bestimmten Zustand wechselt. Die Methode, die Sie zum Ändern von Zuständen aufruft, hängt von Ihrem Szenario ab. Wenn Sie ein Steuerelement erstellen, das die <xref:System.Windows.VisualStateManager> im <xref:System.Windows.Controls.ControlTemplate>verwendet, rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A>-Methode auf. Weitere Informationen zum Erstellen von Steuerelementen, die die <xref:System.Windows.VisualStateManager>verwenden, finden Sie unter [Erstellen eines Steuer Elements, das eine anpassbare Darstellung hat](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance). Wenn Sie die <xref:System.Windows.VisualStateManager> außerhalb eines <xref:System.Windows.Controls.ControlTemplate> verwenden (wenn Sie z. b. eine <xref:System.Windows.VisualStateManager> in einer <xref:System.Windows.Controls.UserControl> oder in einem einzelnen Element verwenden), müssen Sie die <xref:System.Windows.VisualStateManager.GoToElementState%2A>-Methode aufzurufen. In beiden Fällen führt der <xref:System.Windows.VisualStateManager> die erforderliche Logik aus, um die Storyboards, die dem Beteiligten Zustand zugeordnet sind, ordnungsgemäß zu starten und zu unterbinden. Nehmen wir beispielsweise an, dass ein Steuerelement die Zustände, `State1` und `State2`definiert, denen jeweils ein Storyboard zugeordnet ist. Wenn sich das Steuerelement in `State1` und Sie `State2` an <xref:System.Windows.VisualStateManager.GoToState%2A> oder <xref:System.Windows.VisualStateManager.GoToElementState%2A>übergeben, startet das <xref:System.Windows.VisualStateManager> das Storyboard in `State2` und beendet das Storyboard in `State1`.  
  
 Steuerelemente, die in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] enthalten sind, verwenden die <xref:System.Windows.VisualStateManager>, um visuelle Zustände zu ändern. Wenn Sie eine <xref:System.Windows.Controls.ControlTemplate> für ein Steuerelement erstellen, das in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]enthalten ist, können Sie dem <xref:System.Windows.Controls.ControlTemplate> des Steuer Elements <xref:System.Windows.VisualState> Objekte hinzufügen, um die Darstellung des Steuer Elements in einem bestimmten Zustand anzugeben. Informationen zu den Namen der visuellen Zustände für die Steuerelemente, die in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]enthalten sind, finden Sie unter [Steuerelement Stile und-Vorlagen](/dotnet/framework/wpf/controls/control-styles-and-templates). Die Logik des Steuer Elements steuert den Übergang zwischen Zuständen, sodass Sie nichts anderes tun müssen, als die <xref:System.Windows.VisualState> Objekte in der neuen <xref:System.Windows.Controls.ControlTemplate>zu definieren. Weitere Informationen zum Erstellen von Steuerelement Vorlagen für vorhandene Steuerelemente finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control).  
  
 Wenn Sie Ihre eigene Logik für den Übergang zwischen Zuständen implementieren möchten, müssen Sie von <xref:System.Windows.VisualStateManager>erben, die <xref:System.Windows.VisualStateManager.GoToStateCore%2A>-Methode überschreiben und die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> angefügte-Eigenschaft für das Steuerelement festlegen, das die benutzerdefinierte Logik verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Windows.Shapes.Rectangle> erstellt und `VisualStateManager.VisualStatesGroups` der angefügten-Eigenschaft ein <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates` hinzugefügt. Im Beispiel werden die `MouseOver`-und `Normal`<xref:System.Windows.VisualState>-Objekte in der `CommonStates`<xref:System.Windows.VisualStateGroup>definiert. Wenn der Benutzer den Mauszeiger über die <xref:System.Windows.Shapes.Rectangle>bewegt, wird er über eine halbe Sekunde von rot in Grün geändert. Wenn der Benutzer den Mauszeiger aus dem Rechteck bewegt, wird der <xref:System.Windows.Controls.Grid> sofort wieder in rot geändert. Beachten Sie, dass der `Normal` Status keine <xref:System.Windows.Media.Animation.Storyboard>definiert. Eine <xref:System.Windows.Media.Animation.Storyboard> ist nicht erforderlich, da die <xref:System.Windows.Shapes.Rectangle> für <xref:System.Windows.Media.Animation.Storyboard> beendet wird und die `MouseOver`-Eigenschaft für den <xref:System.Windows.Media.SolidColorBrush.Color%2A> zu rot wechselt, wenn der vom `MouseOver` in den `Normal`-Zustand übergeht.<xref:System.Windows.Media.SolidColorBrush>  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 Das folgende Beispiel zeigt den Ereignishandler, der im vorherigen Beispiel definiert wurde, und ruft die <xref:System.Windows.VisualStateManager.GoToElementState%2A>-Methode auf, um zwischen Zuständen zu wechseln. Wenn das Rechteck im vorherigen Beispiel Teil eines <xref:System.Windows.Controls.ControlTemplate>ist, müsste das Beispiel die <xref:System.Windows.VisualStateManager.GoToState%2A>-Methode aufzurufen.  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Windows.VisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.VisualStateManager" />-Objekt ab, das zwischen den Zuständen eines Steuerelements wechselt, oder legt dieses fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> `null`ist, verwendet der <xref:System.Windows.VisualStateManager> seine eigene Logik, um zwischen Zuständen zu wechseln. Wenn Sie Ihre eigene Logik für den Übergang zwischen Zuständen implementieren möchten, erstellen Sie eine Klasse, die von <xref:System.Windows.VisualStateManager> erbt, und überschreiben Sie die <xref:System.Windows.VisualStateManager.GoToStateCore%2A>-Methode. Wenn Sie die benutzerdefinierte Klasse verwenden möchten, legen Sie die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A>-Eigenschaft auf ein Objekt des benutzerdefinierten Typs fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft ab.</summary>
        <returns>Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft ab.</summary>
        <returns>Die Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten, die dem angegebenen Objekt zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen zwei Zuständen des Elements. Verwenden Sie diese Methode zum Wechseln von Zuständen, die von einer Anwendung und nicht von einem Steuerelement definiert werden.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Windows.VisualStateManager.GoToElementState%2A>-Methode auf, um die Zustände eines Elements außerhalb eines <xref:System.Windows.Controls.ControlTemplate> zu ändern (z. b. Wenn Sie eine <xref:System.Windows.VisualStateManager> in einer <xref:System.Windows.DataTemplate> oder <xref:System.Windows.Window>verwenden). Wenn Sie Zustände in einem Steuerelement ändern, das die <xref:System.Windows.VisualStateManager> im <xref:System.Windows.Controls.ControlTemplate>verwendet, können Sie die <xref:System.Windows.VisualStateManager.GoToState%2A>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Anwendung erstellt, die den Benutzer auffordert, eine Zahl zwischen 1 und 100 zu erraten.  Wenn der Benutzer eine Zahl eingibt, gibt die Anwendung an, ob der Schätzwert zu hoch, zu niedrig oder richtig ist.  Im folgenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] wird die Benutzeroberfläche für die Anwendung erstellt und 4 Zustände definiert: `TooLow`, `TooHigh`, `Correct`und `Guessing`. Wenn die Anwendung beginnt, befindet Sie sich im `Guessing` Zustand. erforderlich.  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 Der folgende Code zeigt die Logik der Anwendung.  Wenn der Benutzer eine Zahl eingibt und auf die Schaltfläche klickt, ruft die Anwendung <xref:System.Windows.VisualStateManager.GoToElementState%2A> auf, um zu `TooHigh`, `TooLow`oder `Correct` zu wechseln, um dem Benutzer Feedback über den Schätzwert zu geben.  Um dieses Beispiel zu testen, nennen Sie die `GenerateNumber`-Methode, wenn die Anwendung startet.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />  
  
Oder 
 <paramref name="stateName" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Führt Übergang des Steuerelements von einem Zustand in einen anderen durch. Verwenden Sie diese Methode für Übergänge zwischen Zuständen in Steuerelementen mit <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Zustände in einem Steuerelement ändern, das die <xref:System.Windows.VisualStateManager> im <xref:System.Windows.Controls.ControlTemplate>verwendet, können Sie die <xref:System.Windows.VisualStateManager.GoToState%2A>-Methode aufzurufen. Ruft die <xref:System.Windows.VisualStateManager.GoToElementState%2A>-Methode auf, um die Zustände eines Elements außerhalb eines <xref:System.Windows.Controls.ControlTemplate> zu ändern (z. b. Wenn Sie eine <xref:System.Windows.VisualStateManager> in einem <xref:System.Windows.Controls.UserControl> oder in einem einzelnen Element verwenden).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Steuerelement veranschaulicht, das die <xref:System.Windows.VisualStateManager.GoToState%2A>-Methode verwendet, um zwischen Zuständen zu wechseln. Das gesamte Beispiel finden Sie unter [Erstellen eines Steuer Elements, das über eine anpassbare Darstellung verfügt](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> ist <see langword="null" />  
  
Oder 
 <paramref name="stateName" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Name des Zustands, in den gewechselt werden soll.</param>
        <param name="group">Die <see cref="T:System.Windows.VisualStateGroup" />, zu der der Zustand gehört.</param>
        <param name="state">Die Darstellung des Zustands, in den gewechselt werden soll.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen den Zuständen eines Steuerelements.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.VisualStateManager.GoToStateCore%2A>-Methode führt die erforderliche Logik aus, um die einem Übergang zugeordneten Storyboards ordnungsgemäß zu starten und zu unterbinden. Wenn ein Steuerelement <xref:System.Windows.VisualStateManager.GoToState%2A> aufruft, um seinen Zustand zu ändern, führt der <xref:System.Windows.VisualStateManager> Folgendes aus:  
  
-   Wenn die <xref:System.Windows.VisualState>, zu der das Steuerelement übergeht, eine <xref:System.Windows.Media.Animation.Storyboard>, beginnt das Storyboard. Wenn der <xref:System.Windows.VisualState>, von dem das Steuerelement stammt, über eine <xref:System.Windows.Media.Animation.Storyboard>verfügt, wird das Storyboard beendet.  
  
-   Wenn sich das Steuerelement bereits im `stateName` Zustand befindet, führt <xref:System.Windows.VisualStateManager.GoToState%2A> keine Aktion aus und gibt `true`zurück.  
  
-   Wenn `stateName` im <xref:System.Windows.Controls.ControlTemplate> von `control`nicht vorhanden ist, führt <xref:System.Windows.VisualStateManager.GoToState%2A> keine Aktion aus und gibt `false`zurück.  
  
 Sie können Ihre eigenen <xref:System.Windows.VisualStateManager> implementieren, um eine andere Logik für den Übergang zwischen Zuständen bereitzustellen. Beispielsweise können Sie die zuvor beschriebene Logik ändern, oder Sie können eine Logik für den Übergang zwischen benutzerdefinierten Animations Typen bereitstellen.  Um einen <xref:System.Windows.VisualStateManager>zu implementieren, erstellen Sie eine Klasse, die von <xref:System.Windows.VisualStateManager> erbt, und überschreiben Sie die <xref:System.Windows.VisualStateManager.GoToStateCore%2A>-Methode. Wenn Sie die benutzerdefinierte Klasse verwenden möchten, legen Sie die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A>-Eigenschaft auf ein Objekt des benutzerdefinierten Typs fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.VisualStateGroup> für die <xref:System.Windows.Controls.ControlTemplate> eines Steuer Elements festgelegt wird, wird der `control`-Parameter auf das Steuerelement festgelegt, das <xref:System.Windows.Controls.ControlTemplate>besitzt.  Wenn die <xref:System.Windows.VisualStateGroup> auf einem <xref:System.Windows.FrameworkElement>festgelegt ist, wird `control` `null`, und Sie sollten den `stateGroupsRoot`-Parameter verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />  
  
Oder 
 <paramref name="newState" /> ist <see langword="null" /></exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass die <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />-Methode der Basisklasse aufgerufen wird, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.VisualStateGroup> für die <xref:System.Windows.Controls.ControlTemplate> eines Steuer Elements festgelegt wird, wird der `control`-Parameter auf das Steuerelement festgelegt, das <xref:System.Windows.Controls.ControlTemplate>besitzt.  Wenn die <xref:System.Windows.VisualStateGroup> auf einem <xref:System.Windows.FrameworkElement>festgelegt ist, wird `control` `null`, und Sie sollten den `stateGroupsRoot`-Parameter verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />  
  
Oder 
 <paramref name="newState" /> ist <see langword="null" /></exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass die <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />-Methode der Basisklasse aufgerufen wird, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Eigenschaft festgelegt werden soll.</param>
        <param name="value">Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</param>
        <summary>Legt die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroups">
      <MemberSignature Language="C#" Value="see GetVisualStateGroups" />
      <MemberSignature Language="ILAsm" Value="see GetVisualStateGroups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.VisualStateGroups" />
      <MemberSignature Language="VB.NET" Value="see GetVisualStateGroups" />
      <MemberSignature Language="F#" Value="see GetVisualStateGroups" Usage="see GetVisualStateGroups" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten ab oder legt diese fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks  
 Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von <xref:System.Windows.VisualState>-Objekten. Eine <xref:System.Windows.VisualState> die eine Auflistung von <xref:System.Windows.Media.Animation.Storyboard> Objekten enthält, die angeben, wie sich das Erscheinungsbild des Steuer Elements ändert, wenn sich das Steuerelement in einem bestimmten Zustand befindet. Beispielsweise kann ein <xref:System.Windows.Controls.Button> etwas anders aussehen, wenn es gedrückt wird, als wenn es nicht gedrückt wird. Zwei Zustände, die die <xref:System.Windows.Controls.Button> definiert, entsprechen, wenn Sie gedrückt wird (`"Pressed"`), und wenn dies nicht der Fall ist (`"Normal"`).  
  
 Sie fügen <xref:System.Windows.VisualState> einem Steuerelement hinzu, indem Sie die <xref:System.Windows.VisualStateManager.VisualStateGroups%2A> angefügte-Eigenschaft für das Steuerelement festlegen. Sie können Zustände, die sich gegenseitig ausschließen, in derselben <xref:System.Windows.VisualStateGroup>platzieren. Beispielsweise verfügt die <xref:System.Windows.Controls.CheckBox> über zwei <xref:System.Windows.VisualStateGroup> Objekte. Eine enthält die Zustände, `Normal`, `MouseOver`, `Pressed`und `Disabled`. Der andere enthält die Zustände, `Checked`, `UnChecked`und `Indeterminate`. Die <xref:System.Windows.Controls.CheckBox> können sich in Status `MouseOver` und gleichzeitig `UnChecked` befinden, Sie können sich jedoch nicht gleichzeitig in den `MouseOver`-und `Pressed` Zuständen befinden.  
  
 Obwohl Sie jedem Element <xref:System.Windows.VisualState> Objekte hinzufügen können, ist dies eine besonders nützliche Methode, mit der andere das visuelle Verhalten einer <xref:System.Windows.Controls.Control>neu definieren können. Wenn Sie ein benutzerdefiniertes Steuerelement erstellen, das eine <xref:System.Windows.Controls.ControlTemplate>verwendet, können Sie angeben, in welchen Zuständen sich das Steuerelement befinden kann, indem Sie eine <xref:System.Windows.TemplateVisualStateAttribute> in seiner Klassendefinition hinzufügen. Dann kann jeder Benutzer, der eine neue <xref:System.Windows.Controls.ControlTemplate> für das Steuerelement erstellt, <xref:System.Windows.VisualState> Objekte zur Vorlage hinzufügen. Zustände mit dem gleichen <xref:System.Windows.TemplateVisualStateAttribute.GroupName%2A?displayProperty=fullName> gehören zum gleichen <xref:System.Windows.VisualStateGroup>.  
  
 Weitere Informationen zur Verwendung von <xref:System.Windows.VisualStateGroup> Objekten in einem <xref:System.Windows.Controls.ControlTemplate>finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control). Weitere Informationen zum Erstellen von Steuerelementen, die die <xref:System.Windows.VisualStateManager>verwenden, finden Sie unter [Erstellen eines Steuer Elements, das eine anpassbare Darstellung hat](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
     
## Examples  
 Im folgenden Beispiel wird eine einfache <xref:System.Windows.Controls.ControlTemplate> für einen <xref:System.Windows.Controls.Button> erstellt, der einen <xref:System.Windows.Controls.Grid>enthält. Sie enthält auch einen <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates`, der die `MouseOver` und `Normal` Zustände definiert. Der <xref:System.Windows.VisualStateGroup> verfügt auch über eine <xref:System.Windows.VisualTransition>, die angibt, dass es eine halbe Sekunde dauert, bis der <xref:System.Windows.Controls.Grid> von Grün in rot wechselt, wenn der Benutzer den Mauszeiger über die <xref:System.Windows.Controls.Button>bewegt.  
  
 [!code-xaml[VSMButtonTemplate#11](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmbuttontemplate/csharp/window1.xaml#11)]
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
