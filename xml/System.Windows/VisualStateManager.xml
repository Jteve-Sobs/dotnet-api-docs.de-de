<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="383e291c4cf1fb0fe8e2201dec79c44332c74853" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36455979" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet Zustände und die Logik für Übergänge zwischen Zuständen für Steuerelemente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.VisualStateManager> ermöglicht es Ihnen, Zustände für ein Steuerelement, das die Darstellung eines Steuerelements angeben, wenn es in einem bestimmten Zustand befindet, und wenn ein Steuerelement Zustände ändert. Angenommen, ein <xref:System.Windows.Controls.Button> möglicherweise eine etwas andere Darstellung aus, wenn sie als gedrückt wird, wenn er nicht gedrückt wird. Mit zwei Zuständen, die die <xref:System.Windows.Controls.Button> definiert entsprechen, wenn es gedrückt wird (`"Pressed"`) und wenn es keine ist (`"Normal"`). Die Darstellung eines Steuerelements, wenn es in einem Zustand befindet, wird durch definiert eine <xref:System.Windows.VisualState>. Ein <xref:System.Windows.VisualState> enthält eine Auflistung von <xref:System.Windows.Media.Animation.Storyboard> Objekten, die angeben, wie die Darstellung des Steuerelements ändert, wenn das Steuerelement in diesem Zustand befindet. Sie können visuelle Zustände auf ein Steuerelement hinzufügen, indem die `VisualStateManager.VisualStateGroups` angefügte Eigenschaft für das Steuerelement. Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von <xref:System.Windows.VisualState> Objekte, die sich gegenseitig ausschließende sind. D. h. das Steuerelement ist immer in genau einem Zustand, der in den einzelnen <xref:System.Windows.VisualStateGroup>.  
  
 Die <xref:System.Windows.VisualStateManager> auch können Sie angeben, wenn ein Steuerelement in einem bestimmten Zustand eintritt. Die Methode, die Änderung seines Zustands aufgerufen werden soll, hängt von Ihrem Szenario ab. Wenn Sie ein Steuerelement erstellen, verwendet die <xref:System.Windows.VisualStateManager> in seiner <xref:System.Windows.Controls.ControlTemplate>, rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode. Weitere Informationen über das Erstellen, bei denen Steuerelementen die <xref:System.Windows.VisualStateManager>, finden Sie unter [erstellen ein Steuerelement verfügt, eine anpassbare Darstellung](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md). Bei Verwendung von der <xref:System.Windows.VisualStateManager> außerhalb von eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung eine <xref:System.Windows.VisualStateManager> in eine <xref:System.Windows.Controls.UserControl> oder in ein einzelnes Element), rufen Sie die <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode. In beiden Fällen die <xref:System.Windows.VisualStateManager> führt die Logik, die erforderlich sind, entsprechend starten und beenden die Storyboards, die dem betreffenden Zustand zugeordnet sind. Nehmen wir beispielsweise an, dass ein Steuerelement die Zustände definiert `State1` und `State2`, von denen jeder ein Storyboard zugeordnet wurde. Wenn das Steuerelement in `State1` und übergeben Sie `State2` auf <xref:System.Windows.VisualStateManager.GoToState%2A> oder <xref:System.Windows.VisualStateManager.GoToElementState%2A>, <xref:System.Windows.VisualStateManager> startet das Storyboard im `State2` und beendet das Storyboard in `State1`.  
  
 Steuerelemente, die in enthaltenen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] verwenden die <xref:System.Windows.VisualStateManager> visuelle Zustände zu ändern. Beim Erstellen einer <xref:System.Windows.Controls.ControlTemplate> für ein Steuerelement, das enthalten ist [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], können Sie hinzufügen <xref:System.Windows.VisualState> Objekte an des Steuerelements <xref:System.Windows.Controls.ControlTemplate> an die Darstellung des Steuerelements in einem bestimmten Zustand befinden. Um die Namen der visuellen Zustände für die Steuerelemente zu suchen, die in enthaltenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], finden Sie unter [Steuerelementstile und Vorlagen](~/docs/framework/wpf/controls/control-styles-and-templates.md). Definieren Sie das Steuerelement Logik behandelt, die sich im Übergang zwischen Zuständen an, damit Sie nicht benötigen, nichts zu tun außer der <xref:System.Windows.VisualState> Objekte in der neuen <xref:System.Windows.Controls.ControlTemplate>. Weitere Informationen über das Erstellen von Steuerelementvorlagen für vorhandene Steuerelemente finden Sie unter [Anpassen der Darstellung von einem vorhandenen Steuerelement durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
 Wenn Sie Ihre eigene Logik für den Übergang zwischen Zuständen implementieren möchten, müssen Sie erben von <xref:System.Windows.VisualStateManager>, überschreiben die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> -Methode, und legen die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> -Eigenschaft auf das Steuerelement, das die benutzerdefinierte Logik verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Shapes.Rectangle> und fügt eine <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates` auf die `VisualStateManager.VisualStatesGroups` -Eigenschaft. Im Beispiel definiert die `MouseOver` und `Normal` <xref:System.Windows.VisualState> Objekte in der `CommonStates` <xref:System.Windows.VisualStateGroup>. Wenn der Benutzer den Mauszeiger über die <xref:System.Windows.Shapes.Rectangle>, er wechselt von Rot, Grün eine halbe Sekunde. Wenn der Benutzer die Maus von dem Rechteck weg bewegt die <xref:System.Windows.Controls.Grid> sofort zu rot zurück. Beachten Sie, dass die `Normal` Status ist nicht definiert. eine <xref:System.Windows.Media.Animation.Storyboard>. Ein <xref:System.Windows.Media.Animation.Storyboard> ist nicht erforderlich, da bei der <xref:System.Windows.Shapes.Rectangle> Übergang von der `MouseOver` Zustands, in der `Normal` Zustand, der <xref:System.Windows.Media.Animation.Storyboard> für `MouseOver` wird beendet und die <xref:System.Windows.Media.SolidColorBrush.Color%2A> -Eigenschaft für die <xref:System.Windows.Media.SolidColorBrush> gibt in Rot.  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 Das folgende Beispiel zeigt die Ereignishandler, die im vorherigen Beispiel und Aufrufe definiert ist die <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode für den Übergang zwischen Zuständen. Das Rechteck im vorherigen Beispiel wurde Teil einer <xref:System.Windows.Controls.ControlTemplate>, müsste im Beispiel zum Aufrufen der <xref:System.Windows.VisualStateManager.GoToState%2A> Methode.  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.VisualStateManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft ab.</summary>
        <returns>Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft ab.</summary>
        <returns>Die Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten, die dem angegebenen Objekt zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions">
          <see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen zwei Zuständen des Elements. Verwenden Sie diese Methode zum Wechseln von Zuständen, die von einer Anwendung und nicht von einem Steuerelement definiert werden.</summary>
        <returns>
          <see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.VisualStateManager.GoToElementState%2A> -Methode ändern, Zustände für ein Element außerhalb des eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung einer <xref:System.Windows.VisualStateManager> in einer <xref:System.Windows.DataTemplate> oder <xref:System.Windows.Window>). Rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode, wenn Sie die Zustände, in einem Steuerelement ändern, die verwendet die <xref:System.Windows.VisualStateManager> in seiner <xref:System.Windows.Controls.ControlTemplate>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Anwendung, die den Benutzer auffordert, eine Zahl zwischen 1 und 100 zu erraten.  Wenn der Benutzer eine Zahl eingibt, überprüfen, ob die Anwendung die Schätzung zu hoch, Niedrig oder richtig ist.  Die folgenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] die Benutzeroberfläche für die Anwendung erstellt und definiert 4 Zustände: `TooLow`, `TooHigh`, `Correct`, und `Guessing`. Wenn die Anwendung beginnt, wird Sie der `Guessing` Zustand. sein.  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 Der folgende Code zeigt die Logik der Anwendung.  Wenn der Benutzer eine Zahl eingibt und auf die Schaltfläche klickt, ruft die Anwendung <xref:System.Windows.VisualStateManager.GoToElementState%2A> für den Übergang in `TooHigh`, `TooLow`, oder `Correct` zum Bereitstellen von Feedback für den Benutzer zu den zu erratenden Wert.  Rufen Sie zum Testen dieses Beispiels die `GenerateNumber` Methode, wenn die Anwendung beginnt.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> ist <see langword="null" />.  Oder:  <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions">
          <see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Führt Übergang des Steuerelements von einem Zustand in einen anderen durch. Verwenden Sie diese Methode für Übergänge zwischen Zuständen in Steuerelementen mit <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>
          <see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode, wenn Sie die Zustände, in einem Steuerelement ändern, die verwendet die <xref:System.Windows.VisualStateManager> in seiner <xref:System.Windows.Controls.ControlTemplate>. Aufrufen der <xref:System.Windows.VisualStateManager.GoToElementState%2A> -Methode ändern, Zustände für ein Element außerhalb des eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung einer <xref:System.Windows.VisualStateManager> in einer <xref:System.Windows.Controls.UserControl> oder in ein einzelnes Element).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Steuerelement, verwendet die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode für den Übergang zwischen Zuständen. Das vollständige Beispiel finden Sie unter [erstellen ein Steuerelement, hat eine anpassbare Darstellung](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> ist <see langword="null" />.  Oder:  <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Name des Zustands, in den gewechselt werden soll.</param>
        <param name="group">Die <see cref="T:System.Windows.VisualStateGroup" />, zu der der Zustand gehört.</param>
        <param name="state">Die Darstellung des Zustands, in den gewechselt werden soll.</param>
        <param name="useTransitions">
          <see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen den Zuständen eines Steuerelements.</summary>
        <returns>
          <see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> -Methode führt die Logik zum entsprechend starten und beenden die Storyboards, die bei einem Übergang zugeordnet sind. Wenn ein Steuerelement ruft <xref:System.Windows.VisualStateManager.GoToState%2A> so ändern Sie den Zustand der <xref:System.Windows.VisualStateManager> bewirkt Folgendes:  
  
-   Wenn zunächst die <xref:System.Windows.VisualState> hat, dass das Steuerelement wechselt ein <xref:System.Windows.Media.Animation.Storyboard>, beginnt das Storyboard. Wenn danach die <xref:System.Windows.VisualState> hat, dass das Steuerelement von stammt eine <xref:System.Windows.Media.Animation.Storyboard>, das Storyboard beendet.  
  
-   Wenn das Steuerelement bereits in der `stateName` Zustand <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus, und gibt `true`.  
  
-   Wenn `stateName` ist nicht in der <xref:System.Windows.Controls.ControlTemplate> von `control`, <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus, und gibt `false`.  
  
 Eigene implementieren <xref:System.Windows.VisualStateManager> abweichender Logik für den Übergang zwischen Zuständen bereitstellen. Beispielsweise können Sie die zuvor beschriebene Logik ändern, oder können Sie Logik für den Übergang zwischen benutzerdefinierten Animationstypen bereitstellen.  Implementiert eine <xref:System.Windows.VisualStateManager>, erstellen Sie eine Klasse, die von erben <xref:System.Windows.VisualStateManager> und überschreiben die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode. Um die benutzerdefinierte Klasse zu verwenden, legen die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> Eigenschaft auf ein Objekt des benutzerdefinierten Typs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Windows.VisualStateGroup> festgelegt ist, auf die <xref:System.Windows.Controls.ControlTemplate> eines Steuerelements, der `control` Parametersatz an das Steuerelement, das Besitzer ist <xref:System.Windows.Controls.ControlTemplate>.  Wenn die <xref:System.Windows.VisualStateGroup> festgelegt ist, auf eine <xref:System.Windows.FrameworkElement>, `control` ist `null` und Sie sollten mit der `stateGroupsRoot` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> ist <see langword="null" />.  Oder:  <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Windows.VisualStateGroup> festgelegt ist, auf die <xref:System.Windows.Controls.ControlTemplate> eines Steuerelements, der `control` Parametersatz an das Steuerelement, das Besitzer ist <xref:System.Windows.Controls.ControlTemplate>.  Wenn die <xref:System.Windows.VisualStateGroup> festgelegt ist, auf eine <xref:System.Windows.FrameworkElement>, `control` ist `null` und Sie sollten mit der `stateGroupsRoot` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> ist <see langword="null" />.  Oder:  <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Eigenschaft festgelegt werden soll.</param>
        <param name="value">Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</param>
        <summary>Legt die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>