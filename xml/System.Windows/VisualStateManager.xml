<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="35742499f30807757f43a54d28040e1a8c8a7bc5" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86696944" /></Metadata><TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet Zustände und die Logik für Übergänge zwischen Zuständen für Steuerelemente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.VisualStateManager>Ermöglicht es Ihnen, Zustände für ein Steuerelement anzugeben, das Aussehen eines Steuer Elements, wenn es sich in einem bestimmten Zustand befindet, und wenn sich ein-Steuerelement ändert. Beispielsweise kann eine <xref:System.Windows.Controls.Button> etwas anderes Aussehen, wenn Sie gedrückt wird, als wenn Sie nicht gedrückt wird. Zwei Zustände, denen das <xref:System.Windows.Controls.Button> definiert, wenn es gedrückt wird ( `"Pressed"` ), und wenn es nicht ist ( `"Normal"` ). Die Darstellung eines-Steuer Elements, wenn es sich in einem-Zustand befindet, wird von einem definiert <xref:System.Windows.VisualState> . Eine <xref:System.Windows.VisualState> enthält eine Auflistung von- <xref:System.Windows.Media.Animation.Storyboard> Objekten, die angeben, wie sich die Darstellung des Steuer Elements ändert, wenn sich das Steuerelement in diesem Zustand befindet. Sie fügen einem Steuerelement visuelle Zustände hinzu, indem Sie die `VisualStateManager.VisualStateGroups` angefügte-Eigenschaft für das Steuerelement festlegen. Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von- <xref:System.Windows.VisualState> Objekten, die sich gegenseitig ausschließen. Das heißt, das Steuerelement befindet sich immer in genau einem Zustand von in jedem <xref:System.Windows.VisualStateGroup> .  
  
 <xref:System.Windows.VisualStateManager>Mit können Sie auch angeben, wann ein Steuerelement in einen bestimmten Zustand wechselt. Die Methode, die Sie zum Ändern von Zuständen aufruft, hängt von Ihrem Szenario ab. Wenn Sie ein Steuerelement erstellen, das <xref:System.Windows.VisualStateManager> in seinem verwendet <xref:System.Windows.Controls.ControlTemplate> , rufen Sie die- <xref:System.Windows.VisualStateManager.GoToState%2A> Methode auf. Weitere Informationen zum Erstellen von Steuerelementen, die verwenden <xref:System.Windows.VisualStateManager> , finden Sie unter [Erstellen eines Steuer Elements, das über eine anpassbare Darstellung verfügt](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance). Wenn Sie den <xref:System.Windows.VisualStateManager> außerhalb eines- <xref:System.Windows.Controls.ControlTemplate> Elements verwenden (z. b., wenn Sie <xref:System.Windows.VisualStateManager> in einem <xref:System.Windows.Controls.UserControl> oder in einem einzelnen-Element verwenden), müssen Sie die-Methode aufzurufen <xref:System.Windows.VisualStateManager.GoToElementState%2A> . In beiden Fällen führt die Logik aus, die <xref:System.Windows.VisualStateManager> erforderlich ist, um die Storyboards, die dem Beteiligten Zustand zugeordnet sind, ordnungsgemäß zu starten und zu unterbinden. Angenommen, ein-Steuerelement definiert die Zustände `State1` und `State2` , denen jeweils ein Storyboard zugeordnet ist. Wenn sich das Steuerelement in befindet `State1` und Sie `State2` an <xref:System.Windows.VisualStateManager.GoToState%2A> oder übergeben <xref:System.Windows.VisualStateManager.GoToElementState%2A> , startet das <xref:System.Windows.VisualStateManager> Storyboard in `State2` und beendet das Storyboard in `State1` .  
  
 In enthaltene Steuerelemente [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] verwenden das <xref:System.Windows.VisualStateManager> , um visuelle Zustände zu ändern. Wenn Sie ein <xref:System.Windows.Controls.ControlTemplate> -Steuerelement für ein Steuerelement erstellen, das in enthalten ist [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , können Sie <xref:System.Windows.VisualState> -Objekte dem des-Steuer Elements hinzufügen, <xref:System.Windows.Controls.ControlTemplate> um die Darstellung des Steuer Elements in einem bestimmten Zustand anzugeben. Informationen zu den Namen der visuellen Zustände für die Steuerelemente, die in enthalten sind, finden Sie unter [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [Steuerelement Stile und-Vorlagen](/dotnet/framework/wpf/controls/control-styles-and-templates). Die Logik des Steuer Elements behandelt den Übergang zwischen Zuständen, sodass Sie keine anderen Aktionen ausführen müssen, als die <xref:System.Windows.VisualState> Objekte in der neuen zu definieren <xref:System.Windows.Controls.ControlTemplate> . Weitere Informationen zum Erstellen von Steuerelement Vorlagen für vorhandene Steuerelemente finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control).  
  
 Wenn Sie Ihre eigene Logik für den Übergang zwischen Zuständen implementieren möchten, müssen Sie von Erben <xref:System.Windows.VisualStateManager> , die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> -Methode überschreiben und die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> angefügte-Eigenschaft für das Steuerelement festlegen, das die benutzerdefinierte Logik verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.Windows.Shapes.Rectangle> und <xref:System.Windows.VisualStateGroup> `CommonStates` der angefügten-Eigenschaft ein mit der Bezeichnung hinzugefügt `VisualStateManager.VisualStatesGroups` . Im Beispiel werden das `MouseOver` -Objekt und das- `Normal` <xref:System.Windows.VisualState> Objekt in der definiert `CommonStates` <xref:System.Windows.VisualStateGroup> . Wenn der Benutzer den Mauszeiger über den bewegt <xref:System.Windows.Shapes.Rectangle> , wird er über eine halbe Sekunde von rot in Grün geändert. Wenn der Benutzer den Mauszeiger aus dem Rechteck bewegt, <xref:System.Windows.Controls.Grid> ändert sich sofort wieder in rot. Beachten Sie, dass der- `Normal` Zustand keine definiert <xref:System.Windows.Media.Animation.Storyboard> . Eine <xref:System.Windows.Media.Animation.Storyboard> ist nicht erforderlich, da die <xref:System.Windows.Shapes.Rectangle> für den Übergang vom- `MouseOver` Zustand in den `Normal` <xref:System.Windows.Media.Animation.Storyboard> -Zustand `MouseOver` beendet wird und die- <xref:System.Windows.Media.SolidColorBrush.Color%2A> Eigenschaft für den an den roten Wert zurückgegeben wird <xref:System.Windows.Media.SolidColorBrush> .  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 Das folgende Beispiel zeigt den Ereignishandler, der im vorherigen Beispiel definiert wurde, und ruft die- <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode auf, um zwischen Zuständen zu wechseln. Wenn das Rechteck im vorherigen Beispiel Teil eines <xref:System.Windows.Controls.ControlTemplate> ist, müsste das Beispiel die-Methode aufzurufen <xref:System.Windows.VisualStateManager.GoToState%2A> .  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.VisualStateManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.VisualStateManager" />-Objekt ab, das zwischen den Zuständen eines Steuerelements wechselt, oder legt dieses fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> ist `null` , <xref:System.Windows.VisualStateManager> verwendet die eigene Logik, um zwischen Zuständen zu wechseln. Wenn Sie Ihre eigene Logik für den Übergang zwischen Zuständen implementieren möchten, erstellen Sie eine Klasse, die von erbt, <xref:System.Windows.VisualStateManager> und überschreiben Sie die- <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode. Wenn Sie die benutzerdefinierte Klasse verwenden möchten, legen Sie die- <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> Eigenschaft auf ein Objekt des benutzerdefinierten Typs fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft ab.</summary>
        <returns>Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft ab.</summary>
        <returns>Die Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten, die dem angegebenen Objekt zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen zwei Zuständen des Elements. Verwenden Sie diese Methode zum Wechseln von Zuständen, die von einer Anwendung und nicht von einem Steuerelement definiert werden.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.VisualStateManager.GoToElementState%2A>Verwenden Sie die-Methode, um Zustände für ein Element außerhalb eines-Elements zu ändern <xref:System.Windows.Controls.ControlTemplate> (z. b., wenn Sie <xref:System.Windows.VisualStateManager> in einem oder einem verwenden <xref:System.Windows.DataTemplate> <xref:System.Windows.Window> ). Ruft die- <xref:System.Windows.VisualStateManager.GoToState%2A> Methode auf, wenn Sie Zustände in einem Steuerelement ändern, das in der verwendet <xref:System.Windows.VisualStateManager> <xref:System.Windows.Controls.ControlTemplate> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Anwendung erstellt, die den Benutzer auffordert, eine Zahl zwischen 1 und 100 zu erraten.  Wenn der Benutzer eine Zahl eingibt, gibt die Anwendung an, ob der Schätzwert zu hoch, zu niedrig oder richtig ist.  Im folgenden wird [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] die Benutzeroberfläche für die Anwendung erstellt und 4 Zustände definiert: `TooLow` , `TooHigh` , `Correct` und `Guessing` . Wenn die Anwendung beginnt, befindet Sie sich im- `Guessing` Zustand. .  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 Der folgende Code zeigt die Logik der Anwendung.  Wenn der Benutzer eine Zahl eingibt und auf die Schaltfläche klickt, ruft die Anwendung <xref:System.Windows.VisualStateManager.GoToElementState%2A> für den Übergang zu `TooHigh` , oder auf, `TooLow` `Correct` um dem Benutzer Feedback über den Schätzwert zu geben.  Um dieses Beispiel zu testen, wenden Sie die-Methode an, `GenerateNumber` Wenn die Anwendung startet.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateName">Der Zustand, in den der Übergang durchgeführt wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Führt Übergang des Steuerelements von einem Zustand in einen anderen durch. Verwenden Sie diese Methode für Übergänge zwischen Zuständen in Steuerelementen mit <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die- <xref:System.Windows.VisualStateManager.GoToState%2A> Methode auf, wenn Sie Zustände in einem Steuerelement ändern, das in der verwendet <xref:System.Windows.VisualStateManager> <xref:System.Windows.Controls.ControlTemplate> . <xref:System.Windows.VisualStateManager.GoToElementState%2A>Verwenden Sie die-Methode, um Zustände für ein Element außerhalb eines-Elements zu ändern <xref:System.Windows.Controls.ControlTemplate> (z. b., wenn Sie <xref:System.Windows.VisualStateManager> in einem <xref:System.Windows.Controls.UserControl> oder in einem einzelnen-Element verwenden).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Steuerelement veranschaulicht, das die- <xref:System.Windows.VisualStateManager.GoToState%2A> Methode verwendet, um zwischen Zuständen zu wechseln. Das gesamte Beispiel finden Sie unter [Erstellen eines Steuer Elements, das über eine anpassbare Darstellung verfügt](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Name des Zustands, in den gewechselt werden soll.</param>
        <param name="group">Die <see cref="T:System.Windows.VisualStateGroup" />, zu der der Zustand gehört.</param>
        <param name="state">Die Darstellung des Zustands, in den gewechselt werden soll.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen den Zuständen eines Steuerelements.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode führt die erforderliche Logik aus, um die einem Übergang zugeordneten Storyboards ordnungsgemäß zu starten und zu unterbinden. Wenn ein-Steuerelement aufruft, <xref:System.Windows.VisualStateManager.GoToState%2A> um seinen Zustand zu ändern, führt die folgende Aktionen aus <xref:System.Windows.VisualStateManager> :  
  
-   Zuerst wird das Storyboard gestartet, wenn die, <xref:System.Windows.VisualState> zu der das-Steuerelement übergeht, eine hat <xref:System.Windows.Media.Animation.Storyboard> . Wenn dann das, <xref:System.Windows.VisualState> von dem das Steuerelement stammt, über eine verfügt <xref:System.Windows.Media.Animation.Storyboard> , wird das Storyboard beendet.  
  
-   Wenn sich das Steuerelement bereits im `stateName` -Zustand befindet, <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus und gibt zurück `true` .  
  
-   Wenn `stateName` nicht in der vorhanden <xref:System.Windows.Controls.ControlTemplate> `control` ist, <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus und gibt zurück `false` .  
  
 Sie können eigene implementieren <xref:System.Windows.VisualStateManager> , um eine andere Logik für den Übergang zwischen Zuständen bereitzustellen. Beispielsweise können Sie die zuvor beschriebene Logik ändern, oder Sie können eine Logik für den Übergang zwischen benutzerdefinierten Animations Typen bereitstellen.  Um einen zu implementieren <xref:System.Windows.VisualStateManager> , erstellen Sie eine Klasse, die von erbt, <xref:System.Windows.VisualStateManager> und überschreiben die- <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode. Wenn Sie die benutzerdefinierte Klasse verwenden möchten, legen Sie die- <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> Eigenschaft auf ein Objekt des benutzerdefinierten Typs fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.VisualStateGroup> für die eines-Steuer Elements festgelegt wird <xref:System.Windows.Controls.ControlTemplate> , `control` wird der-Parameter auf das Steuerelement festgelegt, das besitzt <xref:System.Windows.Controls.ControlTemplate> .  Wenn <xref:System.Windows.VisualStateGroup> auf festgelegt wird <xref:System.Windows.FrameworkElement> , `control` ist, `null` und Sie sollten den- `stateGroupsRoot` Parameter verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse sicher, dass die-Methode der Basisklasse aufgerufen wird, <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.VisualStateGroup> für die eines-Steuer Elements festgelegt wird <xref:System.Windows.Controls.ControlTemplate> , `control` wird der-Parameter auf das Steuerelement festgelegt, das besitzt <xref:System.Windows.Controls.ControlTemplate> .  Wenn <xref:System.Windows.VisualStateGroup> auf festgelegt wird <xref:System.Windows.FrameworkElement> , `control` ist, `null` und Sie sollten den- `stateGroupsRoot` Parameter verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse sicher, dass die-Methode der Basisklasse aufgerufen wird, <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Eigenschaft festgelegt werden soll.</param>
        <param name="value">Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</param>
        <summary>Legt die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroups">
      <MemberSignature Language="C#" Value="see GetVisualStateGroups" />
      <MemberSignature Language="ILAsm" Value="see GetVisualStateGroups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.VisualStateGroups" />
      <MemberSignature Language="VB.NET" Value="see GetVisualStateGroups" />
      <MemberSignature Language="F#" Value="see GetVisualStateGroups" Usage="see GetVisualStateGroups" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten ab oder legt diese fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks  
 Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von- <xref:System.Windows.VisualState> Objekten. Eine <xref:System.Windows.VisualState> enthält eine Auflistung von- <xref:System.Windows.Media.Animation.Storyboard> Objekten, die angeben, wie sich das Erscheinungsbild des Steuer Elements ändert, wenn sich das Steuerelement in einem bestimmten Zustand befindet. Beispielsweise kann eine <xref:System.Windows.Controls.Button> etwas anderes Aussehen, wenn Sie gedrückt wird, als wenn Sie nicht gedrückt wird. Zwei Zustände, denen das <xref:System.Windows.Controls.Button> definiert, wenn es gedrückt wird ( `"Pressed"` ), und wenn es nicht ist ( `"Normal"` ).  
  
 Sie fügen <xref:System.Windows.VisualState> einem Steuerelement hinzu, indem Sie die <xref:System.Windows.VisualStateManager.VisualStateGroups%2A> angefügte-Eigenschaft für das Steuerelement festlegen. Sie legen Zustände fest, die sich gegenseitig ausschließen <xref:System.Windows.VisualStateGroup> . Beispielsweise <xref:System.Windows.Controls.CheckBox> verfügt über zwei- <xref:System.Windows.VisualStateGroup> Objekte. Eine enthält die Zustände,,, `Normal` `MouseOver` `Pressed` und `Disabled` . Der andere enthält die Zustände, `Checked` , `UnChecked` und `Indeterminate` . <xref:System.Windows.Controls.CheckBox>Kann sich in einem Status `MouseOver` und `UnChecked` gleichzeitig befinden, kann aber nicht gleichzeitig in den `MouseOver` Zuständen und sein `Pressed` .  
  
 Obwohl Sie-Objekte einem beliebigen-Element hinzufügen können, ist dies <xref:System.Windows.VisualState> eine besonders nützliche Methode, um anderen die Möglichkeit zu bieten, das visuelle Verhalten von zu definieren <xref:System.Windows.Controls.Control> . Wenn Sie ein benutzerdefiniertes Steuerelement erstellen, das ein-Element verwendet <xref:System.Windows.Controls.ControlTemplate> , können Sie angeben, in welchen Zuständen sich das Steuerelement befinden kann <xref:System.Windows.TemplateVisualStateAttribute> . Dann kann jeder, der einen neuen <xref:System.Windows.Controls.ControlTemplate> für das Steuerelement erstellt, <xref:System.Windows.VisualState> der Vorlage Objekte hinzufügen. Zustände mit dem gleichen <xref:System.Windows.TemplateVisualStateAttribute.GroupName%2A?displayProperty=fullName> gehören zu demselben <xref:System.Windows.VisualStateGroup> .  
  
 Weitere Informationen zum Verwenden von- <xref:System.Windows.VisualStateGroup> Objekten in einem <xref:System.Windows.Controls.ControlTemplate> finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuer Elements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control). Weitere Informationen zum Erstellen von Steuerelementen, die verwenden <xref:System.Windows.VisualStateManager> , finden Sie unter [Erstellen eines Steuer Elements, das über eine anpassbare Darstellung verfügt](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
     
## Examples  
 Im folgenden Beispiel wird ein einfaches <xref:System.Windows.Controls.ControlTemplate> für einen erstellt, der einen <xref:System.Windows.Controls.Button> enthält <xref:System.Windows.Controls.Grid> . Sie enthält auch einen <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates` , der `MouseOver` die `Normal` Zustände und definiert. Der <xref:System.Windows.VisualStateGroup> verfügt auch über einen <xref:System.Windows.VisualTransition> , der angibt, dass es eine halbe Sekunde dauert, <xref:System.Windows.Controls.Grid> bis die von Grün in rot wechselt, wenn der Benutzer den Mauszeiger über den bewegt <xref:System.Windows.Controls.Button> .  
  
 [!code-xaml[VSMButtonTemplate#11](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmbuttontemplate/csharp/window1.xaml#11)]
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
