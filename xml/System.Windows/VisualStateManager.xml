<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdf6939baf9f6829fba034b5c7ae0428da81c32f" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59503566" /></Metadata><TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet Zustände und die Logik für Übergänge zwischen Zuständen für Steuerelemente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.VisualStateManager> ermöglicht es Ihnen, die Zustände für ein Steuerelement, das die Darstellung eines Steuerelements angeben, wenn es in einem bestimmten Zustand befindet, und wenn ein Steuerelement den Status ändert. Z. B. eine <xref:System.Windows.Controls.Button> möglicherweise ein geringfügig anderes Aussehen, wenn es als gedrückt wird, wenn es nicht gedrückt wird. Mit zwei Zuständen, die die <xref:System.Windows.Controls.Button> definiert entsprechen, wenn es gedrückt wird (`"Pressed"`) und wann ist nicht (`"Normal"`). Die Darstellung eines Steuerelements, wenn es in einem Zustand befindet, wird durch definiert eine <xref:System.Windows.VisualState>. Ein <xref:System.Windows.VisualState> enthält eine Auflistung von <xref:System.Windows.Media.Animation.Storyboard> Objekte, die angeben, wie die Darstellung des Steuerelements ändert, wenn das Steuerelement in diesem Zustand ist. Hinzufügen von visuellen Zuständen zu einem Steuerelement durch Festlegen der `VisualStateManager.VisualStateGroups` angefügte Eigenschaft für das Steuerelement. Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von <xref:System.Windows.VisualState> Objekte, die sich gegenseitig ausschließende sind. D. h. das Steuerelement ist stets in genau einem Zustand, der in den einzelnen <xref:System.Windows.VisualStateGroup>.  
  
 Die <xref:System.Windows.VisualStateManager> können Sie angeben, wenn ein Steuerelement einen bestimmten Zustand wechselt. Die Methode, die Sie zum Ändern von Zuständen aufrufen sollte, hängt von Ihrem Szenario ab. Wenn Sie ein Steuerelement erstellen, verwendet der <xref:System.Windows.VisualStateManager> in seine <xref:System.Windows.Controls.ControlTemplate>, rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode. Weitere Informationen über das Erstellen mit Steuerelementen die <xref:System.Windows.VisualStateManager>, finden Sie unter [erstellen ein Steuerelement verfügt, einer anpassbaren Darstellung](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md). Bei Verwendung der <xref:System.Windows.VisualStateManager> außerhalb von eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung einer <xref:System.Windows.VisualStateManager> in eine <xref:System.Windows.Controls.UserControl> oder in ein einzelnes Element), Aufrufen der <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode. In beiden Fällen die <xref:System.Windows.VisualStateManager> führt die Logik, die erforderlich sind, entsprechend starten und beenden die Storyboards, die dem betreffenden Zustand zugeordnet sind. Nehmen wir beispielsweise an, dass ein Steuerelement die Bundesstaaten definiert `State1` und `State2`, von denen jeder ein Storyboard zugeordnet ist. Wenn das Steuerelement im `State1` und übergeben Sie `State2` zu <xref:System.Windows.VisualStateManager.GoToState%2A> oder <xref:System.Windows.VisualStateManager.GoToElementState%2A>, <xref:System.Windows.VisualStateManager> startet das Storyboard in `State2` und hält das Storyboard in `State1`.  
  
 Steuerelemente, die in enthaltenen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] verwenden die <xref:System.Windows.VisualStateManager> visuelle Zustände zu ändern. Bei der Erstellung einer <xref:System.Windows.Controls.ControlTemplate> für ein Steuerelement, das enthalten ist [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], hinzufügbaren <xref:System.Windows.VisualState> Objekte des Steuerelements <xref:System.Windows.Controls.ControlTemplate> Darstellung des Steuerelements in einem bestimmten Zustand angeben. Um die Namen des visuellen Zustände für die Steuerelemente zu suchen, die in enthaltenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], finden Sie unter [Steuerelementformate und-Vorlagen](~/docs/framework/wpf/controls/control-styles-and-templates.md). Definieren des Steuerelements Logik behandelt den Übergang zwischen Zuständen, damit Sie nicht benötigen, um nichts außer der <xref:System.Windows.VisualState> Objekte in der neuen <xref:System.Windows.Controls.ControlTemplate>. Weitere Informationen zum Erstellen von Steuerelementvorlagen für vorhandene Steuerelemente finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuerelements durch Erstellen einer ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
 Wenn Sie Ihre eigene Logik für Übergänge zwischen Zuständen implementieren möchten, müssen Sie erben von <xref:System.Windows.VisualStateManager>, überschreiben die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> -Methode, und legen die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> angefügte Eigenschaft für das Steuerelement, das die benutzerdefinierte Logik verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Shapes.Rectangle> und fügt eine <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates` auf die `VisualStateManager.VisualStatesGroups` angefügte Eigenschaft. Das Beispiel definiert die `MouseOver` und `Normal` <xref:System.Windows.VisualState> Objekte in der `CommonStates` <xref:System.Windows.VisualStateGroup>. Wenn der Benutzer den Mauszeiger verschiebt, über die <xref:System.Windows.Shapes.Rectangle>, es ändert von Rot zu Grün über eine halbe Sekunde. Wenn der Benutzer die Maus von Rechtecks richtet die <xref:System.Windows.Controls.Grid> sofort zu rot zurück. Beachten Sie, dass die `Normal` Zustand werden keine definiert eine <xref:System.Windows.Media.Animation.Storyboard>. Ein <xref:System.Windows.Media.Animation.Storyboard> ist nicht erforderlich, da bei der <xref:System.Windows.Shapes.Rectangle> wechselt von der `MouseOver` Zustand der `Normal` Zustand der <xref:System.Windows.Media.Animation.Storyboard> für `MouseOver` wird beendet und die <xref:System.Windows.Media.SolidColorBrush.Color%2A> -Eigenschaft für die <xref:System.Windows.Media.SolidColorBrush> gibt auf Rot.  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 Das folgende Beispiel zeigt den Ereignishandler, der im vorherigen Beispiel und ruft definiert, ist die <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode zum Wechseln zwischen Zuständen. Wenn das Rechteck im vorherigen Beispiel Teil war eine <xref:System.Windows.Controls.ControlTemplate>, im Beispiel müssten Aufrufen der <xref:System.Windows.VisualStateManager.GoToState%2A> Methode.  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.VisualStateManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.VisualStateManager" />-Objekt ab, das zwischen den Zuständen eines Steuerelements wechselt, oder legt dieses fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> ist `null`, <xref:System.Windows.VisualStateManager> ihrer eigenen Logik für den Übergang zwischen Zuständen verwendet. Wenn Sie Ihre eigene Logik für Übergänge zwischen Zuständen implementieren möchten, erstellen Sie eine Klasse, die von erbt <xref:System.Windows.VisualStateManager> und überschreiben die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode. Um die benutzerdefinierte Klasse zu verwenden, legen die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> Eigenschaft auf ein Objekt des benutzerdefinierten Typs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft ab.</summary>
        <returns>Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Das Element, von dem die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft die angefügte <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Eigenschaft ab.</summary>
        <returns>Die Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten, die dem angegebenen Objekt zugeordnet ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Zustand, in den übergegangen wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen zwei Zuständen des Elements. Verwenden Sie diese Methode zum Wechseln von Zuständen, die von einer Anwendung und nicht von einem Steuerelement definiert werden.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode so ändern Sie Zustände für ein Element außerhalb des eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung einer <xref:System.Windows.VisualStateManager> in eine <xref:System.Windows.DataTemplate> oder <xref:System.Windows.Window>). Rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode, wenn Sie die Zustände in einem Steuerelement ändern, die verwendet die <xref:System.Windows.VisualStateManager> in seine <xref:System.Windows.Controls.ControlTemplate>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Anwendung, die den Benutzer auffordert, eine Zahl zwischen 1 und 100 zu erraten.  Der Benutzer eine Zahl ein, gibt die Anwendung an, ob der Schätzwert zu hoch, Niedrig oder korrekt ist.  Die folgenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] erstellt die Benutzeroberfläche für die Anwendung und 4 Zuständen definiert: `TooLow`, `TooHigh`, `Correct`, und `Guessing`. Wenn die Anwendung beginnt, wird Sie der `Guessing` Zustand. sein.  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 Der folgende Code zeigt die Logik der Anwendung.  Wenn der Benutzer eine Zahl eingegeben und auf die Schaltfläche klickt, ruft die Anwendung <xref:System.Windows.VisualStateManager.GoToElementState%2A> für den Übergang zum `TooHigh`, `TooLow`, oder `Correct` zum Bereitstellen von Feedback an den Benutzer die Schätzung.  Rufen Sie zum Testen dieses Beispiels die `GenerateNumber` Methode, wenn die Anwendung wird gestartet.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateName">Der Zustand, in den übergegangen wird.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Führt Übergang des Steuerelements von einem Zustand in einen anderen durch. Verwenden Sie diese Methode für Übergänge zwischen Zuständen in Steuerelementen mit <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.VisualStateManager.GoToState%2A> Methode, wenn Sie die Zustände in einem Steuerelement ändern, die verwendet die <xref:System.Windows.VisualStateManager> in seine <xref:System.Windows.Controls.ControlTemplate>. Rufen Sie die <xref:System.Windows.VisualStateManager.GoToElementState%2A> Methode so ändern Sie Zustände für ein Element außerhalb des eine <xref:System.Windows.Controls.ControlTemplate> (z. B. bei Verwendung einer <xref:System.Windows.VisualStateManager> in eine <xref:System.Windows.Controls.UserControl> oder in ein einzelnes Element).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Steuerelement, verwendet der <xref:System.Windows.VisualStateManager.GoToState%2A> Methode zum Wechseln zwischen Zuständen. Das vollständige Beispiel finden Sie unter [erstellen ein Steuerelement, dass hat einer anpassbaren Darstellung](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="stateName" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, dessen Zustand gewechselt werden soll.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <param name="stateName">Der Name des Zustands, in den gewechselt werden soll.</param>
        <param name="group">Die <see cref="T:System.Windows.VisualStateGroup" />, zu der der Zustand gehört.</param>
        <param name="state">Die Darstellung des Zustands, in den gewechselt werden soll.</param>
        <param name="useTransitions"><see langword="true" />, wenn ein <see cref="T:System.Windows.VisualTransition" />-Objekt für den Zustandsübergang verwendet werden soll, andernfalls <see langword="false" />.</param>
        <summary>Wechselt zwischen den Zuständen eines Steuerelements.</summary>
        <returns><see langword="true" />, wenn der Zustand des Steuerelements erfolgreich gewechselt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode führt die erforderliche Logik zum ordnungsgemäßen Starten und beenden die Storyboards, die bei einem Übergang zugeordnet sind. Wenn ein Steuerelement ruft <xref:System.Windows.VisualStateManager.GoToState%2A> so ändern Sie seinen Status, der die <xref:System.Windows.VisualStateManager> bewirkt Folgendes:  
  
-   Wenn zunächst die <xref:System.Windows.VisualState> hat, dass das Steuerelement wechselt ein <xref:System.Windows.Media.Animation.Storyboard>, beginnt das Storyboard. Wenn danach die <xref:System.Windows.VisualState> , das Steuerelement stammt verfügt über eine <xref:System.Windows.Media.Animation.Storyboard>, das Storyboard beendet.  
  
-   Wenn das Steuerelement bereits in der `stateName` Zustand <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus und gibt `true`.  
  
-   Wenn `stateName` ist nicht in der <xref:System.Windows.Controls.ControlTemplate> von `control`, <xref:System.Windows.VisualStateManager.GoToState%2A> führt keine Aktion aus und gibt `false`.  
  
 Sie können die implementieren Ihre eigenen <xref:System.Windows.VisualStateManager> abweichender Logik für Übergänge zwischen Zuständen bereitstellen. Beispielsweise können Sie die Logik, die zuvor beschriebenen ändern, oder Sie können die Logik für den Übergang zwischen benutzerdefinierten Animationstypen bereitstellen.  Implementieren einer <xref:System.Windows.VisualStateManager>, erstellen Sie eine Klasse, die von erbt <xref:System.Windows.VisualStateManager> und überschreiben die <xref:System.Windows.VisualStateManager.GoToStateCore%2A> Methode. Um die benutzerdefinierte Klasse zu verwenden, legen die <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> Eigenschaft auf ein Objekt des benutzerdefinierten Typs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Windows.VisualStateGroup> festgelegt ist, auf die <xref:System.Windows.Controls.ControlTemplate> eines Steuerelements, die `control` Parameter festgelegt ist, um das Steuerelement, besitzt <xref:System.Windows.Controls.ControlTemplate>.  Wenn die <xref:System.Windows.VisualStateGroup> festgelegt ist, auf eine <xref:System.Windows.FrameworkElement>, `control` ist `null` und Sie sollten die `stateGroupsRoot` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass die Basisklasse aufrufen <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Das Objekt, für das das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis aufgetreten ist.</param>
        <param name="oldState">Der Zustand, aus dem das Steuerelement wechselt.</param>
        <param name="newState">Der Zustand, in den das Steuerelement wechselt.</param>
        <param name="control">Das Steuerelement, dessen Zustände gewechselt werden.</param>
        <param name="stateGroupsRoot">Das Stammelement, das den <see cref="T:System.Windows.VisualStateManager" /> enthält.</param>
        <summary>Löst das <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />-Ereignis für das angegebene <see cref="T:System.Windows.VisualStateGroup" />-Objekt aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Windows.VisualStateGroup> festgelegt ist, auf die <xref:System.Windows.Controls.ControlTemplate> eines Steuerelements, die `control` Parameter festgelegt ist, um das Steuerelement, besitzt <xref:System.Windows.Controls.ControlTemplate>.  Wenn die <xref:System.Windows.VisualStateGroup> festgelegt ist, auf eine <xref:System.Windows.FrameworkElement>, `control` ist `null` und Sie sollten die `stateGroupsRoot` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="newState" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass die Basisklasse aufrufen <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Eigenschaft festgelegt werden soll.</param>
        <param name="value">Der Manager für den visuellen Zustand, durch den Übergänge zwischen den Zuständen eines Steuerelements ausgeführt werden.</param>
        <summary>Legt die angefügte <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />-Eigenschaft fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroups">
      <MemberSignature Language="C#" Value="see GetVisualStateGroups" />
      <MemberSignature Language="ILAsm" Value="see GetVisualStateGroups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.VisualStateGroups" />
      <MemberSignature Language="VB.NET" Value="see GetVisualStateGroups" />
      <MemberSignature Language="F#" Value="see GetVisualStateGroups" Usage="see GetVisualStateGroups" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.VisualStateGroup" />-Objekten ab oder legt diese fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks  
 Jede <xref:System.Windows.VisualStateGroup> enthält eine Auflistung von <xref:System.Windows.VisualState> Objekte. Ein <xref:System.Windows.VisualState> enthält eine Auflistung von <xref:System.Windows.Media.Animation.Storyboard> Objekte, die angeben, wie die Darstellung des Steuerelements ändert, wenn das Steuerelement in einem bestimmten Zustand ist. Z. B. eine <xref:System.Windows.Controls.Button> möglicherweise ein geringfügig anderes Aussehen, wenn es als gedrückt wird, wenn es nicht gedrückt wird. Mit zwei Zuständen, die die <xref:System.Windows.Controls.Button> definiert entsprechen, wenn es gedrückt wird (`"Pressed"`) und wann ist nicht (`"Normal"`).  
  
 Sie fügen <xref:System.Windows.VisualState> an ein Steuerelement durch Festlegen der <xref:System.Windows.VisualStateManager.VisualStateGroups%2A> angefügte Eigenschaft für das Steuerelement. Sie ordnen Zustände, die sich gegenseitig ausschließende zueinander in der gleichen <xref:System.Windows.VisualStateGroup>. Z. B. die <xref:System.Windows.Controls.CheckBox> verfügt über zwei <xref:System.Windows.VisualStateGroup> Objekte. Eine enthält die Zustände `Normal`, `MouseOver`, `Pressed`, und `Disabled`. Die andere enthält die Zustände `Checked`, `UnChecked`, und `Indeterminate`. Die <xref:System.Windows.Controls.CheckBox> Zustände sind möglich `MouseOver` und `UnChecked` zur gleichen Zeit, aber es darf sich nicht in der `MouseOver` und `Pressed` Zustände zur gleichen Zeit.  
  
 Obwohl Sie hinzufügen können <xref:System.Windows.VisualState> Objekte zu einem Element, sie sind besonders sinnvolle Weise zu anderen Benutzern, das visuelle Verhalten des neu zu definieren eine <xref:System.Windows.Controls.Control>. Wenn Sie ein benutzerdefiniertes Steuerelement erstellen, verwendet eine <xref:System.Windows.Controls.ControlTemplate>, können Sie angeben, das besagt, dass das Steuerelement aufweisen kann, durch das Hinzufügen einer <xref:System.Windows.TemplateVisualStateAttribute> auf dessen Klassendefinition. Klicken Sie dann jeder, der eine neue erstellt <xref:System.Windows.Controls.ControlTemplate> für das Steuerelement hinzufügen, kann <xref:System.Windows.VisualState> Objekten zur Vorlage. Zustände mit dem gleichen <xref:System.Windows.TemplateVisualStateAttribute.GroupName%2A?displayProperty=fullName> gehören zur gleichen <xref:System.Windows.VisualStateGroup>.  
  
 Weitere Informationen zur Verwendung von <xref:System.Windows.VisualStateGroup> Objekte in einem <xref:System.Windows.Controls.ControlTemplate>, finden Sie unter [Anpassen der Darstellung eines vorhandenen Steuerelements durch Erstellen einer ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control). Weitere Informationen über das Erstellen mit Steuerelementen die <xref:System.Windows.VisualStateManager>, finden Sie unter [erstellen ein Steuerelement verfügt, einer anpassbaren Darstellung](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
     
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Windows.Controls.ControlTemplate> für eine <xref:System.Windows.Controls.Button> , enthält eine <xref:System.Windows.Controls.Grid>. Es enthält auch eine <xref:System.Windows.VisualStateGroup> mit dem Namen `CommonStates`, die definiert, die `MouseOver` und `Normal` Zustände. Die <xref:System.Windows.VisualStateGroup> verfügt auch über eine <xref:System.Windows.VisualTransition> , der angibt, dass es sich um eine halbe Sekunde, für dauert die <xref:System.Windows.Controls.Grid> , die von Grün zu Rot ändern, wenn der Benutzer den Mauszeiger bewegt wird, über die <xref:System.Windows.Controls.Button>.  
  
 [!code-xaml[VSMButtonTemplate#11](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmbuttontemplate/csharp/window1.xaml#11)]
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>