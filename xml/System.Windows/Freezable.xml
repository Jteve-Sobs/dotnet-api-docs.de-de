<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fe79dbb4dc155fbdde7fa8b29d68576670f646ab" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86697672" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert ein Objekt, das einen änderbaren Zustand und einen schreibgeschützten (fixierten) Zustand aufweist. Von <see cref="T:System.Windows.Freezable" /> abgeleitete Klassen stellen detaillierte Änderungsbenachrichtigung bereit, können unveränderlich gemacht werden und sind imstande, sich selbst zu klonen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Windows.Freezable> Klasse bietet spezielle Features, mit denen die Anwendungsleistung verbessert werden kann, wenn Objekte verwendet werden, die teuer zu ändern oder zu kopieren sind. Beispiele für- <xref:System.Windows.Freezable> Objekte sind:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Ableiten von einem frei wählbaren  
 Eine Klasse, die von abgeleitet wird, <xref:System.Windows.Freezable> erhält die folgenden Features:  
  
-   Sonderzustände: Schreib geschützter Zustand (eingefroren) und Schreib geschützter Zustand.  
  
-   Thread Sicherheit: ein fixierte <xref:System.Windows.Freezable> Objekt kann über mehrere Threads freigegeben werden.  
  
-   Ausführliche Änderungs Benachrichtigung: im Gegensatz zu anderen <xref:System.Windows.DependencyObject> Objekten <xref:System.Windows.Freezable> stellt ein-Objekt Änderungs Benachrichtigungen bereit, wenn sich untergeordnete Eigenschaftswerte ändern.  
  
-   Einfaches Klonen: die Klasse, die frei wählbar ist, hat bereits mehrere Methoden implementiert, die Tiefe Klone ergeben.  
  
 Informationen zum verwenden und Erstellen eigener <xref:System.Windows.Freezable> Objekte finden Sie unter [Übersicht über](/dotnet/framework/wpf/advanced/freezable-objects-overview)frei wählbare Objekte.  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" />-Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Wenn die- <see cref="P:System.Windows.Freezable.IsFrozen" /> Eigenschaft ist <see langword="false" /> , <see cref="T:System.Windows.Freezable" /> kann auf ein-Objekt nur von dem Thread aus zugegriffen werden, für den es erstellt wurde. Der Versuch, von einem anderen Thread aus darauf zuzugreifen, löst eine aus <see cref="T:System.InvalidOperationException" /> . Die <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> -Methode und die- <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> Methode bieten Unterstützung für das Marshalling zum richtigen Thread.  
  
Wenn Ihre- <see cref="P:System.Windows.Freezable.IsFrozen" /> Eigenschaft ist <see langword="true" /> , <see cref="T:System.Windows.Freezable" /> sind-Objekte frei Thread.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](/dotnet/framework/wpf/advanced/freezable-objects-overview).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz einer abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der Konstruktor mit geschützter Barrierefreiheit einer abstrakten Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob das Objekt als nicht änderbar festgelegt werden kann.</summary>
        <value><see langword="true" />, wenn das aktuelle Objekt als nicht änderbar festgelegt werden kann oder bereits nicht änderbar ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Diese Methoden Implementierung verwendet die- <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode, wobei <paramref name="isChecking" /> auf festgelegt <see langword="true" /> ist, um zu bestimmen, ob ein als <see cref="T:System.Windows.Freezable" /> nicht änderbar festgelegt werden kann Überschreiben Sie die-Methode, um zu ändern, wie sich diese Eigenschaft in einer abgeleiteten Klasse verhält <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn <see cref="T:System.Windows.Freezable" /> oder ein darin enthaltenes Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, Ereignishandler hinzuzufügen oder zu entfernen, wenn das aktuelle-Objekt nicht geändert werden kann (wenn die- <xref:System.Windows.Freezable.IsFrozen%2A> Eigenschaft ist `true` ), wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Freezable" />-Objekts, indem tiefe Kopien der Werte des Objekts erstellt werden. Beim Kopieren der Abhängigkeitseigenschaften des Objekts kopiert diese Methode Ausdrücke (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable.Clone%2A> -Methode und die- <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methode ergeben änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekten (die-Methoden klonen auch <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist tatsächlich eine tiefe Kopie des aktuellen-Objekts.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den <xref:System.Windows.Freezable.Clone%2A> Methoden und zusammengefasst <xref:System.Windows.Freezable.CloneCurrentValue%2A> .  
  
|Aktion|Verhalten der Klon Methode|CloneCurrentValue-Methoden Verhalten|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Der Ausdruck wird kopiert, kann jedoch möglicherweise nicht mehr aufgelöst werden. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](/dotnet/framework/wpf/advanced/freezable-objects-overview).|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine Festlegung-Eigenschaft über einen Standardwert verfügt <xref:System.Windows.Freezable> , der eingefroren ist, bleibt der Eigenschafts Wert im anderweitig änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben eines frei wählbaren zwischen Threads  
 Diese Methode kann nützlich sein, um ein <xref:System.Windows.Freezable> zwischen Threads zu verschieben. Legen Sie zunächst die- <xref:System.Windows.Freezable> Methode als nicht änderbar fest <xref:System.Windows.Freezable.Freeze%2A> . Nun kann ein anderer Thread auf das zugreifen <xref:System.Windows.Freezable> und eine lokale erstellen, auf die <xref:System.Windows.Freezable.Clone%2A> er zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> , um den Klon zu entwickeln. Um das Verhalten dieser Methode in einer abgeleiteten Klasse zu ändern, überschreiben Sie die- <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> Methode.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.Clone%2A> -Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine änderbare Kopie des aktuellen-Objekts zu erstellen, rufen Sie auf, <xref:System.Windows.Freezable.Clone%2A> anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von ableiten <see cref="T:System.Windows.Freezable" /> , müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben durchgeführt werden können <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> . Dies gilt z. b., wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" /> .  
  
Klassen, in denen alle Ihre Daten in Abhängigkeits Eigenschaften gespeichert werden und die keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen nicht überschrieben werden <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> .  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung macht Tiefe Kopien aller beschreibbaren, lokal festgelegten Eigenschaften, einschließlich interner Ausdrücke.  
  
Wenn das-Objekt über Daten gebundene Abhängigkeits Eigenschaften verfügt, werden die Ausdrücke kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](/dotnet/framework/wpf/advanced/freezable-objects-overview)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der Basis Wert (nicht animiert) dieser Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind. Wenn für eine solche Eigenschaft ein Standardwert festgelegt ist <see cref="T:System.Windows.Freezable" /> , der eingefroren ist, bleibt der Eigenschafts Wert im anderweitig änderbaren Klon fixiert.  
  
In der folgenden Liste wird das erwartete Verhalten für diese Methode zusammengefasst: 
-Die erstellte Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> untergeordneten Objekte.  
  
-Nicht festgelegte und schreibgeschützte Eigenschaften werden nicht kopiert.  
  
-Ausdrücke werden kopiert.  
  
-Keines dieser unter Objekte wird bei der Erstellung eingefroren.  
  
-Die Kopie selbst ist nicht fixiert.  
  
-Animationen werden nicht kopiert.  
  
-Nur Eigenschafts Basiswerte werden kopiert, keine aktuellen animierten Werte.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon (tiefe Kopie) von <see cref="T:System.Windows.Freezable" /> mit den aktuellen Werten.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable.Clone%2A> -Methode und die- <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methode ergeben änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekten (die-Methoden klonen auch <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist tatsächlich eine tiefe Kopie des aktuellen-Objekts.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den <xref:System.Windows.Freezable.Clone%2A> Methoden und zusammengefasst <xref:System.Windows.Freezable.CloneCurrentValue%2A> .  
  
|Aktion|Verhalten der Klon Methode|CloneCurrentValue-Methoden Verhalten|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Der Ausdruck wird kopiert, kann jedoch möglicherweise nicht mehr aufgelöst werden. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](/dotnet/framework/wpf/advanced/freezable-objects-overview).|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine Festlegung-Eigenschaft über einen Standardwert verfügt <xref:System.Windows.Freezable> , der eingefroren ist, bleibt der Eigenschafts Wert im anderweitig änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben eines frei wählbaren zwischen Threads  
 Diese Methode kann nützlich sein, um ein <xref:System.Windows.Freezable> zwischen Threads zu verschieben. Legen Sie als erstes die- <xref:System.Windows.Freezable> Methode als nicht änderbar fest <xref:System.Windows.Freezable.Freeze%2A> . Nun kann ein anderer Thread auf das zugreifen <xref:System.Windows.Freezable> und einen lokalen Klon erstellen, auf den er zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> erstellt den Klon mithilfe der-Methode <see cref="T:System.Windows.Freezable" /> . Implementierer, die überschreiben, <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> müssen sicherstellen, dass die Kopie bei der Erstellung nicht eingefroren ist.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</param>
        <summary>Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.CloneCurrentValue%2A> -Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine änderbare Kopie des aktuellen-Objekts zu erstellen, rufen Sie auf, <xref:System.Windows.Freezable.CloneCurrentValue%2A> anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von ableiten <see cref="T:System.Windows.Freezable" /> , müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben durchgeführt werden können <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> . Dies gilt z. b., wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" /> .  
  
Klassen, in denen alle Ihre Daten in Abhängigkeits Eigenschaften gespeichert werden und die keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen nicht überschrieben werden <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> .  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung macht Tiefe Kopien aller beschreibbaren, lokal festgelegten Eigenschaften. Wenn das-Objekt Abhängigkeits Eigenschaften mit Ausdrücken (z. b. eine Datenbindung) enthält, wird der aktuelle Wert des Ausdrucks kopiert, aber nicht der Ausdruck selbst.  
  
Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften kopiert, aber die Animationen sind nicht.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind. Wenn für eine solche Eigenschaft ein Standardwert festgelegt ist <see cref="T:System.Windows.Freezable" /> , der eingefroren ist, bleibt der Eigenschafts Wert im anderweitig änderbaren Klon fixiert.  
  
In der folgenden Liste wird das erwartete Verhalten für diese Methode zusammengefasst.  
  
-Die erstellte Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> untergeordneten Objekte.  
  
-Nicht festgelegte und schreibgeschützte Eigenschaften werden nicht kopiert.  
  
-Wenn eine Eigenschaft animiert wird, wird der aktuelle Wert kopiert, aber die Animation selbst ist nicht.  
  
-Keines dieser unter Objekte wird bei der Erstellung eingefroren.  
  
-Die Kopie selbst ist nicht fixiert.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine geschützte Methode, und die eigentlichen Objekt spezifischen Implementierungen für das Verhalten sind von der Überschreibungs Implementierung der- <xref:System.Windows.Freezable.CreateInstanceCore%2A> Methode abhängig, die von dieser Methode intern aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht direkt auf (außer beim Aufrufen von base in einer-Implementierung). Diese Methode wird von der-Methode intern aufgerufen, <xref:System.Windows.Freezable.CreateInstance%2A> Wenn eine neue Instanz von <xref:System.Windows.Freezable> erstellt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine typische Implementierung von <xref:System.Windows.Freezable.CreateInstanceCore%2A> .  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede <see cref="T:System.Windows.Freezable" /> abgeleitete Klasse muss diese Methode implementieren. Eine typische Implementierung besteht darin, einfach den Parameter losen Konstruktor aufzurufen und das Ergebnis zurückzugeben.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest oder überprüft, ob ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar festgelegt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiert das aktuelle Objekt als nicht änderbar und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Möglichkeit eines <xref:System.InvalidOperationException> beim Aufrufen dieser Methode zu vermeiden, überprüfen Sie die- <xref:System.Windows.Freezable.CanFreeze%2A> Eigenschaft, um zu bestimmen, ob <xref:System.Windows.Freezable> vor dem Aufruf dieser Methode als nicht änderbar festgelegt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.Freezable" />-Objekt kann nicht als nicht änderbar definiert werden.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die- <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode, um das als <see cref="T:System.Windows.Freezable" /> nicht änderbar festzulegen. Überschreiben Sie die-Methode, um das Einfrieren zu ändern <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> .</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function Freeze (freezable As Freezable, isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Das Objekt, das überprüft oder als nicht änderbar festgelegt werden soll. Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, wird das Objekt überprüft, um zu bestimmen, ob es als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> hat, wird das Objekt als nicht änderbar festgelegt, falls möglich.</param>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Wenn der <paramref name="isChecking" />-Parameter <see langword="true" /> ist, gibt diese Methode an, ob das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann. Wenn der <paramref name="isChecking" />-Parameter <see langword="false" /> ist, versucht diese Methode, das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festzulegen und gibt an, ob der Vorgang erfolgreich ausgeführt wurde.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nur, wenn Sie von ableiten <xref:System.Windows.Freezable> und die- <xref:System.Windows.Freezable.FreezeCore%2A> Methode überschreiben.  Diese Methode kann in der-Methode verwendet werden <xref:System.Windows.Freezable.FreezeCore%2A> , um Klassendatenmember zu fixieren, die selbst <xref:System.Windows.Freezable> Objekte sind.  
  
 Es ist in Ordnung, diese Methode erneut für ein-Objekt aufzurufen <xref:System.Windows.Freezable> , das bereits eingefroren (nicht änderbar) ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, war der Versuch, <paramref name="freezable" /> als nicht änderbar festzulegen, nicht erfolgreich. Das Objekt befindet sich nun in einem unbekannten Zustand (möglicherweise ist es teilweise fixiert).</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die- <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode, um das als <see cref="T:System.Windows.Freezable" /> nicht änderbar festzulegen. Überschreiben Sie die-Methode, um das Einfrieren zu ändern <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> .</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Legt das <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest oder überprüft, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht direkt auf (außer beim Aufrufen von base in einer-Implementierung). Diese Methode wird intern von der <xref:System.Windows.Freezable.CanFreeze%2A> -Eigenschaft (mit `isChecking` gleich `true` ) und der- <xref:System.Windows.Freezable.Freeze%2A> Methode (mit `isChecking` gleich `false` ) aufgerufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> Implementierer müssen diese Methode überschreiben, wenn die Klasse Daten enthält, die nicht mithilfe von Abhängigkeits Eigenschaften gespeichert werden.  
  
Eine typische Implementierung ruft die Basis auf und ruft dann die statische <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> Methode für alle <see cref="T:System.Windows.Freezable" /> typisierten Eigenschaften auf, die die Klasse enthält, und <see langword="true" /> gibt nur dann zurück, wenn alle Eigenschaften fixiert waren (oder möglicherweise eingefroren wurden, wenn für angegeben wurde <see langword="true" /> <paramref name="isChecking" /> ).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit Basiseigenschaftswerten (nicht animiert). Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überprüfen Sie <xref:System.Windows.Freezable.CanFreeze%2A> vor dem Aufrufen dieser Methode die-Eigenschaft, um zu überprüfen, ob <xref:System.Windows.Freezable> eingefroren werden kann. Die Verwendung dieser Methode ähnelt dem Erstellen einer Kopie mithilfe von <xref:System.Windows.Freezable.Clone%2A> und dem anschließenden fixieren mit der- <xref:System.Windows.Freezable.Freeze%2A> Methode.  
  
 Die <xref:System.Windows.Freezable.GetAsFrozen%2A> -Methode und die- <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methode können die Kopier Leistung verbessern, da Sie keine <xref:System.Windows.Freezable> unter Objekte klonen, die bereits eingefroren sind. Sie werden nur nach Verweis kopiert.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den <xref:System.Windows.Freezable.GetAsFrozen%2A> Methoden und zusammengefasst <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> .  
  
|Aktion|Verhalten der GetAsFrozen-Methode|GetCurrentValueAsFrozen-Methoden Verhalten|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Die-Methode löst eine <xref:System.InvalidOperationException> aus, da die-Eigenschaft nicht möglich ist <xref:System.Windows.Freezable.Freeze%2A> .|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
 Verwenden Sie die-Methode, um eine Kopie von zu erstellen, die <xref:System.Windows.Freezable> nicht eingefroren ist <xref:System.Windows.Freezable.Clone%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> kann nicht fixiert werden, da er Ausdrücke oder animierte Eigenschaften enthält.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle- <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> Methode, um den Klon zu entwickeln.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Die zu kopierende Instanz.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.GetAsFrozen%2A> -Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine fixierte Kopie des aktuellen-Objekts zu erstellen, rufen Sie auf, <xref:System.Windows.Freezable.GetAsFrozen%2A> anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von abgeleitet haben <see cref="T:System.Windows.Freezable" /> , müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben durchgeführt werden können <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> . Dies gilt z. b., wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" /> .  
  
Klassen, in denen alle Ihre Daten in Abhängigkeits Eigenschaften gespeichert werden und die keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen nicht überschrieben werden <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> .  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung stellt Tiefe Kopien aller nicht fixierten, frei wählbaren und flachen Kopien aller anderen beschreibbaren, lokal festgelegten Eigenschaften dar, die Sie enthält. Wenn das-Objekt über Daten gebundene Abhängigkeits Eigenschaften verfügt, werden die Ausdrücke kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](/dotnet/framework/wpf/advanced/freezable-objects-overview)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, werden die Basiswerte (nicht animiert) dieser Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die Basis Implementierung aufzurufen.  
  
Beim Kopieren müssen keine <see cref="M:System.Windows.Freezable.Freeze" /> Werte angezeigt werden.  Das Ergebnis wird durch eingefroren <see cref="M:System.Windows.Freezable.GetAsFrozen" /> , bevor es zurückgegeben wird.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit aktuellen Eigenschaftswerten. Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieser Methode ähnelt dem Erstellen einer Kopie mithilfe von <xref:System.Windows.Freezable.CloneCurrentValue%2A> und dem anschließenden fixieren mit der- <xref:System.Windows.Freezable.Freeze%2A> Methode.  
  
 Die <xref:System.Windows.Freezable.GetAsFrozen%2A> -Methode und die- <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methode können die Kopier Leistung verbessern, da Sie keine <xref:System.Windows.Freezable> unter Objekte klonen, die bereits eingefroren sind. Sie werden nur nach Verweis kopiert.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den <xref:System.Windows.Freezable.GetAsFrozen%2A> Methoden und zusammengefasst <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> .  
  
|Aktion|Verhalten der GetAsFrozen-Methode|GetCurrentValueAsFrozen-Methoden Verhalten|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Die-Methode löst eine <xref:System.InvalidOperationException> aus, da die-Eigenschaft nicht möglich ist <xref:System.Windows.Freezable.Freeze%2A> .|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
 Verwenden Sie die-Methode, um eine Kopie von zu erstellen, die <xref:System.Windows.Freezable> nicht eingefroren ist <xref:System.Windows.Freezable.CloneCurrentValue%2A> .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle- <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> Methode, um den Klon zu entwickeln.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</param>
        <summary>Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> -Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine fixierte Kopie des aktuellen-Objekts zu erstellen, rufen Sie auf, <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von ableiten <see cref="T:System.Windows.Freezable" /> , müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben durchgeführt werden können <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> . Dies gilt z. b., wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" /> .  
  
Klassen, in denen alle Ihre Daten in Abhängigkeits Eigenschaften gespeichert werden und die keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen nicht überschrieben werden <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> .  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung erstellt <see cref="T:System.Windows.Freezable" /> mithilfe der <see cref="M:System.Windows.Freezable.CreateInstance" /> -Methode eine neue und erstellt tiefe Kopien von nicht fixierten, frei wählbaren und flachen Kopien aller anderen beschreibbaren, lokal festgelegten Eigenschaften, die Sie enthält. Wenn das Objektdaten gebundene Abhängigkeits Eigenschaften aufweist, werden die Daten Bindungen kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](/dotnet/framework/wpf/advanced/freezable-objects-overview)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften kopiert, aber die Animationen sind nicht.  
  
Schreibgeschützte Abhängigkeits Eigenschaften innerhalb <see cref="T:System.Windows.Freezable" /> von werden nicht von dieser Standard Implementierung kopiert.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die Basis Implementierung aufzurufen.  
  
Beim Kopieren müssen keine <see cref="M:System.Windows.Freezable.Freeze" /> Werte angezeigt werden.  Das Ergebnis wird durch eingefroren <see cref="M:System.Windows.Freezable.GetAsFrozen" /> , bevor es zurückgegeben wird.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Objekt derzeit geändert werden kann.</summary>
        <value><see langword="true" />, wenn das Objekt eingefroren ist und nicht geändert werden kann, <see langword="false" />, wenn das Objekt geändert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Versuch, ein Objekt zu ändern, wenn seine- <xref:System.Windows.Freezable.IsFrozen%2A> Eigenschaft `true` eine auslöst <xref:System.InvalidOperationException> .  
  
 Diese Eigenschaft ist aus der Sicht des Objektmodells schreibgeschützt. Ein Teil der Dokumentation über das Verhalten <xref:System.Windows.Freezable> kann "Sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true` " oder eine ähnliche Sprache enthalten, wenn das Verhalten anderer Methoden von erörtert wird <xref:System.Windows.Freezable> . dieses Verhalten wird jedoch intern in den Klassen Instanzen ausgeführt, wenn die Methoden der Instanz die privaten Variablen ändern, die in der abstrakten Klasse vorhanden sind. Um den Wert dieser Eigenschaft festzulegen, sollten Sie den Befehl <xref:System.Windows.Freezable.Freeze%2A> . Dabei handelt es sich um einen einmaligen Vorgang, um die- <xref:System.Windows.Freezable.IsFrozen%2A> Eigenschaft vom anfänglichen Standard `false` Zustand in den-Zustand zu ändern `true` . Es gibt keine Möglichkeit, den Wert wieder auf festzulegen `false` . Stattdessen können Sie jede beliebige Tiefe Kopie ändern, die vom Original erstellt wurde (Weitere Informationen finden Sie unter der- <xref:System.Windows.Freezable.Clone%2A> Methode). Dies ist Entwurfs bedingt und gibt an, wie sich jede abgeleitete Klasse Verhalten sollte, wenn Sie auf die Fälle angewendet wird, in denen das <xref:System.Windows.Freezable> Muster nützlich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, wenn das aktuelle <see cref="T:System.Windows.Freezable" />-Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird immer dann aufgerufen, wenn das- <xref:System.Windows.Freezable.Changed> Ereignis auftritt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eine Klasse implementieren, die von abgeleitet <see cref="T:System.Windows.Freezable" /> wird, können Sie diese Methode überschreiben, um Aufgaben auszuführen.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade geänderten Datenmember vom Typ <see cref="T:System.Windows.DependencyObject" /> eingerichtet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade festgelegten <see cref="T:System.Windows.DependencyObjectType" />-Datenmember eingerichtet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von <xref:System.Windows.Freezable> vererbern jedes Mal aufgerufen werden, wenn ein <xref:System.Windows.DependencyObject> Datenmember, der nicht als gespeichert ist, <xref:System.Windows.DependencyProperty> festgelegt ist.  
  
 Diese Methode muss nicht für Datenmember aufgerufen werden <xref:System.Windows.DependencyObject> , die mit einem gespeichert werden <xref:System.Windows.DependencyProperty> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <param name="property">Die geänderte Eigenschaft.</param>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten mit Informationen dazu, welche Eigenschaft geändert wurde, sowie dem alten und neuen Wert.</param>
        <summary>Überschreibt die <see cref="T:System.Windows.DependencyObject" />-Implementierung von <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, damit in Reaktion auf eine geänderte Abhängigkeitseigenschaft des Typs <see cref="T:System.Windows.Freezable" /> auch <see cref="E:System.Windows.Freezable.Changed" />-Handler aufgerufen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisdaten enthalten nur Informationen über die <xref:System.Windows.Freezable> selbst. Alle untergeordneten Eigenschafts Informationen müssen über die Handler abgerufen werden <xref:System.Windows.Freezable.Changed> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass über einen gültigen Thread auf <see cref="T:System.Windows.Freezable" /> zugegriffen wird. Vererber von <see cref="T:System.Windows.Freezable" /> müssen diese Methode am Anfang jeder API aufrufen, die Datenmember liest, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klassen, die von abgeleitet <see cref="T:System.Windows.Freezable" /> werden, sollten die-Methode aufrufen, <see cref="M:System.Windows.Freezable.ReadPreamble" /> bevor Sie versuchen, auf Elemente zuzugreifen, die keine Abhängigkeits Eigenschaften sind. Die- <see cref="M:System.Windows.Freezable.WritePreamble" /> Methode sollte aufgerufen werden, bevor solche Member in geschrieben werden.  
  
Diese Methode führt praktisch nur den-Befehl aus <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" /> .</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Freezable.Changed" />-Ereignis für das <see cref="T:System.Windows.Freezable" />-Objekt aus und ruft dessen <see cref="M:System.Windows.Freezable.OnChanged" />-Methode auf. Klassen, die aus <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten diese Methode am Ende jeder API aufrufen, die Klassenmember ändert, die nicht als Abhängigkeitseigenschaften gespeichert sind.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klassen, die von abgeleitet <see cref="T:System.Windows.Freezable" /> werden, sollten diese Methode am Ende jeder API aufzurufen, die einen Klassenmember ändert, der nicht als gespeichert ist <see cref="T:System.Windows.DependencyProperty" /> .</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass das <see cref="T:System.Windows.Freezable" /> nicht fixiert ist und dass über einen gültigen Threadkontext darauf zugegriffen wird. Vererber von <see cref="T:System.Windows.Freezable" /> sollten diese Methode am Anfang jeder API aufrufen, die Datenmember schreibt, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> auf, um zu überprüfen, ob der Threading Kontext zugänglich ist, und löst eine Ausnahme aus, wenn die <xref:System.Windows.Freezable> Instanz bereits eingefroren ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Windows.Freezable" />-Instanz ist fixiert, und in ihre Member kann nicht geschrieben werden.</exception>
        <block subset="none" type="overrides"><para>Klassen, die von abgeleitet <see cref="T:System.Windows.Freezable" /> werden, sollten <see cref="M:System.Windows.Freezable.WritePreamble" /> vor dem Versuch, in Elemente zu schreiben, die keine Abhängigkeits Eigenschaften sind. Wenn Sie <see cref="M:System.Windows.Freezable.WritePreamble" /> in einer API aufzurufen, können Sie einen-Befehl weglassen <see cref="M:System.Windows.Freezable.ReadPreamble" /> .</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
