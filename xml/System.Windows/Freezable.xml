<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214104" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert ein Objekt, das einen änderbaren Zustand und einen schreibgeschützten (fixierten) Zustand aufweist. Von <see cref="T:System.Windows.Freezable" /> abgeleitete Klassen stellen detaillierte Änderungsbenachrichtigung bereit, können unveränderlich gemacht werden und sind imstande, sich selbst zu klonen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable> Klasse bietet spezielle Features, die helfen können die Leistung der Anwendung verbessert, wenn Sie Objekte verwenden, die aufwendig zu ändern oder zu kopieren. Beispiele für <xref:System.Windows.Freezable> umfassen folgende Objekte:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Ableiten von Freezable-Objekts  
 Eine abgeleitete Klasse <xref:System.Windows.Freezable> erhält die folgenden Features:  
  
-   Besondere Zustände: einen schreibgeschützten (fixierten) Zustand und einen beschreibbaren Status.  
  
-   Threadsicherheit: ein fixiertes <xref:System.Windows.Freezable> Objekt über Threads freigegeben werden kann.  
  
-   Detaillierte änderungsbenachrichtigung: im Gegensatz zu anderen <xref:System.Windows.DependencyObject> Objekte, eine <xref:System.Windows.Freezable> Objekt bietet änderungsbenachrichtigungen aus, wenn untergeordnete Eigenschaftswerte sofort geändert.  
  
-   Klonen einfach: die Freezable-Klasse verfügt über mehrere Methoden, die tiefe Klone erstellen bereits implementiert.  
  
 Informationen zum verwenden und erstellen eigene <xref:System.Windows.Freezable> Objekten finden Sie [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" /> Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Wenn die <see cref="P:System.Windows.Freezable.IsFrozen" /> Eigenschaft <see langword="false" />, <see cref="T:System.Windows.Freezable" /> Objekt zugegriffen werden kann, nur aus dem Thread, in dem es erstellt wurde. Es wird versucht, die Zugriffsberechtigung von einem anderen Thread ausgelöst ein <see cref="T:System.InvalidOperationException" />. Die <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> und <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> Methoden bieten Unterstützung für das marshalling an den richtigen Thread.  
  
Wenn ihre <see cref="P:System.Windows.Freezable.IsFrozen" /> Eigenschaft <see langword="true" />, <see cref="T:System.Windows.Freezable" /> Objekte sind Freethread-.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz einer abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der Konstruktor für die geschützten Zugriff einer abstrakten Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob das Objekt als nicht änderbar festgelegt werden kann.</summary>
        <value><see langword="true" />, wenn das aktuelle Objekt als nicht änderbar festgelegt werden kann oder bereits nicht änderbar ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Diese methodenimplementierung verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> -Methode mit <paramref name="isChecking" /> festgelegt <see langword="true" /> um zu bestimmen, ob eine <see cref="T:System.Windows.Freezable" /> änderbar festgelegt werden können. So ändern Sie die Methode, diese Eigenschaft verhält sich in einer abgeleiteten Klasse, außer Kraft setzen der <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn <see cref="T:System.Windows.Freezable" /> oder ein darin enthaltenes Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, hinzufügen oder Entfernen von Ereignishandlern, wenn das aktuelle Objekt nicht geändert werden kann (wenn die <xref:System.Windows.Freezable.IsFrozen%2A> Eigenschaft `true`), wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Freezable" />-Objekts, indem tiefe Kopien der Werte des Objekts erstellt werden. Beim Kopieren der Abhängigkeitseigenschaften des Objekts kopiert diese Methode Ausdrücke (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methoden erstellen, änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekte (Methoden auch Klonen <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist im Grunde eine tiefe Kopie des aktuellen Objekts.  
  
 In der folgende Tabelle werden die Unterschiede zwischen der <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methoden.  
  
|Aktion|Verhalten der Klon-Methode|Verhalten der CloneCurrentValue-Methode|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeitseigenschaft, die einen Ausdruck verfügt.|Der Ausdruck wird kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Der aktuelle Wert des Ausdrucks wird jedoch nicht den Ausdruck selbst kopiert.|  
|Kopieren einer animierten Abhängigkeitseigenschaft|Kopiert den Wert der Eigenschaft Basis (nicht animiert). Animationen werden nicht kopiert.|Der Eigenschaft aktuelle animierte Wert wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine nicht festgelegte Eigenschaft einen Standardwert verfügt, die ein fixiertes <xref:System.Windows.Freezable>, bleibt dieser Eigenschaftswert in den ansonsten änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben von Freezable zwischen Threads  
 Diese Methode kann für das Verschieben von nützlich sein, eine <xref:System.Windows.Freezable> zwischen Threads. Stellen Sie zunächst die <xref:System.Windows.Freezable> als nicht änderbar fest, durch den Aufruf der <xref:System.Windows.Freezable.Freeze%2A> Methode. Nun einem anderen Thread zugreifen, kann die <xref:System.Windows.Freezable> und einen lokalen <xref:System.Windows.Freezable.Clone%2A> , die darauf zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> den Klon. Um das Verhalten dieser Methode in einer abgeleiteten Klasse zu ändern, überschreiben die <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> Methode.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, indem die <xref:System.Windows.Freezable.Clone%2A> Methode und sollte nicht aufgerufen werden direkt aus Ihrem Code, außer wenn beim Überschreiben dieser Methode die basisimplementierung aufrufen. Rufen Sie zum Erstellen einer änderbaren Kopie des aktuellen Objekts <xref:System.Windows.Freezable.Clone%2A> müssen diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Bei der Ableitung von <see cref="T:System.Windows.Freezable" />, müssen Sie möglicherweise diese Methode überschreiben. Die folgenden: Gründe für die außer Kraft setzen 
-Die abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeitseigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss eine zusätzliche Initialisierung-Aufgaben, die nicht erreicht werden kann, indem Sie einfach überschreiben ausführen <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Dies gilt z. B. wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Klassen, die alle Daten in Abhängigkeitseigenschaften speichern und keine zusätzlichen Initialisierungsaufgaben ausführen, müssen nicht außer Kraft setzen <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Es ist wichtig, dass alle Implementierungen dieser Methode die basisimplementierung aufrufen. Implementierungen sollten nur Aufgaben ausführen, die von der Standardimplementierung nicht ausgeführt wird. Die Standardimplementierung erstellt tiefe Kopien alle beschreibbaren, lokal festgelegte Eigenschaften, einschließlich interner Ausdrücke.  
  
Wenn das Objekt von datengebundenen Abhängigkeitseigenschaften verfügt, wird die Ausdrücke werden kopiert, jedoch möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von datengebundenen Objekten finden Sie unter [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, wird der Basiswert (nicht animiert) diese Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden oder sind schreibgeschützte Eigenschaften. Wenn diese Eigenschaft einen Standardwert verfügt, die ein fixiertes <see cref="T:System.Windows.Freezable" />, bleibt dieser Eigenschaftswert in den ansonsten änderbaren Klon fixiert.  
  
Die folgende Liste enthält das erwartete Verhalten für diese Methode: 
– Die erstellt Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> untergeordnete Objekte.  
  
-Die Festlegung und Read-only-Eigenschaften werden nicht kopiert.  
  
-Ausdrücke werden kopiert.  
  
– None dieser untergeordnete Objekte werden bei der Erstellung fixiert.  
  
– Die Kopie selbst ist nicht fixiert.  
  
-Animationen werden nicht kopiert.  
  
-Nur Basis Eigenschaftswerte werden kopiert, nicht den aktuellen animierten Werte.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon (tiefe Kopie) von <see cref="T:System.Windows.Freezable" /> mit den aktuellen Werten.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methoden erstellen, änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekte (Methoden auch Klonen <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist im Grunde eine tiefe Kopie des aktuellen Objekts.  
  
 In der folgende Tabelle werden die Unterschiede zwischen der <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methoden.  
  
|Aktion|Verhalten der Klon-Methode|Verhalten der CloneCurrentValue-Methode|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeitseigenschaft, die einen Ausdruck verfügt.|Der Ausdruck wird kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Der aktuelle Wert des Ausdrucks wird jedoch nicht den Ausdruck selbst kopiert.|  
|Kopieren einer animierten Abhängigkeitseigenschaft|Kopiert den Wert der Eigenschaft Basis (nicht animiert). Animationen werden nicht kopiert.|Der Eigenschaft aktuelle animierte Wert wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine nicht festgelegte Eigenschaft einen Standardwert verfügt, die ein fixiertes <xref:System.Windows.Freezable>, bleibt dieser Eigenschaftswert in den ansonsten änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben von Freezable zwischen Threads  
 Diese Methode kann für das Verschieben von nützlich sein, eine <xref:System.Windows.Freezable> zwischen Threads. Stellen Sie zunächst die <xref:System.Windows.Freezable> als nicht änderbar fest, mit dessen <xref:System.Windows.Freezable.Freeze%2A> Methode. Nun einem anderen Thread zugreifen, kann die <xref:System.Windows.Freezable> und einen lokalen Klon, die darauf zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> Methode zum Erstellen des Klons; <see cref="T:System.Windows.Freezable" /> Implementierer, die überschreiben <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> müssen sicherstellen, dass die Kopie bei der Erstellung nicht fixiert ist.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</param>
        <summary>Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, indem die <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methode und sollte nicht aufgerufen werden direkt aus Ihrem Code, außer wenn beim Überschreiben dieser Methode die basisimplementierung aufrufen. Rufen Sie zum Erstellen einer änderbaren Kopie des aktuellen Objekts <xref:System.Windows.Freezable.CloneCurrentValue%2A> müssen diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Bei der Ableitung von <see cref="T:System.Windows.Freezable" />, müssen Sie möglicherweise diese Methode überschreiben. Die folgenden: Gründe für die außer Kraft setzen 
-Die abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeitseigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss eine zusätzliche Initialisierung-Aufgaben, die nicht erreicht werden kann, indem Sie einfach überschreiben ausführen <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Dies gilt z. B. wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Klassen, die alle Daten in Abhängigkeitseigenschaften speichern und keine zusätzlichen Initialisierungsaufgaben ausführen, müssen nicht außer Kraft setzen <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Es ist wichtig, dass alle Implementierungen dieser Methode die basisimplementierung aufrufen. Implementierungen sollten nur Aufgaben ausführen, die von der Standardimplementierung nicht ausgeführt wird. Die Standardimplementierung erstellt tiefe Kopien alle beschreibbaren, lokal festgelegte Eigenschaften. Wenn das Objekt Abhängigkeitseigenschaften mit Ausdrücken (z. B. eine Datenbindung) enthält, wird der aktuelle Wert des Ausdrucks aber nicht den Ausdruck selbst kopiert.  
  
Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften wird kopiert, aber die Animationen sind nicht.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden oder sind schreibgeschützte Eigenschaften. Wenn diese Eigenschaft einen Standardwert verfügt, die ein fixiertes <see cref="T:System.Windows.Freezable" />, bleibt dieser Eigenschaftswert in den ansonsten änderbaren Klon fixiert.  
  
Die folgende Liste enthält das erwartete Verhalten für diese Methode.  
  
– Die erstellt Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> untergeordnete Objekte.  
  
-Die Festlegung und Read-only-Eigenschaften werden nicht kopiert.  
  
– Wenn eine Eigenschaft animiert wird, wird der aktuelle Wert wird kopiert, aber die Animation selbst ist nicht.  
  
– None dieser untergeordnete Objekte werden bei der Erstellung fixiert.  
  
– Die Kopie selbst ist nicht fixiert.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine geschützte Methode, und die eigentlichen objektspezifischen Implementierungen für das Verhalten hängt von der Implementierung der Außerkraftsetzung von werden die <xref:System.Windows.Freezable.CreateInstanceCore%2A> -Methode, die diese Methode intern ruft.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode direkt (mit Ausnahme beim Aufrufen der Basis in einer Implementierung) nicht. Diese Methode wird aufgerufen, intern von der <xref:System.Windows.Freezable.CreateInstance%2A> -Methode auf, wenn eine neue Instanz der der <xref:System.Windows.Freezable> erstellt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine typische Implementierung der <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede <see cref="T:System.Windows.Freezable" /> abgeleitete Klasse muss diese Methode implementieren. Eine typische Implementierung ist, einfach den Standardkonstruktor aufrufen und das Ergebnis zurückgeben.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest oder überprüft, ob ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar festgelegt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiert das aktuelle Objekt als nicht änderbar und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Möglichkeit zu vermeiden ein <xref:System.InvalidOperationException> überprüfen Sie beim Aufrufen dieser Methode die <xref:System.Windows.Freezable.CanFreeze%2A> Eigenschaft, um zu bestimmen, ob der <xref:System.Windows.Freezable> können änderbar festgelegt werden vor dem Aufrufen dieser Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.Freezable" />-Objekt kann nicht als nicht änderbar definiert werden.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode zum Erstellen der <see cref="T:System.Windows.Freezable" /> als nicht änderbar fest. Um Einfrieren Verhalten ändern möchten, überschreiben die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Das Objekt, das überprüft oder als nicht änderbar festgelegt werden soll. Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, wird das Objekt überprüft, um zu bestimmen, ob es als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> hat, wird das Objekt als nicht änderbar festgelegt, falls möglich.</param>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Wenn der <paramref name="isChecking" />-Parameter <see langword="true" /> ist, gibt diese Methode an, ob das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann. Wenn der <paramref name="isChecking" />-Parameter <see langword="false" /> ist, versucht diese Methode, das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festzulegen und gibt an, ob der Vorgang erfolgreich ausgeführt wurde.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode nicht aufrufen, es sei denn, beim Ableiten von <xref:System.Windows.Freezable> und überschreiben die <xref:System.Windows.Freezable.FreezeCore%2A> Methode.  Diese Methode kann verwendet werden, der <xref:System.Windows.Freezable.FreezeCore%2A> Methode, um die Datenmember der Klasse zu fixieren, die selbst sind <xref:System.Windows.Freezable> Objekte.  
  
 Es ist möglich, diese Methode erneut aufrufen, auf eine <xref:System.Windows.Freezable> -Objekt, das bereits fixiert ist (nicht änderbar).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, war der Versuch, <paramref name="freezable" /> als nicht änderbar festzulegen, nicht erfolgreich. Das Objekt befindet sich nun in einem unbekannten Zustand (möglicherweise ist es teilweise fixiert).</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode zum Erstellen der <see cref="T:System.Windows.Freezable" /> als nicht änderbar fest. Um Einfrieren Verhalten ändern möchten, überschreiben die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> Methode.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Legt das <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest oder überprüft, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode direkt (mit Ausnahme beim Aufrufen der Basis in einer Implementierung) nicht. Diese Methode wird aufgerufen, intern von der <xref:System.Windows.Freezable.CanFreeze%2A> Eigenschaft (mit `isChecking` gleich `true`) und die <xref:System.Windows.Freezable.Freeze%2A> Methode (mit `isChecking` gleich `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> Implementierungen müssen diese Methode überschreiben, wenn die Klasse Daten enthält, die nicht mit Abhängigkeitseigenschaften gespeichert.  
  
Eine typische Implementierung Basis aufrufen würden, dann rufen Sie die statische <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> für alle <see cref="T:System.Windows.Freezable" /> typisierte Eigenschaften mit die Klasse zurückgeben, <see langword="true" /> nur, wenn alle Eigenschaften, die fixiert waren (oder, im Fall von angeben eingefroren konnte <see langword="true" /> für <paramref name="isChecking" />).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit Basiseigenschaftswerten (nicht animiert). Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überprüfen Sie die <xref:System.Windows.Freezable.CanFreeze%2A> -Eigenschaft vor dem Aufrufen dieser Methode, um sicherzustellen, dass die <xref:System.Windows.Freezable> kann fixiert werden. Mit dieser Methode ähnelt der beim Erstellen einer Kopie mithilfe der <xref:System.Windows.Freezable.Clone%2A> und dem anschließenden mit Fixieren der <xref:System.Windows.Freezable.Freeze%2A> Methode.  
  
 Die <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methoden können die kopieren-Leistung verbessern, da sie nicht Klonen <xref:System.Windows.Freezable> untergeordnete Objekte, die bereits eingefroren werden; sie nur kopieren Sie sie als Verweis.  
  
 In der folgende Tabelle werden die Unterschiede zwischen der <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methoden.  
  
|Aktion|Verhalten der GetAsFrozen-Methode|Verhalten der GetCurrentValueAsFrozen-Methode|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeitseigenschaft, die einen Ausdruck verfügt.|Löst die Methode eine <xref:System.InvalidOperationException> , da dies nicht möglich <xref:System.Windows.Freezable.Freeze%2A> die-Eigenschaft.|Der aktuelle Wert des Ausdrucks wird jedoch nicht den Ausdruck selbst kopiert.|  
|Kopieren einer animierten Abhängigkeitseigenschaft|Kopiert den Wert der Eigenschaft Basis (nicht animiert). Animationen werden nicht kopiert.|Der Eigenschaft aktuelle animierte Wert wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden oder sind schreibgeschützte Eigenschaften.  
  
 Erstellen Sie eine Kopie der <xref:System.Windows.Freezable> , nicht fixiert ist, verwenden die <xref:System.Windows.Freezable.Clone%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> kann nicht fixiert werden, da er Ausdrücke oder animierte Eigenschaften enthält.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> Methode, um den Klon zu erstellen.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Die zu kopierende Instanz.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, indem die <xref:System.Windows.Freezable.GetAsFrozen%2A> Methode und sollte nicht aufgerufen werden direkt aus Ihrem Code, außer wenn beim Überschreiben dieser Methode die basisimplementierung aufrufen. Rufen Sie zum Erstellen einer fixierten Kopie des aktuellen Objekts <xref:System.Windows.Freezable.GetAsFrozen%2A> müssen diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Bei der Ableitung von <see cref="T:System.Windows.Freezable" /> müssen Sie möglicherweise diese Methode überschreiben. Die folgenden: Gründe für die außer Kraft setzen 
-Die abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeitseigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss eine zusätzliche Initialisierung-Aufgaben, die nicht erreicht werden kann, indem Sie einfach überschreiben ausführen <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Dies gilt z. B. wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Klassen, die alle Daten in Abhängigkeitseigenschaften speichern und keine zusätzlichen Initialisierungsaufgaben ausführen, müssen nicht außer Kraft setzen <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Es ist wichtig, dass alle Implementierungen dieser Methode die basisimplementierung aufrufen. Implementierungen sollten nur Aufgaben ausführen, die von der Standardimplementierung nicht ausgeführt wird. Die Standardimplementierung erstellt tiefe Kopien jeder nicht fixierten Freezable-Objekte und alle anderen beschreibbaren flache Kopien, lokal darin enthaltenen Eigenschaften. Wenn das Objekt von datengebundenen Abhängigkeitseigenschaften verfügt, werden die Ausdrücke werden kopiert, jedoch möglicherweise nicht mehr aufgelöst; Weitere Informationen zum Klonen von datengebundenen Objekten finden Sie unter [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die Basiswerte (nicht animiert) diese Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden oder sind schreibgeschützte Eigenschaften.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die basisimplementierung aufrufen.  
  
Sie müssen sich nicht um <see cref="M:System.Windows.Freezable.Freeze" /> Werte, wie sie kopiert werden.  Das Ergebnis ist gesperrt, indem <see cref="M:System.Windows.Freezable.GetAsFrozen" /> vor der Rückgabe.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit aktuellen Eigenschaftswerten. Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode ähnelt der beim Erstellen einer Kopie mithilfe der <xref:System.Windows.Freezable.CloneCurrentValue%2A> und dem anschließenden mit Fixieren der <xref:System.Windows.Freezable.Freeze%2A> Methode.  
  
 Die <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methoden können die kopieren-Leistung verbessern, da sie nicht Klonen <xref:System.Windows.Freezable> untergeordnete Objekte, die bereits eingefroren werden; sie nur kopieren Sie sie als Verweis.  
  
 In der folgende Tabelle werden die Unterschiede zwischen der <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methoden.  
  
|Aktion|Verhalten der GetAsFrozen-Methode|Verhalten der GetCurrentValueAsFrozen-Methode|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeitseigenschaft, die einen Ausdruck verfügt.|Löst die Methode eine <xref:System.InvalidOperationException> , da dies nicht möglich <xref:System.Windows.Freezable.Freeze%2A> die-Eigenschaft.|Der aktuelle Wert des Ausdrucks wird jedoch nicht den Ausdruck selbst kopiert.|  
|Kopieren einer animierten Abhängigkeitseigenschaft|Kopiert den Wert der Eigenschaft Basis (nicht animiert). Animationen werden nicht kopiert.|Der Eigenschaft aktuelle animierte Wert wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden oder sind schreibgeschützte Eigenschaften.  
  
 Erstellen Sie eine Kopie der <xref:System.Windows.Freezable> , nicht fixiert ist, verwenden die <xref:System.Windows.Freezable.CloneCurrentValue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> Methode, um den Klon zu erstellen.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</param>
        <summary>Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, indem die <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> Methode und sollte nicht aufgerufen werden direkt aus Ihrem Code, außer wenn beim Überschreiben dieser Methode die basisimplementierung aufrufen. Rufen Sie zum Erstellen einer fixierten Kopie des aktuellen Objekts <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> müssen diese Methode nicht direkt aufrufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Bei der Ableitung von <see cref="T:System.Windows.Freezable" />, müssen Sie möglicherweise diese Methode überschreiben. Die folgenden: Gründe für die außer Kraft setzen 
-Die abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeitseigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss eine zusätzliche Initialisierung-Aufgaben, die nicht erreicht werden kann, indem Sie einfach überschreiben ausführen <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Dies gilt z. B. wenn die abgeleitete Klasse implementiert <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Klassen, die alle Daten in Abhängigkeitseigenschaften speichern und keine zusätzlichen Initialisierungsaufgaben ausführen, müssen nicht außer Kraft setzen <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Es ist wichtig, dass alle Implementierungen dieser Methode die basisimplementierung aufrufen. Implementierungen sollten nur Aufgaben ausführen, die von der Standardimplementierung nicht ausgeführt wird. Die Standardimplementierung erstellt einen neuen <see cref="T:System.Windows.Freezable" /> mithilfe der <see cref="M:System.Windows.Freezable.CreateInstance" /> -Methode und führt tiefe Kopien nicht fixierten Freezable-Objekte und alle anderen beschreibbaren flache Kopien lokal darin enthaltenen Eigenschaften festgelegt. Wenn das Objekt von datengebundenen Abhängigkeitseigenschaften verfügt, datenbindungen, die beim Übertragungsvorgang kopiert werden, aber Sie werden möglicherweise nicht mehr aufgelöst; Weitere Informationen zum Klonen von datengebundenen Objekten finden Sie unter [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften wird kopiert, aber die Animationen sind nicht.  
  
Schreibgeschützte Abhängigkeitseigenschaften innerhalb einer <see cref="T:System.Windows.Freezable" /> werden durch diese Standardimplementierung nicht kopiert.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die basisimplementierung aufrufen.  
  
Sie müssen sich nicht um <see cref="M:System.Windows.Freezable.Freeze" /> Werte, wie sie kopiert werden.  Das Ergebnis ist gesperrt, indem <see cref="M:System.Windows.Freezable.GetAsFrozen" /> vor der Rückgabe.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Objekt derzeit geändert werden kann.</summary>
        <value><see langword="true" />, wenn das Objekt eingefroren ist und nicht geändert werden kann, <see langword="false" />, wenn das Objekt geändert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Versuchen, ein Objekt zu ändern. bei der <xref:System.Windows.Freezable.IsFrozen%2A> -Eigenschaft ist `true` löst eine <xref:System.InvalidOperationException>.  
  
 Diese Eigenschaft ist schreibgeschützt und aus der Perspektive der Object-Modell. Teil der Dokumentation zu <xref:System.Windows.Freezable> Verhalten möglicherweise ganz zu schweigen "legt diese fest <xref:System.Windows.Freezable.IsFrozen%2A> zu `true`" oder ähnliche Sprache, bei der das Verhalten der anderen Methoden der Erörterung <xref:System.Windows.Freezable>, aber dies geschieht intern in der Klasseninstanzen Wenn Methoden der Instanz die privaten Variablen bearbeiten, die in der abstrakten Klasse vorhanden sein. Um den Wert dieser Eigenschaft festzulegen, rufen Sie <xref:System.Windows.Freezable.Freeze%2A>. Dies effektiv ist ein Einmaliger Vorgang so ändern Sie die <xref:System.Windows.Freezable.IsFrozen%2A> Eigenschaft aus der anfängliche Standardwert `false` -Zustand in den `true` Zustand. Es gibt keine Möglichkeit zum Festlegen des Werts an `false`. Stattdessen könnten Sie jede tiefe Kopie, die von der ursprünglichen ändern (siehe die <xref:System.Windows.Freezable.Clone%2A> Methode). Dies ist beabsichtigt und eine abgeleitete Klasse Verhalten sollte bei Anwendung auf die Fälle, in denen die <xref:System.Windows.Freezable> Muster ist hilfreich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, wenn das aktuelle <see cref="T:System.Windows.Freezable" />-Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn die <xref:System.Windows.Freezable.Changed> Ereignis auftritt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eine abgeleitete Klasse implementieren <see cref="T:System.Windows.Freezable" />, Sie können angeben, überschreiben diese Methode zum Durchführen von Aufgaben.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade geänderten Datenmember vom Typ <see cref="T:System.Windows.DependencyObject" /> eingerichtet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade festgelegten <see cref="T:System.Windows.DependencyObjectType" />-Datenmember eingerichtet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte aufgerufen werden, indem <xref:System.Windows.Freezable> erben jedes Mal eine <xref:System.Windows.DependencyObject> Datenmember, die nicht als gespeichert ist eine <xref:System.Windows.DependencyProperty> festgelegt ist.  
  
 Diese Methode muss nicht aufgerufen werden, damit <xref:System.Windows.DependencyObject> Datenmember, die gespeichert werden, mithilfe einer <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <param name="property">Die geänderte Eigenschaft.</param>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten mit Informationen dazu, welche Eigenschaft geändert wurde, sowie dem alten und neuen Wert.</param>
        <summary>Überschreibt die <see cref="T:System.Windows.DependencyObject" />-Implementierung von <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, damit in Reaktion auf eine geänderte Abhängigkeitseigenschaft des Typs <see cref="T:System.Windows.Freezable" /> auch <see cref="E:System.Windows.Freezable.Changed" />-Handler aufgerufen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisdaten enthalten nur Informationen zu den <xref:System.Windows.Freezable> selbst. Alle Informationen für die untergeordnete Eigenschaft abgerufen werden muss, bis die <xref:System.Windows.Freezable.Changed> Handler.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass über einen gültigen Thread auf <see cref="T:System.Windows.Freezable" /> zugegriffen wird. Erben von <see cref="T:System.Windows.Freezable" /> müssen diese Methode am Anfang jeder [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] aufrufen, die Datenmember liest, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Abgeleitete Klassen <see cref="T:System.Windows.Freezable" /> aufrufen, sollte die <see cref="M:System.Windows.Freezable.ReadPreamble" /> -Methode auf, bevor sie versuchen, alle Member zuzugreifen, die keine Abhängigkeitseigenschaften sind. Die <see cref="M:System.Windows.Freezable.WritePreamble" /> -Methode aufgerufen werden soll, bevor solche Member in geschrieben werden.  
  
Diese Methode effektiv macht nichts anderes als Aufrufen <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Freezable.Changed" />-Ereignis für das <see cref="T:System.Windows.Freezable" />-Objekt aus und ruft dessen <see cref="M:System.Windows.Freezable.OnChanged" />-Methode auf. Klassen, die aus <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten diese Methode am Ende jeder API aufrufen, die Klassenmember ändert, die nicht als Abhängigkeitseigenschaften gespeichert sind.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Abgeleitete Klassen <see cref="T:System.Windows.Freezable" /> sollten diese Methode am Ende jeder API, die einen Klassenmember, die nicht ändert als gespeichert Aufrufen einer <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass das <see cref="T:System.Windows.Freezable" /> nicht fixiert ist und dass über einen gültigen Threadkontext darauf zugegriffen wird. Erben von <see cref="T:System.Windows.Freezable" /> sollten diese Methode am Anfang jeder [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] aufrufen, die Datenmember schreibt, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> so Überprüfen der Threadkontext kann zugegriffen werden, und es wird eine Ausnahme ausgelöst, wenn die <xref:System.Windows.Freezable> Instanz ist bereits eingefroren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Windows.Freezable" />-Instanz ist fixiert, und in ihre Member kann nicht geschrieben werden.</exception>
        <block subset="none" type="overrides"><para>Abgeleitete Klassen <see cref="T:System.Windows.Freezable" /> sollten Aufrufen <see cref="M:System.Windows.Freezable.WritePreamble" /> vor dem Schreiben von Elementen, die keine Abhängigkeitseigenschaften sind. Wenn Sie aufrufen <see cref="M:System.Windows.Freezable.WritePreamble" /> in einer [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], können Sie einen Aufruf von weglassen <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>