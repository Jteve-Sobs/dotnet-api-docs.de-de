<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="84a1d4d58413b5da087fb4163d93657ff4ec0d7a" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78808687" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert ein Objekt, das einen änderbaren Zustand und einen schreibgeschützten (fixierten) Zustand aufweist. Von <see cref="T:System.Windows.Freezable" /> abgeleitete Klassen stellen detaillierte Änderungsbenachrichtigung bereit, können unveränderlich gemacht werden und sind imstande, sich selbst zu klonen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Freezable>-Klasse bietet spezielle Features, mit denen die Anwendungsleistung verbessert werden kann, wenn Objekte verwendet werden, die teuer zu ändern oder zu kopieren sind. Beispiele für <xref:System.Windows.Freezable> Objekte sind:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Ableiten von einem frei wählbaren  
 Eine Klasse, die von <xref:System.Windows.Freezable> abgeleitet wird, erhält die folgenden Features:  
  
-   Sonderzustände: Schreib geschützter Zustand (eingefroren) und Schreib geschützter Zustand.  
  
-   Thread Sicherheit: ein fixierte <xref:System.Windows.Freezable> Objekt kann über mehrere Threads gemeinsam genutzt werden.  
  
-   Ausführliche Änderungs Benachrichtigung: im Gegensatz zu anderen <xref:System.Windows.DependencyObject> Objekten stellt ein <xref:System.Windows.Freezable> Objekt Änderungs Benachrichtigungen bereit, wenn sich untergeordnete Eigenschaftswerte ändern.  
  
-   Einfaches Klonen: die Klasse, die frei wählbar ist, hat bereits mehrere Methoden implementiert, die Tiefe Klone ergeben.  
  
 Informationen zum verwenden und Erstellen eigener <xref:System.Windows.Freezable> Objekte finden Sie unter [Übersicht über](~/docs/framework/wpf/advanced/freezable-objects-overview.md)frei wählbare Objekte.  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle öffentlichen <see langword="static" />-Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft <see langword="false" />ist, kann auf ein <see cref="T:System.Windows.Freezable" /> Objekt nur von dem Thread aus zugegriffen werden, für den es erstellt wurde. Der Versuch, von einem anderen Thread aus darauf zuzugreifen, löst eine <see cref="T:System.InvalidOperationException" />aus. Die Methoden <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> und <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> unterstützen das Marshalling zum richtigen Thread.  
  
Wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft <see langword="true" />ist, sind <see cref="T:System.Windows.Freezable" /> Objekte frei Thread.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz einer abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der Konstruktor mit geschützter Barrierefreiheit einer abstrakten Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob das Objekt als nicht änderbar festgelegt werden kann.</summary>
        <value><see langword="true" />, wenn das aktuelle Objekt als nicht änderbar festgelegt werden kann oder bereits nicht änderbar ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Diese Methoden Implementierung verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode mit <paramref name="isChecking" /> auf <see langword="true" /> festgelegt, um zu bestimmen, ob ein <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann. Um zu ändern, wie sich diese Eigenschaft in einer abgeleiteten Klasse verhält, überschreiben Sie die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn <see cref="T:System.Windows.Freezable" /> oder ein darin enthaltenes Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, Ereignishandler hinzuzufügen oder zu entfernen, wenn das aktuelle Objekt nicht geändert werden kann (wenn die <xref:System.Windows.Freezable.IsFrozen%2A>-Eigenschaft `true`ist), wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Freezable" />-Objekts, indem tiefe Kopien der Werte des Objekts erstellt werden. Beim Kopieren der Abhängigkeitseigenschaften des Objekts kopiert diese Methode Ausdrücke (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit den Methoden <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> werden änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekten erzeugt (die Methoden Klonen ebenfalls <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist tatsächlich eine tiefe Kopie des aktuellen-Objekts.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den Methoden <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> zusammengefasst.  
  
|Action|Verhalten der Klon Methode|CloneCurrentValue-Methoden Verhalten|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Der Ausdruck wird kopiert, kann jedoch möglicherweise nicht mehr aufgelöst werden. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine Festlegung-Eigenschaft über einen Standardwert verfügt, bei dem es sich um eine fixierte <xref:System.Windows.Freezable>handelt, bleibt der Eigenschafts Wert im ansonsten änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben eines frei wählbaren zwischen Threads  
 Diese Methode kann nützlich sein, um eine <xref:System.Windows.Freezable> zwischen Threads zu verschieben. Legen Sie zunächst den <xref:System.Windows.Freezable> als nicht änderbar fest, indem Sie dessen <xref:System.Windows.Freezable.Freeze%2A>-Methode aufrufen. Nun kann ein anderer Thread auf den <xref:System.Windows.Freezable> zugreifen und eine lokale <xref:System.Windows.Freezable.Clone%2A> erstellen, auf die er zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />, um den Klon zu entwickeln. Um das Verhalten dieser Methode in einer abgeleiteten Klasse zu ändern, überschreiben Sie die <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />-Methode.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.Clone%2A>-Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine änderbare Kopie des aktuellen-Objekts zu erstellen, rufen Sie <xref:System.Windows.Freezable.Clone%2A> auf, anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von <see cref="T:System.Windows.Freezable" />ableiten, müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben von <see cref="M:System.Windows.Freezable.CreateInstanceCore" />durchgeführt werden können. Dies gilt z. b., wenn die abgeleitete Klasse <see cref="T:System.ComponentModel.ISupportInitialize" />implementiert.  
  
Klassen, die all Ihre Daten in Abhängigkeits Eigenschaften speichern und keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />nicht überschreiben.  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung macht Tiefe Kopien aller beschreibbaren, lokal festgelegten Eigenschaften, einschließlich interner Ausdrücke.  
  
Wenn das-Objekt über Daten gebundene Abhängigkeits Eigenschaften verfügt, werden die Ausdrücke kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](~/docs/framework/wpf/advanced/freezable-objects-overview.md)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der Basis Wert (nicht animiert) dieser Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind. Wenn eine solche Eigenschaft über einen Standardwert verfügt, bei dem es sich um eine fixierte <see cref="T:System.Windows.Freezable" />handelt, bleibt der Eigenschafts Wert im ansonsten änderbaren Klon fixiert.  
  
In der folgenden Liste wird das erwartete Verhalten für diese Methode zusammengefasst: 
-Die erstellte Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> unter Objekte.  
  
-Nicht festgelegte und schreibgeschützte Eigenschaften werden nicht kopiert.  
  
-Ausdrücke werden kopiert.  
  
-Keines dieser unter Objekte wird bei der Erstellung eingefroren.  
  
-Die Kopie selbst ist nicht fixiert.  
  
-Animationen werden nicht kopiert.  
  
-Nur Eigenschafts Basiswerte werden kopiert, keine aktuellen animierten Werte.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon (tiefe Kopie) von <see cref="T:System.Windows.Freezable" /> mit den aktuellen Werten.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit den Methoden <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> werden änderbare Klone von fixierten <xref:System.Windows.Freezable> Objekten erzeugt (die Methoden Klonen ebenfalls <xref:System.Windows.Freezable> Objekte, die nicht eingefroren sind). Der Klon ist tatsächlich eine tiefe Kopie des aktuellen-Objekts.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den Methoden <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A> zusammengefasst.  
  
|Action|Verhalten der Klon Methode|CloneCurrentValue-Methoden Verhalten|  
|------------|---------------------------|---------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Der Ausdruck wird kopiert, kann jedoch möglicherweise nicht mehr aufgelöst werden. Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften nicht kopiert werden. Wenn eine Festlegung-Eigenschaft über einen Standardwert verfügt, bei dem es sich um eine fixierte <xref:System.Windows.Freezable>handelt, bleibt der Eigenschafts Wert im ansonsten änderbaren Klon fixiert.  
  
## <a name="move-a-freezable-between-threads"></a>Verschieben eines frei wählbaren zwischen Threads  
 Diese Methode kann nützlich sein, um eine <xref:System.Windows.Freezable> zwischen Threads zu verschieben. Legen Sie den <xref:System.Windows.Freezable> zuerst mithilfe seiner <xref:System.Windows.Freezable.Freeze%2A>-Methode als nicht änderbar fest. Nun kann ein anderer Thread auf den <xref:System.Windows.Freezable> zugreifen und einen lokalen Klon erstellen, auf den er zugreifen kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />-Methode, um den Klon zu entwickeln. <see cref="T:System.Windows.Freezable" /> Implementierer, die <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> überschreiben, müssen sicherstellen, dass die Kopie bei der Erstellung nicht eingefroren ist.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</param>
        <summary>Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.CloneCurrentValue%2A>-Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine änderbare Kopie des aktuellen-Objekts zu erstellen, rufen Sie <xref:System.Windows.Freezable.CloneCurrentValue%2A> auf, anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von <see cref="T:System.Windows.Freezable" />ableiten, müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben von <see cref="M:System.Windows.Freezable.CreateInstanceCore" />durchgeführt werden können. Dies gilt z. b., wenn die abgeleitete Klasse <see cref="T:System.ComponentModel.ISupportInitialize" />implementiert.  
  
Klassen, die all Ihre Daten in Abhängigkeits Eigenschaften speichern und keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />nicht überschreiben.  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung macht Tiefe Kopien aller beschreibbaren, lokal festgelegten Eigenschaften. Wenn das-Objekt Abhängigkeits Eigenschaften mit Ausdrücken (z. b. eine Datenbindung) enthält, wird der aktuelle Wert des Ausdrucks kopiert, aber nicht der Ausdruck selbst.  
  
Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften kopiert, aber die Animationen sind nicht.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind. Wenn eine solche Eigenschaft über einen Standardwert verfügt, bei dem es sich um eine fixierte <see cref="T:System.Windows.Freezable" />handelt, bleibt der Eigenschafts Wert im ansonsten änderbaren Klon fixiert.  
  
In der folgenden Liste wird das erwartete Verhalten für diese Methode zusammengefasst.  
  
-Die erstellte Kopie enthält Kopien aller <see cref="T:System.Windows.Freezable" /> unter Objekte.  
  
-Nicht festgelegte und schreibgeschützte Eigenschaften werden nicht kopiert.  
  
-Wenn eine Eigenschaft animiert wird, wird der aktuelle Wert kopiert, aber die Animation selbst ist nicht.  
  
-Keines dieser unter Objekte wird bei der Erstellung eingefroren.  
  
-Die Kopie selbst ist nicht fixiert.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine geschützte Methode, und die eigentlichen Objekt spezifischen Implementierungen für das Verhalten sind von der Überschreibungs Implementierung der <xref:System.Windows.Freezable.CreateInstanceCore%2A>-Methode abhängig, die von dieser Methode intern aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Freezable" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht direkt auf (außer beim Aufrufen von base in einer-Implementierung). Diese Methode wird von der <xref:System.Windows.Freezable.CreateInstance%2A>-Methode intern aufgerufen, wenn eine neue Instanz der <xref:System.Windows.Freezable> erstellt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine typische Implementierung von <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede <see cref="T:System.Windows.Freezable" /> abgeleitete Klasse muss diese Methode implementieren. Eine typische Implementierung besteht darin, einfach den Parameter losen Konstruktor aufzurufen und das Ergebnis zurückzugeben.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest oder überprüft, ob ein <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar festgelegt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiert das aktuelle Objekt als nicht änderbar und legt seine <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Möglichkeit einer <xref:System.InvalidOperationException> beim Aufrufen dieser Methode zu vermeiden, überprüfen Sie die <xref:System.Windows.Freezable.CanFreeze%2A>-Eigenschaft, um zu bestimmen, ob die <xref:System.Windows.Freezable> als nicht änderbar festgelegt werden kann, bevor Sie diese Methode aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.Freezable" />-Objekt kann nicht als nicht änderbar definiert werden.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode, um die <see cref="T:System.Windows.Freezable" /> als nicht änderbar festzulegen. Überschreiben Sie die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode, um das Einfrieren zu ändern.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function Freeze (freezable As Freezable, isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Das Objekt, das überprüft oder als nicht änderbar festgelegt werden soll. Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, wird das Objekt überprüft, um zu bestimmen, ob es als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> hat, wird das Objekt als nicht änderbar festgelegt, falls möglich.</param>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Wenn der <paramref name="isChecking" />-Parameter <see langword="true" /> ist, gibt diese Methode an, ob das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann. Wenn der <paramref name="isChecking" />-Parameter <see langword="false" /> ist, versucht diese Methode, das angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festzulegen und gibt an, ob der Vorgang erfolgreich ausgeführt wurde.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nur, wenn Sie von <xref:System.Windows.Freezable> ableiten und die <xref:System.Windows.Freezable.FreezeCore%2A>-Methode überschreiben.  Diese Methode kann in der <xref:System.Windows.Freezable.FreezeCore%2A>-Methode verwendet werden, um Klassendatenmember zu fixieren, die selbst <xref:System.Windows.Freezable>-Objekten sind.  
  
 Es ist in Ordnung, diese Methode erneut für ein <xref:System.Windows.Freezable> Objekt aufzurufen, das bereits eingefroren ist (nicht änderbar).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, war der Versuch, <paramref name="freezable" /> als nicht änderbar festzulegen, nicht erfolgreich. Das Objekt befindet sich nun in einem unbekannten Zustand (möglicherweise ist es teilweise fixiert).</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode, um die <see cref="T:System.Windows.Freezable" /> als nicht änderbar festzulegen. Überschreiben Sie die <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />-Methode, um das Einfrieren zu ändern.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />, um zurückzugeben, ob das Objekt fixiert werden kann (ohne es tatsächlich zu fixieren), <see langword="false" />, um das Objekt tatsächlich zu fixieren.</param>
        <summary>Legt das <see cref="T:System.Windows.Freezable" />-Objekt als nicht änderbar fest oder überprüft, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der <see cref="T:System.Windows.Freezable" /> als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann. Wenn <paramref name="isChecking" /> den Wert <see langword="false" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn der angegebene <see cref="T:System.Windows.Freezable" /> jetzt nicht änderbar ist, oder <see langword="false" />, wenn er nicht als nicht änderbar festgelegt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht direkt auf (außer beim Aufrufen von base in einer-Implementierung). Diese Methode wird intern von der <xref:System.Windows.Freezable.CanFreeze%2A>-Eigenschaft (mit `isChecking` gleich `true`) und der <xref:System.Windows.Freezable.Freeze%2A>-Methode (mit `isChecking` gleich `false`) aufgerufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> Implementierer müssen diese Methode überschreiben, wenn die Klasse Daten enthält, die nicht mithilfe von Abhängigkeits Eigenschaften gespeichert werden.  
  
Eine typische Implementierung ruft die Basis auf und ruft dann die statische <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> Methode für alle <see cref="T:System.Windows.Freezable" /> typisierten Eigenschaften auf, die in der Klasse enthalten sind, und gibt nur dann <see langword="true" /> zurück, wenn alle Eigenschaften fixiert waren (oder im Fall der Angabe <see langword="true" /> für <paramref name="isChecking" />eingefroren wurden).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit Basiseigenschaftswerten (nicht animiert). Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überprüfen Sie die <xref:System.Windows.Freezable.CanFreeze%2A>-Eigenschaft, bevor Sie diese Methode aufrufen, um zu überprüfen, ob die <xref:System.Windows.Freezable> eingefroren werden kann. Die Verwendung dieser Methode ähnelt dem Erstellen einer Kopie mithilfe des <xref:System.Windows.Freezable.Clone%2A> und dem anschließenden Einfrieren der Methode mit der <xref:System.Windows.Freezable.Freeze%2A>-Methode.  
  
 Die Methoden <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> können die Kopier Leistung verbessern, da Sie nicht <xref:System.Windows.Freezable> unter Objekte klonen, die bereits eingefroren sind. Sie werden nur nach Verweis kopiert.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den Methoden <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zusammengefasst.  
  
|Action|Verhalten der GetAsFrozen-Methode|GetCurrentValueAsFrozen-Methoden Verhalten|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Die-Methode löst eine <xref:System.InvalidOperationException> aus, da Sie die-Eigenschaft nicht <xref:System.Windows.Freezable.Freeze%2A> kann.|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
 Verwenden Sie die <xref:System.Windows.Freezable.Clone%2A>-Methode, um eine Kopie der <xref:System.Windows.Freezable> zu erstellen, die nicht eingefroren ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> kann nicht fixiert werden, da er Ausdrücke oder animierte Eigenschaften enthält.</exception>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />-Methode, um den Klon zu entwickeln.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Die zu kopierende Instanz.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.GetAsFrozen%2A>-Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine fixierte Kopie des aktuellen Objekts zu erstellen, rufen Sie <xref:System.Windows.Freezable.GetAsFrozen%2A> auf, anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von <see cref="T:System.Windows.Freezable" /> ableiten, müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben von <see cref="M:System.Windows.Freezable.CreateInstanceCore" />durchgeführt werden können. Dies gilt z. b., wenn die abgeleitete Klasse <see cref="T:System.ComponentModel.ISupportInitialize" />implementiert.  
  
Klassen, die all Ihre Daten in Abhängigkeits Eigenschaften speichern und keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />nicht überschreiben.  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung stellt Tiefe Kopien aller nicht fixierten, frei wählbaren und flachen Kopien aller anderen beschreibbaren, lokal festgelegten Eigenschaften dar, die Sie enthält. Wenn das-Objekt über Daten gebundene Abhängigkeits Eigenschaften verfügt, werden die Ausdrücke kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](~/docs/framework/wpf/advanced/freezable-objects-overview.md)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, werden die Basiswerte (nicht animiert) dieser Eigenschaften kopiert. Animationen werden nicht kopiert.  
  
Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die Basis Implementierung aufzurufen.  
  
Sie müssen keine Werte <see cref="M:System.Windows.Freezable.Freeze" />, wenn Sie kopiert werden.  Das Ergebnis wird durch <see cref="M:System.Windows.Freezable.GetAsFrozen" /> eingefroren, bevor es zurückgegeben wird.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine fixierte Kopie von <see cref="T:System.Windows.Freezable" /> mit aktuellen Eigenschaftswerten. Da die Kopie fixiert ist, werden alle fixierten Unterobjekte als Verweis kopiert.</summary>
        <returns>Eine fixierte Kopie von <see cref="T:System.Windows.Freezable" />. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Kopie ist auf <see langword="true" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieser Methode ähnelt dem Erstellen einer Kopie mithilfe des <xref:System.Windows.Freezable.CloneCurrentValue%2A> und dem anschließenden Einfrieren der Methode mit der <xref:System.Windows.Freezable.Freeze%2A>-Methode.  
  
 Die Methoden <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> können die Kopier Leistung verbessern, da Sie nicht <xref:System.Windows.Freezable> unter Objekte klonen, die bereits eingefroren sind. Sie werden nur nach Verweis kopiert.  
  
 In der folgenden Tabelle werden die Unterschiede zwischen den Methoden <xref:System.Windows.Freezable.GetAsFrozen%2A> und <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> zusammengefasst.  
  
|Action|Verhalten der GetAsFrozen-Methode|GetCurrentValueAsFrozen-Methoden Verhalten|  
|------------|---------------------------------|---------------------------------------------|  
|Kopieren einer Abhängigkeits Eigenschaft, die über einen Ausdruck verfügt|Die-Methode löst eine <xref:System.InvalidOperationException> aus, da Sie die-Eigenschaft nicht <xref:System.Windows.Freezable.Freeze%2A> kann.|Der aktuelle Wert des Ausdrucks wird kopiert, aber nicht der Ausdruck selbst.|  
|Kopieren einer animierten Abhängigkeits Eigenschaft|Der Basis Wert (nicht animierter Wert) der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|Der aktuelle animierte Wert der Eigenschaft wird kopiert. Animationen werden nicht kopiert.|  
  
 Beachten Sie, dass nicht festgelegte Eigenschaften weder kopiert noch schreibgeschützte Eigenschaften sind.  
  
 Verwenden Sie die <xref:System.Windows.Freezable.CloneCurrentValue%2A>-Methode, um eine Kopie der <xref:System.Windows.Freezable> zu erstellen, die nicht eingefroren ist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode verwendet die virtuelle <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />-Methode, um den Klon zu entwickeln.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</param>
        <summary>Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>-Methode aufgerufen und sollte nicht direkt aus dem Code aufgerufen werden, außer wenn beim Überschreiben dieser Methode die Basis Implementierung aufgerufen wird. Um eine fixierte Kopie des aktuellen Objekts zu erstellen, rufen Sie <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> auf, anstatt diese Methode direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie von <see cref="T:System.Windows.Freezable" />ableiten, müssen Sie diese Methode möglicherweise außer Kraft setzen. Folgende Gründe können außer Kraft gesetzt werden: 
-Ihre abgeleitete Klasse verfügt über Daten, die nicht über Abhängigkeits Eigenschaften verfügbar gemacht werden.  
  
-Die abgeleitete Klasse muss zusätzliche Initialisierungs Aufgaben ausführen, die nicht durch einfaches Überschreiben von <see cref="M:System.Windows.Freezable.CreateInstanceCore" />durchgeführt werden können. Dies gilt z. b., wenn die abgeleitete Klasse <see cref="T:System.ComponentModel.ISupportInitialize" />implementiert.  
  
Klassen, die all Ihre Daten in Abhängigkeits Eigenschaften speichern und keine zusätzlichen Initialisierungs Aufgaben ausführen müssen, müssen <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />nicht überschreiben.  
  
Es ist von grundlegender Bedeutung, dass alle-Implementierungen die Basis Implementierung dieser Methode aufzurufen. Implementierungen sollten nur Aufgaben ausführen, die nicht von der Standard Implementierung ausgeführt werden. Die Standard Implementierung erstellt mithilfe der <see cref="M:System.Windows.Freezable.CreateInstance" />-Methode eine neue <see cref="T:System.Windows.Freezable" /> und erstellt tiefe Kopien von nicht fixierten, frei wählbaren und flachen Kopien aller anderen beschreibbaren, lokal festgelegten Eigenschaften, die Sie enthält. Wenn das Objektdaten gebundene Abhängigkeits Eigenschaften aufweist, werden die Daten Bindungen kopiert, aber möglicherweise nicht mehr aufgelöst. Weitere Informationen zum Klonen von Daten gebundenen Objekten finden Sie unter [Übersicht](~/docs/framework/wpf/advanced/freezable-objects-overview.md)über frei wählbare Objekte. Wenn das Objekt über animierte Abhängigkeits Eigenschaften verfügt, wird der aktuelle animierte Wert dieser Eigenschaften kopiert, aber die Animationen sind nicht.  
  
Schreibgeschützte Abhängigkeits Eigenschaften innerhalb einer <see cref="T:System.Windows.Freezable" /> werden von dieser Standard Implementierung nicht kopiert.  
  
Wenn Sie diese Methode überschreiben, müssen Sie die Basis Implementierung aufzurufen.  
  
Sie müssen keine Werte <see cref="M:System.Windows.Freezable.Freeze" />, wenn Sie kopiert werden.  Das Ergebnis wird durch <see cref="M:System.Windows.Freezable.GetAsFrozen" /> eingefroren, bevor es zurückgegeben wird.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Objekt derzeit geändert werden kann.</summary>
        <value><see langword="true" />, wenn das Objekt eingefroren ist und nicht geändert werden kann, <see langword="false" />, wenn das Objekt geändert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, ein Objekt zu ändern, wenn seine <xref:System.Windows.Freezable.IsFrozen%2A>-Eigenschaft `true` wird eine <xref:System.InvalidOperationException>ausgelöst.  
  
 Diese Eigenschaft ist aus der Sicht des Objektmodells schreibgeschützt. Ein Teil der Dokumentation zu den <xref:System.Windows.Freezable> Verhalten kann beispielsweise "legt <xref:System.Windows.Freezable.IsFrozen%2A> auf `true`" oder eine ähnliche Sprache fest, wenn das Verhalten anderer Methoden <xref:System.Windows.Freezable>erläutert wird. dieses Verhalten wird jedoch intern in den Klassen Instanzen durchgeführt, wenn Methoden der Instanz die privaten Variablen, die innerhalb der abstrakten Klasse vorhanden sind, bearbeiten. Um den Wert dieser Eigenschaft festzulegen, sollten Sie <xref:System.Windows.Freezable.Freeze%2A>abrufen. Dabei handelt es sich um einen einmaligen Vorgang, um die <xref:System.Windows.Freezable.IsFrozen%2A>-Eigenschaft vom anfänglichen Standard `false` Zustand in den `true`-Zustand zu ändern. Es gibt keine Möglichkeit, den Wert wieder auf `false`festzulegen. Stattdessen können Sie jede beliebige Tiefe Kopie ändern, die vom Original erstellt wurde (Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A>-Methode). Dies ist Entwurfs bedingt und gibt an, wie sich jede abgeleitete Klasse Verhalten sollte, wenn Sie auf die Fälle angewendet wird, in denen das <xref:System.Windows.Freezable> Muster nützlich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, wenn das aktuelle <see cref="T:System.Windows.Freezable" />-Objekt geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird immer dann aufgerufen, wenn das <xref:System.Windows.Freezable.Changed> Ereignis auftritt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eine Klasse implementieren, die von <see cref="T:System.Windows.Freezable" />abgeleitet ist, können Sie diese Methode überschreiben, um Aufgaben auszuführen.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade geänderten Datenmember vom Typ <see cref="T:System.Windows.DependencyObject" /> eingerichtet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <summary>Stellt sicher, dass entsprechende Kontextzeiger für einen gerade festgelegten <see cref="T:System.Windows.DependencyObjectType" />-Datenmember eingerichtet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von <xref:System.Windows.Freezable> vererbern jedes Mal aufgerufen werden, wenn ein <xref:System.Windows.DependencyObject> Datenmember, der nicht als <xref:System.Windows.DependencyProperty> gespeichert ist, festgelegt wird.  
  
 Diese Methode muss nicht für <xref:System.Windows.DependencyObject> Datenmember aufgerufen werden, die mit einem <xref:System.Windows.DependencyProperty>gespeichert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Der vorherige Wert des Datenmembers.</param>
        <param name="newValue">Der aktuelle Wert des Datenmembers.</param>
        <param name="property">Die geänderte Eigenschaft.</param>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten mit Informationen dazu, welche Eigenschaft geändert wurde, sowie dem alten und neuen Wert.</param>
        <summary>Überschreibt die <see cref="T:System.Windows.DependencyObject" />-Implementierung von <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, damit in Reaktion auf eine geänderte Abhängigkeitseigenschaft des Typs <see cref="E:System.Windows.Freezable.Changed" /> auch <see cref="T:System.Windows.Freezable" />-Handler aufgerufen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ereignisdaten enthalten nur Informationen zu den <xref:System.Windows.Freezable> selbst. Alle untergeordneten Eigenschafts Informationen müssen über die <xref:System.Windows.Freezable.Changed> Handler abgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass über einen gültigen Thread auf <see cref="T:System.Windows.Freezable" /> zugegriffen wird. Vererber von <see cref="T:System.Windows.Freezable" /> müssen diese Methode am Anfang jeder API aufrufen, die Datenmember liest, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klassen, die von <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten die <see cref="M:System.Windows.Freezable.ReadPreamble" />-Methode aufrufen, bevor Sie versuchen, auf Elemente zuzugreifen, die keine Abhängigkeits Eigenschaften sind. Die <see cref="M:System.Windows.Freezable.WritePreamble" />-Methode sollte aufgerufen werden, bevor solche Member in geschrieben werden.  
  
Diese Methode führt praktisch nur den Rückruf <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />aus.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Freezable.Changed" />-Ereignis für das <see cref="T:System.Windows.Freezable" />-Objekt aus und ruft dessen <see cref="M:System.Windows.Freezable.OnChanged" />-Methode auf. Klassen, die aus <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten diese Methode am Ende jeder API aufrufen, die Klassenmember ändert, die nicht als Abhängigkeitseigenschaften gespeichert sind.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Klassen, die von <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten diese Methode am Ende jeder API aufzurufen, die einen Klassenmember ändert, der nicht als <see cref="T:System.Windows.DependencyProperty" />gespeichert ist.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass das <see cref="T:System.Windows.Freezable" /> nicht fixiert ist und dass über einen gültigen Threadkontext darauf zugegriffen wird. Vererber von <see cref="T:System.Windows.Freezable" /> sollten diese Methode am Anfang jeder API aufrufen, die Datenmember schreibt, bei denen es sich nicht um Abhängigkeitseigenschaften handelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> auf, um zu überprüfen, ob der Threading Kontext zugänglich ist, und löst eine Ausnahme aus, wenn die <xref:System.Windows.Freezable> Instanz bereits eingefroren ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Windows.Freezable" />-Instanz ist fixiert, und in ihre Member kann nicht geschrieben werden.</exception>
        <block subset="none" type="overrides"><para>Klassen, die von <see cref="T:System.Windows.Freezable" /> abgeleitet werden, sollten <see cref="M:System.Windows.Freezable.WritePreamble" /> vor dem Versuch, in Elemente zu schreiben, die keine Abhängigkeits Eigenschaften sind. Wenn Sie <see cref="M:System.Windows.Freezable.WritePreamble" /> in einer API aufzurufen, können Sie einen <see cref="M:System.Windows.Freezable.ReadPreamble" />-aufrufsbefehl weglassen.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
