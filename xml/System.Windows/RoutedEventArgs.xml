<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="39a4c7a889ce793c1720c4be8a9d51d14000c240" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86715028" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="d8d6a-101">Enthält Zustandsinformationen und Ereignisdaten, die einem Routingereignis zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-102">Andere <xref:System.Windows.RoutedEventArgs> können mit einem einzelnen verwendet werden <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="d8d6a-103">Diese Klasse ist für das Verpacken der Ereignisdaten für einen zuständig <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> und stellt zusätzliche Ereignis Zustandsinformationen bereit und wird vom Ereignis System zum Aufrufen des dem Routing Ereignis zugeordneten Handlers verwendet.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d8d6a-104">Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8d6a-105">Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-106">Wenn dieser Parameter lose Konstruktor verwendet wird, nehmen alle öffentlichen Eigenschaften der neuen <xref:System.Windows.RoutedEventArgs> Instanz die folgenden Standardwerte an:</span><span class="sxs-lookup"><span data-stu-id="d8d6a-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d8d6a-107">Der Standardwert von <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d8d6a-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> Standardwert `false`</span><span class="sxs-lookup"><span data-stu-id="d8d6a-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d8d6a-109">Der Standardwert von <xref:System.Windows.RoutedEventArgs.Source%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d8d6a-110">Der Standardwert von <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d8d6a-111">NULL-Werte für <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> bedeuten nur, dass die <xref:System.Windows.RoutedEventArgs> Daten nicht versuchen, die Quelle anzugeben.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="d8d6a-112">Wenn diese Instanz in einem-Rückruf verwendet wird <xref:System.Windows.UIElement.RaiseEvent%2A> ,  <xref:System.Windows.RoutedEventArgs.Source%2A> werden die-und- <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Werte basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und über das Routing an Listener weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (routedEvent As RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="d8d6a-113">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="d8d6a-114">Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-115">Wenn dieser überladene Konstruktor verwendet wird, nehmen nicht angegebene Eigenschaften der neuen <xref:System.Windows.RoutedEventArgs> Instanz die folgenden Standardwerte an:</span><span class="sxs-lookup"><span data-stu-id="d8d6a-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d8d6a-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> Standardwert `false`</span><span class="sxs-lookup"><span data-stu-id="d8d6a-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d8d6a-117">Der Standardwert von <xref:System.Windows.RoutedEventArgs.Source%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d8d6a-118">Der Standardwert von <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d8d6a-119">NULL-Werte für <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> bedeuten nur, dass dadurch <xref:System.Windows.RoutedEventArgs> nicht versucht wird, die Quelle anzugeben.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="d8d6a-120">Wenn diese Instanz in einem-Rückruf verwendet wird <xref:System.Windows.UIElement.RaiseEvent%2A> ,  <xref:System.Windows.RoutedEventArgs.Source%2A> werden die-und- <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Werte basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und über das Routing an Listener weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8d6a-121">Im folgenden Beispiel wird ein neues erstellt <xref:System.Windows.RoutedEventArgs> , das in einem-Befehl verwendet werden soll <xref:System.Windows.UIElement.RaiseEvent%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (routedEvent As RoutedEvent, source As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="d8d6a-122">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="d8d6a-123">Eine alternative Quelle, die beim Behandeln des Ereignisses gemeldet wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="d8d6a-124">Diese füllt die <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft vorab.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="d8d6a-125">Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse, wobei die Möglichkeit zum Deklarieren einer anderen Quelle für das Ereignis besteht.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-126">Wenn dieser überladene Konstruktor verwendet wird, nehmen nicht angegebene Eigenschaften der neuen <xref:System.Windows.RoutedEventArgs> Instanz die folgenden Standardwerte an:</span><span class="sxs-lookup"><span data-stu-id="d8d6a-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d8d6a-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> Standardwert `false`</span><span class="sxs-lookup"><span data-stu-id="d8d6a-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d8d6a-128">Der Standardwert von <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> ist `null`.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d8d6a-129">NULL-Werte für <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> werden basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und durch das Routing weitergeleitet wird, das jedoch vor dem Aufruf gelesen wird `null` .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="d8d6a-130">Verwenden Sie diese Signatur bei <xref:System.Windows.RoutedEventArgs> der Übergabe an Virtuale wie z <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A> . b., wobei die Argumente verwendet werden, um intern aufzurufen <xref:System.Windows.UIElement.RaiseEvent%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8d6a-131">Ruft einen Wert ab, der den aktuellen Zustand der Ereignisbehandlung für ein Routingereignis beim Durchlaufen der Route angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="d8d6a-132">Wenn dieser Wert festgelegt wird, legen Sie ihn auf <see langword="true" /> fest, wenn das Ereignis als behandelt markiert werden soll, andernfalls auf <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="d8d6a-133">Wenn dieser Wert gelesen wird, gibt <see langword="true" /> an, dass dieses Ereignis bereits von einem Klassenhandler oder einem Instanzhandler entlang der Route als behandelt markiert wurde.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="d8d6a-134"><see langword="false" /> gibt an, dass das Ereignis von keinem Handler als behandelt markiert wurde.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
<span data-ttu-id="d8d6a-135">Standardwert: <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-136">Wenn das Ereignis behandelt wird, wird die Sichtbarkeit des Routing Ereignisses auf die Ereignis Route beschränkt.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="d8d6a-137">Das Ereignis leitet weiterhin den Rest der Route, aber nur Handler, die speziell mit im Methodenaufruf hinzugefügt wurden, werden `HandledEventsToo` `true` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> als Antwort aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="d8d6a-138">Standard Handler für Instanzlistener (z. b. die in ausgedrückten [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] ) werden nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="d8d6a-139">Das Behandeln von Ereignissen, die als behandelt gekennzeichnet sind, ist kein gängiges Szenario.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="d8d6a-140">Wenn Sie ein Steuerelement Autor sind, der Ihre eigenen Ereignisse definiert, betreffen die Entscheidungen, die Sie bezüglich der Ereignis Behandlung auf Klassenebene treffen, die Benutzer Ihres Steuer Elements sowie alle Benutzer von abgeleiteten Steuerelementen und potenziell andere Elemente, die entweder in Ihrem Steuerelement enthalten sind oder das Steuerelement enthalten.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="d8d6a-141">Weitere Informationen finden Sie unter [Markieren von Routingereignissen als behandelt und Klassenbehandlung](/dotnet/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling).</span><span class="sxs-lookup"><span data-stu-id="d8d6a-141">For more information, see [Marking Routed Events as Handled, and Class Handling](/dotnet/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling).</span></span>  
  
 <span data-ttu-id="d8d6a-142">In sehr seltenen Fällen ist es sinnvoll, Ereignisse zu behandeln  <xref:System.Windows.RoutedEventArgs.Handled%2A> , bei denen markiert ist `true` , und die Ereignis Argumente zu ändern, indem Sie <xref:System.Windows.RoutedEventArgs.Handled%2A> in ändern `false` .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="d8d6a-143">Dies kann in bestimmten Bereichen von Eingabe Ereignissen von Steuerelementen erforderlich sein, z. b. bei der Schlüssel Behandlung von im <xref:System.Windows.UIElement.KeyDown> Vergleich zu <xref:System.Windows.UIElement.TextInput> , wenn Low-Level-und High-Level-Eingabeereignisse für die Verarbeitung konkurrieren, und jede versucht, mit einer anderen Routing Strategie zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8d6a-144">Im folgenden Beispiel wird ein Ereignishandler implementiert, der das behandelte Ereignis kennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="d8d6a-145">Die aufzurufende generische Handler- bzw. Delegatimplementierung.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="d8d6a-146">Das Ziel, für das der bereitgestellte Handler aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="d8d6a-147">Ermöglicht beim Überschreiben in einer abgeleiteten Klasse das typspezifische Aufrufen von Ereignishandlern, wodurch die Effizienz gegenüber der Basisimplementierung verbessert werden kann.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-148">Die Basis Implementierung schließt Reflektion ein, um den richtigen Handler für alle Fälle zu ermitteln, in denen der Handler nicht buchstäblich ist <xref:System.Windows.RoutedEventHandler> , und dieser reflektionsschritt hat einige Leistungs Konsequenzen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="d8d6a-149">Aufrufe können effizienter gemacht werden, da Sie sich nicht auf Reflektion verlassen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="d8d6a-150">Dies ist das Szenario, in dem diese Methode für alle Routing Ereignis Argument-Klassen verfügbar ist, die Sie überschreiben möchten.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="d8d6a-151">Implementierungen sollten die Basis für diese Methode nicht aufrufen, da ihre Implementierung bereits für das Aufrufen der typsicheren Handler zuständig ist.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8d6a-152">Der folgende Code zeigt ein grundlegendes Muster, das für die Implementierung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="d8d6a-153">Hier `MyRoutedEventHandler` ist eine Unterklasse von <xref:System.Windows.RoutedEventHandler> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d8d6a-154">Diese Methode ist dafür vorgesehen, von abgeleiteten Ereignisdaten Klassen überschrieben zu werden, um einen effizienteren Aufruf ihrer Delegaten bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="d8d6a-155">Die-Implementierung muss die bereitgestellte <paramref name="genericHandler" /> in den typspezifischen Delegaten umwandeln und dann diesen Handler aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
<span data-ttu-id="d8d6a-156">Die Standard Implementierung versucht, den bereitgestellten Handler aufzurufen, wobei versucht wird, ihn als umzuwandeln <see cref="T:System.Windows.RoutedEventHandler" /> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="d8d6a-157">Wenn entweder <paramref name="genericHandler" /> oder <paramref name="genericTarget" /> als angegeben wird <see langword="null" /> , werden Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d8d6a-158">Der neue Wert, auf den <see cref="P:System.Windows.RoutedEventArgs.Source" /> festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="d8d6a-159">Gibt beim Überschreiben in einer abgeleiteten Klasse einen Einstiegspunkt für Benachrichtigungsrückrufe an, wenn der Wert der <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft einer Instanz geändert wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d8d6a-160">Wenn Sie die gemeldete Quelle eines Ereignisses Programm gesteuert ändern, ist es möglicherweise erforderlich, dass die typspezifischen Daten innerhalb des Ereignisses aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="d8d6a-161">Aus diesem Grund ist die <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> -Methode geschützt und soll von Unterklassen von überschrieben werden <see cref="T:System.Windows.RoutedEventArgs" /> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
<span data-ttu-id="d8d6a-162">Diese Methode hat keine Standard Implementierung.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-162">This method has no default implementation.</span></span></para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8d6a-163">Ruft die ursprünglich meldende Quelle ab, die durch einen reinen Treffertest bestimmt wurde, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine übergeordnete Klasse erfolgt.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="d8d6a-164">Die ursprüngliche meldende Quelle, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine Klassenbehandlung vorgenommen wird, die möglicherweise ausgeführt wird, um zusammengesetzte Elementstrukturen flachzumachen.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-165">Diese Eigenschaft ruft den Wert einmal ab, bevor die Klassen Ereignishandler oder Instanzhandler aufgerufen werden, und wird an diesem Punkt nie angepasst.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="d8d6a-166">Die ursprünglichen Quell Informationen sind in Klassen Handlern oder Klassen Implementierungen schreibgeschützt, ebenso wie Sie in den Ereignisdaten gemeldet werden.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="d8d6a-167">Häufige Fälle, in denen die Quelle angepasst werden kann, enthalten Inhaltselemente in einem Inhalts Modell für ein Steuerelement (der Inhalt eines Listen Elements meldet beispielsweise das Listenelement Element als <xref:System.Windows.RoutedEventArgs.Source%2A> und das tatsächliche Element innerhalb des Listen Elements) <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="d8d6a-168">Die Quell Anpassung nach verschiedenen Elementen und Inhalts Modellen variiert von Klasse zu Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="d8d6a-169">Jede Klasse, die Ereignis Quellen anpasst, versucht vorherzusagen, welche Quelle für die meisten Eingabe Szenarios und die Szenarien, für die die Klasse vorgesehen ist, am nützlichsten ist, und legt diese Quelle dann als fest <xref:System.Windows.RoutedEventArgs.Source%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="d8d6a-170">Wenn diese Quelle nicht der Wert ist, der für die Behandlung des Ereignisses relevant ist, versuchen Sie <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> stattdessen, zu überprüfen, ob Sie eine andere Quelle meldet, die besser geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="d8d6a-171">Weitere Informationen zu Eingabe Ereignissen finden Sie unter [Übersicht](/dotnet/framework/wpf/advanced/input-overview)über die Eingabe.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-171">For more details on input events, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8d6a-172">Ruft die <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Instanz ab, die dieser <see cref="T:System.Windows.RoutedEventArgs" />-Instanz zugeordnet ist, oder legt die Instanz fest.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="d8d6a-173">Der Bezeichner für das Ereignis, das aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-174">Sie können diesen Wert nicht für einen festlegen <xref:System.Windows.RoutedEventArgs> , der bereits weitergeleitet wurde (wenn Sie beispielsweise die Argumente über einen Handler abgerufen haben).</span><span class="sxs-lookup"><span data-stu-id="d8d6a-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="d8d6a-175">Wenn Sie versuchen, dies zu tun, wird eine Ausnahme generiert.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="d8d6a-176">Sie können Sie nur für eine-Instanz festlegen, die noch nicht verwendet wurde, um einen Aufruf des Ereignisses zu generieren.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="d8d6a-177">Der Wert von <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> darf nicht `null` gleichzeitig sein.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d8d6a-178">Im folgenden Beispiel werden neue Routing Ereignisdaten mit einem anfänglichen Konstruktor erstellt und dann die- <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Eigenschaft als nachfolgende Vorgang festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="d8d6a-179">Sie müssen <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> vor der Erhöhung des-Routing Ereignisses festgelegt haben.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d8d6a-180">Es wurde versucht, den <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Wert zu ändern, während das Ereignis weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8d6a-181">Ruft einen Verweis auf das Objekt ab, das das Ereignis ausgelöst hat, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="d8d6a-182">Das Objekt, das das Ereignis ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8d6a-183">Für alle bubbling-Routingereignisse, die die Route tatsächlich hinter dem Element, das sie ausgelöst hat, und für alle Tunneling-Routingereignisse, die noch nicht auf das Element getunnelt wurden, das sie ausgelöst hat, ist der Wert <xref:System.Windows.RoutedEventArgs.Source%2A> anders als der Wert der `sender` Parameter der Ereignisargumentklasse.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="d8d6a-184">Welches der beiden Elemente, die an dem Ereignis beteiligt sind, ist die größte Wichtigkeit in einem bestimmten Handler ( <xref:System.Windows.RoutedEventArgs.Source%2A> , dem Element, das es ausgelöst hat, oder `sender` , das Element, das es gerade verarbeitet), hängt von der Anwendungslogik ab, die der Handler adressiert.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="d8d6a-185">Das Festlegen dieser Eigenschaft erfolgt in der Regel nur, wenn andere APIs überschrieben oder implementiert werden, die Ereignis Quellen anpassen, z. b. wenn die Klasse ein Ereignis behandelt.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-185">Setting this property is typically only done when overriding or implementing other APIs that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="d8d6a-186">Das Zurücksetzen von sichtbaren Ereignis Quellen aus Instanzhandlern wird nicht empfohlen, insbesondere dann, wenn der Handler das Ereignis nicht als behandelt kennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="d8d6a-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="d8d6a-187">Wenn Sie zurücksetzen, <xref:System.Windows.RoutedEventArgs.Source%2A> um eine andere Ereignis Quelle zu melden, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> meldet die Quelle weiterhin wie zuvor durch den ursprünglichen-Befehl ausgelöst <xref:System.Windows.UIElement.RaiseEvent%2A> .</span><span class="sxs-lookup"><span data-stu-id="d8d6a-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
