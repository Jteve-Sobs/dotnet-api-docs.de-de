<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b67754600f5ea5cf963bca9d8314062e0287aaae" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55404023" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält Zustandsinformationen und Ereignisdaten, die einem Routingereignis zugeordnet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verschiedene <xref:System.Windows.RoutedEventArgs> kann verwendet werden, mit einem einzelnen <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Diese Klasse ist zuständig für das Verpacken der Ereignisdaten zu einem <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>zusätzliche ereignisstatusinformationen bereitgestellt und wird durch das System verwendet, für das Aufrufen des Handlers für das Routingereignis zugeordnet.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung dieser parameterlosen Konstruktor, der alle öffentlichen Eigenschaften der neuen <xref:System.Windows.RoutedEventArgs> Instanz davon aus, die folgenden Standardwerte:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Standardmäßig `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Der Standardwert ist `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Standardmäßig `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Standardmäßig `null`.  
  
 NULL-Werte für <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> bedeuten lediglich, dass die <xref:System.Windows.RoutedEventArgs> Daten unternimmt keinen Versuch, die die Quelle angeben. Wenn diese Instanz verwendet wird, in einem Aufruf von <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Werte werden basierend auf das Element, das das Ereignis ausgelöst hat, und über die Weiterleitung an Listener übergeben werden aufgefüllt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</param>
        <summary>Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diesem überladenen Konstruktor verwenden, nicht angegeben Eigenschaften des neuen <xref:System.Windows.RoutedEventArgs> Instanz davon aus, die folgenden Standardwerte:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Der Standardwert ist `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Standardmäßig `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Standardmäßig `null`.  
  
 NULL-Werte für <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> bedeuten lediglich, dass dies <xref:System.Windows.RoutedEventArgs> unternimmt keinen Versuch, die die Quelle angeben. Wenn diese Instanz verwendet wird, in einem Aufruf von <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> und <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Werte werden basierend auf das Element, das das Ereignis ausgelöst hat, und über die Weiterleitung an Listener übergeben werden aufgefüllt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Windows.RoutedEventArgs> für die Verwendung in einem Aufruf von <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</param>
        <param name="source">Eine alternative Quelle, die beim Behandeln des Ereignisses gemeldet wird. Diese füllt die <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft vorab.</param>
        <summary>Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse, wobei die Möglichkeit zum Deklarieren einer anderen Quelle für das Ereignis besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diesem überladenen Konstruktor verwenden, nicht angegeben Eigenschaften des neuen <xref:System.Windows.RoutedEventArgs> Instanz davon aus, die folgenden Standardwerte:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Der Standardwert ist `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Standardmäßig `null`.  
  
 NULL-Werte für <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> werden basierend auf das Element, das das Ereignis ausgelöst hat und über die Weiterleitung übergeben aufgefüllt, aber liest `null` vor dem Aufruf.  
  
 Verwenden Sie diese Signatur, bei der Übergabe <xref:System.Windows.RoutedEventArgs> an virtuelle Aufrufe wie z. B. <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, wobei die Argumente verwendet werden, aufrufen, <xref:System.Windows.UIElement.RaiseEvent%2A> intern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den aktuellen Zustand der Ereignisbehandlung für ein Routingereignis beim Durchlaufen der Route angibt, oder legt diesen fest.</summary>
        <value>Wenn Sie festlegen, legen Sie auf <see langword="true" /> Wenn das Ereignis ist, werden als behandelt markiert, andernfalls <see langword="false" />. Wenn dieser Wert gelesen <see langword="true" /> gibt an, dass es sich bei einem Klassenhandler oder einem Instanzhandler entlang der Route bereits dieses Ereignis als behandelt markiert wurde. <see langword="false" /> gibt an, dass das Ereignis von keinem Handler als behandelt markiert wurde.  
  
Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ereignis als behandelt markieren, wird die Sichtbarkeit des Routingereignisses an Listener auf der Ereignisroute beschränkt. Das Ereignis wird immer noch übertragen den Rest der Route, aber nur Handler ausdrücklich hinzugefügt werden, mit `HandledEventsToo` `true` in die <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Methodenaufruf wird als Antwort aufgerufen werden. Standard-Handler für Instanzlistener (z. B. die ausgedrückt in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) wird nicht aufgerufen werden. Behandeln von Ereignissen, die markiert sind, verarbeitet, ist kein gängiges Szenario.  
  
 Wenn Sie Autor eines Steuerelements sind definieren Ihre eigenen Ereignisse, die Entscheidungen in Bezug auf Ereignis behandeln, die auf Klassenebene hat Auswirkungen auf Benutzer des Steuerelements sowie alle Benutzer der abgeleitete Steuerelemente und potenziell andere Elemente, die entweder das Steuerelement enthalten sind oder das Steuerelement enthalten. Weitere Informationen finden Sie unter [Markieren von Routingereignissen als behandelt und Klassenbehandlung](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 In sehr seltenen Fällen ist es zum Behandeln von Ereignissen geeignet, in denen <xref:System.Windows.RoutedEventArgs.Handled%2A> markiert ist `true`, und ändern die Ereignisargumente <xref:System.Windows.RoutedEventArgs.Handled%2A> zu `false`. Dies kann erforderlich sein, in bestimmten Bereichen der Eingabeereignisse von Steuerelementen, z. B. die Bearbeitung von Schlüsseln <xref:System.Windows.UIElement.KeyDown> im Vergleich zu <xref:System.Windows.UIElement.TextInput> auf niedriger Stufe, in denen auf hoher Ebene Eingabeereignisse, die im Wettbewerb stehen für die Behandlung und jede versucht, die Arbeit mit einer anderen routing-Strategie.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Ereignishandler, der das Ereignis als behandelt markiert.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Die aufzurufende generische Handler- bzw. Delegatimplementierung.</param>
        <param name="genericTarget">Das Ziel, für das der bereitgestellte Handler aufgerufen werden soll.</param>
        <summary>Ermöglicht beim Überschreiben in einer abgeleiteten Klasse das typspezifische Aufrufen von Ereignishandlern, wodurch die Effizienz gegenüber der Basisimplementierung verbessert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die grundlegende Implementierung umfasst die Reflektion, um zu bestimmen, den richtigen Handler für alle Fälle, in dem der Handler handelt es sich nicht <xref:System.Windows.RoutedEventHandler>, und diesen Schritt für die Reflektion verfügt über einige Leistung folgen. Aufrufe können effizienter vorgenommen werden, indem Sie nicht auf Reflektion. Dies ist das Szenario, das diese Methode wird für jede Routingereignis-Argumente-Klasse, die sie außer Kraft setzen motiviert. Implementierungen sollten die Basis für diese Methode nicht aufrufen, da Ihre Implementierung bereits für die sichere Typ-Handler aufrufen verantwortlich sein sollte.  
  
   
  
## Examples  
 Der folgende Code ist Pseudocode, der ein grundlegendes Muster veranschaulicht, das für die Implementierung verwendet werden können. Hier `MyRoutedEventHandler` ist eine Unterklasse von <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode wird von abgeleiteten Ereignisdatenklassen effizienter Aufrufe ihrer Delegaten zu überschreiben werden sollen. Die Implementierung sollte eine Umwandlung der bereitgestellten <paramref name="genericHandler" /> die typspezifische delegieren und rufen Sie dann diesen Handler.  
  
Die Standardimplementierung versucht, den angegebenen Handler auf, es wird versucht, ihn als umwandeln Aufrufen <see cref="T:System.Windows.RoutedEventHandler" />. Wenn entweder <paramref name="genericHandler" /> oder <paramref name="genericTarget" /> dient als <see langword="null" />, werden Ausnahmen ausgelöst.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Der neue Wert, auf den <see cref="P:System.Windows.RoutedEventArgs.Source" /> festgelegt wird.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse einen Einstiegspunkt für Benachrichtigungsrückrufe an, wenn der Wert der <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft einer Instanz geändert wird.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Programmgesteuertes Ändern der gemeldeten Quelle eines Ereignisses kann möglicherweise erfordern das Aktualisieren der typspezifischen Daten im Ereignis. Aus diesem Grund die <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> Methode virtuell geschützt und von Unterklassen von außer Kraft gesetzt werden soll <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Diese Methode besitzt keine Standardimplementierung.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ursprünglich meldende Quelle ab, die durch einen reinen Treffertest bestimmt wurde, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine übergeordnete Klasse erfolgt.</summary>
        <value>Die ursprüngliche meldende Quelle, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine Klassenbehandlung vorgenommen wird, die möglicherweise ausgeführt wird, um zusammengesetzte Elementstrukturen flachzumachen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft den Wert ab, einmal vor der Schulung Ereignishandler oder keine Instanzhandler aufgerufen werden und nicht jenseits dieses Punktes angepasst wird. Die ursprüngliche Quellinformationen ist schreibgeschützt und Klassenhandler oder Implementierungen der Klasse, wie in den Ereignisdaten gemeldet wird.  
  
 Allgemeine Fälle, in dem die Quelle angepasst werden kann kann, gehören Inhaltselemente in einem Inhaltsmodell für ein Steuerelement (Melden Sie den Inhalt des Listenelements verwendet wird, z. B. werden das Listenelement als die <xref:System.Windows.RoutedEventArgs.Source%2A> und das tatsächliche Element innerhalb des Listenelements werden die <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Anpassung der Quelle durch die verschiedenen Elemente und Inhaltsmodelle variiert von Klasse zu Klasse. Möchte, dass jede Klasse, die Ereignisquellen anpasst, erwarten die Quelle ist besonders hilfreich für die Eingabe und die Szenarien für den die Klasse wurde gemeldet, und klicken Sie dann Gruppen, die als Quelle der <xref:System.Windows.RoutedEventArgs.Source%2A>. Wenn diese Quelle nicht die, die Relevanz für Ihre Behandlung des Ereignisses, versuchen Sie es überprüfen <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> stattdessen, ob es eine andere Quelle meldet, die besser geeignet ist. Weitere Informationen zu den Eingabeereignissen, finden Sie unter [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Instanz ab, die dieser <see cref="T:System.Windows.RoutedEventArgs" />-Instanz zugeordnet ist, oder legt die Instanz fest.</summary>
        <value>Der Bezeichner für das Ereignis, das aufgerufen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann nicht, legen Sie diesen Wert auf eine <xref:System.Windows.RoutedEventArgs> , die bereits weitergeleitet wurde (z. B. Wenn Sie die Argumente durch einen Handler abgerufen haben). Dies dennoch versuchen, wird eine Ausnahme generiert. Sie können nur auf einer Instanz festgelegt werden, die noch nicht verwendet wurde verfügt über einen Aufruf des Ereignisses zu generieren.  
  
 Der Wert des <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> nicht `null` zu einem beliebigen Zeitpunkt.  
  
   
  
## Examples  
 Im folgenden Beispiel neue Routingereignis-Daten mit einem ursprünglichen Konstruktor erstellt, und legt dann die <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> -Eigenschaft, wie eine nachfolgende Operation. Sie benötigen <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> vor dem Auslösen des Routingereignisses festgelegt.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Wert zu ändern, während das Ereignis weitergeleitet wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf das Objekt ab, das das Ereignis ausgelöst hat, oder legt diesen fest.</summary>
        <value>Das Objekt, das das Ereignis ausgelöst hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für alle bubbling-Routingereignisse, die die Route tatsächlich hinter dem Element, das sie ausgelöst hat, und für alle Tunneling-Routingereignisse, die noch nicht auf das Element getunnelt wurden, das sie ausgelöst hat, ist der Wert <xref:System.Windows.RoutedEventArgs.Source%2A> anders als der Wert der `sender` Parameter der Ereignisargumentklasse. Welche der beiden Elemente an das Ereignis beteiligt ist, die größte Relevanz in einem bestimmten Handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, das Element, das es ausgelöst oder `sender`, das Element, das derzeit behandelnde) ist abhängig von der Anwendungslogik, die Ihren Handler Adressierung.  
  
 Durch Festlegen dieser Eigenschaft in der Regel erfolgt nur beim Überschreiben oder implementieren andere [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , die Ereignisquellen anpassen, z. B. Wenn Klasse behandeln eines Ereignisses. Das Zurücksetzen von instanzhandlern offensichtlich Ereignisquellen wird nicht empfohlen, insbesondere dann, wenn der Handler nicht das Ereignis nicht als behandelt markiert.  
  
 Wenn Sie zurücksetzen <xref:System.Windows.RoutedEventArgs.Source%2A> melden eine andere Ereignisquelle, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> wird fortgesetzt, an die Quelle als erste ausgelöst wird, vom ursprünglichen Bericht <xref:System.Windows.UIElement.RaiseEvent%2A> aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>