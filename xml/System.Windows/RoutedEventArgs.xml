<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bcf7dc63deeaebfa62a5b5e0578c3f64cef20e2d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69433632" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält Zustandsinformationen und Ereignisdaten, die einem Routingereignis zugeordnet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Andere <xref:System.Windows.RoutedEventArgs> können mit einem einzelnen <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>verwendet werden. Diese Klasse ist für das Verpacken der Ereignisdaten für einen <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>zuständig und stellt zusätzliche Ereignis Zustandsinformationen bereit und wird vom Ereignis System zum Aufrufen des dem Routing Ereignis zugeordneten Handlers verwendet.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Parameter lose Konstruktor verwendet wird, nehmen alle öffentlichen Eigenschaften der neuen <xref:System.Windows.RoutedEventArgs> Instanz die folgenden Standardwerte an:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>der Standardwert ist. `null`  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Standardwert`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>der Standardwert ist. `null`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>der Standardwert ist. `null`  
  
 NULL-Werte <xref:System.Windows.RoutedEventArgs.Source%2A> für <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> und bedeuten nur, <xref:System.Windows.RoutedEventArgs> dass die Daten nicht versuchen, die Quelle anzugeben. Wenn diese Instanz in einem-Rückruf <xref:System.Windows.UIElement.RaiseEvent%2A>verwendet wird, werden die <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> -und-Werte basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und über das Routing an Listener weitergeleitet wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</param>
        <summary>Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser überladene Konstruktor verwendet wird, nehmen nicht angegebene <xref:System.Windows.RoutedEventArgs> Eigenschaften der neuen Instanz die folgenden Standardwerte an:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Standardwert`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>der Standardwert ist. `null`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>der Standardwert ist. `null`  
  
 NULL-Werte <xref:System.Windows.RoutedEventArgs.Source%2A> für <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> und bedeuten nur, <xref:System.Windows.RoutedEventArgs> dass dadurch nicht versucht wird, die Quelle anzugeben. Wenn diese Instanz in einem-Rückruf <xref:System.Windows.UIElement.RaiseEvent%2A>verwendet wird, werden die <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> <xref:System.Windows.RoutedEventArgs.Source%2A> -und-Werte basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und über das Routing an Listener weitergeleitet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues <xref:System.Windows.RoutedEventArgs> erstellt, das in einem- <xref:System.Windows.UIElement.RaiseEvent%2A>Befehl verwendet werden soll.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Der Bezeichner des Routingereignisses für diese Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse.</param>
        <param name="source">Eine alternative Quelle, die beim Behandeln des Ereignisses gemeldet wird. Diese füllt die <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft vorab.</param>
        <summary>Initialisiert mithilfe des angegebenen Bezeichners für das Routingereignis eine neue Instanz der <see cref="T:System.Windows.RoutedEventArgs" />-Klasse, wobei die Möglichkeit zum Deklarieren einer anderen Quelle für das Ereignis besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser überladene Konstruktor verwendet wird, nehmen nicht angegebene <xref:System.Windows.RoutedEventArgs> Eigenschaften der neuen Instanz die folgenden Standardwerte an:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>Standardwert`false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>der Standardwert ist. `null`  
  
 NULL-Werte <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> für werden basierend auf dem Element aufgefüllt, das das Ereignis ausgelöst hat und durch das Routing weitergeleitet wird `null` , das jedoch vor dem Aufruf gelesen wird.  
  
 Verwenden Sie diese Signatur bei <xref:System.Windows.RoutedEventArgs> der Übergabe an Virtuale <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>wie z. b., wobei die <xref:System.Windows.UIElement.RaiseEvent%2A> Argumente verwendet werden, um intern aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den aktuellen Zustand der Ereignisbehandlung für ein Routingereignis beim Durchlaufen der Route angibt, oder legt diesen fest.</summary>
        <value>Wenn dieser Wert festgelegt wird, legen Sie ihn auf <see langword="true" /> fest, wenn das Ereignis als behandelt markiert werden soll, andernfalls auf <see langword="false" />. Wenn dieser Wert gelesen wird, gibt <see langword="true" /> an, dass dieses Ereignis bereits von einem Klassenhandler oder einem Instanzhandler entlang der Route als behandelt markiert wurde. <see langword="false" />gibt an, dass das Ereignis von keinem Handler als behandelt markiert wurde.  
  
Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Ereignis behandelt wird, wird die Sichtbarkeit des Routing Ereignisses auf die Ereignis Route beschränkt. Das Ereignis leitet weiterhin den Rest der Route, aber nur Handler, die speziell mit `HandledEventsToo` `true` im <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Methodenaufruf hinzugefügt wurden, werden als Antwort aufgerufen. Standard Handler für Instanzlistener (z. b. die [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]in ausgedrückten) werden nicht aufgerufen. Das Behandeln von Ereignissen, die als behandelt gekennzeichnet sind, ist kein gängiges Szenario.  
  
 Wenn Sie ein Steuerungs Autor sind, der Ihre eigenen Ereignisse definiert, betreffen die Entscheidungen, die Sie bezüglich der Ereignis Behandlung auf Klassenebene treffen, die Benutzer Ihres Steuer Elements sowie alle Benutzer von abgeleiteten Steuerelementen und potenziell andere Elemente, die entweder in Ihrem Steuerelement enthalten sind. oder, das das Steuerelement enthält. Weitere Informationen finden Sie unter [Markieren von Routingereignissen als behandelt und Klassenbehandlung](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 In sehr seltenen Fällen ist es sinnvoll, Ereignisse zu behandeln <xref:System.Windows.RoutedEventArgs.Handled%2A> , bei `true`denen markiert ist, und die Ereignis Argumente <xref:System.Windows.RoutedEventArgs.Handled%2A> zu `false`ändern, indem Sie in ändern. Dies kann in bestimmten Bereichen von Eingabe Ereignissen von Steuerelementen erforderlich sein, z. b. <xref:System.Windows.UIElement.KeyDown> bei <xref:System.Windows.UIElement.TextInput> der Schlüssel Behandlung von im Vergleich zu, wenn Low-Level-und High-Level-Eingabeereignisse für die Verarbeitung konkurrieren, und jede versucht, mit einer anderen Routing Strategie zu arbeiten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Ereignishandler implementiert, der das behandelte Ereignis kennzeichnet.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Die aufzurufende generische Handler- bzw. Delegatimplementierung.</param>
        <param name="genericTarget">Das Ziel, für das der bereitgestellte Handler aufgerufen werden soll.</param>
        <summary>Ermöglicht beim Überschreiben in einer abgeleiteten Klasse das typspezifische Aufrufen von Ereignishandlern, wodurch die Effizienz gegenüber der Basisimplementierung verbessert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung schließt Reflektion ein, um den richtigen Handler für alle Fälle zu ermitteln, in <xref:System.Windows.RoutedEventHandler>denen der Handler nicht buchstäblich ist, und dieser reflektionsschritt hat einige Leistungs Konsequenzen. Aufrufe können effizienter gemacht werden, da Sie sich nicht auf Reflektion verlassen. Dies ist das Szenario, in dem diese Methode für alle Routing Ereignis Argument-Klassen verfügbar ist, die Sie überschreiben möchten. Implementierungen sollten die Basis für diese Methode nicht aufrufen, da ihre Implementierung bereits für das Aufrufen der typsicheren Handler zuständig ist.  
  
   
  
## Examples  
 Der folgende Code zeigt ein grundlegendes Muster, das für die Implementierung verwendet werden kann. Hier ist eine Unterklasse von <xref:System.Windows.RoutedEventHandler>. `MyRoutedEventHandler`  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode ist dafür vorgesehen, von abgeleiteten Ereignisdaten Klassen überschrieben zu werden, um einen effizienteren Aufruf ihrer Delegaten bereitzustellen. Die-Implementierung muss die bereit <paramref name="genericHandler" /> gestellte in den typspezifischen Delegaten umwandeln und dann diesen Handler aufrufen.  
  
Die Standard Implementierung versucht, den bereitgestellten Handler aufzurufen, wobei versucht wird, <see cref="T:System.Windows.RoutedEventHandler" />ihn als umzuwandeln. Wenn entweder <paramref name="genericHandler" /> oder <paramref name="genericTarget" /> als <see langword="null" />angegeben wird, werden Ausnahmen ausgelöst.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Der neue Wert, auf den <see cref="P:System.Windows.RoutedEventArgs.Source" /> festgelegt wird.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse einen Einstiegspunkt für Benachrichtigungsrückrufe an, wenn der Wert der <see cref="P:System.Windows.RoutedEventArgs.Source" />-Eigenschaft einer Instanz geändert wird.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die gemeldete Quelle eines Ereignisses Programm gesteuert ändern, ist es möglicherweise erforderlich, dass die typspezifischen Daten innerhalb des Ereignisses aktualisiert werden. Aus diesem Grund ist die <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> -Methode geschützt und soll von Unterklassen von <see cref="T:System.Windows.RoutedEventArgs" />überschrieben werden.  
  
Diese Methode hat keine Standard Implementierung.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ursprünglich meldende Quelle ab, die durch einen reinen Treffertest bestimmt wurde, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine übergeordnete Klasse erfolgt.</summary>
        <value>Die ursprüngliche meldende Quelle, bevor eine mögliche <see cref="P:System.Windows.RoutedEventArgs.Source" />-Anpassung durch eine Klassenbehandlung vorgenommen wird, die möglicherweise ausgeführt wird, um zusammengesetzte Elementstrukturen flachzumachen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft den Wert einmal ab, bevor die Klassen Ereignishandler oder Instanzhandler aufgerufen werden, und wird an diesem Punkt nie angepasst. Die ursprünglichen Quell Informationen sind in Klassen Handlern oder Klassen Implementierungen schreibgeschützt, ebenso wie Sie in den Ereignisdaten gemeldet werden.  
  
 Häufige Fälle, in denen die Quelle angepasst werden kann, enthalten Inhaltselemente in einem Inhalts Modell für ein Steuerelement (der Inhalt eines Listen Elements meldet beispielsweise das Listenelement Element als <xref:System.Windows.RoutedEventArgs.Source%2A> und das tatsächliche Element innerhalb des Listen Elements )<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Die Quell Anpassung nach verschiedenen Elementen und Inhalts Modellen variiert von Klasse zu Klasse. Jede Klasse, die Ereignis Quellen anpasst, versucht vorherzusagen, welche Quelle für die meisten Eingabe Szenarios und die Szenarien, für die die Klasse vorgesehen ist, am nützlichsten ist, und legt <xref:System.Windows.RoutedEventArgs.Source%2A>diese Quelle dann als fest. Wenn diese Quelle nicht der Wert ist, der für die Behandlung des Ereignisses relevant ist, versuchen Sie <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> stattdessen, zu überprüfen, ob Sie eine andere Quelle meldet, die besser geeignet ist. Weitere Informationen zu Eingabe Ereignissen finden Sie unter [Übersicht](~/docs/framework/wpf/advanced/input-overview.md)über die Eingabe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Instanz ab, die dieser <see cref="T:System.Windows.RoutedEventArgs" />-Instanz zugeordnet ist, oder legt die Instanz fest.</summary>
        <value>Der Bezeichner für das Ereignis, das aufgerufen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diesen Wert nicht für einen <xref:System.Windows.RoutedEventArgs> festlegen, der bereits weitergeleitet wurde (wenn Sie beispielsweise die Argumente über einen Handler abgerufen haben). Wenn Sie versuchen, dies zu tun, wird eine Ausnahme generiert. Sie können Sie nur für eine-Instanz festlegen, die noch nicht verwendet wurde, um einen Aufruf des Ereignisses zu generieren.  
  
 Der Wert von <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> darf nicht `null` gleichzeitig sein.  
  
   
  
## Examples  
 Im folgenden Beispiel werden neue Routing Ereignisdaten mit einem anfänglichen Konstruktor erstellt und dann die <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> -Eigenschaft als nachfolgende Vorgang festgelegt. Sie müssen vor <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> der Erhöhung des-Routing Ereignisses festgelegt haben.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />-Wert zu ändern, während das Ereignis weitergeleitet wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf das Objekt ab, das das Ereignis ausgelöst hat, oder legt diesen fest.</summary>
        <value>Das Objekt, das das Ereignis ausgelöst hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für alle bubbling-Routingereignisse, die die Route tatsächlich hinter dem Element, das sie ausgelöst hat, und für alle Tunneling-Routingereignisse, die noch nicht auf das Element getunnelt wurden, das sie ausgelöst hat, ist der Wert <xref:System.Windows.RoutedEventArgs.Source%2A> anders als der Wert der `sender` Parameter der Ereignisargumentklasse. Welches der beiden Elemente, die an dem Ereignis beteiligt sind, ist die größte Wichtigkeit in einem<xref:System.Windows.RoutedEventArgs.Source%2A>bestimmten Handler (, dem Element, das `sender`es ausgelöst hat, oder, das Element, das es gerade verarbeitet), hängt von der Anwendungslogik ab, die der Handler ist. Erschließung.  
  
 Das Festlegen dieser Eigenschaft erfolgt in der Regel nur beim Überschreiben [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] oder Implementieren anderer, die Ereignis Quellen anpassen, z. b. bei der Klasse, die ein Ereignis behandelt. Das Zurücksetzen von sichtbaren Ereignis Quellen aus Instanzhandlern wird nicht empfohlen, insbesondere dann, wenn der Handler das Ereignis nicht als behandelt kennzeichnet.  
  
 Wenn Sie zurücksetzen <xref:System.Windows.RoutedEventArgs.Source%2A> , um eine andere Ereignis Quelle zu <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> melden, meldet die Quelle weiterhin wie zuvor durch den ursprünglichen <xref:System.Windows.UIElement.RaiseEvent%2A> -Befehl ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
