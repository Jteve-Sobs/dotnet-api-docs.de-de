<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6023396816c2ce384f3a4bba180bad7392c9134f" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72408265" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Objekt dar, das im Abhängigkeitseigenschaftensystem teilnimmt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.DependencyObject>-Klasse ermöglicht die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Eigenschaften Systemdienste für viele abgeleitete Klassen.  
  
 Die primäre Funktion des Eigenschaften Systems ist, die Werte von Eigenschaften zu berechnen und System Benachrichtigungen über geänderte Werte bereitzustellen. Eine andere Schlüssel Klasse, die am Eigenschaften System teilnimmt, ist <xref:System.Windows.DependencyProperty>. mit <xref:System.Windows.DependencyProperty> können Abhängigkeits Eigenschaften im Eigenschaften System registriert werden, und es werden Identifizierungs-und Informations Informationen zu den einzelnen Abhängigkeits Eigenschaften bereitstellt, während <xref:System.Windows.DependencyObject> als Basisklasse die Verwendung der Abhängigkeits Eigenschaften durch die Objekte ermöglicht.  
  
 <xref:System.Windows.DependencyObject>-Dienste und-Merkmale umfassen Folgendes:  
  
-   Unterstützung für Abhängigkeits Eigenschaften Hosting. Sie registrieren eine Abhängigkeits Eigenschaft, indem Sie die <xref:System.Windows.DependencyProperty.Register%2A>-Methode aufrufen und den Rückgabewert der Methode als öffentliches statisches Feld in der Klasse speichern.  
  
-   Unterstützung für angefügte Eigenschaften Hosting. Sie registrieren eine angefügte Eigenschaft, indem Sie die <xref:System.Windows.DependencyProperty.RegisterAttached%2A>-Methode aufrufen und den Rückgabewert der Methode als öffentliches statisches Schreib geschütztes Feld in der Klasse speichern. (Es gibt auch zusätzliche Member-Anforderungen. Beachten Sie, dass dies eine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-spezifische Implementierung für angefügte Eigenschaften darstellt. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Die angefügte Eigenschaft kann dann für jede Klasse festgelegt werden, die von <xref:System.Windows.DependencyObject> abgeleitet ist.  
  
-   Get, Set und Clear Utility-Methoden für Werte aller Abhängigkeits Eigenschaften, die auf dem <xref:System.Windows.DependencyObject> vorhanden sind.  
  
-   Metadaten, coerce-Wert Unterstützung, Benachrichtigung über geänderte Eigenschaften und Überschreiben von Rückrufen für Abhängigkeits Eigenschaften oder angefügte Eigenschaften. Außerdem ermöglicht die <xref:System.Windows.DependencyObject>-Klasse die metadateneigenschaftenmetadaten für eine Abhängigkeits Eigenschaft.  
  
-   Eine allgemeine Basisklasse für Klassen, die von <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable> oder <xref:System.Windows.Media.Visual> abgeleitet werden. (<xref:System.Windows.UIElement>, eine andere Basiselement Klasse, verfügt über eine Klassenhierarchie, die <xref:System.Windows.Media.Visual> enthält.)  
  
   
  
## Examples  
 Im folgenden Beispiel wird von <xref:System.Windows.DependencyObject> abgeleitet, um eine neue abstrakte Klasse zu erstellen. Die Klasse registriert dann eine angefügte Eigenschaft und enthält Unterstützungs Member für diese angefügte Eigenschaft.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.DependencyObject" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den lokalen Wert einer Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Objektverweis identifiziert.</param>
        <summary>Löscht den lokalen Wert einer Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Löschen des Eigenschafts Werts durch Aufrufen von <xref:System.Windows.DependencyObject.ClearValue%2A> weist nicht notwendigerweise eine Abhängigkeits Eigenschaft als Standardwert zu, der in den Metadaten der Abhängigkeits Eigenschaft angegeben ist. Durch das Löschen der Eigenschaft wird lediglich der lokale Wert gelöscht, der möglicherweise angewendet wurde. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Eigenschaften durchlaufen, für die lokale Werte für ein Objekt festgelegt sind, und dann <xref:System.Windows.DependencyObject.ClearValue%2A> aufgerufen, um die Werte der einzelnen Eigenschaften zu löschen.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel für die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll.</param>
        <summary>Löscht den lokalen Wert einer schreibgeschützten Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyPropertyKey" /> angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyPropertyKey> identifiziert eine schreibgeschützte Abhängigkeits Eigenschaft für Eigenschaften System Vorgänge. Klassen, die schreibgeschützte Abhängigkeits Eigenschaften definieren, sollten diesen Schlüssel nicht mit öffentlichem Zugriff verfügbar machen. Ein öffentlich verfügbar gemachter Schlüssel stellt einen öffentlichen Codepfad bereit, der das schreibgeschützte Zeichen der-Eigenschaft negiert, wenn Methoden wie <xref:System.Windows.DependencyObject.ClearValue%2A> oder <xref:System.Windows.DependencyObject.SetValue%2A> außerhalb der Klasse oder Assembly aufgerufen werden können, die auf den Schlüssel verweisen.  
  
 Das Löschen des Eigenschafts Werts durch Aufrufen von <xref:System.Windows.DependencyObject.ClearValue%2A> weist nicht notwendigerweise eine Abhängigkeits Eigenschaft als Standardwert zu, der in den Metadaten der Abhängigkeits Eigenschaft angegeben ist. Durch das Löschen des Werts wird lediglich der lokale Wert gelöscht. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die zu erzwingende Abhängigkeitseigenschaft.</param>
        <summary>Erzwingt den Wert der angegebenen Abhängigkeitseigenschaft. Dies erfolgt durch den Aufruf einer beliebigen <see cref="T:System.Windows.CoerceValueCallback" />-Funktion, die in den Metadaten für die Abhängigkeitseigenschaft angegeben ist, während sie beim aufrufenden <see cref="T:System.Windows.DependencyObject" /> beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.CoerceValueCallback> für eine Abhängigkeits Eigenschaft wird nicht nur explizit durch Aufrufen von <xref:System.Windows.DependencyObject.CoerceValue%2A> aufgerufen, sondern auch intern aufgerufen, wenn der Wert der Abhängigkeits Eigenschaft vom [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System erneut ausgewertet wird.  
  
 Wenn Sie die <xref:System.Windows.DependencyObject.CoerceValue%2A>-Methode aufrufen, rufen Sie letztendlich den coerce-Wert Rückruf für die angegebene Eigenschaft auf. In der Regel werden Sie <xref:System.Windows.DependencyObject.CoerceValue%2A> nur aufrufen, wenn Sie wissen, dass ein coerce-Wert Rückruf vorhanden ist, und wenn Sie die Kriterien des Rückrufs für die Umwandlung kennen.  
  
 Das gängigste Szenario für das Aufrufen von <xref:System.Windows.DependencyObject.CoerceValue%2A> liegt innerhalb der Klassen Behandlung oder der Rückrufe von Eigenschafts Änderungen von verknüpften Eigenschaften, die die Werte der anderen Werte auf abhängige Weise beeinflussen. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.CoerceValue%2A> innerhalb einer <xref:System.Windows.PropertyChangedCallback>-Implementierung aufgerufen, die als <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> für andere Abhängigkeits Eigenschaften für dieselbe Klasse verwendet wird. Dies ist ein gängiges Muster zum Einführen von true-Wert Abhängigkeiten zwischen Abhängigkeits Eigenschaften.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene <paramref name="dp" /> oder sein Wert waren ungültig oder sind nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.DependencyObjectType" /> ab, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</summary>
        <value>Ein <see cref="T:System.Windows.DependencyObjectType" />, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nützlich, wenn ein Objekt, das von einer Methode zurückgegeben wird, den Rückgabe Werttyp <xref:System.Windows.DependencyObject> aufweist und Sie abhängig vom Typ Eigenschaften systemspezifische Vorgänge ausführen möchten. Beispielsweise ist es effizienter, <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> mit der <xref:System.Windows.DependencyObjectType> statt mit dem [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ aufzurufen. <xref:System.Windows.DependencyObjectType> ermöglicht eine schnellere Suche.  
  
   
  
## Examples  
 Im folgenden Pseudo Codebeispiel geht `MySubClass` davon aus, dass zusätzliche abgeleitete Klassen möglicherweise den Standardwert der Abhängigkeits Eigenschaft `MyCustom` ändern. Die-Klasse implementiert einen Parameter losen Konstruktor, der die tatsächliche abgeleitete Klasse ermitteln kann, indem Sie Polymorphie für den <xref:System.Windows.DependencyObjectType>-Wert verwendet, wenn dieser Konstruktor als abgeleitete klasseninstanziator verwendet wird.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Der <see cref="T:System.Windows.DependencyObject" />, der mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob ein angegebenes <see cref="T:System.Windows.DependencyObject" /> dem aktuellen <see cref="T:System.Windows.DependencyObject" /> entspricht.</summary>
        <returns><see langword="true" />, wenn beide Instanzen identisch sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ist nur Verweis Gleichheit und versucht nicht, die Wert Gleichheit der enthaltenen Eigenschaften auszuwerten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> überschreibt und dann zwei grundlegende <see cref="T:System.Object" />-Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Die über schreibungen nennen die <see cref="T:System.Object" />-Implementierungen, was zu einem Objekt Gleichheits Verhalten führt. Der Zweck dieser absichtlichen über schreibungen besteht darin, zu verhindern, dass abgeleitete Klassen versuchen, eine Wert Gleichheit für eine <see cref="T:System.Windows.DependencyObject" /> zu definieren. Der Wert der equalitäten für "<see cref="T:System.Windows.DependencyObject" />" ist aufgrund der angeborenen Eigenschafts Wert veränderlichen Funktionen einer <see cref="T:System.Windows.DependencyObject" /> und ihrer Abhängigkeits Eigenschaften nie genau. Dies schließt grundlegende [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Funktionen ein, z. b. die Datenbindung und das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für diese <see cref="T:System.Windows.DependencyObject" /> ab.</summary>
        <returns>Ein 32-Bit-Ganzzahl-Hashcode mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> überschreibt und dann zwei <see cref="T:System.Object" />-Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Die über schreibungen nennen die <see cref="T:System.Object" />-Implementierungen, was zu einem Objekt Gleichheits Verhalten führt. Der Zweck dieser absichtlichen über schreibungen besteht darin, zu verhindern, dass abgeleitete Klassen versuchen, eine Wert Gleichheit für eine <see cref="T:System.Windows.DependencyObject" /> zu definieren. Der Wert der equalitäten für "<see cref="T:System.Windows.DependencyObject" />" ist aufgrund der angeborenen Eigenschafts Wert veränderlichen Funktionen einer <see cref="T:System.Windows.DependencyObject" /> und ihrer Abhängigkeits Eigenschaften nie genau. Dies schließt grundlegende [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Funktionen ein, z. b. die Datenbindung und das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen spezialisierten Enumerator, mit dem bestimmt wird, welche Abhängigkeitseigenschaften dieses <see cref="T:System.Windows.DependencyObject" /> über lokal festgelegte Werte verfügen.</summary>
        <returns>Ein spezialisierter lokaler Wertenumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *lokaler Wert* ist ein beliebiger Wert für eine Abhängigkeits Eigenschaft, der von <xref:System.Windows.DependencyObject.SetValue%2A> festgelegt wurde, im Gegensatz zu anderen Aspekten des Eigenschaften Systems.  
  
 Der <xref:System.Windows.LocalValueEnumerator>, der durch Aufrufen von <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> abgerufen wird, kann verwendet werden, um Eigenschaften aufzulisten, die einen lokal festgelegten Wert für eine <xref:System.Windows.DependencyObject>-Instanz aufweisen. Jede dieser Eigenschaften wird im Enumerator durch ein <xref:System.Windows.LocalValueEntry>-Objekt dargestellt, das über Eigenschaften verfügt, die auf den spezifischen <xref:System.Windows.DependencyProperty> und seine Werte verweisen. Diese Methode zum Auflisten der lokal festgelegten Werte kann für die Optimierung oder andere Behandlung lokaler Werte verwendet werden, z. b. um zu ermitteln, welche Eigenschaftswerte einer <xref:System.Windows.DependencyObject> geändert werden, wenn Sie gelöscht wurden.  
  
> [!IMPORTANT]
>  Der zurückgegebene <xref:System.Windows.LocalValueEnumerator> kann <xref:System.Windows.LocalValueEntry>-Einträge für Abhängigkeits Eigenschaften enthalten, die schreibgeschützt sind, oder Abhängigkeits Eigenschaften, bei denen Werte vom-Eigenschaften System berechnet werden. Ein Visual Framework-Element, das über das Layout über eine festgelegte Breite verfügt, meldet z. b. einen lokalen Wert für <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Wenn Sie lokale Werte erhalten, um diese zurückzusetzen, überprüfen Sie den <xref:System.Windows.DependencyProperty.ReadOnly%2A>-Wert auf dem Eigenschaften Bezeichner jedes <xref:System.Windows.LocalValueEntry>, um sicherzustellen, dass die betreffende <xref:System.Windows.DependencyProperty>-Option nicht schreibgeschützt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Eigenschaften durchlaufen, für die lokale Werte für ein Objekt festgelegt sind, und dann <xref:System.Windows.DependencyObject.ClearValue%2A> aufgerufen, um die Werte der einzelnen Eigenschaften zu löschen.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, für die der Wert abgerufen wird.</param>
        <summary>Gibt den aktuellen effektiven Wert einer Abhängigkeitseigenschaft für diese Instanz eines <see cref="T:System.Windows.DependencyObject" /> zurück.</summary>
        <returns>Gibt den aktuellen effektiven Wert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der *effektive Wert* ist der Wert der Eigenschaft, die vom Eigenschaften System an jeden Aufrufer zurückgegeben wird, der den Wert anfordert. Der effektive Wert ist das Ergebnis des Eigenschaften Systems, das alle möglichen Eingaben ausgewertet hat, die an der Rangfolge des Eigenschaften System Werts beteiligt sind. Dies schließt Umwandlungs-und Animations Zeichen ein. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Diese Methode gibt nie <xref:System.Windows.DependencyProperty.UnsetValue> zurück. Der <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert für das Eigenschaften System, der in verschiedenen Kapazitäten intern verwendet und gelegentlich auch durch Umwandlungs Rückrufe verfügbar gemacht wird.  
  
 Wenn Sie nicht sicher sind, welcher Eigenschaftentyp sein sollte, können Sie den Bezeichner der angeforderten Abhängigkeits Eigenschaft Abfragen, um zu bestimmen, ob eine spezifischere <xref:System.Windows.DependencyProperty.PropertyType%2A> vorhanden ist, in die der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene <paramref name="dp" /> oder sein Wert ist ungültig, oder das angegebene <paramref name="dp" /> ist nicht vorhanden.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der neu zu berechnenden Eigenschaft.</param>
        <summary>Wertet den effektiven Wert für die angegebene Abhängigkeitseigenschaft erneut aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> aufrufen, können alle zugeordneten und anwendbaren <xref:System.Windows.CoerceValueCallback>-oder <xref:System.Windows.PropertyChangedCallback>-Funktionen, die für diese Abhängigkeits Eigenschaft registriert sind, aufgerufen werden.  
  
 Das Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> für eine Eigenschaft, deren lokaler Wert festgelegt ist, hat keine Auswirkung, da der lokale Wert Vorrang vor anderen Eigenschaften System Eingaben hat, mit Ausnahme von Animationen. Sie können jedoch <xref:System.Windows.DependencyObject.ClearValue%2A> und dann <xref:System.Windows.DependencyObject.InvalidateProperty%2A> aufzurufen. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Das Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ist nicht notwendigerweise auf viele Szenarien mit Abhängigkeits Eigenschaften anwendbar. Wenn eine Abhängigkeits Eigenschaft aufgrund von Wertänderungen in einer der Bestandteile ungültig wird, wird die Abhängigkeits Eigenschaft durch das Eigenschaften System ungültig und automatisch erneut ausgewertet. Es gibt jedoch noch einige geeignete Szenarios, in denen <xref:System.Windows.DependencyObject.InvalidateProperty%2A> nützlich ist. Insbesondere können Sie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> innerhalb des coerce-Werts oder des Eigenschafts geänderten Rückrufs für eine andere Abhängigkeits Eigenschaft verwenden. Sie können auch <xref:System.Windows.DependencyObject.InvalidateProperty%2A> verwenden, um die erneute Auswertung einer Bindung für eine Datenquelle zu erzwingen, die nicht in der Lage ist, den empfohlenen <xref:System.ComponentModel.INotifyPropertyChanged>-Benachrichtigungs Mechanismus zu implementieren (z. b., wenn Sie Daten Klassen verwenden, die nicht von abgeleitet werden können, oder wenn die Daten ein statischer Member sind).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.InvalidateProperty%2A> für eine benutzerdefinierte Eigenschaft aufgerufen, wenn Eigenschaften, die an den Berechnungen der ungültigen Eigenschaft beteiligt sind, geändert werden. Dies ist eine alternative Methode, um die <xref:System.Windows.DependencyObject.CoerceValue%2A>-Methode aufzurufen, da durch das invalidieren der Eigenschaft auch alle registrierten <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> aufgerufen werden.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese Instanz derzeit versiegelt (schreibgeschützt) ist.</summary>
        <value><see langword="true" />, wenn diese Instanz versiegelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird intern festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten, die den betreffenden Bezeichner für eine Abhängigkeitseigenschaft, die Eigenschaftsmetadaten für den Typ sowie die alten und neuen Werte enthalten.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.DependencyObject" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird in den Ereignisdaten gemeldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht dafür vorgesehen, einzelne Eigenschafts Änderungen im Allgemeinen zu erkennen oder die Validierung von Eigenschaften auf Einzelfallbasis auszuführen. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> ist stattdessen für Änderungen des allgemeinen invalidierungsmusters vorgesehen, wenn bestimmte Informationen über breite Klassifizierungen von Eigenschaften bekannt sind. Änderungen in einem <xref:System.Windows.Freezable> können z. b. Änderungen in den Werttypen von <xref:System.Windows.Freezable> oder unter Eigenschaften sein, bei denen sich die Änderungen innerhalb anderer <xref:System.Windows.Freezable>-Verweise befinden. Die <xref:System.Windows.Freezable>-Überschreibungs Implementierung von <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> verwendet interne Informationen, um zu bestimmen, ob es sich bei den Eigenschaften um untergeordnete Eigenschaften handelt, und bietet für beide Fälle eine entsprechende Basisklassen Logik.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> kann während der Lebensdauer eines Objekts möglicherweise mehrmals aufgerufen werden. Aus diesem Grund können Sie eine bessere Leistung für das allgemeine Eigenschaften System erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und dann <xref:System.Windows.CoerceValueCallback>-oder <xref:System.Windows.PropertyChangedCallback>-Funktionen für einzelne Eigenschaften anfügen. Sie verwenden diese Methode jedoch, wenn eine <xref:System.Windows.DependencyObject> eine beträchtliche Anzahl von Wert abhängigen Abhängigkeits Eigenschaften enthält, oder wenn Sie Logik wie das Renderingverhalten enthält, das für mehrere verwandte Fälle von Eigenschafts Invalidierungen erneut ausgeführt werden muss.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ruft immer die Basis Implementierung auf. Wenn dies nicht der Fall ist, wird das gesamte [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System erheblich deaktiviert, sodass falsche Werte gemeldet werden.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, für die der Wert abgerufen wird.</param>
        <summary>Gibt, sofern vorhanden, den lokalen Wert einer Abhängigkeitseigenschaft zurück.</summary>
        <returns>Gibt den lokalen Wert oder den Sentinelwert <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> zurück, wenn kein lokaler Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für eine Abhängigkeits Eigenschaft sollten Sie <xref:System.Windows.DependencyObject.GetValue%2A> für die meisten typischen "Get"-Vorgänge verwenden. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> gibt den effektiven Wert für eine Vielzahl von Situationen zurück, in denen der Wert nicht lokal festgelegt wurde.  
  
 Werte, die durch Stile, Designs, Vorlagen, den Standardwert aus Metadaten oder die Vererbung von Eigenschafts Werten festgelegt werden, werden nicht als lokale Werte betrachtet. Bindungen und andere Ausdrücke werden jedoch als lokale Werte betrachtet, nachdem Sie ausgewertet wurden.  
  
 Wenn kein lokaler Wert festgelegt ist, gibt diese Methode <xref:System.Windows.DependencyProperty.UnsetValue> zurück.  
  
 Wenn der zurückgegebene Wert nicht <xref:System.Windows.DependencyProperty.UnsetValue> ist, können Sie die Metadaten der angeforderten Abhängigkeits Eigenschaft Abfragen, um zu bestimmen, ob es einen spezifischeren Typ gibt, in den der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den Wert einer Abhängigkeitseigenschaft fest, ohne die Wertquelle zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einer Komponente verwendet, die den Wert einer ihrer eigenen Eigenschaften Programm gesteuert festlegt, ohne die deklarierte Verwendung der-Eigenschaft einer Anwendung zu deaktivieren. Mit der <xref:System.Windows.DependencyObject.SetCurrentValue%2A>-Methode wird der effektive Wert der Eigenschaft geändert, vorhandene Trigger, Daten Bindungen und Stile funktionieren jedoch weiterhin.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft eines versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> hatte nicht den richtigen Typ, wie er für die <paramref name="dp" />-Eigenschaft registriert ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest, die über ihren Bezeichner angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Typ nicht mit dem Typ identisch ist, der für die Abhängigkeits Eigenschaft deklariert wurde, weil er ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Der Parameter "`value`" sollte immer als geeigneter Typ angegeben werden.  
  
 Die Ausnahmebedingungen werden potenziell durch den <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>-Rückruf beeinflusst, der im Bezeichner der Abhängigkeits Eigenschaft der festgelegten Abhängigkeits Eigenschaft vorhanden ist. Andernfalls können bei dem bereitgestellten Wert allgemeine Typüberprüfungen fehlschlagen (z. b. das Übergeben einer Zeichenfolge, wenn der Native Typ Double ist).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft eines versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> entsprach nicht dem für die <paramref name="dp" />-Eigenschaft registrierten Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der festzulegenden Eigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer schreibgeschützten Abhängigkeitseigenschaft fest, die durch den <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der Abhängigkeitseigenschaft angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur wird in der Regel verwendet, wenn Sie Werte für schreibgeschützte Abhängigkeits Eigenschaften festlegen, die von Ihren benutzerdefinierten Klassen definiert werden. Im Allgemeinen wird <xref:System.Windows.DependencyObject.SetValue%2A> nur von dem Typ aufgerufen, der diese Abhängigkeits Eigenschaft registriert hat, die die interne Logik implementiert, die den festgelegten Wert für die Abhängigkeits Eigenschaft bereitstellt. Weitere Informationen finden Sie unter [Schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Wenn der angegebene Typ nicht mit dem Typ identisch ist, der für die Abhängigkeits Eigenschaft deklariert wurde, weil er ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Der Parameter "`value`" sollte immer als geeigneter Typ angegeben werden. Die Ausnahmebedingungen werden potenziell durch den <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>-Rückruf beeinflusst, der im Bezeichner der Abhängigkeits Eigenschaft der festgelegten Abhängigkeits Eigenschaft vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine schreibgeschützte Abhängigkeits Eigenschaft zusammen mit einer `public static readonly`-<xref:System.Windows.DependencyProperty> definiert, die die erforderliche schreibgeschützte bereit barkeit für eigenschaftenconsumer und den Get-Accessor für den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Wrapper bereitstellt.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die Abhängigkeitseigenschaft, die serialisiert werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob Serialisierungsprozesse den Wert der bereitgestellten Abhängigkeitseigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn die bereitgestellte Abhängigkeitseigenschaft serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt für alle Fälle, in denen für eine Abhängigkeits Eigenschaft ein lokaler Wert auf <xref:System.Windows.DependencyObject> festgelegt wurde, `true` zurück.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Durch außer Kraft setzungen für diese Methode können bestimmte Abhängigkeits Eigenschaften anders behandelt werden.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
