<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9909bfd452bcd81963621d54c49b964f2e5e3ce1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69434689" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Objekt dar, das am System der Abhängigkeitseigenschaften teilnimmt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.DependencyObject> -Klasse [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aktiviert Eigenschaften Systemdienste für viele abgeleitete Klassen.  
  
 Die primäre Funktion des Eigenschaften Systems ist, die Werte von Eigenschaften zu berechnen und System Benachrichtigungen über geänderte Werte bereitzustellen. Eine andere Schlüssel Klasse, die am Eigenschaften System teilnimmt <xref:System.Windows.DependencyProperty>, ist. <xref:System.Windows.DependencyProperty>ermöglicht die Registrierung von Abhängigkeits Eigenschaften im Eigenschaften System und stellt Identifizierungs-und Informations Informationen zu den einzelnen Abhängigkeits Eigenschaften bereit, während <xref:System.Windows.DependencyObject> Objekte mithilfe der-Basisklasse die Abhängigkeits Eigenschaften verwenden können.  
  
 <xref:System.Windows.DependencyObject>zu den Diensten und Merkmalen zählen die folgenden:  
  
-   Unterstützung für Abhängigkeits Eigenschaften Hosting. Sie registrieren eine Abhängigkeits Eigenschaft, indem <xref:System.Windows.DependencyProperty.Register%2A> Sie die-Methode aufrufen und den Rückgabewert der Methode als öffentliches statisches Feld in der Klasse speichern.  
  
-   Unterstützung für angefügte Eigenschaften Hosting. Sie registrieren eine angefügte Eigenschaft, indem <xref:System.Windows.DependencyProperty.RegisterAttached%2A> Sie die-Methode aufrufen und den Rückgabewert der Methode als öffentliches statisches Schreib geschütztes Feld in der Klasse speichern. (Es gibt auch zusätzliche Member-Anforderungen. Beachten Sie, dass [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dies eine bestimmte Implementierung für angefügte Eigenschaften darstellt. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Die angefügte-Eigenschaft kann dann für jede Klasse festgelegt werden <xref:System.Windows.DependencyObject>, die von abgeleitet wird.  
  
-   Get-, Set-und Clear-Hilfsprogrammmethoden für Werte aller Abhängigkeits Eigenschaften, <xref:System.Windows.DependencyObject>die im vorhanden sind.  
  
-   Metadaten, coerce-Wert Unterstützung, Benachrichtigung über geänderte Eigenschaften und Überschreiben von Rückrufen für Abhängigkeits Eigenschaften oder angefügte Eigenschaften. Außerdem vereinfacht die <xref:System.Windows.DependencyObject> -Klasse die Eigenschaften Metadaten pro Besitzer für eine Abhängigkeits Eigenschaft.  
  
-   Eine allgemeine Basisklasse für Klassen, die <xref:System.Windows.ContentElement>von <xref:System.Windows.Freezable>, oder <xref:System.Windows.Media.Visual>abgeleitet sind. (<xref:System.Windows.UIElement>, eine andere Basiselement Klasse, verfügt über eine Klassenhierarchie, die enthält <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Im folgenden Beispiel wird von <xref:System.Windows.DependencyObject> abgeleitet, um eine neue abstrakte Klasse zu erstellen. Die Klasse registriert dann eine angefügte Eigenschaft und enthält Unterstützungs Member für diese angefügte Eigenschaft.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.DependencyObject" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den lokalen Wert einer Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Objektverweis identifiziert.</param>
        <summary>Löscht den lokalen Wert einer Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Löschen des Eigenschafts Werts <xref:System.Windows.DependencyObject.ClearValue%2A> durch Aufrufen von weist nicht notwendigerweise eine Abhängigkeits Eigenschaft als Standardwert zu, der in den Metadaten der Abhängigkeits Eigenschaft angegeben ist. Durch das Löschen der Eigenschaft wird lediglich der lokale Wert gelöscht, der möglicherweise angewendet wurde. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Eigenschaften durchlaufen, für die lokale Werte für ein-Objekt fest <xref:System.Windows.DependencyObject.ClearValue%2A> gelegt sind. Anschließend wird aufgerufen, um die Werte jeder solchen Eigenschaft zu löschen.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel für die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll.</param>
        <summary>Löscht den lokalen Wert einer schreibgeschützten Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyPropertyKey" /> angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyPropertyKey> identifiziert eine schreibgeschützte Abhängigkeits Eigenschaft für Eigenschaften System Vorgänge. Klassen, die schreibgeschützte Abhängigkeits Eigenschaften definieren, sollten diesen Schlüssel nicht mit öffentlichem Zugriff verfügbar machen. Ein öffentlich verfügbar gemachter Schlüssel stellt einen öffentlichen Codepfad bereit, der das schreibgeschützte Zeichen der-Eigenschaft negiert, wenn Methoden wie <xref:System.Windows.DependencyObject.ClearValue%2A> oder <xref:System.Windows.DependencyObject.SetValue%2A> außerhalb der Klasse oder Assembly aufgerufen werden können, die auf den Schlüssel verweisen.  
  
 Das Löschen des Eigenschafts Werts <xref:System.Windows.DependencyObject.ClearValue%2A> durch Aufrufen von weist nicht notwendigerweise eine Abhängigkeits Eigenschaft als Standardwert zu, der in den Metadaten der Abhängigkeits Eigenschaft angegeben ist. Durch das Löschen des Werts wird lediglich der lokale Wert gelöscht. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die zu erzwingende Abhängigkeitseigenschaft.</param>
        <summary>Erzwingt den Wert der angegebenen Abhängigkeitseigenschaft. Dies erfolgt durch den Aufruf einer beliebigen <see cref="T:System.Windows.CoerceValueCallback" />-Funktion, die in den Metadaten für die Abhängigkeitseigenschaft angegeben ist, während sie beim aufrufenden <see cref="T:System.Windows.DependencyObject" /> beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu dem explizit durch Aufrufen <xref:System.Windows.DependencyObject.CoerceValue%2A>von aufgerufen wird, wird die <xref:System.Windows.CoerceValueCallback> für eine Abhängigkeits Eigenschaft auch intern aufgerufen, wenn der Wert der Abhängigkeits Eigenschaft vom [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System erneut ausgewertet wird.  
  
 Wenn Sie die <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode aufrufen, rufen Sie letztendlich den coerce-Wert Rückruf für die angegebene Eigenschaft auf. Normalerweise werden Sie <xref:System.Windows.DependencyObject.CoerceValue%2A> nur aufrufen, wenn Sie wissen, dass ein coerce-Wert Rückruf vorhanden ist, und wenn Sie die Kriterien des Rückrufs für die Umwandlung kennen.  
  
 Das häufigste Szenario für das Aufrufen <xref:System.Windows.DependencyObject.CoerceValue%2A> von ist innerhalb der Klassen Behandlung oder der Rückrufe von Eigenschafts Änderungen von verknüpften Eigenschaften, die die Werte der anderen Werte auf abhängige Weise beeinflussen. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.DependencyObject.CoerceValue%2A> wird innerhalb einer <xref:System.Windows.PropertyChangedCallback> -Implementierung aufgerufen <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> , die als für andere Abhängigkeits Eigenschaften für dieselbe Klasse verwendet wird. Dies ist ein gängiges Muster zum Einführen von true-Wert Abhängigkeiten zwischen Abhängigkeits Eigenschaften.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene <paramref name="dp" /> oder sein Wert waren ungültig oder sind nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.DependencyObjectType" /> ab, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</summary>
        <value>Ein <see cref="T:System.Windows.DependencyObjectType" />, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nützlich, wenn ein Objekt, das von einer Methode zurückgegeben wird, über einen <xref:System.Windows.DependencyObject> Rückgabe Werttyp von verfügt und Sie abhängig vom Typ systemspezifische Vorgänge für das System ausführen möchten. Beispielsweise ist es effizienter, <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> <xref:System.Windows.DependencyObjectType> mit anstelle des [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] -Typs aufzurufen. <xref:System.Windows.DependencyObjectType>ermöglicht eine schnellere Suche.  
  
   
  
## Examples  
 Im folgenden Pseudo Codebeispiel wird `MySubClass` `MyCustom` von erwartet, dass zusätzliche abgeleitete Klassen möglicherweise den Standardwert der Abhängigkeits Eigenschaft ändern. Die-Klasse implementiert einen Parameter losen Konstruktor, der die tatsächliche abgeleitete Klasse ermitteln kann, indem Sie die Vorteile von Polymorphie für den <xref:System.Windows.DependencyObjectType> Wert verwendet, wenn dieser Konstruktor als abgeleiteter klasseninstanzierer verwendet wird.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die Struktur <see cref="T:System.Windows.DependencyObject" />, die mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob ein angegebenes <see cref="T:System.Windows.DependencyObject" /> dem aktuellen <see cref="T:System.Windows.DependencyObject" /> entspricht.</summary>
        <returns><see langword="true" />, wenn beide Instanzen identisch sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ist nur Verweis Gleichheit und versucht nicht, die Wert Gleichheit der enthaltenen Eigenschaften auszuwerten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />überschreibt und versiegelt zwei grundlegende <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Die über schreibungen bezeichnen die <see cref="T:System.Object" /> -Implementierungen, was zu einem Objekt Gleichheits Verhalten führt. Der Zweck dieser absichtlichen über schreibungen besteht darin, zu verhindern, dass abgeleitete Klassen versuchen, eine Wert <see cref="T:System.Windows.DependencyObject" />Gleichheit für einen zu definieren. Der Wert für die <see cref="T:System.Windows.DependencyObject" /> equalitäten für ist aufgrund der angeborenen Eigenschafts Wert veränderlichen Funktionen <see cref="T:System.Windows.DependencyObject" /> von und der zugehörigen Abhängigkeits Eigenschaften nie präzise. Dies schließt Grund [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Legende Funktionen ein, z. b [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] . die Datenbindung und das Eigenschaften System.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für diesen <see cref="T:System.Windows.DependencyObject" /> ab.</summary>
        <returns>Ein 32-Bit-Ganzzahl-Hashcode mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" />überschreibt und dann zwei <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Die über schreibungen bezeichnen die <see cref="T:System.Object" /> -Implementierungen, was zu einem Objekt Gleichheits Verhalten führt. Der Zweck dieser absichtlichen über schreibungen besteht darin, zu verhindern, dass abgeleitete Klassen versuchen, eine Wert <see cref="T:System.Windows.DependencyObject" />Gleichheit für einen zu definieren. Der Wert für die <see cref="T:System.Windows.DependencyObject" /> equalitäten für ist aufgrund der angeborenen Eigenschafts Wert veränderlichen Funktionen <see cref="T:System.Windows.DependencyObject" /> von und der zugehörigen Abhängigkeits Eigenschaften nie präzise. Dies schließt Grund [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Legende Funktionen ein, z. b [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] . die Datenbindung und das Eigenschaften System.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen spezialisierten Enumerator, mit dem bestimmt wird, welche Abhängigkeitseigenschaften dieses <see cref="T:System.Windows.DependencyObject" /> über lokal festgelegte Werte verfügen.</summary>
        <returns>Ein spezialisierter lokaler Wertenumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *lokaler Wert* ist ein beliebiger Abhängigkeits Eigenschafts Wert <xref:System.Windows.DependencyObject.SetValue%2A>, der von festgelegt wurde, im Gegensatz zu anderen Aspekten des Eigenschaften Systems.  
  
 Der <xref:System.Windows.LocalValueEnumerator> , der durch <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> Aufrufen von abgerufen wird, kann verwendet werden, um Eigenschaften aufzulisten, die einen <xref:System.Windows.DependencyObject> lokal festgelegten Wert für eine-Instanz aufweisen. Jede dieser Eigenschaften wird im Enumerator durch ein <xref:System.Windows.LocalValueEntry> -Objekt dargestellt, das über Eigenschaften verfügt, die auf die spezifischen <xref:System.Windows.DependencyProperty> Werte und ihre Werte verweisen. Diese Methode für das Auflisten der lokal festgelegten Werte kann für die Optimierung oder andere Behandlung lokaler Werte verwendet werden, z. b. um zu ermitteln, welche Eigenschafts <xref:System.Windows.DependencyObject> Werte von geändert werden, wenn Sie gelöscht wurden.  
  
> [!IMPORTANT]
>  Der zurück <xref:System.Windows.LocalValueEnumerator> gegebene enthält <xref:System.Windows.LocalValueEntry> möglicherweise Datensätze für Abhängigkeits Eigenschaften, die schreibgeschützt sind, oder Abhängigkeits Eigenschaften, bei denen Werte vom-Eigenschaften System berechnet werden. Ein Visual Framework-Element, das über das Layout über eine festgelegte Breite verfügt, meldet z. <xref:System.Windows.FrameworkElement.ActualWidth%2A>b. einen lokalen Wert für. Wenn Sie lokale Werte erhalten, um Sie zurückzusetzen, überprüfen Sie <xref:System.Windows.DependencyProperty.ReadOnly%2A> den Wert des Eigenschafts Bezeichners <xref:System.Windows.LocalValueEntry> jedes, um zu <xref:System.Windows.DependencyProperty> überprüfen, ob die betreffende Frage nicht schreibgeschützt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Eigenschaften durchlaufen, für die lokale Werte für ein-Objekt fest <xref:System.Windows.DependencyObject.ClearValue%2A> gelegt sind. Anschließend wird aufgerufen, um die Werte jeder solchen Eigenschaft zu löschen.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, deren Wert abgerufen werden soll.</param>
        <summary>Gibt den aktuellen effektiven Wert einer Abhängigkeitseigenschaft für diese Instanz eines <see cref="T:System.Windows.DependencyObject" /> zurück.</summary>
        <returns>Gibt den aktuellen effektiven Wert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der *effektive Wert* ist der Wert der Eigenschaft, die vom Eigenschaften System an jeden Aufrufer zurückgegeben wird, der den Wert anfordert. Der effektive Wert ist das Ergebnis des Eigenschaften Systems, das alle möglichen Eingaben ausgewertet hat, die an der Rangfolge des Eigenschaften System Werts beteiligt sind. Dies schließt Umwandlungs-und Animations Zeichen ein. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Diese Methode gibt nie zurück <xref:System.Windows.DependencyProperty.UnsetValue>. Bei <xref:System.Windows.DependencyProperty.UnsetValue> handelt es sich um einen Sentinelwert für das Eigenschaften System, der in verschiedenen Kapazitäten intern verwendet und gelegentlich auch durch Umwandlungs Rückrufe verfügbar gemacht wird.  
  
 Wenn Sie nicht sicher sind, welcher Eigenschaftentyp sein sollte, können Sie den Bezeichner der angeforderten Abhängigkeits Eigenschaft Abfragen, um zu bestimmen, ob <xref:System.Windows.DependencyProperty.PropertyType%2A> ein spezifischere vorhanden ist, in den der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die angegebene <paramref name="dp" /> oder ihr Wert ist ungültig, oder die angegebene <paramref name="dp" /> ist nicht vorhanden.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der neu zu berechnenden Eigenschaft.</param>
        <summary>Berechnet den effektiven Wert für die angegebene Abhängigkeitseigenschaft neu</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie aufrufen <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, können alle zugeordneten <xref:System.Windows.CoerceValueCallback> und <xref:System.Windows.PropertyChangedCallback> anwendbaren Funktionen oder Funktionen, die für diese Abhängigkeits Eigenschaft registriert sind, aufgerufen werden.  
  
 Das <xref:System.Windows.DependencyObject.InvalidateProperty%2A> Aufrufen von für eine Eigenschaft, deren lokaler Wert festgelegt ist, hat keine Auswirkung, da der lokale Wert Vorrang vor anderen Eigenschaften System Eingaben hat, mit Ausnahme von Animationen. Sie können jedoch auch aufzurufen <xref:System.Windows.DependencyObject.ClearValue%2A>und dann aufzurufen. <xref:System.Windows.DependencyObject.InvalidateProperty%2A> Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Das <xref:System.Windows.DependencyObject.InvalidateProperty%2A> Aufrufen von ist nicht notwendigerweise auf viele Szenarien mit Abhängigkeits Eigenschaften anwendbar. Wenn eine Abhängigkeits Eigenschaft aufgrund von Wertänderungen in einer der Bestandteile ungültig wird, wird die Abhängigkeits Eigenschaft durch das Eigenschaften System ungültig und automatisch erneut ausgewertet. Es gibt jedoch noch einige geeignete Szenarios, <xref:System.Windows.DependencyObject.InvalidateProperty%2A> in denen nützlich ist. Insbesondere können Sie innerhalb des coerce-Werts oder des Eigenschafts geänderten Rückrufs für eine andere Abhängigkeits Eigenschaft verwenden <xref:System.Windows.DependencyObject.InvalidateProperty%2A> . Sie können auch verwenden <xref:System.Windows.DependencyObject.InvalidateProperty%2A> , um die erneute Auswertung einer Bindung für eine Datenquelle zu erzwingen, die nicht in der Lage ist <xref:System.ComponentModel.INotifyPropertyChanged> , den empfohlenen Benachrichtigungs Mechanismus zu implementieren (z. b. Wenn Sie Daten Klassen verwenden, die nicht von abgeleitet werden können, oder wenn die Daten statisch sind). -Member).  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.DependencyObject.InvalidateProperty%2A> wird für eine benutzerdefinierte Eigenschaft aufgerufen, wenn Eigenschaften, die an den Berechnungen der ungültigen Eigenschaft beteiligt sind, geändert werden. Dies ist eine alternative Methode zum Aufrufen der <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode, da durch das Aufheben der-Eigenschaft auch alle <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>registrierten aufgerufen werden.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese Instanz derzeit versiegelt (schreibgeschützt) ist.</summary>
        <value><see langword="true" />, wenn diese Instanz versiegelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird intern festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten, die den Bezeichner der betroffenen Abhängigkeitseigenschaft, die Eigenschaftenmetadaten des Typs sowie die alten und neuen Werte enthalten.</param>
        <summary>Wird immer dann aufgerufen, wenn der effektive Wert einer Abhängigkeitseigenschaft für dieses <see cref="T:System.Windows.DependencyObject" /> aktualisiert wurde. Die spezifische Abhängigkeitseigenschaft, die sich geändert hat, wird in den Ereignisdaten angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht dafür vorgesehen, einzelne Eigenschafts Änderungen im Allgemeinen zu erkennen oder die Validierung von Eigenschaften auf Einzelfallbasis auszuführen. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>ist stattdessen für Änderungen des allgemeinen invalidierungsmusters vorgesehen, wenn bestimmte Informationen über breite Klassifizierungen von Eigenschaften bekannt sind. Änderungen in einer <xref:System.Windows.Freezable> können z. b. Änderungen in den Werttypen <xref:System.Windows.Freezable>von oder unter Eigenschaften sein, bei denen sich die Änderungen innerhalb anderer <xref:System.Windows.Freezable> Verweise befinden. Die <xref:System.Windows.Freezable> Außerkraftsetzungs <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierung von verwendet interne Informationen, um zu bestimmen, ob es sich bei den Eigenschaften um unter Eigenschaften handelt, und stellt für beide Fälle die entsprechende Basisklassen Logik  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>kann während der Lebensdauer eines Objekts möglicherweise mehrmals aufgerufen werden. Aus diesem Grund können Sie eine bessere Leistung für das allgemeine Eigenschaften System erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben <xref:System.Windows.CoerceValueCallback> und <xref:System.Windows.PropertyChangedCallback> dann eine Verbindung mit den einzelnen Eigenschaften anfügen. Sie verwenden diese Methode jedoch, wenn eine eine <xref:System.Windows.DependencyObject> beträchtliche Anzahl von Wert abhängigen Abhängigkeits Eigenschaften enthält, oder wenn Sie eine Logik wie das Renderingverhalten enthält, das für mehrere verwandte Fälle von Eigenschafts Invalidierungen erneut ausgeführt werden muss.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ruft immer die Basis Implementierung auf. Wenn dies nicht der Fall ist, wird das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] gesamte Eigenschaften System erheblich deaktiviert, sodass falsche Werte gemeldet werden.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, deren Wert abgerufen werden soll.</param>
        <summary>Gibt, sofern vorhanden, den lokalen Wert einer Abhängigkeitseigenschaft zurück.</summary>
        <returns>Gibt den lokalen Wert zurück oder den Sentinelwert <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, wenn kein lokaler Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten für <xref:System.Windows.DependencyObject.GetValue%2A> die meisten typischen "Get"-Vorgänge für eine Abhängigkeits Eigenschaft verwenden. <xref:System.Windows.DependencyObject.ReadLocalValue%2A>gibt für verschiedene Situationen, in denen der Wert nicht lokal festgelegt wurde, nicht den effektiven Wert zurück.  
  
 Werte, die durch Stile, Designs, Vorlagen, den Standardwert aus Metadaten oder die Vererbung von Eigenschafts Werten festgelegt werden, werden nicht als lokale Werte betrachtet. Bindungen und andere Ausdrücke werden jedoch als lokale Werte betrachtet, nachdem Sie ausgewertet wurden.  
  
 Wenn kein lokaler Wert festgelegt ist, gibt diese <xref:System.Windows.DependencyProperty.UnsetValue>Methode zurück.  
  
 Wenn der zurückgegebene Wert nicht <xref:System.Windows.DependencyProperty.UnsetValue>ist, können Sie die Metadaten der angeforderten Abhängigkeits Eigenschaft Abfragen, um zu bestimmen, ob ein spezifischeren Typ vorhanden ist, in den der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den Wert einer Abhängigkeitseigenschaft fest, ohne die Wertquelle zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einer Komponente verwendet, die den Wert einer ihrer eigenen Eigenschaften Programm gesteuert festlegt, ohne die deklarierte Verwendung der-Eigenschaft einer Anwendung zu deaktivieren. Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A> -Methode ändert den effektiven Wert der-Eigenschaft, vorhandene Trigger, Daten Bindungen und Stile werden jedoch weiterhin funktionieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft in einem versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> entsprach nicht dem für die <paramref name="dp" />-Eigenschaft registrierten Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest, die über ihren Bezeichner angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Typ nicht mit dem Typ identisch ist, der für die Abhängigkeits Eigenschaft deklariert wurde, weil er ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Der `value` -Parameter sollte immer als geeigneter Typ angegeben werden.  
  
 Die Ausnahmebedingungen werden potenziell von dem <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf beeinflusst, der im Bezeichner der Abhängigkeits Eigenschaft für die festgelegte Abhängigkeits Eigenschaft vorhanden ist. Andernfalls können bei dem bereitgestellten Wert allgemeine Typüberprüfungen fehlschlagen (z. b. das Übergeben einer Zeichenfolge, wenn der Native Typ Double ist).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft in einem versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> entsprach nicht dem für die <paramref name="dp" />-Eigenschaft registrierten Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der festzulegenden Eigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer schreibgeschützten Abhängigkeitseigenschaft fest, die durch den <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der Abhängigkeitseigenschaft angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur wird in der Regel verwendet, wenn Sie Werte für schreibgeschützte Abhängigkeits Eigenschaften festlegen, die von Ihren benutzerdefinierten Klassen definiert werden. Im allgemeinen <xref:System.Windows.DependencyObject.SetValue%2A> wird nur von dem Typ aufgerufen, der diese Abhängigkeits Eigenschaft registriert hat, die die interne Logik implementiert, die den festgelegten Wert für die Abhängigkeits Eigenschaft bereitstellt. Weitere Informationen finden Sie unter [Schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Wenn der angegebene Typ nicht mit dem Typ identisch ist, der für die Abhängigkeits Eigenschaft deklariert wurde, weil er ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Der `value` -Parameter sollte immer als geeigneter Typ angegeben werden. Die Ausnahmebedingungen werden potenziell von dem <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf beeinflusst, der im Bezeichner der Abhängigkeits Eigenschaft für die festgelegte Abhängigkeits Eigenschaft vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine schreibgeschützte Abhängigkeits Eigenschaft sowie eine `public static readonly` <xref:System.Windows.DependencyProperty> definiert, die die erforderliche schreibgeschützte verfügbar machung für eigenschaftenconsumer und den Get-Accessor [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] für den Wrapper bereitstellt.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der Abhängigkeitseigenschaft, die serialisiert werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob Serialisierungsprozesse den Wert der bereitgestellten Abhängigkeitseigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der Wert der angegebenen Abhängigkeitseigenschaft serialisiert wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt `true` für alle Fälle zurück, in denen für eine Abhängigkeits Eigenschaft ein lokaler Wert <xref:System.Windows.DependencyObject>in festgelegt wurde.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Durch außer Kraft setzungen für diese Methode können bestimmte Abhängigkeits Eigenschaften anders behandelt werden.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
