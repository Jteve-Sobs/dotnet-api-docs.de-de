<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="62d0c6b5a93fa38d970f0445e7a629dacdae551c" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48699230" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Objekt dar, das im Abhängigkeitseigenschaftensystem teilnimmt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.DependencyObject> -Klasse ermöglicht es [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Dienste für das System für alle abgeleiteten Klassen.  
  
 Primäre Funktion des Eigenschaftensystems ist, berechnen Sie die Werte der Eigenschaften und Benachrichtigung des Systems zu Werten bereitzustellen, die geändert wurden. Eine andere wichtige-Klasse, die im Eigenschaftensystem beteiligt ist, ist <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> ermöglicht die Registrierung von Abhängigkeitseigenschaften im Eigenschaftensystem und stellt die Identifikation und Informationen über jede Abhängigkeitseigenschaft während <xref:System.Windows.DependencyObject> ermöglicht eine Basisklasse die Objekte, die die Abhängigkeitseigenschaften verwendet.  
  
 <xref:System.Windows.DependencyObject> Dienste und Merkmale umfassen Folgendes:  
  
-   Unterstützung für das hosting-Abhängigkeitseigenschaft. Sie registrieren eine Abhängigkeitseigenschaft durch Aufrufen der <xref:System.Windows.DependencyProperty.Register%2A> -Methode, und Speichern von der Methodenrückgabewert als öffentliches statisches Feld in der Klasse.  
  
-   Angefügte Eigenschaft, die Unterstützung für das hosting. Sie Registrieren einer angefügten Eigenschaft durch Aufrufen der <xref:System.Windows.DependencyProperty.RegisterAttached%2A> -Methode, und Speichern der Rückgabewert der Methode als öffentliche statische schreibgeschützte Feld in der Klasse. (Es gibt auch zusätzliche Memberanforderungen vor; Beachten Sie, dass dies stellt eine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] bestimmte Implementierung für angefügte Eigenschaften. Weitere Informationen finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Die angefügte Eigenschaft klicken Sie dann für jede abgeleitete Klasse festgelegt werden kann <xref:System.Windows.DependencyObject>.  
  
-   Get-, Set- und Löschen von Hilfsmethoden für die Werte aller Abhängigkeitseigenschaften, die auf vorhanden der <xref:System.Windows.DependencyObject>.  
  
-   Metadaten, coerce wertunterstützung, Benachrichtigung der Eigenschaftenänderung und außer Kraft setzen-Rückrufe für Abhängigkeitseigenschaften oder angefügte Eigenschaften. Darüber hinaus die <xref:System.Windows.DependencyObject> Klasse vereinfacht das Eigenschaftenmetadaten für eine Abhängigkeitseigenschaft.  
  
-   Eine allgemeine Basisklasse für Klassen abgeleitet <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, oder <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, Basiselementklasse, verfügt über eine Hierarchie von Klassen, die enthält <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Im folgende Beispiel leitet sich von <xref:System.Windows.DependencyObject> um eine neue abstrakte Klasse zu erstellen. Die Klasse dann eine angefügte Eigenschaft registriert und enthält Elemente der Unterstützung für diese angefügte Eigenschaft.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.DependencyObject" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den lokalen Wert einer Eigenschaft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Objektverweis identifiziert.</param>
        <summary>Löscht den lokalen Wert einer Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyProperty" />-Bezeichner angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löschen den Wert der Eigenschaft durch den Aufruf <xref:System.Windows.DependencyObject.ClearValue%2A> ist nicht zwingend auf einer Abhängigkeitseigenschaft den Standardwert, der in den Metadaten der Abhängigkeitseigenschaft angegeben ist. Löschen die Eigenschaft nur speziell löscht der lokaler Wert möglicherweise angewendet wurden. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Eigenschaften, die lokalen Werte, die für ein Objekt festgelegt werden ruft dann <xref:System.Windows.DependencyObject.ClearValue%2A> , deaktivieren Sie die Werte dieser Eigenschaften.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel für die Abhängigkeitseigenschaft, deren Wert gelöscht werden soll.</param>
        <summary>Löscht den lokalen Wert einer schreibgeschützten Eigenschaft. Die Eigenschaft, deren Wert gelöscht werden soll, wird durch einen <see cref="T:System.Windows.DependencyPropertyKey" /> angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyPropertyKey> wird eine schreibgeschützte Abhängigkeitseigenschaft für die Operationen des Eigenschaftensystems identifiziert. Klassen, die schreibgeschützten Abhängigkeitseigenschaften definieren sollten diesen Schlüssel mit öffentlichem Zugriff nicht verfügbar machen. Ein öffentlich verfügbar gemachte Schlüssel würde einen öffentlichen Code-Pfad, der das Zeichen "schreibgeschützt" der Eigenschaft, die negiert bereitstellen, wenn Methoden, z. B. <xref:System.Windows.DependencyObject.ClearValue%2A> oder <xref:System.Windows.DependencyObject.SetValue%2A> außerhalb der Klasse oder Assembly verweisen auf den Schlüssel aufgerufen werden kann.  
  
 Löschen den Wert der Eigenschaft durch den Aufruf <xref:System.Windows.DependencyObject.ClearValue%2A> ist nicht zwingend auf einer Abhängigkeitseigenschaft den Standardwert, der in den Metadaten der Abhängigkeitseigenschaft angegeben ist. Löschen des Werts nur speziell löscht der lokaler Wert möglicherweise angewendet wurden. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> für ein versiegeltes <see cref="T:System.Windows.DependencyObject" /> aufzurufen.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die zu erzwingende Abhängigkeitseigenschaft.</param>
        <summary>Erzwingt den Wert der angegebenen Abhängigkeitseigenschaft. Dies erfolgt durch den Aufruf einer beliebigen <see cref="T:System.Windows.CoerceValueCallback" />-Funktion, die in den Metadaten für die Abhängigkeitseigenschaft angegeben ist, während sie beim aufrufenden <see cref="T:System.Windows.DependencyObject" /> beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zum expliziten Aufruf durch den Aufruf <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> für eine Abhängigkeit aufgerufen, wenn intern, wenn der Wert der Abhängigkeitseigenschaft von erneut bewertet wird die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem.  
  
 Beim Aufruf der <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode, Sie letztendlich den Rückruf zum Wert für die Eigenschaft, die Sie angeben. In der Regel rufen Sie <xref:System.Windows.DependencyObject.CoerceValue%2A> nur, wenn Sie wissen, dass ein Coerce-Wert vorhanden ist und Sie wissen, dass der Rückruf die Kriterien für die Umwandlung.  
  
 Das häufigste Szenario für den Aufruf <xref:System.Windows.DependencyObject.CoerceValue%2A> befindet sich innerhalb der Klasse behandeln oder eine Eigenschaft ändern-Rückrufe verwandter Eigenschaften, die anderen Werte in einer abhängigen Weise beeinflussen. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.CoerceValue%2A> innerhalb einer <xref:System.Windows.PropertyChangedCallback> -Implementierung, die verwendet wird, als die <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> für eine andere Abhängigkeitseigenschaften für die gleiche Klasse. Dies ist ein häufiges Muster für das Einführen von Wert "true"-Abhängigkeiten zwischen Abhängigkeitseigenschaften.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene <paramref name="dp" /> oder sein Wert waren ungültig oder sind nicht vorhanden.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.DependencyObjectType" /> ab, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</summary>
        <value>Ein <see cref="T:System.Windows.DependencyObjectType" />, der den [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Typ dieser Instanz umschließt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nützlich, wenn ein Objekt, das von einer Methode zurückgegeben wird einen Typ des Rückgabewerts <xref:System.Windows.DependencyObject> und Sie spezifische Vorgänge des Eigenschaftensystems darauf abhängig von deren Typ ausführen möchten. Beispielsweise ist es effizienter, rufen Sie <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> mithilfe der <xref:System.Windows.DependencyObjectType> anstelle der [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Typ. <xref:System.Windows.DependencyObjectType> ermöglicht eine schnellere Suche.  
  
   
  
## Examples  
 Im folgenden Pseudocodebeispiel `MySubClass` erwartet, dass abgeleitete Klassen den Standardwert ändern, können die `MyCustom` Abhängigkeitseigenschaft. Die Klasse implementiert einen Standardkonstruktor, der die tatsächliche abgeleitete Klasse bestimmen kann, durch die Nutzung von Polymorphie auf die <xref:System.Windows.DependencyObjectType> Wert diesen Konstruktor verwendet wird, wie eine abgeleitete Klasse zurückgreift.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Der <see cref="T:System.Windows.DependencyObject" />, der mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob ein angegebenes <see cref="T:System.Windows.DependencyObject" /> dem aktuellen <see cref="T:System.Windows.DependencyObject" /> entspricht.</summary>
        <returns><see langword="true" />, wenn beide Instanzen identisch sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung wird nur auf Verweisgleichheit und versucht nicht, die Wertgleichheit der enthaltenen Eigenschaften ausgewertet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> überschreibt und versiegelt anschließend zwei Basic <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Der Aufruf überschreibt die <see cref="T:System.Object" /> Implementierungen, die ein Objekt auf Gleichheit Verhalten. Der Zweck der arbeitsaufwendig beabsichtigt wird verhindert, dass abgeleitete Klassen möchten, definieren Sie eine Wertgleichheit für einen <see cref="T:System.Windows.DependencyObject" />. Wert Gleichheitsprädikate für <see cref="T:System.Windows.DependencyObject" /> werden nie genau aufgrund der ausgeprägten Eigenschaft verändernder Funktionen eine <see cref="T:System.Windows.DependencyObject" /> und der Abhängigkeitseigenschaften. Dazu gehören grundlegende [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Features wie z. B. die Datenbindung und die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für diese <see cref="T:System.Windows.DependencyObject" /> ab.</summary>
        <returns>Ein 32-Bit-Ganzzahl-Hashcode mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> überschreibt und versiegelt anschließend zwei <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Der Aufruf überschreibt die <see cref="T:System.Object" /> Implementierungen, die ein Objekt auf Gleichheit Verhalten. Der Zweck der arbeitsaufwendig beabsichtigt wird verhindert, dass abgeleitete Klassen möchten, definieren Sie eine Wertgleichheit für einen <see cref="T:System.Windows.DependencyObject" />. Wert Gleichheitsprädikate für <see cref="T:System.Windows.DependencyObject" /> werden nie genau aufgrund der ausgeprägten Eigenschaft verändernder Funktionen eine <see cref="T:System.Windows.DependencyObject" /> und der Abhängigkeitseigenschaften. Dazu gehören grundlegende [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Features wie z. B. die Datenbindung und die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen spezialisierten Enumerator, mit dem bestimmt wird, welche Abhängigkeitseigenschaften dieses <see cref="T:System.Windows.DependencyObject" /> über lokal festgelegte Werte verfügen.</summary>
        <returns>Ein spezialisierter lokaler Wertenumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *lokaler Wert* wird jeder Wert einer Abhängigkeitseigenschaft, die festgelegt wurde, indem <xref:System.Windows.DependencyObject.SetValue%2A>, im Gegensatz zu anderen Aspekte des Eigenschaftensystems.  
  
 Die <xref:System.Windows.LocalValueEnumerator> durch den Aufruf <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> können verwendet werden, um die Eigenschaften aufgelistet, die ein lokal festgelegter Wert in eine <xref:System.Windows.DependencyObject> Instanz. Jede dieser Eigenschaften ist dargestellt, im Enumerator durch eine <xref:System.Windows.LocalValueEntry> -Objekt, das Eigenschaften an, die die spezifischen verweisen <xref:System.Windows.DependencyProperty> und die zugehörigen Werte. Diese Technik aufzulisten, über die lokal festgelegte Werte können verwendet werden für die Optimierung oder für andere lokale Werte, z. B. um zu bestimmen, welche Eigenschaftswerte von einem <xref:System.Windows.DependencyObject> ändern würde, wenn sie gelöscht wurden.  
  
> [!IMPORTANT]
>  Das zurückgegebene <xref:System.Windows.LocalValueEnumerator> enthält möglicherweise <xref:System.Windows.LocalValueEntry> Datensätze für Abhängigkeitseigenschaften, die schreibgeschützt sind oder Abhängigkeitseigenschaften, deren Werte vom Eigenschaftensystem berechnet werden. Z. B. einen lokalen Wert für ein visuelles Element, das einer festgelegten durch Layout Breite meldet <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Wenn Sie lokale Werte abrufen, um diese zurückzusetzen, überprüfen Sie die <xref:System.Windows.DependencyProperty.ReadOnly%2A> Wert der Eigenschaft-ID der einzelnen <xref:System.Windows.LocalValueEntry> zu überprüfen, ob die <xref:System.Windows.DependencyProperty> zweifelhaft ist nicht schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Eigenschaften, die lokalen Werte, die für ein Objekt festgelegt werden ruft dann <xref:System.Windows.DependencyObject.ClearValue%2A> , deaktivieren Sie die Werte dieser Eigenschaften.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, deren Wert abgerufen werden soll.</param>
        <summary>Gibt den aktuellen effektiven Wert einer Abhängigkeitseigenschaft für diese Instanz eines <see cref="T:System.Windows.DependencyObject" /> zurück.</summary>
        <returns>Gibt den aktuellen effektiven Wert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die *effektiven Wert* ist der Wert der Eigenschaft, die vom Eigenschaftensystem für jeden Aufrufer zurückgegeben wird, der den Wert anfordert. Der effektive Wert ist das Ergebnis des Eigenschaftensystems nach Auswertung aller möglichen Eingaben, die in der System Eigenschaftswert-Rangfolge einbezogen. Dies schließt die Umwandlung und Animationen. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Diese Methode gibt nie <xref:System.Windows.DependencyProperty.UnsetValue>. Die <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert des Eigenschaftensystems, die in unterschiedlichen Kapazitäten, die intern und gelegentlich auch durch Umwandlung Rückrufe verfügbar gemacht werden.  
  
 Wenn Sie nicht sicher sind, was den Typ der Eigenschaft handelt, können Sie den Bezeichner der angeforderten Abhängigkeitseigenschaft zu bestimmen, ob es eine weitere spezifische ist Abfragen <xref:System.Windows.DependencyProperty.PropertyType%2A> , die der Rückgabewert in konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die angegebene <paramref name="dp" /> oder ihr Wert ist ungültig, oder die angegebene <paramref name="dp" /> ist nicht vorhanden.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der neu zu berechnenden Eigenschaft.</param>
        <summary>Berechnet den effektiven Wert für die angegebene Abhängigkeitseigenschaft neu</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, alle zugeordneten und anwendbaren <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen registriert wird, für die Abhängigkeitseigenschaft, die aufgerufen werden kann.  
  
 Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> auf eine Eigenschaft mit dem lokalen Wert hat keine Auswirkungen, da der lokale Wert Vorrang vor anderen Eingaben des Eigenschaft-System, mit Ausnahme von Animationen hat. Sie können jedoch aufrufen <xref:System.Windows.DependencyObject.ClearValue%2A>, rufen Sie anschließend <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ist nicht notwendigerweise auch für viele Szenarien der Dependency-Eigenschaft. Wenn aufgrund von Änderungen in einer der Bestandteile eine Abhängigkeitseigenschaft ungültig wird, wird das Eigenschaftensystem erklärt und wertet die Abhängigkeitseigenschaft automatisch neu aus. Es gibt jedoch noch einige Szenarios, in denen <xref:System.Windows.DependencyObject.InvalidateProperty%2A> eignet. Insbesondere können Sie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> in die Coerce-Wert oder eine Eigenschaft geändert Rückruf für eine andere Abhängigkeitseigenschaft. Sie können auch <xref:System.Windows.DependencyObject.InvalidateProperty%2A> um eine erneute Auswertung von einer Bindung für eine Datenquelle zu erzwingen, die nicht die empfohlene implementieren kann <xref:System.ComponentModel.INotifyPropertyChanged> Benachrichtigungsmechanismus (vielleicht Datenklassen in Anspruch, kann nicht abgeleitet werden, oder die Daten, in denen eine statische sind, (Element).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ändern für die benutzerdefinierte Eigenschaft jedes Mal, wenn Sie Eigenschaften, die in der Eigenschaft für ungültig erklärten Berechnungen beteiligt sind. Dies ist eine alternative Methode zum Aufruf der <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode, da die Eigenschaft für ungültig zu erklären auch jeden Aufruf wird registriert <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese Instanz derzeit versiegelt (schreibgeschützt) ist.</summary>
        <value><see langword="true" />, wenn diese Instanz versiegelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird intern festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten, die den betreffenden Bezeichner für eine Abhängigkeitseigenschaft, die Eigenschaftsmetadaten für den Typ sowie die alten und neuen Werte enthalten.</param>
        <summary>Wird immer dann aufgerufen, wenn der tatsächliche Wert einer Abhängigkeitseigenschaft für diese <see cref="T:System.Windows.DependencyObject" /> aktualisiert wurde. Welche spezifische Abhängigkeitseigenschaft geändert wird, wird in den Ereignisdaten gemeldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht vorgesehen, in der Regel erkennen von Änderungen der einzelnen Eigenschaften oder invalidierungen der Eigenschaften, die pro-Fall zu Fall ausführen. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> stattdessen für Änderungen der allgemeinen invalidierung-Muster, richtet sich an, wenn bestimmte Informationen über wide Klassifizierungen der Eigenschaften, die bekannt ist. Ändert sich beispielsweise einer <xref:System.Windows.Freezable> möglicherweise Änderungen in die Werttypen der der <xref:System.Windows.Freezable>, oder möglicherweise Untereigenschaften, in dem die Änderungen in den anderen sind <xref:System.Windows.Freezable> verweisen. Die <xref:System.Windows.Freezable> überschreiben Implementierung der <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> verwendet interne Informationen, um zu bestimmen, ob die Eigenschaften sind untergeordnete und entsprechenden Basisklasse Logik für das Vorarbeiten bereitstellt.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> oft wird möglicherweise während der Lebensdauer eines Objekts aufgerufen werden. Aus diesem Grund können Sie eine bessere Leistung für das gesamte Eigenschaftensystem erzielen, wenn Sie die Metadaten der bestimmte Eigenschaften überschreiben, und Sie dann fügen <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen für die einzelnen Eigenschaften. Allerdings würden Sie diese Methode verwenden, wenn eine <xref:System.Windows.DependencyObject> umfasst eine Vielzahl von Wert in wechselseitiger Beziehung Abhängigkeitseigenschaften, oder wenn sie die Logik enthält, wie z. B. Renderingverhalten, die erneut ausgeführt werden, muss einige Fälle von eigenschafteninvalidierungen beziehen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Rufen Sie immer die basisimplementierung. Geschieht dies nicht die gesamte erheblich deaktiviert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem, bewirkt, dass falsche Werte gemeldet werden.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der <see cref="T:System.Windows.DependencyProperty" />-Bezeichner der Eigenschaft, deren Wert abgerufen werden soll.</param>
        <summary>Gibt den lokalen Wert einer Abhängigkeitseigenschaft zurück, wenn dieser vorhanden ist.</summary>
        <returns>Gibt den lokalen Wert zurück oder den Sentinelwert <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, wenn kein lokaler Wert festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Windows.DependencyObject.GetValue%2A> für typische "get"-Vorgänge für eine Abhängigkeitseigenschaft. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Gibt nicht zurück den gültigen Wert für eine Vielzahl von Situationen, in denen der Wert nicht lokal festgelegt wurde.  
  
 Werte, die von Stilen, Designs, Vorlagen festgelegt werden, der Standardwert aus Metadaten oder die Vererbung von Eigenschaftswerten werden lokale Werte nicht berücksichtigt. Allerdings gelten Bindungen und andere Ausdrücke als lokale Werte, nachdem sie ausgewertet wurden.  
  
 Wenn kein lokaler Wert festgelegt ist, gibt diese Methode <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Wenn der zurückgegebene Wert außer <xref:System.Windows.DependencyProperty.UnsetValue>, Sie können Abfragen, die Metadaten für die angeforderte Abhängigkeitseigenschaft, um zu bestimmen, ob es ein spezifischer Typ, der der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den Wert einer Abhängigkeitseigenschaft fest, ohne deren Wertquelle zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einer Komponente verwendet, die den Wert von einem der über eigene Eigenschaften programmgesteuert festgelegt, ohne die einer Anwendung deklarierten Verwendung der Eigenschaft zu deaktivieren. Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Methode ändert sich den effektiven Wert der Eigenschaft, aber vorhandene Trigger, datenbindungen und Stile sind weiterhin funktionsfähig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft in einem versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> entsprach nicht dem für die <paramref name="dp" />-Eigenschaft registrierten Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der festzulegenden Abhängigkeitseigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer Abhängigkeitseigenschaft fest, die durch ihren Bezeichner angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es sich bei der bereitgestellte Typ nicht mit den Typ übereinstimmt, der für die Abhängigkeitseigenschaft deklariert wird, wie es ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Die `value` Parameter sollte immer den entsprechenden Typ angegeben werden.  
  
 Die Ausnahmebedingungen möglicherweise beeinflusst die <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf, der auf den Bezeichner der festzulegenden Abhängigkeitseigenschaft Abhängigkeitseigenschaft vorhanden ist. Andernfalls kann der angegebene Wert ein Fehler auf allgemeine Typprüfung Bedingungen (z. B. eine Zeichenfolge übergeben, wenn der systemeigene Typ Double-Wert ist).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine schreibgeschützte Abhängigkeitseigenschaft oder eine Eigenschaft in einem versiegelten <see cref="T:System.Windows.DependencyObject" /> zu ändern.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> entsprach nicht dem für die <paramref name="dp" />-Eigenschaft registrierten Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der festzulegenden Eigenschaft.</param>
        <param name="value">Der neue lokale Wert.</param>
        <summary>Legt den lokalen Wert einer schreibgeschützten Abhängigkeitseigenschaft fest, die durch den <see cref="T:System.Windows.DependencyPropertyKey" />-Bezeichner der Abhängigkeitseigenschaft angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur wird in der Regel verwendet, wenn Sie Werte für schreibgeschützte Abhängigkeitseigenschaften festlegen, die durch die benutzerdefinierten Klassen definiert werden. Im allgemeinen <xref:System.Windows.DependencyObject.SetValue%2A> heißt nur anhand des Typs, der die Abhängigkeitseigenschaft registriert die interne Logik implementiert, die den festgelegten Wert für die Abhängigkeitseigenschaft bereitstellt. Weitere Informationen finden Sie unter [Schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Wenn es sich bei der bereitgestellte Typ nicht mit den Typ übereinstimmt, der für die Abhängigkeitseigenschaft deklariert wird, wie es ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Die `value` Parameter sollte immer den entsprechenden Typ angegeben werden. Die Ausnahmebedingungen möglicherweise beeinflusst die <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf, der auf den Bezeichner der festzulegenden Abhängigkeitseigenschaft Abhängigkeitseigenschaft vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine schreibgeschützte Abhängigkeitseigenschaft zusammen mit einem `public static readonly` <xref:System.Windows.DependencyProperty> bereitstellt erforderlichen nur-Lese Kenntnisse in Bezug auf Abfragen der Eigenschaft bereitstellt, und die Get-Accessor für die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die Abhängigkeitseigenschaft, die serialisiert werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob Serialisierungsprozesse den Wert der bereitgestellten Abhängigkeitseigenschaft serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der Wert der angegebenen Abhängigkeitseigenschaft serialisiert wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt `true` für alle Fälle, in dem eine Abhängigkeitseigenschaft einen lokalen Wert auf eingerichtet hatten, die <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Außerkraftsetzungen für diese Methode möglicherweise für bestimmte Abhängigkeitseigenschaften unterschiedlich behandelt werden.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>