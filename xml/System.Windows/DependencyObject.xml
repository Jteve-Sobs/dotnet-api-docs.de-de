<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b20096950e5ef29b8ab06fba5406a44bbc3ff7f2" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461254" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an object that participates in the dependency property system.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.DependencyObject> -Klasse ermöglicht es [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Eigenschaftensystemdienste für viele abgeleiteten Klassen.  
  
 Primäre Funktion im Eigenschaftensystem wird zum Berechnen der Werte der Eigenschaften und systembenachrichtigung zu Werten bereitzustellen, die geändert wurden. Eine andere schlüsselklasse, die in dem Eigenschaftensystem einbezogen ist <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> ermöglicht die Registrierung von Abhängigkeitseigenschaften im Eigenschaftensystem und Identifikation und Informationen für jede Abhängigkeitseigenschaft während <xref:System.Windows.DependencyObject> eine Basisklasse ermöglicht die Objekte, die die Abhängigkeitseigenschaften verwendet.  
  
 <xref:System.Windows.DependencyObject> Dienste und Merkmale umfassen Folgendes:  
  
-   Unterstützung für das hosting Abhängigkeitseigenschaft. Registrieren Sie eine Abhängigkeitseigenschaft, durch Aufrufen der <xref:System.Windows.DependencyProperty.Register%2A> -Methode, und Speichern der Rückgabewert der Methode als öffentliche statische Feld in Ihrer Klasse.  
  
-   Angefügte Eigenschaft, die Unterstützung für das hosting. Sie registrieren eine angefügte Eigenschaft durch Aufrufen der <xref:System.Windows.DependencyProperty.RegisterAttached%2A> -Methode, und Speichern der Rückgabewert der Methode als öffentliche statische schreibgeschützte Feld in Ihrer Klasse. (Es gibt auch zusätzliche Memberanforderungen; Beachten Sie, dass dies stellt eine [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] spezifischen Implementierung für angefügte Eigenschaften. Weitere Informationen finden Sie unter [Eigenschaftenübersicht angefügt](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Die angefügte Eigenschaft kann dann festgelegt werden, auf jede Klasse, die abgeleitet <xref:System.Windows.DependencyObject>.  
  
-   Abrufen, festlegen und Löschen von Hilfsmethoden für die Werte aller Abhängigkeitseigenschaften, die auf die <xref:System.Windows.DependencyObject>.  
  
-   Metadaten, coerce-Wert-Unterstützung, geänderten Eigenschaft Benachrichtigung und Außerkraftsetzung Rückrufe für Abhängigkeitseigenschaften oder angefügte Eigenschaften. Darüber hinaus die <xref:System.Windows.DependencyObject> Klasse vereinfacht die Eigenschaftenmetadaten für eine Abhängigkeitseigenschaft.  
  
-   Eine allgemeine Basisklasse für Klassen abgeleitet <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, oder <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, Basiselementklasse, verfügt über eine Hierarchie von Klassen, die enthält <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Im folgende Beispiel leitet sich von <xref:System.Windows.DependencyObject> zum Erstellen einer neuen abstrakte Klasse. Die Klasse registriert eine angefügte Eigenschaft dann und schließt Elemente der Unterstützung für diese angefügten Eigenschaft.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.DependencyObject" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Clears the local value of a property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The dependency property to be cleared, identified by a <see cref="T:System.Windows.DependencyProperty" /> object reference.</param>
        <summary>Clears the local value of a property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyProperty" /> identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löschen den Wert der Eigenschaft durch den Aufruf <xref:System.Windows.DependencyObject.ClearValue%2A> ist nicht zwingend auf einer Abhängigkeitseigenschaft den Standardwert, der in den Metadaten der Abhängigkeitseigenschaft angegeben ist. Löschen die Eigenschaft nur speziell löscht der lokaler Wert möglicherweise angewendet wurden. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Eigenschaften, die lokalen Werte, die auf ein Objekt festgelegt wurden ruft dann <xref:System.Windows.DependencyObject.ClearValue%2A> So löschen Sie die Werte dieser Eigenschaften.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">The key for the dependency property to be cleared.</param>
        <summary>Clears the local value of a read-only property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.DependencyPropertyKey> eine schreibgeschützte Abhängigkeitseigenschaft für Systemvorgänge Eigenschaft identifiziert. Klassen, die nur-Lese Abhängigkeitseigenschaften definieren sollten öffentlichen Zugriff auf diesen Schlüssel nicht verfügbar. Ein öffentlich verfügbarer Schlüssel würde eine öffentliche Code Weg, die schreibgeschützt sind und die Eigenschaft unterlaufen bereitstellen, wenn Methoden, z. B. <xref:System.Windows.DependencyObject.ClearValue%2A> oder <xref:System.Windows.DependencyObject.SetValue%2A> außerhalb der Klasse oder Assembly verweisen auf den Schlüssel aufgerufen werden.  
  
 Löschen den Wert der Eigenschaft durch den Aufruf <xref:System.Windows.DependencyObject.ClearValue%2A> ist nicht zwingend auf einer Abhängigkeitseigenschaft den Standardwert, der in den Metadaten der Abhängigkeitseigenschaft angegeben ist. Löschen den Wert nur speziell löscht der lokaler Wert möglicherweise angewendet wurden. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property to coerce.</param>
        <summary>Coerces the value of the specified dependency property. This is accomplished by invoking any <see cref="T:System.Windows.CoerceValueCallback" /> function specified in property metadata for the dependency property as it exists on the calling <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu den aufgerufenen explizit durch Aufrufen von <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> für eine Abhängigkeit Eigenschaft ist auch dann aufgerufen, intern Wenn Werts der Abhängigkeitseigenschaft vom erneut ausgewertet wird die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem.  
  
 Beim Aufruf der <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode, rufen Sie letztendlich den Rückruf zum Wert für die Eigenschaft, die Sie angeben. In der Regel rufen Sie <xref:System.Windows.DependencyObject.CoerceValue%2A> nur, wenn Sie wissen, dass ein Rückruf zum Wert vorhanden ist und Sie wissen, dass die Rückruf-Kriterien für die Umwandlung.  
  
 Das häufigste Szenario für den Aufruf von <xref:System.Windows.DependencyObject.CoerceValue%2A> liegt innerhalb der Rückrufe Klasse behandeln oder die Eigenschaft der Änderung von verwandten Eigenschaften, die jeweils anderen Werte in einer abhängigen Weise beeinflussen. Weitere Informationen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.CoerceValue%2A> innerhalb einer <xref:System.Windows.PropertyChangedCallback> Implementierung, die verwendet wird, als die <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> für einen anderen Abhängigkeitseigenschaften für die gleiche Klasse. Dies ist ein allgemeines Muster für die Einführung der Wert "true" Abhängigkeiten zwischen Abhängigkeitseigenschaften.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value were invalid or do not exist.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.DependencyObjectType" /> that wraps the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] type of this instance.</summary>
        <value>Ein <see cref="T:System.Windows.DependencyObjectType" /> , umschließt der [! Include[TLA2#tla_clr](~/Includes/tla2sharptla-CLR-MD.MD)]-Typ, der dieser Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nützlich, wenn ein Objekt, das von einer Methode zurückgegeben wird einen Typ des Rückgabewerts enthält <xref:System.Windows.DependencyObject> und Eigenschaft System Ausführen bestimmter Vorgänge davon abhängig vom Anwendungstyp werden sollen. Beispielsweise ist es effizienter, rufen Sie <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> mithilfe der <xref:System.Windows.DependencyObjectType> statt über das [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Typ. <xref:System.Windows.DependencyObjectType> ermöglicht eine schnellere Suche.  
  
   
  
## Examples  
 Im folgenden Pseudocodebeispiel `MySubClass` geht davon aus, dass abgeleitete Klassen den Standardwert ändern, können die `MyCustom` Abhängigkeitseigenschaft. Die Klasse implementiert einen Standardkonstruktor, die die tatsächliche abgeleitete Klasse bestimmen kann, durch die Nutzung von Polymorphie auf die <xref:System.Windows.DependencyObjectType> Wert als eine abgeleitete Klasse zurückgreift, Konstruktor verwendet wird.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Windows.DependencyObject" /> to compare to the current instance.</param>
        <summary>Determines whether a provided <see cref="T:System.Windows.DependencyObject" /> is equivalent to the current <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" /> if the two instances are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung wird nur auf Verweisgleichheit und versucht nicht, Wertgleichheit der enthaltenen Eigenschaften auswerten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> außer Kraft gesetzt, und klicken Sie dann zwei Basic versiegelt <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Der Aufruf überschreibt die <see cref="T:System.Object" /> Implementierungen, die ein Objekt auf Gleichheit Verhalten führen. Der Zweck dieser absichtlichen Außerkraftsetzungen wird verhindert, dass abgeleitete Klassen eine Wertgleichheit für definieren möchten eine <see cref="T:System.Windows.DependencyObject" />. Wert Gleichheitsprädikate für <see cref="T:System.Windows.DependencyObject" /> werden nie genau aufgrund Wert ändern-Funktionen des Standard-Eigenschaft einer <see cref="T:System.Windows.DependencyObject" /> und seine Abhängigkeitseigenschaften. Dazu gehören grundlegende [! Include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)]-Funktionen, z. B. Datenbindung und das [! Include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)] Eigenschaftensystem.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a hash code for this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A signed 32-bit integer hash code.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> überschreibt und versiegelt anschließend zwei <see cref="T:System.Object" /> Methoden: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> und <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Der Aufruf überschreibt die <see cref="T:System.Object" /> Implementierungen, die ein Objekt auf Gleichheit Verhalten führen. Der Zweck dieser absichtlichen Außerkraftsetzungen wird verhindert, dass abgeleitete Klassen eine Wertgleichheit für definieren möchten eine <see cref="T:System.Windows.DependencyObject" />. Wert Gleichheitsprädikate für <see cref="T:System.Windows.DependencyObject" /> werden nie genau aufgrund Wert ändern-Funktionen des Standard-Eigenschaft einer <see cref="T:System.Windows.DependencyObject" /> und seine Abhängigkeitseigenschaften. Dazu gehören grundlegende [! Include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)]-Funktionen, z. B. Datenbindung und das [! Include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)] Eigenschaftensystem.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a specialized enumerator for determining which dependency properties have locally set values on this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A specialized local value enumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein *lokaler Wert* ist jeder Wert einer Abhängigkeitseigenschaft, die festgelegt wurde, indem Sie <xref:System.Windows.DependencyObject.SetValue%2A>, im Gegensatz zu anderen Aspekte des Eigenschaftensystems.  
  
 Die <xref:System.Windows.LocalValueEnumerator> durch den Aufruf von <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> können verwendet werden, um die Eigenschaften aufgelistet, die ein lokal festgelegter haben Wert auf eine <xref:System.Windows.DependencyObject> Instanz. Jede dieser Eigenschaften wird dargestellt, in der Enumerator durch einen <xref:System.Windows.LocalValueEntry> -Objekt, das Eigenschaften verfügt, die die spezifische verweisen <xref:System.Windows.DependencyProperty> und die zugehörigen Werte. Diese Technik Aufzählen über die lokal festgelegte Werte dienen zur Optimierung oder für andere Behandlung von lokalen Werte wie z. B. um zu bestimmen, welche Eigenschaftswerte des eine <xref:System.Windows.DependencyObject> ändern würde, wenn sie deaktiviert wurden.  
  
> [!IMPORTANT]
>  Das zurückgegebene <xref:System.Windows.LocalValueEnumerator> enthalten möglicherweise <xref:System.Windows.LocalValueEntry> Datensätze für Abhängigkeitseigenschaften, die schreibgeschützt sind oder Abhängigkeitseigenschaften, deren Werte vom Eigenschaftensystem berechnet werden. Ein visuelles Element, das eine eingerichtete Breite durch Layout verfügt z. B. einen lokalen Wert für meldet <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Wenn Sie lokale Werte abrufen, um diese zurückzusetzen, überprüfen Sie die <xref:System.Windows.DependencyProperty.ReadOnly%2A> Wert der Eigenschaft-ID der einzelnen <xref:System.Windows.LocalValueEntry> zu überprüfen, ob die <xref:System.Windows.DependencyProperty> zweifelhaft ist nicht schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Eigenschaften, die lokalen Werte, die auf ein Objekt festgelegt wurden ruft dann <xref:System.Windows.DependencyObject.ClearValue%2A> So löschen Sie die Werte dieser Eigenschaften.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the current effective value of a dependency property on this instance of a <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Returns the current effective value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die *effektiven Wert* ist der Wert der Eigenschaft, die von dem Eigenschaftensystem für jeden Aufrufer zurückgegeben wird, die den Wert anfordert. Der effektive Wert ist das Ergebnis des Eigenschaftensystems müssen alle möglichen Eingaben, die in der Eigenschaft System Wert Rangfolge einbezogen ausgewertet. Dies schließt die Umwandlung und Animation. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Diese Methode gibt nie zurück <xref:System.Windows.DependencyProperty.UnsetValue>. Die <xref:System.Windows.DependencyProperty.UnsetValue> ist ein Sentinelwert für die Eigenschaftensystem, in verschiedene Kapazitäten verfügbar gemachten intern und gelegentlich auch mithilfe von Rückrufen in Umwandlung verwendet wird.  
  
 Wenn Sie nicht sicher sind, wie der Typ der Eigenschaft sein soll, können Sie den Bezeichner der angeforderten Abhängigkeitseigenschaft zu bestimmen, ob es eine spezifischere Abfragen <xref:System.Windows.DependencyProperty.PropertyType%2A> , die der Rückgabewert in konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value was invalid, or the specified <paramref name="dp" /> does not exist.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to invalidate.</param>
        <summary>Re-evaluates the effective value for the specified dependency property</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, alle zugeordneten und anwendbaren <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen registriert werden, für die Abhängigkeitseigenschaft aufgerufen werden kann.  
  
 Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> auf eine Eigenschaft, die einen lokalen Wert festgelegt hat keine Auswirkungen, da der lokale Wert Vorrang vor anderen Eigenschaft System Eingaben, mit Ausnahme von Animationen enthält. Sie können jedoch aufrufen <xref:System.Windows.DependencyObject.ClearValue%2A>, rufen Sie anschließend <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Aufrufen von <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ist nicht notwendigerweise auch für viele Szenarien der Abhängigkeit-Eigenschaft. Wenn aufgrund von wertänderungen in einer der Bestandteile eine Abhängigkeitseigenschaft ungültig wird, wird das Eigenschaftensystem führt und neuauswertung automatisch die Abhängigkeitseigenschaft. Es gibt jedoch immer noch einige Szenarios, in denen <xref:System.Windows.DependencyObject.InvalidateProperty%2A> eignet. Insbesondere können Sie <xref:System.Windows.DependencyObject.InvalidateProperty%2A> innerhalb des zum Umwandeln von Werten oder die Eigenschaft geändert Rückruf für einen anderen Abhängigkeitseigenschaft. Sie können auch <xref:System.Windows.DependencyObject.InvalidateProperty%2A> um eine erneute Auswertung von einer Bindung für eine Datenquelle zu erzwingen, die nicht die empfohlene implementieren kann <xref:System.ComponentModel.INotifyPropertyChanged> Benachrichtigungsmechanismus (vielleicht Datenklassen in Anspruch, kann nicht abgeleitet werden, oder die Daten, in dem eine statische enthalten, Element).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ändern für die benutzerdefinierte Eigenschaft bei jedem-Eigenschaften, die in die für ungültig erklärten Eigenschaft Berechnungen beteiligt sind. Dies ist eine alternative Verfahren mit einem Aufruf der <xref:System.Windows.DependencyObject.CoerceValue%2A> -Methode, da ungültig macht die Eigenschaft auch jeden Aufruf wird registriert <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this instance is currently sealed (read-only).</summary>
        <value>
          <see langword="true" /> Wenn diese Instanz versiegelt ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird intern festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that will contain the dependency property identifier of interest, the property metadata for the type, and old and new values.</param>
        <summary>Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.DependencyObject" /> has been updated. The specific dependency property that changed is reported in the event data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient nicht zum einzelne eigenschaftenänderungen in der Regel zu erkennen oder Ausführen von Außerkraftsetzungen aufgewendet von Eigenschaften pro Fall zu entscheiden. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> wird stattdessen für Änderungen des Musters allgemeine invalidierung vorgesehen, wenn bestimmte Informationen über wide Klassifizierungen Eigenschaften bekannt ist. Ändert z. B. einem <xref:System.Windows.Freezable> möglicherweise Änderungen in die Werttypen der der <xref:System.Windows.Freezable>, oder möglicherweise Untereigenschaften, in dem die Änderungen in anderen sind <xref:System.Windows.Freezable> Verweise. Die <xref:System.Windows.Freezable> -überschreibungsimplementierung von <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> verwendet interne Informationen, um zu bestimmen, ob die Eigenschaften sind untergeordnete sowie die entsprechenden Basisklasse Logik für jedem Fall.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> oft wird möglicherweise während der Lebensdauer eines Objekts aufgerufen werden. Aus diesem Grund können Sie eine bessere Leistung für die gesamte Eigenschaftensystem erzielen, wenn Sie die Metadaten bestimmter Eigenschaften überschreiben und Sie dann fügen <xref:System.Windows.CoerceValueCallback> oder <xref:System.Windows.PropertyChangedCallback> Funktionen für die einzelnen Eigenschaften. Allerdings würden Sie diese Methode verwenden, wenn eine <xref:System.Windows.DependencyObject> enthält eine signifikante Anzahl Wert verknüpft Abhängigkeitseigenschaften, oder wenn es die Logik enthält, wie z. B. Renderingverhalten, die erneut ausgeführt werden, muss mehrere Fälle der Ungültigkeitserklärungen beziehen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Rufen Sie immer die grundlegende Implementierung. Dies versäumt wird die gesamte erheblich deaktiviert [! Include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)] Eigenschaftensystem, bewirkt, dass falsche Werte gemeldet werden.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the local value of a dependency property, if it exists.</summary>
        <returns>Returns the local value, or returns the sentinel value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> if no local value is set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Windows.DependencyObject.GetValue%2A> für die meisten typischen "get"-Vorgänge für eine Abhängigkeitseigenschaft. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Gibt nicht zurück den gültigen Wert für eine Vielzahl von Situationen, in denen der Wert nicht lokal festgelegt wurde.  
  
 Werte, die durch die Stile, Designs und Vorlagen festgelegt werden, der Standardwert von Metadaten oder Vererbung von Eigenschaftenwerten gelten nicht als lokale Werte sein. Jedoch werden Bindungen und andere Ausdrücke interpretiert, um die lokalen Werte werden, nachdem sie ausgewertet wurden.  
  
 Wenn kein lokaler Wert festgelegt ist, gibt diese Methode <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Wenn der zurückgegebene Wert, außer ist <xref:System.Windows.DependencyProperty.UnsetValue>, Sie können Abfragen, die Metadaten der angeforderten Abhängigkeitseigenschaft zu bestimmen, ob es ein spezifischeren Typ, der der Rückgabewert konvertiert werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the value of a dependency property without changing its value source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einer Komponente verwendet, die den Wert eines der seine eigenen Eigenschaften programmgesteuert festgelegt, ohne eine Anwendung deklarierte Verwendung der Eigenschaft deaktivieren. Die <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Methode ändert sich den effektiven Wert der Eigenschaft, aber vorhandene Trigger, datenbindungen und Stile sind weiterhin funktionsfähig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the local value of a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a dependency property, specified by its dependency property identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Typ nicht mit dem Typ übereinstimmt, der für die Abhängigkeitseigenschaft deklariert wird, wie es ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Die `value` Parameter sollte immer in den entsprechenden Typ angegeben werden.  
  
 Die Ausnahmebedingungen werden möglicherweise von diesem beeinflusst die <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf, der auf den Bezeichner der festzulegenden Abhängigkeitseigenschaft Abhängigkeit vorhanden ist. Andernfalls möglicherweise angegebene Wert fehlerhaft allgemeine Typprüfung Bedingungen (z. B. eine Zeichenfolge übergeben, wenn der systemeigene Typ Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a read-only dependency property, specified by the <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the dependency property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur wird normalerweise verwendet, wenn Sie Werte für schreibgeschützte Abhängigkeitseigenschaften festgelegt, die durch die benutzerdefinierten Klassen definiert werden. Im allgemeinen <xref:System.Windows.DependencyObject.SetValue%2A> aufgerufen wird, nur anhand des Typs, der die Abhängigkeitseigenschaft registriert die interne Logik implementiert, die der festgelegten Wert für die Abhängigkeitseigenschaft bereitstellt. Weitere Informationen finden Sie unter [Schreibgeschützte Abhängigkeitseigenschaften](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Wenn der angegebene Typ nicht mit dem Typ übereinstimmt, der für die Abhängigkeitseigenschaft deklariert wird, wie es ursprünglich registriert wurde, wird eine Ausnahme ausgelöst. Die `value` Parameter sollte immer in den entsprechenden Typ angegeben werden. Die Ausnahmebedingungen werden möglicherweise von diesem beeinflusst die <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> Rückruf, der auf den Bezeichner der festzulegenden Abhängigkeitseigenschaft Abhängigkeit vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine schreibgeschützte Abhängigkeitseigenschaft zusammen mit einem `public static readonly` <xref:System.Windows.DependencyProperty> bereitstellt erforderlichen nur-Lese Anfälligkeit für Consumer der Eigenschaft und die Get-Zugriffsmethode für die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property that should be serialized.</param>
        <summary>Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.</summary>
        <returns>
          <see langword="true" /> if the dependency property that is supplied should be value-serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die standardmäßige Implementierung `true` für alle Fälle, bei dem eine Abhängigkeitseigenschaft einen lokalen Wert festgelegt werden hatte, auf, die <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Außerkraftsetzungen für diese Methode möglicherweise für bestimmte Abhängigkeitseigenschaften unterschiedlich behandelt werden.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>