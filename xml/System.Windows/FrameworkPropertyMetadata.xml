<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="346b263b0e22fb800ba4b1fdb296032637c17b7c" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52737237" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Meldet die Metadaten für eine Abhängigkeitseigenschaft oder wendet diese an und fügt dabei insbesondere Systemmerkmale für frameworkspezifische Eigenschaften hinzu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird von <xref:System.Windows.PropertyMetadata> (über <xref:System.Windows.UIPropertyMetadata>). Für die meisten WPF-Frameworkebene-Anwendung Entwicklungszwecke <xref:System.Windows.FrameworkPropertyMetadata> ist der Typ, der für die Metadaten für Abhängigkeitseigenschaften verwendet, sondern die Basismetadaten Typen <xref:System.Windows.PropertyMetadata> oder <xref:System.Windows.UIPropertyMetadata>. Dies gilt sowohl für vorhandene Abhängigkeitseigenschaften als auch für die meisten Szenarios mit benutzerdefinierten Abhängigkeitseigenschaften.  
  
 Die Elemente deklariert, die von dieser Klasse diese Ergänzung der <xref:System.Windows.PropertyMetadata> Basisklasse enthalten verschiedene boolesche Eigenschaften, die angeben, oder Melden von WPF-Frameworkebene System das Verhalten wie die Vererbung von Eigenschaften, Datenbindung und Layout.  
  
 Einige Konstruktorsignaturen zum Erstellen einer <xref:System.Windows.FrameworkPropertyMetadata> -Instanz nehmen eine <xref:System.Windows.FrameworkPropertyMetadataOptions> Parameter. Die <xref:System.Windows.FrameworkPropertyMetadataOptions> Enumeration wird nur verwendet, um anfängliche Verhalten im Konstruktor angeben und ist nicht anderweitig verfügbar gemacht nach <xref:System.Windows.FrameworkPropertyMetadata> erstellt wird. Eine erstellte Instanz können Sie abrufen oder Festlegen von die entsprechenden Informationen über verschiedene Eigenschaften, die den Namen der Enumerationswerte, der im Konstruktoraufruf verwendet haben.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Diese Klasse ist nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Metadaten für eine Abhängigkeitseigenschaft für einen bestimmten Besitzer als der ursprüngliche Basis <xref:System.Windows.PropertyMetadata> Typ. Die Metadaten der Umwandlung in <xref:System.Windows.FrameworkPropertyMetadata>. Wenn die Umwandlung einen gültigen zurückgegeben <xref:System.Windows.FrameworkPropertyMetadata>, und dann verschiedene <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaftswerte werden über eine einfache Benutzeroberfläche, die (nicht abgebildet) gemeldet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Signatur initialisiert alle Werte von <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> auf ihre Standardwerte für die Eigenschaft. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> werden `null`, und die verschiedenen <xref:System.Windows.FrameworkPropertyMetadata> boolesche Eigenschaften werden `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
 Werte gekennzeichnet, als Satz von Flags in der `flags` Parametersatz wird den booleschen Wert des <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die entsprechen <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen auf `true`. Sie können anschließend die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einem bestimmten Vorgang angewendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert und dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung wird aufgerufen, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ein basisinitialisierung aufruft, und fügt dann die `coerceValueCallback` durch Festlegen der Eigenschaft auf der Basis-Instanz.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene sowie dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
 Werte gekennzeichnet, als Satz von Flags in der `flags` Parametersatz wird den booleschen Wert des <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die entsprechen <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen auf `true`. Sie können weiterhin die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einem bestimmten Vorgang angewendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert und den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene sowie den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
 Werte gekennzeichnet, als Satz von Flags in der `flags` Parametersatz wird den booleschen Wert des <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die entsprechen <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen auf `true`. Sie können weiterhin die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einem bestimmten Vorgang angewendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <param name="isAnimationProhibited">
          <see langword="true" />, um zu verhindern, dass das Eigenschaftensystem die Eigenschaft animiert, auf die diese Metadaten angewendet werden. Diese Eigenschaften lösen eine Laufzeitausnahme aus, die aus dem Eigenschaftensystem stammt, wenn versucht wird, sie zu animieren. <see langword="false" />, um das Animieren der Eigenschaft zuzulassen. Der Standardwert ist <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene, den angegebenen Rückrufen und einem booleschen Wert, mit dem die Animation der Eigenschaft verhindert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
 Die `isAnimationProhibited` Parameter wird den Anfangswert der <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Eigenschaft deklariert, durch die sofortige Basis <xref:System.Windows.UIPropertyMetadata> Klasse.  
  
 Werte gekennzeichnet, als Satz von Flags in der `flags` Parametersatz wird den booleschen Wert des <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die entsprechen <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen auf `true`. Sie können weiterhin die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einem bestimmten Vorgang angewendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Signatur dieses Konstruktors aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <param name="isAnimationProhibited">
          <see langword="true" />, um zu verhindern, dass das Eigenschaftensystem die Eigenschaft animiert, auf die diese Metadaten angewendet werden. Diese Eigenschaften lösen eine Laufzeitausnahme aus, die aus dem Eigenschaftensystem stammt, wenn versucht wird, sie zu animieren. Der Standardwert ist <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">Der <see cref="T:System.Windows.Data.UpdateSourceTrigger" />, der verwendet werden soll, wenn Bindungen für diese Eigenschaft angewendet werden, deren <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene, den angegebenen Rückrufen, einem booleschen Wert, mit dem die Animation der Eigenschaft verhindert werden kann, und einem Standardwert für den Aktualisierungstrigger der Datenbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts zur `defaultValue` übereinstimmen oder in Beziehung stehen in den Typ angegeben, in der ursprünglichen Registrierung der Abhängigkeitseigenschaft, die auf diese Metadaten angewendet werden soll. Konflikte zwischen Standardwerttyp Metadaten und den Typ der Abhängigkeitseigenschaft, die, der es angewendet wird, können schwierig zu debuggen, möglicherweise der Konflikt während der Kompilierung nicht erkannt wird. Das Eigenschaftensystem wird nicht den effektiven Wert einer Eigenschaft bis zur Laufzeit ausgewertet, daher ist das Ergebnis ein Typenkonflikt des standardmäßigen Wert Type-Eigenschaft einen Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat eine besondere Bedeutung im Eigenschaftensystem und nicht als Standardwert für eine Abhängigkeitseigenschaft verwendet werden.  
  
 Die `isAnimationProhibited` Parameter wird den Anfangswert der <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Eigenschaft deklariert, durch die sofortige Basis <xref:System.Windows.UIPropertyMetadata> Klasse.  
  
 Weitere Informationen zu das Updateverhalten für die Quelle für Bindungen, finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Werte gekennzeichnet, als Satz von Flags in der `flags` Parametersatz wird den booleschen Wert des <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die entsprechen <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen auf `true`. Sie können weiterhin die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einem bestimmten Vorgang angewendet wurde.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für <paramref name="defaultValue" /> ist <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Anordnungsphase während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value>
          <see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Anordnungsphase beeinflusst, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> eine Implementierung der <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , überwacht die effektive Änderungen für alle Abhängigkeitseigenschaften, die auf ein Element vorhanden. Als Teil dieser Logik können Abhängigkeitseigenschaften, die Änderung des effektiven Wert und die Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> festgelegt `true` initiiert eine verzögerte Anforderung, die die visuellen Objekte für dieses Element für ungültig erklären (einen Aufruf von <xref:System.Windows.UIElement.InvalidateArrange%2A>). Da diese Implementierung der WPF-Frameworkebene bereits vorhanden ist, Sie müssen normalerweise nicht für Abhängigkeitseigenschaften mit suchen <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , wenn Sie im Wesentlichen ersetzen oder ändern die WPF-Frameworkebene-Layout-Verhalten.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können auch ein ähnliches Verhalten zum Ändern von Eigenschaften Abhängigkeit verfügen, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> ist `true`.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in der Regel nicht in verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Messphase während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value>
          <see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Messphase beeinflusst, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> eine Implementierung der <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , überwacht die effektive Änderungen für alle Abhängigkeitseigenschaften, die auf ein Element vorhanden. Als Teil dieser Logik können Abhängigkeitseigenschaften, die Änderung des effektiven Wert und die Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> festgelegt `true` initiiert eine verzögerte Anforderung die visuellen Objekte für dieses Element ungültig gemacht werden. Da diese Implementierung der WPF-Frameworkebene bereits vorhanden ist, Sie müssen normalerweise nicht für Abhängigkeitseigenschaften mit suchen <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , wenn Sie im Wesentlichen ersetzen oder ändern die WPF-Frameworkebene-Layout-Verhalten.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können auch ein ähnliches Verhalten zum Ändern von Eigenschaften Abhängigkeit verfügen, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> ist `true`.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Anordnungsphase des übergeordneten Elements während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value>
          <see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Anordnungsphase beeinflusst (insbesondere für das übergeordnete Element), andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> eine Implementierung der <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , überwacht die effektive Änderungen für alle Abhängigkeitseigenschaften, die auf ein Element vorhanden. Als Teil dieser Logik können Abhängigkeitseigenschaften, die Änderung des effektiven Wert und die Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> festgelegt `true` initiiert eine verzögerte Anforderung, die die visuellen Objekte für das übergeordnete Element für ungültig zu erklären.  
  
 Im Allgemeinen, Sie müssen nicht mit einem <xref:System.Windows.FrameworkElement> Eigenschaft einem übergeordneten Element mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , da das Element selbst bereits einen eigenen müssten <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> als `true`. In der Regel ausreichend, da Initiierung des Änderungsvorgangs im untergeordneten Element in der Regel ein übergeordnetes Element anzuordnen, bei Bedarf. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> wird für manchmal verwendet eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse. In diesem Fall ist das untergeordnete Element legt eine Eigenschaft, aber eine <xref:System.Windows.FrameworkContentElement> abgeleiteten Klasse nicht ihr eigenes Rendering gesteuert. Das Rendering erfolgt durch eine <xref:System.Windows.FrameworkElement> übergeordneten Elements, das als den Inhaltshost dient. Z. B. eine Änderung an den Wert des der <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> angefügte Eigenschaft von einem untergeordneten Element ungültig Anordnen des übergeordneten Elements, da die Position des untergeordneten Elements in das übergeordnete Element geändert werden muss. Aus diesem Grund die <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> angefügte Eigenschaft verfügt über Metadaten, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ist `true`. Ein weiteres Beispiel ist <xref:System.Windows.Controls.Control.Padding%2A>; Wenn das übergeordnete Element dieser Eigenschaft geändert wird, ändern kann, wenn die Positionierung des untergeordneten Elements, abhängig von den verfügbaren Speicherplatz.  
  
 Da diese Implementierung der WPF-Frameworkebene bereits vorhanden ist, Sie müssen normalerweise nicht für Abhängigkeitseigenschaften mit suchen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , wenn Sie im Wesentlichen ersetzen oder ändern die WPF-Frameworkebene-Layout-Verhalten.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können auch ein ähnliches Verhalten zum Ändern von Eigenschaften Abhängigkeit verfügen, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ist `true`.  
  
 Eigenschaften für alle abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise den Bemessungsdurchgang des übergeordneten Elements während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value>
          <see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise den Bemessungsdurchgang beeinflusst (insbesondere für das übergeordnete Element), andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> eine Implementierung der <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , überwacht die effektive Änderungen für alle Abhängigkeitseigenschaften, die auf ein Element vorhanden. Als Teil dieser Logik können Abhängigkeitseigenschaften, die Änderung des effektiven Wert und die Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> festgelegt `true` initiiert eine verzögerte Anforderung, die die visuellen Objekte für das übergeordnete Element für ungültig zu erklären. Da diese Implementierung der WPF-Frameworkebene bereits vorhanden ist, Sie müssen normalerweise nicht für Abhängigkeitseigenschaften mit suchen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , wenn Sie im Wesentlichen ersetzen oder ändern die WPF-Frameworkebene-Layout-Verhalten.  
  
 Im Allgemeinen, Sie müssen nicht mit einem <xref:System.Windows.FrameworkElement> Eigenschaft einem übergeordneten Element mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , da das Element selbst bereits einen eigenen müssten <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> als `true`. Der Grund Initiierung des Änderungsvorgangs im untergeordneten Element in der Regel eine übergeordnete Maßübergabe bei Bedarf in der Regel ausreichend ist. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> wird für manchmal verwendet eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse. In diesem Fall ist das untergeordnete Element legt eine Eigenschaft, aber eine <xref:System.Windows.FrameworkContentElement> abgeleiteten Klasse nicht ihr eigenes Rendering gesteuert. Das Rendering erfolgt durch eine <xref:System.Windows.FrameworkElement> übergeordneten Elements, das als den Inhaltshost dient. Z. B. eine Änderung an den Wert des der <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> Eigenschaft von einem untergeordneten Element die Maß für das übergeordnete Element ungültig, da es sich bei der relative Abstand von Absätzen ändern, und möglicherweise erhöhen oder Verringern der Größe des kann. Aus diesem Grund die <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> Eigenschaft verfügt über Metadaten, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ist `true`.  
  
 Inhaltshostelemente häufig suchen Sie nach Änderungen an Abhängigkeitseigenschaften, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ist `true`, als Teil der Renderinglogik Inhaltshost. Z. B. die <xref:System.Windows.Controls.TextBox> Element muss auf bestimmte Änderungen im Text, die erfordern, die das umgebende Feld des reagieren die <xref:System.Windows.Controls.TextBox> selbst geändert werden.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können auch ein ähnliches Verhalten zum Ändern von Eigenschaften Abhängigkeit verfügen, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ist `true`.  
  
 Eigenschaften für alle abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob sich eine Abhängigkeitseigenschaft möglicherweise in irgendeiner Weise (nicht speziell in Bezug auf Anordnung oder Messung, jedoch hinsichtlich eines erforderlichen Neuzeichnens) auf das allgemeine Layout auswirkt.</summary>
        <value>
          <see langword="true" />, falls die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, sich auf das Rendering auswirkt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> eine Implementierung der <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , überwacht die effektive Änderungen für alle Abhängigkeitseigenschaften, die auf ein Element vorhanden. Als Teil dieser Logik können Abhängigkeitseigenschaften, die Änderung des effektiven Wert und die Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> festgelegt `true` initiiert eine verzögerte Anforderung die visuellen Objekte für dieses Element ungültig gemacht werden. Da diese Implementierung der WPF-Frameworkebene bereits vorhanden ist, Sie müssen normalerweise nicht für Abhängigkeitseigenschaften mit suchen <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , wenn Sie im Wesentlichen ersetzen oder ändern die WPF-Frameworkebene-Layout-Verhalten.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können auch ein ähnliches Verhalten zum Ändern von Eigenschaften Abhängigkeit verfügen, in denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> ist `true`.  
  
 Eigenschaften für alle abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Eigenschaft standardmäßig bidirektional gebunden wird, oder legt ihn fest.</summary>
        <value>
          <see langword="true" />, falls die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, standardmäßig bidirektional gebunden wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einem Nichtvorhandensein von dieser Eigenschaft wird `true`, bindungsaktualisierungen sind unidirektional ist, wird standardmäßig basierend auf das Standardverhalten der <xref:System.Windows.Data.Binding> Konstruktoren oder einer entsprechenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax.  
  
 In der vorhandenen Elemente finden Sie in der Regel diese Eigenschaft auf festgelegt `true` in den Metadaten für Abhängigkeitseigenschaften, Status gemeldet und z. B. geändert werden, durch eine Benutzeraktion können <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Diese Eigenschaft meldet im Allgemeinen nur die standardmäßige Bindung Update Merkmale der Abhängigkeitseigenschaft. Eine Bindung mit dem Festlegen dieser Eigenschaft auf einer Instanz kann lokal festgelegt. die <xref:System.Windows.Data.Binding.Mode%2A> -Eigenschaft der Bindung und diese Standardeinstellung ändern.  
  
 Eigenschaften für alle abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert für <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> ab, der beim Anwenden von Bindungen für die Eigenschaft mit diesen Metadaten verwendet werden soll, bei denen <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt ist, oder legt ihn fest.</summary>
        <value>Ein Wert der Enumeration, ungleich <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Diese Eigenschaft ist auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt. Der von Ihnen festgelegte Wert soll bei der Anforderung durch Bindungen zum Standardwert werden.</exception>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Wert für die Abhängigkeitseigenschaft vererbbar ist, oder legt ihn fest.</summary>
        <value>
          <see langword="true" />, wenn der Eigenschaftswert vererbbar ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vererbung von Eigenschaftswerten ist eine Funktion von der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem auf WPF-Frameworkebene, bei dem bestimmte Abhängigkeitseigenschaften lokal werden auf ein Element auf oder nahe dem Stamm des festgelegt können eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Element Struktur und dann von Eigenschaftswerten alle Elemente innerhalb der logischen Struktur der untergeordneten Elemente, die auch diese Eigenschaft besitzen. Die Vererbung von Eigenschaftswerten ist nicht standardmäßig aktiviert, und aktivieren es weist auf die Leistung auswirkt. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Obwohl die Vererbung von Eigenschaftswerten bei nicht angefügten Abhängigkeitseigenschaften zu funktionieren scheint, ist das Vererbungsverhalten einer nicht angefügten Eigenschaft über bestimmte Abteilungen Objekten in der Common Language Runtime-Struktur nicht definiert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A> zum Registrieren von Eigenschaften in dem Sie angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob die Datenbindung für die Abhängigkeitseigenschaft unterstützt wird.</summary>
        <value>
          <see langword="true" />, wenn die Datenbindung für die Abhängigkeitseigenschaft unterstützt wird, für die diese Metadaten gelten, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `false` für eine der folgenden möglichen Ursachen: entweder die Datenbindung für eine Abhängigkeitseigenschaft ist unzulässig, weil die Abhängigkeitseigenschaft (wie Berichte erstellt werden in der Bezeichner der Abhängigkeitseigenschaft, nicht die Metadaten), schreibgeschützt ist oder der Wert des eine andere Metadateneigenschaft, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, nastaven NA hodnotu `true` in diesen Metadaten. Diese Eigenschaft wird als verfügbar gemacht aus Gründen der benutzerfreundlichkeit, damit Aufrufer keine müssen beide überprüfen <xref:System.Windows.DependencyProperty.ReadOnly%2A> und <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Wenn Sie versuchen, um Metadaten zu erstellen, der angibt, dass eine andernfalls Lese-/Schreibzugriff-Eigenschaft die Datenbindung nicht unterstützen soll, geben Sie das Flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Beachten Sie die Benennungskonventionen Konvention Unterschiede im Vergleich zu <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardmetadaten aus verschiedenen Abhängigkeit abgerufen, den Wert von unterschiedlichen Abfragen <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften auf, und verwendet die Informationen zum Auffüllen einer Tabelle zum Implementieren von "Metadatenbrowser".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenbindung von der Abhängigkeitseigenschaft unterstützt wird, oder legt ihn fest.</summary>
        <value>
          <see langword="true" />, wenn die Eigenschaft die Datenbindung nicht unterstützt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, die diese Metadateneigenschaft, um festgelegt wird `true` speziell für die Eigenschaften, die nicht über die Datenbindung, obwohl Sie über Lese-/ Schreibeigenschaften unterstützen soll. Der Annahme liegt, dass in den meisten Fällen, in eine Abhängigkeitseigenschaft deklariert wird, die Datenbindung gewünscht ist, die Datenbindung eines der wichtigsten Szenarios ist, in denen eine Abhängigkeitseigenschaft nützlich ist. Im Gegensatz zu <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, dies ändert nicht nur einen Standardwert, der später zu einer bestimmten Bindung geändert werden kann. Durch Festlegen dieser Eigenschaft `true` Metadaten wird in den Metadaten für eine Abhängigkeitseigenschaft Alle Bindungen aus dem Anwenden von deren Werte durch die Ausdrücke auf die Abhängigkeitseigenschaft deaktiviert.  
  
 Schreibgeschützte Abhängigkeitseigenschaften unterstützen nicht die Datenbindung (da sie keine Set-Methode, die geänderten Werte anwenden können verfügen), melden aber trotzdem `false` für <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Dies ist, da Eigenschaften entsprechen, die auf eine <xref:System.Windows.FrameworkPropertyMetadataOptions> Werte meldet die Parität mit der tatsächlichen der Metadaten Einrichtung melden und nicht immer das Verhalten der End-Ergebnis, das die Benennung der Eigenschaft impliziert. Um zu bestimmen, ob eine angegebene Abhängigkeitseigenschaft Datenbindung zulässt, sollten Sie in der Regel überprüfen <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> stattdessen. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> ist eine Annehmlichkeit zum Überprüfen von sowohl <xref:System.Windows.DependencyProperty.ReadOnly%2A> und <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> als einzelner Vorgang, wobei das erwartete Ergebnis.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der angibt, ob diese Eigenschaft Journalinginformationen enthält, die von Anwendungen im Rahmen einer Journalingimplementierung gespeichert werden können oder sollen.</summary>
        <value>
          <see langword="true" />, wenn das Journaling für die Abhängigkeitseigenschaft ausgeführt werden soll, auf die diese Metadaten angewendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Die für das Zusammenführen zu verwendenden Basismetadaten.</param>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden sollen.</param>
        <summary>Ermöglicht einen Merge der Quellmetadaten mit den Basismetadaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern verwendet, wenn die Metadaten überschrieben wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen <see cref="T:System.Windows.PropertyMetadata" /> (oder sich die Klasse besonders) sollten diese Methode, um für alle Metadateneigenschaften-Konto hinzugefügt deren Implementierung wurde überschreiben. Z. B. Ihre Implementierung möglicherweise hinzugefügt, einen neuen Flag-Enumerationswert und die <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung sollte dann in der Lage, solche Flags ordnungsgemäß zu kombinieren.  
  
Rufen Sie immer die basisimplementierung vor eigene Implementierung, da die basisimplementierung übernimmt Zusammenführen aller Eigenschaften, die bereits in der vorherigen Typen in der Hierarchie definiert.  
  
Das Verhalten hinzugefügt, indem die <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> -Implementierung in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> ist, die bestimmte Eigenschaften von WPF-Frameworkebene in den Metadaten wie z. B. <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> werden in einer bitweisen Kombination oder -Vorgang.  
  
Die <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Verhalten implementiert außerdem das Verhalten, wenn Sie durch den Aufruf die Eigenschaftenmetadaten auf einer vorhandenen Abhängigkeitseigenschaft überschreiben <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, mithilfe von Metadaten für die Überschreibung, die <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die die Metadaten angewendet wurden.</param>
        <param name="targetType">Der diesen Metadaten zugeordnete Typ, wenn es sich um typspezifische Metadaten handelt. Wenn es sich um Standardmetadaten handelt, kann dieser Wert <see langword="null" /> sein.</param>
        <summary>Wird aufgerufen, wenn diese Metadaten auf eine Eigenschaft angewendet wurden. Dies gibt an, dass die Metadaten versiegelt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Veränderlichkeit von der Struktur einer <xref:System.Windows.FrameworkPropertyMetadata> Instanz sollte als unveränderlich gekennzeichnet, wenn diese Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see cref="T:System.Windows.FrameworkPropertyMetadata" /> Implementierung dieser Methode nichts über die basisimplementierung aufrufen.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auswertung der Vererbung von Eigenschaftenwerten über bestimmte Inhaltsgrenzen in der logischen Struktur der Elemente hinweg ausgeführt werden soll.</summary>
        <value>
          <see langword="true" />, wenn die Vererbung von Eigenschaftenwerten über bestimmte Inhaltsgrenzen hinweg ausgeführt werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Metadaten meldet eine selten angewendete Änderung Vererbungsverhalten von Eigenschaftswerten über Grenzen hinweg besonderen übergeordneten und untergeordneten-Element. Beispiel einer solchen Grenze ist der Inhalt des eine <xref:System.Windows.Controls.Frame>, wobei die <xref:System.Windows.Controls.Frame> Inhalt erneut geladen werden kann unabhängig von der das Vorhandensein der <xref:System.Windows.Controls.Frame>. Die gewünschte Eigenschaft gibt an, dass die Vererbung von Eigenschaftswerten nicht in den Inhalt von durchlaufen soll die <xref:System.Windows.Controls.Frame>, weil diese Inhalte Elemente, die die Anwendung sein können, die den Frame hostet, nicht besitzen oder steuern. Angeben von Metadaten mit <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> festgelegt `true`, sowie das angeben <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> als `true`, führt dazu, dass die Eigenschaft, die auf dem die Metadaten angewendet werden, auch im geerbt werden die <xref:System.Windows.Controls.Frame> Grenze oder ähnliche Grenzen.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, nachdem die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob sich untergeordnete Eigenschaften der Abhängigkeitseigenschaft nicht auf das Rendern des enthaltenden Objekts auswirken.</summary>
        <value>
          <see langword="true" />, wenn sich Änderungen an untergeordneten Eigenschaftswerten nicht auf das Rendern auswirken, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Metadatenoption ist relevant für Abhängigkeitseigenschaften, die Verweistypen sind, in dem Typ eine eigene Eigenschaftswerte verfügt. Normalerweise ist die Layoutlogik für das System davon ausgehen, dass jede Abhängigkeitseigenschaft Untereigenschaften potenziell wird auf das Layout auswirken, da alle untergeordneten Eigenschaften für Änderungen überprüfen zeitaufwändiger als die tatsächlich ausgeführten ist eine andere Renderings aus. Wenn diese Option auf `true` eignet sich zum Optimieren der Leistung der WPF-Framework auf Layout-System-Implementierung.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> in der Regel im Objektmodell als schreibgeschützt definiert sind. Dies ist, dass sie nach der Initialisierung der Instanz angepasst werden können. Jedoch, wenn die Metadaten als Teil eines Aufrufs von verbraucht ist <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, das Eigenschaftensystem die betreffende Metadateninstanz, und Eigenschaften, die die Merkmale der Metadaten enthalten jetzt als unveränderlich angesehen werden. Es wird versucht, zum Festlegen dieser Eigenschaft nach dem <xref:System.Windows.PropertyMetadata.IsSealed%2A> ist `true` auf diesen Metadaten Instanz löst eine Ausnahme aus.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML-Text-Nutzung  
 Member dieser Klasse werden in nicht in der Regel verwendet [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>