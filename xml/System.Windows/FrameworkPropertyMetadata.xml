<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdd84f72675390d1c868ff5904a4ccc72cfa84f5" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82487010" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Meldet die Metadaten für eine Abhängigkeitseigenschaft oder wendet diese an und fügt dabei insbesondere Systemmerkmale für frameworkspezifische Eigenschaften hinzu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird von <xref:System.Windows.PropertyMetadata> (über <xref:System.Windows.UIPropertyMetadata>) abgeleitet. Bei den meisten Anwendungs Entwicklungszwecken auf WPF-Frameworkebene ist <xref:System.Windows.FrameworkPropertyMetadata> der Typ, der für Metadaten für Abhängigkeits Eigenschaften verwendet wird, und nicht die Basis Metadaten-Typen <xref:System.Windows.PropertyMetadata> oder <xref:System.Windows.UIPropertyMetadata>. Dies gilt sowohl für vorhandene Abhängigkeits Eigenschaften als auch für die meisten benutzerdefinierten Abhängigkeits Eigenschafts Szenarios.  
  
 Die von dieser Klasse deklarierten Member, die die <xref:System.Windows.PropertyMetadata> Basisklasse ergänzen, beinhalten verschiedene boolesche Eigenschaften, die das Verhalten des Eigenschaften Systems auf WPF-Frameworkebene angeben oder melden, z. b. Eigenschaften Vererbung, Datenbindung und Layout.  
  
 Mehrere Konstruktorsignaturen zum Erstellen einer <xref:System.Windows.FrameworkPropertyMetadata> Instanz nehmen einen <xref:System.Windows.FrameworkPropertyMetadataOptions> Parameter. Die <xref:System.Windows.FrameworkPropertyMetadataOptions> Enumeration wird nur verwendet, um das anfängliche Verhalten im Konstruktor anzugeben, und wird nicht anderweitig verfügbar gemacht, nachdem <xref:System.Windows.FrameworkPropertyMetadata> erstellt wurde. Aus einer konstruierten Instanz können Sie die entsprechenden Informationen über verschiedene Eigenschaften abrufen oder festlegen, die den Namen der im konstruktorbefehl verwendeten Enumerationswerte gemeinsam verwenden.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Diese Klasse wird in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Metadaten für eine Abhängigkeits Eigenschaft eines bestimmten Besitzers als Ausgangsbasis <xref:System.Windows.PropertyMetadata> Typs abgerufen. Diese Metadaten werden in <xref:System.Windows.FrameworkPropertyMetadata>umgewandelt. Wenn die Umwandlung eine gültige <xref:System.Windows.FrameworkPropertyMetadata>zurückgegeben hat, werden verschiedene <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaftswerte über eine einfache Benutzeroberfläche (nicht angezeigt) gemeldet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Signatur werden alle Werte von <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> auf Ihre Eigenschafts Standardwerte initialisiert. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> werden `null`, und die verschiedenen <xref:System.Windows.FrameworkPropertyMetadata> booleschen Eigenschaften werden `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
 Werte, die im `flags`-Parameter als Set-Flags gekennzeichnet sind, legen den booleschen Wert <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die mit diesem <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen identisch sind, auf `true`fest. Anschließend können Sie die Werte der Eigenschaften in den Metadaten ändern, solange die Metadaten noch nicht auf einen bestimmten Eigenschafts System Vorgang angewendet wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert und dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung wird aufgerufen, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ruft einen Basisinitialisierer auf und fügt dann die `coerceValueCallback` hinzu, indem die-Eigenschaft für die-Basis Instanz festgelegt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene sowie dem angegebenen <see cref="T:System.Windows.PropertyChangedCallback" />-Rückruf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
 Werte, die im `flags`-Parameter als Set-Flags gekennzeichnet sind, legen den booleschen Wert <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die mit diesem <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen identisch sind, auf `true`fest. Sie können die Werte der Eigenschaften in den Metadaten weiterhin ändern, solange die Metadaten noch nicht auf einen bestimmten Eigenschafts System Vorgang angewendet wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem angegebenen Standardwert und den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene sowie den angegebenen Rückrufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
 Werte, die im `flags`-Parameter als Set-Flags gekennzeichnet sind, legen den booleschen Wert <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die mit diesem <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen identisch sind, auf `true`fest. Sie können die Werte der Eigenschaften in den Metadaten weiterhin ändern, solange die Metadaten noch nicht auf einen bestimmten Eigenschafts System Vorgang angewendet wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <param name="isAnimationProhibited"><see langword="true" />, um zu verhindern, dass das Eigenschaftensystem die Eigenschaft animiert, auf die diese Metadaten angewendet werden. Diese Eigenschaften lösen eine Laufzeitausnahme aus, die aus dem Eigenschaftensystem stammt, wenn versucht wird, sie zu animieren. <see langword="false" />, um das Animieren der Eigenschaft zuzulassen. Der Standardwert lautet <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene, den angegebenen Rückrufen und einem booleschen Wert, mit dem die Animation der Eigenschaft verhindert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
 Der `isAnimationProhibited`-Parameter legt den Anfangswert der <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Eigenschaft fest, die von der unmittelbaren Basis <xref:System.Windows.UIPropertyMetadata> Klasse deklariert wird.  
  
 Werte, die im `flags`-Parameter als Set-Flags gekennzeichnet sind, legen den booleschen Wert <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die mit diesem <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen identisch sind, auf `true`fest. Sie können die Werte der Eigenschaften in den Metadaten weiterhin ändern, solange die Metadaten noch nicht auf einen bestimmten Eigenschafts System Vorgang angewendet wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Konstruktorsignatur aufgerufen:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean, defaultUpdateSourceTrigger As UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Der Standardwert für die Abhängigkeitseigenschaft, der normalerweise als Wert eines bestimmten Typs angegeben wird.</param>
        <param name="flags">Die Flags für die Metadatenoptionen (eine Kombination von <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> Werten). Diese Optionen geben Merkmale der Abhängigkeitseigenschaft an, die mit Systemen wie Layout oder Datenbindung zusammen arbeiten.</param>
        <param name="propertyChangedCallback">Ein Verweis auf eine Handlerimplementierung, die das Eigenschaftensystem aufruft, wenn der effektive Wert der Eigenschaft geändert wird.</param>
        <param name="coerceValueCallback">Ein Verweis auf eine Handlerimplementierung, der aufgerufen wird, wenn das Eigenschaftensystem <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> für diese Abhängigkeitseigenschaft aufruft.</param>
        <param name="isAnimationProhibited"><see langword="true" />, um zu verhindern, dass das Eigenschaftensystem die Eigenschaft animiert, auf die diese Metadaten angewendet werden. Diese Eigenschaften lösen eine Laufzeitausnahme aus, die aus dem Eigenschaftensystem stammt, wenn versucht wird, sie zu animieren. Der Standardwert lautet <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">Der <see cref="T:System.Windows.Data.UpdateSourceTrigger" />, der verwendet werden soll, wenn Bindungen für diese Eigenschaft angewendet werden, deren <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkPropertyMetadata" />-Klasse mit dem bereitgestellten Standardwert und Metadatenoptionen auf Frameworkebene, den angegebenen Rückrufen, einem booleschen Wert, mit dem die Animation der Eigenschaft verhindert werden kann, und einem Standardwert für den Aktualisierungstrigger der Datenbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Werts, der für `defaultValue` bereitgestellt wird, muss mit dem Typ identisch sein, der in der ursprünglichen Registrierung der Abhängigkeits Eigenschaft angegeben ist, auf die diese Metadaten angewendet werden. Konflikte zwischen metadatenstandardwerttyp und dem Typ der Abhängigkeits Eigenschaft, auf die Sie angewendet wird, können schwierig zu debuggen sein, da der Konflikt während der Kompilierung nicht erkennbar ist. Das Eigenschaften System wertet den effektiven Wert einer Eigenschaft erst zur Laufzeit aus, d. h., das Ergebnis eines standardmäßigen Werttyps ist ein Laufzeitfehler.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue> hat im Eigenschaften System eine besondere Bedeutung und kann nicht als Standardwert für die Abhängigkeits Eigenschaft verwendet werden.  
  
 Der `isAnimationProhibited`-Parameter legt den Anfangswert der <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> Eigenschaft fest, die von der unmittelbaren Basis <xref:System.Windows.UIPropertyMetadata> Klasse deklariert wird.  
  
 Weitere Informationen zum Verhalten der Update Quelle für Bindungen finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Werte, die im `flags`-Parameter als Set-Flags gekennzeichnet sind, legen den booleschen Wert <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften, die mit diesem <xref:System.Windows.FrameworkPropertyMetadataOptions> flagnamen identisch sind, auf `true`fest. Sie können die Werte der Eigenschaften in den Metadaten weiterhin ändern, solange die Metadaten noch nicht auf einen bestimmten Eigenschafts System Vorgang angewendet wurden.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ist auf <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> festgelegt.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Anordnungsphase während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value><see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Anordnungsphase beeinflusst, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> enthalten eine Implementierung von <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>, mit der effektive Wertänderungen an allen in einem Element vorhandenen Abhängigkeits Eigenschaften überwacht werden. Im Rahmen dieser Logik wird durch Abhängigkeits Eigenschaften, die den effektiven Wert ändern und Metadaten enthalten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> auf `true` festgelegt ist, eine verzögerte Anforderung initiiert, um die visuellen Elemente für dieses Element (einen <xref:System.Windows.UIElement.InvalidateArrange%2A>aufzurufen) ungültig zu machen. Da diese Implementierung auf WPF-Frameworkebene bereits vorhanden ist, müssen Sie in der Regel keine Abhängigkeits Eigenschaften mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> suchen, es sei denn, Sie ersetzen oder ändern das Layoutverhalten auf WPF-Frameworkebene.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können ein ähnliches Verhalten für Änderungen an Abhängigkeits Eigenschaften haben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true`ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Messphase während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value><see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Messphase beeinflusst, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> enthalten eine Implementierung von <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>, mit der effektive Wertänderungen an allen in einem Element vorhandenen Abhängigkeits Eigenschaften überwacht werden. Im Rahmen dieser Logik wird durch Abhängigkeits Eigenschaften, die den effektiven Wert ändern und Metadaten enthalten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> auf `true` festgelegt ist, eine verzögerte Anforderung initiiert, um die visuellen Elemente für dieses Element ungültig zu machen. Da diese Implementierung auf WPF-Frameworkebene bereits vorhanden ist, müssen Sie in der Regel keine Abhängigkeits Eigenschaften mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> suchen, es sei denn, Sie ersetzen oder ändern das Layoutverhalten auf WPF-Frameworkebene.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können ein ähnliches Verhalten für Änderungen an Abhängigkeits Eigenschaften haben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> `true`ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise die Anordnungsphase des übergeordneten Elements während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value><see langword="true" />, wenn die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, möglicherweise die Anordnungsphase beeinflusst (insbesondere für das übergeordnete Element), andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> enthalten eine Implementierung von <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>, mit der effektive Wertänderungen an allen in einem Element vorhandenen Abhängigkeits Eigenschaften überwacht werden. Im Rahmen dieser Logik wird durch Abhängigkeits Eigenschaften, die einen effektiven Wert ändern und Metadaten aufweisen, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> auf `true` festgelegt ist, eine verzögerte Anforderung initiiert, um die visuellen Elemente für das übergeordnete Element ungültig zu machen.  
  
 Im Allgemeinen ist es nicht erforderlich, Änderungen einer <xref:System.Windows.FrameworkElement>-Eigenschaft mithilfe <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> an ein übergeordnetes Element zu melden, da das Element selbst bereits seine eigene <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true`hat. Das ist in der Regel ausreichend, da Änderungen im untergeordneten Element im Allgemeinen eine übergeordnete anordnen initiieren, wenn dies angebracht ist. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> wird manchmal für eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse verwendet. In diesem Fall legt das untergeordnete-Element eine Eigenschaft fest, aber eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse steuert nicht Ihr eigenes Rendering. Das Rendering wird von einem <xref:System.Windows.FrameworkElement> übergeordneten Element behandelt, das als Inhalts Host fungiert. Beispielsweise wird durch eine Änderung des Werts der angefügten <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> angefügten Eigenschaft durch ein untergeordnetes Element die Anordnung des übergeordneten Elements ungültig, da die Position des untergeordneten Elements im übergeordneten Element geändert werden muss. Daher verfügt die <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> angefügte-Eigenschaft über Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> `true`ist. Ein weiteres Beispiel ist <xref:System.Windows.Controls.Control.Padding%2A>. Wenn diese Eigenschaft geändert wird, kann das übergeordnete Element abhängig vom verfügbaren Platz die Positionierung des untergeordneten Elements ändern.  
  
 Da diese Implementierung auf WPF-Frameworkebene bereits vorhanden ist, müssen Sie in der Regel keine Abhängigkeits Eigenschaften mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> suchen, es sei denn, Sie ersetzen oder ändern das Layoutverhalten auf WPF-Frameworkebene.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können ein ähnliches Verhalten für Änderungen an Abhängigkeits Eigenschaften haben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> `true`ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob eine Abhängigkeitseigenschaft möglicherweise den Bemessungsdurchgang des übergeordneten Elements während Layout-Engine-Vorgängen beeinflusst.</summary>
        <value><see langword="true" />, wenn die Abhängigkeits Eigenschaft, für die diese Metadaten vorhanden sind, möglicherweise den Measure-Durchlauf speziell für das übergeordnete Element beeinflusst. Andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> enthalten eine Implementierung von <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>, mit der effektive Wertänderungen an allen in einem Element vorhandenen Abhängigkeits Eigenschaften überwacht werden. Im Rahmen dieser Logik wird durch Abhängigkeits Eigenschaften, die einen effektiven Wert ändern und Metadaten aufweisen, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> auf `true` festgelegt ist, eine verzögerte Anforderung initiiert, um die visuellen Elemente für das übergeordnete Element ungültig zu machen. Da diese Implementierung auf WPF-Frameworkebene bereits vorhanden ist, müssen Sie in der Regel keine Abhängigkeits Eigenschaften mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> suchen, es sei denn, Sie ersetzen oder ändern das Layoutverhalten auf WPF-Frameworkebene.  
  
 Im Allgemeinen ist es nicht erforderlich, Änderungen einer <xref:System.Windows.FrameworkElement>-Eigenschaft mithilfe <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> an ein übergeordnetes Element zu melden, da das Element selbst bereits seine eigene <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> `true`hat. Das ist in der Regel ausreichend, da Änderungen im untergeordneten Element in der Regel eine übergeordnete Maßübergabe auslösen, wenn dies angebracht ist. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> wird manchmal für eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse verwendet. In diesem Fall legt das untergeordnete-Element eine Eigenschaft fest, aber eine <xref:System.Windows.FrameworkContentElement> abgeleitete Klasse steuert nicht Ihr eigenes Rendering. Das Rendering wird von einem <xref:System.Windows.FrameworkElement> übergeordneten Element behandelt, das als Inhalts Host fungiert. Beispielsweise wird durch eine Änderung am Wert der <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>-Eigenschaft durch ein untergeordnetes Element das Measure des übergeordneten Elements ungültig, da sich der relative Abstand von Absätzen ändern und die Größe des Inhalts Hosts erhöhen oder verringern kann. Daher verfügt die <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>-Eigenschaft über Metadaten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`ist.  
  
 Inhalts Host Elemente suchen häufig auch nach Änderungen in Abhängigkeits Eigenschaften, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> als Teil der Inhalts Host-Renderinglogik `true`ist. Beispielsweise muss das <xref:System.Windows.Controls.TextBox>-Element auf bestimmte Änderungen innerhalb von Text reagieren, die ggf. erfordern, dass das umgebende Feld des <xref:System.Windows.Controls.TextBox> selbst geändert werden kann.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können ein ähnliches Verhalten für Änderungen an Abhängigkeits Eigenschaften haben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob sich eine Abhängigkeitseigenschaft möglicherweise in irgendeiner Weise (nicht speziell in Bezug auf Anordnung oder Messung, jedoch hinsichtlich eines erforderlichen Neuzeichnens) auf das allgemeine Layout auswirkt.</summary>
        <value><see langword="true" />, falls die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, sich auf das Rendering auswirkt, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> und <xref:System.Windows.FrameworkContentElement> enthalten eine Implementierung von <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>, mit der effektive Wertänderungen an allen in einem Element vorhandenen Abhängigkeits Eigenschaften überwacht werden. Im Rahmen dieser Logik wird durch Abhängigkeits Eigenschaften, die den effektiven Wert ändern und Metadaten enthalten, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> auf `true` festgelegt ist, eine verzögerte Anforderung initiiert, um die visuellen Elemente für dieses Element ungültig zu machen. Da diese Implementierung auf WPF-Frameworkebene bereits vorhanden ist, müssen Sie in der Regel keine Abhängigkeits Eigenschaften mit <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> suchen, es sei denn, Sie ersetzen oder ändern das Layoutverhalten auf WPF-Frameworkebene.  
  
 Benutzerdefinierte <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Implementierungen können ein ähnliches Verhalten für Änderungen an Abhängigkeits Eigenschaften haben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> `true`ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Eigenschaft standardmäßig bidirektional gebunden wird, oder legt ihn fest.</summary>
        <value><see langword="true" />, falls die Abhängigkeitseigenschaft, für die diese Metadaten vorhanden sind, standardmäßig bidirektional gebunden wird, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft nicht `true`wird, sind Bindungs Aktualisierungen standardmäßig unidirektional, basierend auf dem Standardverhalten der <xref:System.Windows.Data.Binding> Konstruktoren oder der entsprechenden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]-Syntax.  
  
 In vorhandenen Elementen wird diese Eigenschaft in der Regel auf `true` in den Metadaten für Abhängigkeits Eigenschaften festgelegt, die sowohl den Status melden als auch durch eine Benutzeraktion änderbar sind, z. b. <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Mit dieser Eigenschaft werden nur die standardmäßigen Bindungs Update Merkmale der Abhängigkeits Eigenschaft im allgemeinen gemeldet. Jede Bindung, die auf diese Eigenschaft für eine Instanz festgelegt ist, kann die <xref:System.Windows.Data.Binding.Mode%2A>-Eigenschaft der Bindung lokal festlegen und diese Standardeinstellung ändern.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert für <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> ab, der beim Anwenden von Bindungen für die Eigenschaft mit diesen Metadaten verwendet werden soll, bei denen <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt ist, oder legt ihn fest.</summary>
        <value>Ein Wert der Enumeration, ungleich <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Diese Eigenschaft ist auf <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> festgelegt. Der von Ihnen festgelegte Wert soll bei der Anforderung durch Bindungen zum Standardwert werden.</exception>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Wert für die Abhängigkeitseigenschaft vererbbar ist, oder legt ihn fest.</summary>
        <value><see langword="true" />, wenn der Eigenschaftswert vererbbar ist, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vererbung von Eigenschafts Werten ist eine Funktion des [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften Systems auf der WPF-Frameworkebene, bei der bestimmte Abhängigkeits Eigenschaften lokal für ein Element in oder in der Nähe des Stamms einer [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Elementstruktur festgelegt werden können und deren Wert dann von allen Elementen in der logischen Struktur von untergeordneten Elementen geerbt wird, die auch diese Eigenschaft besitzen. Die Vererbung von Eigenschafts Werten ist standardmäßig nicht aktiviert, und das Aktivieren der Eigenschaft wirkt sich auf die Leistung aus. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Obwohl die Vererbung von Eigenschafts Werten für nicht angefügte Abhängigkeits Eigenschaften aussehen könnte, ist das Vererbungs Verhalten für eine nicht angefügte Eigenschaft über bestimmte Objekt-Objekt-Bereiche in der Laufzeitstruktur nicht definiert. Verwenden Sie immer <xref:System.Windows.DependencyProperty.RegisterAttached%2A>, um Eigenschaften zu registrieren, bei denen Sie <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in den Metadaten angeben.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob die Datenbindung für die Abhängigkeitseigenschaft unterstützt wird.</summary>
        <value><see langword="true" />, wenn die Datenbindung für die Abhängigkeitseigenschaft unterstützt wird, für die diese Metadaten gelten, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft meldet `false` für eine von zwei möglichen Bedingungen: eine Datenbindung an eine Abhängigkeits Eigenschaft ist nicht zulässig, da die Abhängigkeits Eigenschaft schreibgeschützt ist (wie im Bezeichner der Abhängigkeits Eigenschaft, nicht in den Metadaten), oder wenn der Wert einer anderen Metadateneigenschaft, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, auf `true` in diesen Metadaten festgelegt ist. Diese Eigenschaft wird als bequeme bereitgestellt, sodass Aufrufer nicht sowohl <xref:System.Windows.DependencyProperty.ReadOnly%2A> als auch <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>überprüfen müssen.  
  
 Wenn Sie versuchen, Metadaten zu erstellen, die angeben, dass eine anderweitig Lese-/Schreibeigenschaft keine Datenbindung unterstützen soll, geben Sie das-Flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> an (Beachten Sie den Unterschied der geringfügigen Namenskonvention und <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standard Metadaten aus verschiedenen Abhängigkeits Eigenschaften Feldern abgerufen, der Wert verschiedener <xref:System.Windows.FrameworkPropertyMetadata> Eigenschaften abgefragt und die Informationen zum Auffüllen einer Tabelle zum Implementieren eines "metadatenbrowsers" verwendet.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Datenbindung von der Abhängigkeitseigenschaft unterstützt wird, oder legt ihn fest.</summary>
        <value><see langword="true" />, wenn die Eigenschaft die Datenbindung nicht unterstützt, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Metadateneigenschaft auf `true` speziell für Eigenschaften festgelegt ist, die die Datenbindung trotz der Lese-/Schreibeigenschaften nicht unterstützen sollen. Die Annahme ist, dass in den meisten Fällen, in denen eine Abhängigkeits Eigenschaft deklariert wird, Daten Bindungen gewünscht werden, da die Datenbindung eines der wichtigsten Szenarien ist, in denen eine Abhängigkeits Eigenschaft nützlich ist. Im Gegensatz zu <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>ändert dies nicht nur einen Standardwert, der später für eine bestimmte Bindung geändert werden kann. Wenn diese Eigenschaft `true` in den Metadaten für die Metadaten einer Abhängigkeits Eigenschaft festgelegt wird, werden alle Bindungen daran deaktiviert, ihre Werte durch Ausdrücke auf diese Abhängigkeits Eigenschaft anzuwenden.  
  
 Schreibgeschützte Abhängigkeits Eigenschaften unterstützen die Datenbindung nicht (da Sie über keinen Setter verfügen, der geänderte Werte anwenden kann), Sie melden jedoch weiterhin `false` für <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Dies liegt daran, dass Eigenschaften, die einem <xref:System.Windows.FrameworkPropertyMetadataOptions> Werten entsprechen, die Parität mit der tatsächlichen Einrichtung der Metadaten melden, anstatt immer das Ergebnis des Endergebnis zu melden, dass die Benennung der Eigenschaft impliziert werden könnte. Wenn Sie ermitteln möchten, ob eine bestimmte Abhängigkeits Eigenschaft die Datenbindung zulässt, sollten Sie in der Regel <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> überprüfen. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> ist eine einfache Möglichkeit zum Überprüfen von <xref:System.Windows.DependencyProperty.ReadOnly%2A> und <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> als einzelner Vorgang und liefert das erwartete Ergebnis.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der angibt, ob diese Eigenschaft Journalinginformationen enthält, die von Anwendungen im Rahmen einer Journalingimplementierung gespeichert werden können oder sollen.</summary>
        <value><see langword="true" />, wenn das Journaling für die Abhängigkeitseigenschaft ausgeführt werden soll, auf die diese Metadaten angewendet werden, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Die für das Zusammenführen zu verwendenden Basismetadaten.</param>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die diese Metadaten angewendet werden sollen.</param>
        <summary>Ermöglicht ein Zusammenführen der Quellmetadaten mit den Basismetadaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern verwendet, wenn Metadaten überschrieben werden.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klassen, die von <see cref="T:System.Windows.PropertyMetadata" /> (oder dieser Klasse) abgeleitet werden, sollten diese Methode überschreiben, um Metadaten-Eigenschaften zu berücksichtigen, die Sie in ihren Implementierungen hinzugefügt haben. Beispielsweise kann Ihre-Implementierung einen neuen flagbezogenen Enumerationswert hinzugefügt haben, und die <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung sollte dann in der Lage sein, diese Flags ordnungsgemäß zu kombinieren.  
  
Die Basis Implementierung muss immer vor ihrer eigenen Implementierung aufgerufen werden, da die Basis Implementierung alle Eigenschaften zusammenführt, die bereits für vorherige Typen in der Hierarchie definiert wurden.  
  
Das von der <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Implementierung in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> hinzugefügte Verhalten besteht darin, dass bestimmte Eigenschaften auf WPF-Frameworkebene in den Metadaten wie <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> in einer bitweisen OR-Operation kombiniert werden.  
  
Das <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Verhalten implementiert auch das Verhalten, wenn Sie die Eigenschafts Metadaten für eine vorhandene Abhängigkeits Eigenschaft überschreiben, indem Sie <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />mithilfe von <see cref="T:System.Windows.FrameworkPropertyMetadata" />Überschreibungs Metadaten aufrufen.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Die Abhängigkeitseigenschaft, auf die die Metadaten angewendet wurden.</param>
        <param name="targetType">Der diesen Metadaten zugeordnete Typ, wenn es sich um typspezifische Metadaten handelt. Wenn es sich um Standardmetadaten handelt, kann dieser Wert <see langword="null" /> sein.</param>
        <summary>Wird aufgerufen, wenn diese Metadaten auf eine Eigenschaft angewendet wurden. Dies gibt an, dass die Metadaten versiegelt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Änderbarkeit der Datenstruktur einer <xref:System.Windows.FrameworkPropertyMetadata> Instanz sollte als unveränderlich gekennzeichnet werden, wenn diese Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die <see cref="T:System.Windows.FrameworkPropertyMetadata" /> Implementierung dieser Methode führt nicht zum Aufrufen der Basis Implementierung.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auswertung der Vererbung von Eigenschaftenwerten über bestimmte Inhaltsgrenzen in der logischen Struktur der Elemente hinweg ausgeführt werden soll.</summary>
        <value><see langword="true" />, wenn die Vererbung von Eigenschaftenwerten über bestimmte Inhaltsgrenzen hinweg ausgeführt werden soll, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Metadaten melden eine selten angewendete Änderung des Vererbungs Verhaltens von Eigenschafts Werten über spezielle übergeordnete Elementgrenzen hinweg. Das kanonische Beispiel einer solchen Grenze ist der Inhalt einer <xref:System.Windows.Controls.Frame>, bei der der <xref:System.Windows.Controls.Frame> Inhalt unabhängig vom vorhanden sein der <xref:System.Windows.Controls.Frame>erneut geladen werden kann. Das gewünschte Eigenschaften Systemverhalten besteht darin, dass die Vererbung von Eigenschafts Werten nicht in den Inhalt des <xref:System.Windows.Controls.Frame>übertragen werden kann, da es sich bei diesen Inhalten möglicherweise um Elemente handelt, die von der Anwendung, die den Frame gehostet, nicht Wenn Sie Metadaten angeben, bei denen <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> auf `true`festgelegt ist, und <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> als `true`angeben, bewirkt dies, dass die Eigenschaft, auf die die Metadaten angewendet werden, auch über die <xref:System.Windows.Controls.Frame> Grenze oder ähnliche Grenzen hinweg vererbbar ist.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Nachdem die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet wurden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen eines Werts, der angibt, ob sich untergeordnete Eigenschaften der Abhängigkeitseigenschaft nicht auf das Rendern des enthaltenden Objekts auswirken.</summary>
        <value><see langword="true" />, wenn sich Änderungen an untergeordneten Eigenschaftswerten nicht auf das Rendern auswirken, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Metadatenoption ist für Abhängigkeits Eigenschaften relevant, bei denen es sich um Verweis Typen handelt, bei denen dieser Typ eigene Eigenschaftswerte aufweist. In der Regel ist die layoutsystemlogik davon auszugehen, dass sich jede Abhängigkeits Eigenschaft mit untergeordneten Eigenschaften möglicherweise auf das Layout auswirkt, da das Überprüfen aller unter Eigenschaften auf Änderungen zeitaufwändiger ist, als ein anderer renderdurchlauf tatsächlich ausgeführt wird. Das Festlegen dieser Option auf `true` ist für die Optimierung der Leistung der layoutsystemimplementierung der WPF-Frameworkebene nützlich.  
  
 Eigenschaften für abgeleitete Klassen von <xref:System.Windows.PropertyMetadata> werden in der Regel im Objektmodell als Lese-/Schreibzugriff definiert. So können Sie nach der Initialisierung der-Instanz angepasst werden. Sobald die Metadaten jedoch im Rahmen eines Aufrufes <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>oder <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>verarbeitet werden, versiegelt das Eigenschaften System, dass die Metadateninstanz und die Eigenschaften, die die Einzelheiten der Metadaten vermitteln, jetzt als unveränderlich angesehen werden. Wenn Sie versuchen, diese Eigenschaft festzulegen, nachdem <xref:System.Windows.PropertyMetadata.IsSealed%2A> in dieser Metadateninstanz `true` ist, wird eine Ausnahme ausgelöst.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Metadaten wurden bereits auf einen Vorgang der Abhängigkeitseigenschaft angewendet, sodass Metadaten versiegelt sind und keine Eigenschaften für Metadaten festgelegt werden können.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
