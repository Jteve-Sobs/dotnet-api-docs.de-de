<Type Name="EventManager" FullName="System.Windows.EventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2e0251fbd3d9179e855a3573194cd3b7d5169712" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460484" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EventManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EventManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.EventManager" />
  <TypeSignature Language="VB.NET" Value="Public Class EventManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventManager abstract sealed" />
  <TypeSignature Language="F#" Value="type EventManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides event-related utility methods that register routed events for class owners and add class handlers.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird am häufigsten verwendet, um ein neues Routingereignis beim Registrieren <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.  
  
 Die zweite am häufigsten vorkommen [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] Auslastung ist <xref:System.Windows.EventManager.RegisterClassHandler%2A>. Sie können diese Methode verwenden, um eine Klassenbehandlung für ein Routingereignis für die Klasse oder ein angefügtes Ereignis zu aktivieren. Weitere Informationen finden Sie unter [Routingereignisse als bearbeitete sowie die Behandlung von Klasse markieren](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie diese Klasse verwenden, um ein neues Routingereignis als Klassenmember, zusammen mit der Routingereignis "Wrapper" Technik, überschreiben die hinzufügen zu registrieren und Entfernen von Implementierungen für eine [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis.  
  
 [!code-csharp[DPCustom#EventManagerClass](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#eventmanagerclass)]
 [!code-vb[DPCustom#EventManagerClass](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#eventmanagerclass)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetRoutedEvents">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEvents () As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEvents();" />
      <MemberSignature Language="F#" Value="static member GetRoutedEvents : unit -&gt; System.Windows.RoutedEvent[]" Usage="System.Windows.EventManager.GetRoutedEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns identifiers for routed events that have been registered to the event system.</summary>
        <returns>An array of type <see cref="T:System.Windows.RoutedEvent" /> that contains the registered objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere <xref:System.Windows.RoutedEvent> Objekte später registriert werden können. Diese Methode wird eine Momentaufnahme erstellt, und die Auflistung der Routingereignisse kann in der gesamten Lebensdauer einer Anwendung geschrieben werden. Die zurückgegebene Auflistung möglicherweise sehr groß sein. Zählen auch nur die Ereignisse, die Teil der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], der sammlungsanzahl in hundert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRoutedEventsForOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEventsForOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEventsForOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEventsForOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEventsForOwner (ownerType As Type) As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEventsForOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member GetRoutedEventsForOwner : Type -&gt; System.Windows.RoutedEvent[]" Usage="System.Windows.EventManager.GetRoutedEventsForOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to start the search with. Base classes are included in the search.</param>
        <summary>Finds all routed event identifiers for events that are registered with the provided owner type.</summary>
        <returns>An array of matching routed event identifiers if any match is found; otherwise, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClassHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a class handler for a particular routed event.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="static member RegisterClassHandler : Type * System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="System.Windows.EventManager.RegisterClassHandler (classType, routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="classType">The type of the class that is declaring class handling.</param>
        <param name="routedEvent">The routed event identifier of the event to handle.</param>
        <param name="handler">A reference to the class handler implementation.</param>
        <summary>Registers a class handler for a particular routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassenbehandlung ist ein Feature, das für Routingereignisse, einschließlich angefügte Ereignisse, die implementiert werden, mit Routingereignis Sicherung verfügbar ist. Ein Klassenhandler ist wie ein statischer Handler, der für alle Instanzen der Klasse vorhanden ist. Da der Handler statisch sind, Instanzeigenschaften direkt mit einem Klassenhandler kann nicht geändert werden, aber Sie die Instanzen über erreichen die `sender` Parameter und/oder die Ereignisdaten.  
  
 Klassenhandler werden vor den Handlern Instanz aufgerufen. Sie können einen Klassenhandler implementieren, der das Verhalten der das Ereignis als behandelt markiert wurde. Aus diesem Grund werden Instanzhandler für ein Ereignis Klasse behandelt nicht aufgerufen, es sei denn, der den Handler für die behandelten Ereignisse registrieren.  
  
 Anzahl der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Basiselement Ereignisse bieten eine Klassenbehandlung virtuelle Methoden. Durch das Überschreiben dieser Methoden in Klassen, die die Basisklassen erben, können Sie eine Klassenbehandlung ohne Aufruf implementieren <xref:System.Windows.EventManager.RegisterClassHandler%2A> in statischen Konstruktoren. Methoden dieser Klasse wird in der Regel für die Eingabeereignisse vorhanden sind, und haben Namen, die mit "On" beginnen und enden mit dem Namen des Ereignisses Klasse behandelt wird.  
  
 Weitere Informationen zur Klassenbehandlung finden Sie unter [Routingereignisse als bearbeitete sowie die Behandlung von Klasse markieren](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Mithilfe dieser Signatur werden Klassenhandler registriert werden, um nur als Reaktion auf Ereignisse ohne Behandlung aufzurufen. Sie können auch registrieren Klassenhandler aufrufen, auch wenn die Ereignisargumente behandelt,, mithilfe markiert sind der <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur, mit `handledEventsToo` festgelegt `true`.  
  
   
  
## Examples  
 Das folgende Beispiel fügt einen Handler für <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>Aufrufen <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 [!code-csharp[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#staticandregisterclasshandler)]
 [!code-vb[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#staticandregisterclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="static member RegisterClassHandler : Type * System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="System.Windows.EventManager.RegisterClassHandler (classType, routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classType">The type of the class that is declaring class handling.</param>
        <param name="routedEvent">The routed event identifier of the event to handle.</param>
        <param name="handler">A reference to the class handler implementation.</param>
        <param name="handledEventsToo">
          <see langword="true" /> to invoke this class handler even if arguments of the routed event have been marked as handled; <see langword="false" /> to retain the default behavior of not invoking the handler on any marked-handled event.</param>
        <summary>Registers a class handler for a particular routed event, with the option to handle events where event data is already marked handled.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassenbehandlung ist ein Feature, das für Routingereignisse, einschließlich angefügte Ereignisse, die implementiert werden, mit Routingereignis Sicherung verfügbar ist. Ein Klassenhandler ist wie ein statischer Handler, der für alle Instanzen der Klasse vorhanden ist. Da der Handler statisch sind, Instanzeigenschaften direkt mit einem Klassenhandler kann nicht geändert werden, aber Sie die Instanzen über erreichen die `sender` Parameter und/oder die Ereignisdaten.  
  
 Klassenhandler werden vor den Handlern Instanz aufgerufen. Sie können einen Klassenhandler implementieren, der das Verhalten der das Ereignis als behandelt markiert wurde. Aus diesem Grund werden Instanzhandler für ein Ereignis Klasse behandelt nicht aufgerufen, es sei denn, der den Handler für die behandelten Ereignisse registrieren.  
  
 Anzahl der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Basiselement Ereignisse bieten eine Klassenbehandlung virtuelle Methoden. Durch das Überschreiben dieser Methoden in Klassen, die die Basisklassen erben, können Sie eine Klassenbehandlung ohne Aufruf implementieren <xref:System.Windows.EventManager.RegisterClassHandler%2A> in statischen Konstruktoren. Methoden dieser Klasse wird in der Regel für die Eingabeereignisse vorhanden sind, und haben Namen, die mit "On" beginnen und enden mit dem Namen des Ereignisses Klasse behandelt wird.  
  
 Weitere Informationen zur Klassenbehandlung finden Sie unter [Routingereignisse als bearbeitete sowie die Behandlung von Klasse markieren](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Mithilfe dieser Signatur Klassenhandler können registriert werden, um bei behandelten Ereignisse durch Festlegen von aufgerufen `handledEventsToo` festgelegt `true`. Im Allgemeinen sollten Sie dies tun, nur dann, wenn ein bekannter Behandlungsproblem zu umgehen, z. B. der Eingabesystem Behandlung von Ereignissen der Maus oder Tastatur ausführen möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRoutedEvent">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent RegisterRoutedEvent (string name, System.Windows.RoutingStrategy routingStrategy, Type handlerType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent RegisterRoutedEvent(string name, valuetype System.Windows.RoutingStrategy routingStrategy, class System.Type handlerType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterRoutedEvent(System.String,System.Windows.RoutingStrategy,System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::RoutedEvent ^ RegisterRoutedEvent(System::String ^ name, System::Windows::RoutingStrategy routingStrategy, Type ^ handlerType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterRoutedEvent : string * System.Windows.RoutingStrategy * Type * Type -&gt; System.Windows.RoutedEvent" Usage="System.Windows.EventManager.RegisterRoutedEvent (name, routingStrategy, handlerType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="routingStrategy" Type="System.Windows.RoutingStrategy" />
        <Parameter Name="handlerType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the routed event. The name must be unique within the owner type and cannot be <see langword="null" /> or an empty string.</param>
        <param name="routingStrategy">The routing strategy of the event as a value of the enumeration.</param>
        <param name="handlerType">The type of the event handler. This must be a delegate type and cannot be <see langword="null" />.</param>
        <param name="ownerType">The owner class type of the routed event. This cannot be <see langword="null" />.</param>
        <summary>Registers a new routed event with the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] event system.</summary>
        <returns>The identifier for the newly registered routed event. This identifier object can now be stored as a static field in a class and then used as a parameter for methods that attach handlers to the event. The routed event identifier is also used for other event system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Rückgabewert dieser Methode verwenden, erstellen Sie die statische Deklaration für eine eindeutige <xref:System.Windows.RoutedEvent> Bezeichnerfeld. Dieses Feld sollte im Besitzertyp gespeichert werden.  
  
 Es gibt zahlreiche Konventionen und best Practices in Verbindung mit Routingereignissen sollte mit dem Namen, registriert und in einer Klasse verfügbar gemacht werden. Weitere Informationen finden Sie unter [Ereignisübersicht weitergeleitet](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>