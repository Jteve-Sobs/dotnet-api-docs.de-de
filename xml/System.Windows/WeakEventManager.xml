<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71ce1d618f8a5d9522719cc5caee0b1d3e8e4e74" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82443018" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WeakEventManager extends System.Windows.Threading.DispatcherObject" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Basisklasse für den Ereignis-Manager bereit, der im *Muster für schwache Ereignisse* verwendet wird. Der Manager fügt Listener hinzu oder entfernt diese für Ereignisse (oder Rückrufe), die ebenfalls dieses Muster verwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise verwenden Sie das schwache Ereignis Muster, wenn die Ereignis Quelle eine Objekt Lebensdauer hat, die unabhängig von den Ereignislistenern ist. Durch die Verwendung der Funktion für die zentrale Ereignis Verteilung einer <xref:System.Windows.WeakEventManager> können die Handler des Listener auch dann in die Garbage Collection aufgenommen werden, wenn das Quell Objekt weiterhin besteht. Im Gegensatz dazu bewirkt ein reguläres Ereignis mit dem `+=`-Operator, dass die möglicherweise getrennte Quelle einen Verweis auf die Listener enthält. Dadurch wird verhindert, dass der Empfänger rechtzeitig eine Garbage Collection durchgeführt wird.  
  
 Eine häufige Situation, in der die Lebensdauer Beziehungen zwischen Quellen und Listenern das schwache Ereignis Muster verwenden sollten, ist die Behandlung von Update Ereignissen aus Daten Bindungen.  
  
 Das schwache Ereignis Muster kann auch für Rückrufe und reguläre Ereignisse verwendet werden.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Ein Beispiel für eine benutzerdefinierte <see cref="T:System.Windows.WeakEventManager" />finden Sie unter [schwache Ereignis Muster](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert als Initialisierer innerhalb des Konstruktors einer abgeleiteten Klasse die Basisklassenwerte.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die vom Ereignis zu liefernden Ereignisdaten enthält.</param>
        <summary>Übermittelt das verwaltete Ereignis an alle Listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode aus den Ereignis Handlern auf, die durch die <xref:System.Windows.WeakEventManager.StartListening%2A>-und <xref:System.Windows.WeakEventManager.StopListening%2A>-Implementierungen von Unterklassen hinzugefügt oder daraus entfernt werden.  
  
 Wenn Sie die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>-Methode in ihrer `AddListener`-Implementierung der Klasse aufzurufen, wird die Liste der Listener, die das Ereignis empfangen, in einer zugrunde liegenden Auflistung gespeichert. (`AddListener` ist nicht Teil einer Schnittstelle oder eines Klassen Vertrags. `AddListener` ist der vorgeschlagene Name für die-Methode Ihrer Manager-Klasse, die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> aufruft und schwache ereignismusterlistener für das-Ereignis hinzufügt.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> fügt einer einzelnen Liste Listener hinzu. Wenn die Manager-Implementierung mehr als eine Liste von Listenern pro Ereignis beibehält, verwenden Sie nicht <xref:System.Windows.WeakEventManager.DeliverEvent%2A> oder <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `AddListener` der entsprechenden Liste Listener hinzufügen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <param name="list">Die bereitgestellte <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Übermittelt das verwaltete Ereignis an jeden Listener in der bereitgestellten Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist erforderlich, wenn die Manager-Implementierung separate Listener-Listen auf der Grundlage von Informationen verwaltet, die in den Ereignisdaten aufgezeichnet werden. Wenn Sie diese erweiterte Technik verwenden, müssen Sie die separaten Listen als Teil ihrer Manager-Implementierung erstellen und verwalten, und Sie müssen eine Möglichkeit zum Hinzufügen von Listenern zu einer bestimmten Liste bereitstellen. Die Handlerimplementierung, die auf das unformatierte Ereignis lauscht, muss auf die Bedingung reagieren, die Sie verwenden, um die Listen zu unterscheiden, und das Ereignis nur an die entsprechende Liste oder Listen übermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, für den der <see cref="T:System.Windows.WeakEventManager" /> abgerufen werden sollen.</param>
        <summary>Gibt die <see cref="T:System.Windows.WeakEventManager" />-Implementierung zurück, die für den bereitgestellten Typ verwendet wird.</summary>
        <returns>Die übereinstimmende <see cref="T:System.Windows.WeakEventManager" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> Implementierungen verwenden diese Methode mithilfe Ihres bestandenen `managerType`. Der zurückgegebene <xref:System.Windows.WeakEventManager> wird dann als Differenzierer verwendet, der bestimmt, welches Ereignis empfangen wurde und welcher private Klassen Handler aufgerufen werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Der nullbasierte Index der angeforderten Quelle.</param>
        <summary>Ruft die Daten ab, die für die angegebene Quelle gespeichert werden, oder legt diese fest.</summary>
        <value>Daten, die vom Manager für diese Quelle gespeichert werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können auswählen, welche Daten und Typen in diesem Indexer gespeichert werden sollen. In der Regel wird dies als <xref:System.Windows.WeakEventManager.ListenerList>implementiert, bei dem es sich um eine Liste schwacher Verweise auf Listener handelt. Sie müssen diesen Typ nur ändern, wenn der <xref:System.Windows.WeakEventManager.ListenerList> Typ nicht die erforderlichen Informationen enthalten kann. Wenn dies der Fall ist, müssen Sie die <xref:System.Windows.WeakEventManager.Purge%2A>-Methode überschreiben, damit alle Bereinigungs Vorgänge des zugrunde liegenden Typs ordnungsgemäß durchgeführt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein neues Objekt zurück, mit dem Listener zu einem Ereignis hinzugefügt werden.</summary>
        <returns>Ein neues Objekt, mit dem Listener zu einem Ereignis hinzugefügt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Das Quellobjekt, das der Handlerdelegat abonniert.</param>
        <param name="handler">Der Delegat, der das Ereignis behandelt, das von <paramref name="source" /> ausgelöst wird.</param>
        <summary>Fügt den angegebenen Delegaten als Ereignishandler der angegebenen Quelle hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, an die Listener angefügt werden.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Fügt den bereitgestellten Listener der bereitgestellten Quelle für das verwaltete Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nennen Sie diese Methode in der Manager-Klasse `AddListener` Methoden für <xref:System.Windows.WeakEventManager> Implementierungen. `AddListener` ist der vorgeschlagene Name für die statische Methode, die Sie in der Manager-Klasse definieren, damit andere Klassen einen Listener für das schwache Ereignis Muster hinzufügen können. `AddListener` sollten zwei Parameter annehmen: die `source`, an die der Listener angefügt ist, und die `listener` Instanz. Für Ihre `AddListener`-Implementierung wird die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>-Methode für den aktuellen Manager aufgerufen und die gleichen zwei Parameter übergeben.  
  
 Wenn die Liste der Listener zuvor leer war, ruft <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> intern die <xref:System.Windows.WeakEventManager.StartListening%2A>-Methode auf, die ihre spezifische <xref:System.Windows.WeakEventManager.StartListening%2A> Überschreibung über Polymorphie aufruft.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> fügt einem einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> Listener pro `source`hinzu. Wenn die Manager-Implementierung mehr als eine Liste von Listenern für jede Kombination aus Ereignis Quelle verwaltet, verwenden Sie <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>nicht. Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `AddListener` der entsprechenden Liste Listener hinzufügen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem das <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> Ereignis anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Der Handler, der aus der Quelle entfernt werden soll.</param>
        <param name="handler">Der zu vom <paramref name="source" />, zu entfernende Delegat.</param>
        <summary>Entfernt den zuvor hinzugefügten Handler aus der angegebenen Quelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, aus der Listener entfernt werden sollen.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Entfernt einen zuvor hinzugefügten Listener aus der bereitgestellten Quelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nennen Sie diese Methode in der Manager-Klasse `RemoveListener` Methoden für <xref:System.Windows.WeakEventManager> Implementierungen. `RemoveListener` ist der vorgeschlagene Name für die statische Methode, die Sie in der Manager-Klasse definieren, damit andere Klassen einen Listener für das schwache Ereignis Muster entfernen können. `RemoveListener` sollten zwei Parameter annehmen: die `source`, in der der Listener entfernt wird, und die `listener`-Klasse. Für Ihre `RemoveListener`-Implementierung wird die <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>-Methode für den aktuellen Manager aufgerufen und die gleichen zwei Parameter übergeben.  
  
 Wenn ein Aufruf von <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> den letzten Listener in der Liste entfernt, ruft <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> intern die <xref:System.Windows.WeakEventManager.StopListening%2A>-Methode auf, die eine bestimmte <xref:System.Windows.WeakEventManager.StopListening%2A> Überschreibung durch Polymorphie aufruft.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> entfernt Listener aus einer einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> pro `source`. Wenn die Manager-Implementierung mehr als eine Liste von Listenern für jede Kombination aus Ereignis Quelle verwaltet, verwenden Sie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>nicht. Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `RemoveListener` Listener aus der entsprechenden Liste entfernen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode die <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>-Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle für Ereignisse, auf die gelauscht wird.</param>
        <param name="data">Die zu prüfenden Daten. Bei diesem Objekt wird erwartet, dass es sich um eine <see cref="T:System.Windows.WeakEventManager.ListenerList" />-Implementierung handelt.</param>
        <param name="purgeAll"><see langword="true" />, um das Lauschen auf <paramref name="source" /> zu beenden und alle Einträge aus <paramref name="data" /> zu entfernen.</param>
        <summary>Entfernt inaktive Listenereinträge aus der Datenliste für die bereitgestellte Quelle. Gibt <see langword="true" /> zurück, wenn tatsächlich Einträge aus der Liste entfernt wurden.</summary>
        <returns><see langword="true" />, wenn tatsächlich Einträge entfernt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.WeakEventManager.Purge%2A>-Methode verfügt über eine Standard Implementierung, bei der alle Einträge entfernt werden, wenn es sich um Daten <xref:System.Windows.WeakEventManager.ListenerList>handelt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn der zugrunde liegende Typ für die <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> etwas anderes als <see cref="T:System.Windows.WeakEventManager.ListenerList" />ist oder Daten enthält, die über einen <see cref="T:System.Windows.WeakEventManager.ListenerList" />hinausgehen, müssen Sie die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />-Methode überschreiben. Die außer Kraft Setzung sollte das Lösch Verhalten für die Alternative typelementliste bereitstellen. Im Allgemeinen sollte die Überschreibung Verhalten bereitstellen, ohne die Basis Implementierung aufrufen zu müssen. Wenn eine bestimmte <see cref="T:System.Windows.WeakEventManager.ListenerList" /> weiterhin gelöscht werden muss, wenden Sie <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />an.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Lesesperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In abgeleiteten Klassen sollten Abfragen an die in <xref:System.Windows.WeakEventManager.Item%2A> enthaltene Tabelle immer innerhalb einer `using (ReadLock) { ... }`-Klausel erfolgen, mit Ausnahme von Abfragen, die sich bereits in einer Schreibsperre befinden. Diese Abfragen sind möglicherweise erforderlich, wenn Ihre Klasse eine ausgereiftere `AddListener` Implementierung unterstützt, die über die `source` und `listener`hinaus mehr Daten erfordert und die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung verwendet, um die zusätzlichen Informationen zu speichern.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, für die Listenerinformationen entfernt werden sollen.</param>
        <summary>Entfernt alle Listener für die angegebene Quelle.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert an, dass das Löschen nicht verwendeter Einträge aus der zugrunde liegenden Liste der Listener in einem Thread mit niedrigerer Priorität ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen der <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A>-Methode ähnelt dem Aufrufen der <xref:System.Windows.WeakEventManager.Purge%2A>-Methode in der Liste des aktuellen Managers mit niedrigerer Thread Priorität, wobei der `purgeAll`-Parameter auf `false`festgelegt ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, auf den der neue Ereignis-Manager festgelegt werden soll.</param>
        <param name="manager">Der neue Ereignis-Manager.</param>
        <summary>Legt den aktuellen Manager für den angegebenen Managertyp fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Windows.WeakEventManager.SetCurrentManager%2A>-Methode auf, um einen Vorgesetzten zu initialisieren, wenn dies für einen aufzurufenden `CurrentManager`-Eigenschaft in einer <xref:System.Windows.WeakEventManager>-Implementierung erforderlich ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, die überwacht werden soll.</param>
        <summary>Startet beim Überschreiben in einer abgeleiteten Klasse die Überwachung des verwalteten Ereignisses. Nach dem ersten Aufruf der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode muss der Manager bereit sein für einen Aufruf von <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> oder <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />, sobald das relevante Ereignis aus der bereitgestellten Quelle behandelt werden muss.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> über schreibungen sollten dem bereitgestellten <paramref name="source" />einen Handler hinzufügen. Der Handler wird vom Vorgesetzten selbst deklariert. Der Klassen Handler sollte nicht öffentlich sein und sollte nur als Reaktion auf das verwaltete Ereignis aufgerufen werden. Der Klassen Handler sollte die <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />-Methode oder die <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />-Methode entsprechend aufzurufen.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, deren Überwachung beendet werden soll.</param>
        <summary>Stoppt beim Überschreiben in einer abgeleiteten Klasse die Überwachung der bereitgestellten Quelle für das verwaltete Ereignis.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> Implementierungen sollten den Klassen Handler entfernen, wie er von der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode hinzugefügt wurde. Beim Entfernen eines Listener sollte die Listenerliste nicht gelöscht werden. Stattdessen sollte Sie nur den Klassen Handler trennen (möglicherweise vorübergehend). Zum Löschen der gesamten Liste stehen andere Methoden zur Verfügung, z. b. die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />-Methode, wobei der Parameter <paramref name="purgeAll" /> auf <see langword="true" />festgelegt ist.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Schreibsperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In abgeleiteten Klassen sollten alle Änderungen an der zugrunde liegenden Datentabelle innerhalb einer `using (WriteLock) { ... }`-Klausel erfolgen. Diese Änderungen sind möglicherweise erforderlich, wenn Ihre Klasse eine ausgereiftere `AddListener` Implementierung unterstützt, die über die `source` und `listener`hinaus mehr Daten erfordert und die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung verwendet, um die zusätzlichen Informationen zu speichern.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
