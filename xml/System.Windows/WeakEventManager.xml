<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7c50f8e21321e058314ffb0c59534252db4eb2aa" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52232395" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Basisklasse für den Ereignis-Manager bereit, der im *Muster für schwache Ereignisse* verwendet wird. Der Manager fügt Listener hinzu oder entfernt diese für Ereignisse (oder Rückrufe), die ebenfalls dieses Muster verwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise verwenden Sie das Muster für schwache Ereignisse, wenn die Ereignisquelle eine Objektlebensdauer enthält, die unabhängig von der Ereignislistener ist. Mit dem zentralen Ereignis verteilen die Möglichkeit, eine <xref:System.Windows.WeakEventManager> des Listeners Handler können Garbage Collection durchgeführt, selbst wenn das Quellobjekt weiterhin besteht. Im Gegensatz dazu ein reguläres ereigniseinbindung mithilfe der `+=` bewirkt, dass die potenziell nicht verbundene Quelle für einen Verweis an die Listener. Dadurch wird verhindert, dass den Empfänger der Garbage collection rechtzeitig.  
  
 Eine allgemeine Situation, in denen die Beziehungen der Objektlebensdauer zwischen Quellen und die Listener verwenden soll, das Muster für schwache Ereignisse ist die Behandlung der Update-Ereignisse, die von datenbindungen an.  
  
 Das Muster für schwache Ereignisse kann auch für Rückrufe und regelmäßigem Ereignis verwendet werden.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Ein Beispiel für eine benutzerdefinierte <see cref="T:System.Windows.WeakEventManager" />, finden Sie unter [schwache Ereignismuster](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert als Initialisierer innerhalb des Konstruktors einer abgeleiteten Klasse die Basisklassenwerte.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die vom Ereignis zu liefernden Ereignisdaten enthält.</param>
        <summary>Übermittelt das verwaltete Ereignis an alle Listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode innerhalb der Ereignishandler, die hinzugefügt oder entfernt werden, indem die <xref:System.Windows.WeakEventManager.StartListening%2A> und <xref:System.Windows.WeakEventManager.StopListening%2A> Implementierungen von Unterklassen.  
  
 Aufrufen der <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> -Methode in Ihrer `AddListener` Implementierung der Klasse, die Liste der Listener das Ereignis empfängt in einer zugrunde liegenden Auflistung beibehalten. (`AddListener` ist nicht Teil einer Schnittstelle oder Klasse. `AddListener` ist der vorgeschlagene Name für die Methode von der Managerklasse, die Aufrufe <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> und schwache Ereignismuster-Listener für das Ereignis hinzugefügt.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Fügt den Listener zu einer einzelnen Liste hinzu. Wenn die Manager-Implementierung mehr als eine Liste von Listenern pro Ereignis verwaltet, verwenden Sie keine <xref:System.Windows.WeakEventManager.DeliverEvent%2A> oder <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Ihre Implementierung sollten erstellen Sie stattdessen eine eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen `AddListener` sollten Listener die entsprechende Liste hinzufügen, und Ereignisse in die Liste der geeigneten Listener gesendet werden soll, durch den Aufruf <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <param name="list">Die bereitgestellte <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Übermittelt das verwaltete Ereignis an jeden Listener in der bereitgestellten Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist erforderlich, wenn die Manager-Implementierung verwaltet Listen von separaten Listener auf Basis der Informationen, die in den Ereignisdaten erfasst werden. Wenn Sie diesem fortschrittlichen Techniken verwenden, müssen Sie erstellen und verwalten Sie die separaten Listen als Teil der Manager-Implementierung, und Sie müssen eine Möglichkeit zum Hinzufügen von Listenern für eine bestimmte Liste angeben. Der Handlerimplementierung, die das rohdatenereignis überwacht, muss auf die Bedingung reagieren, die Sie verwenden, um die Listen zu unterscheiden, und das Ereignis nur für die entsprechende Liste oder Listen bereitstellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, für den der <see cref="T:System.Windows.WeakEventManager" /> abgerufen werden sollen.</param>
        <summary>Gibt die <see cref="T:System.Windows.WeakEventManager" />-Implementierung zurück, die für den bereitgestellten Typ verwendet wird.</summary>
        <returns>Die übereinstimmende <see cref="T:System.Windows.WeakEventManager" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> Implementierungen rufen Sie diese Methode, die mit ihrer übergebenen `managerType`. Das zurückgegebene <xref:System.Windows.WeakEventManager> dient dann als das Unterscheidungsmerkmal, der bestimmt, welches Ereignis empfangen wurde, und die private Klassenhandler aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Der nullbasierte Index der angeforderten Quelle.</param>
        <summary>Ruft die Daten ab, die für die angegebene Quelle gespeichert werden, oder legt diese fest.</summary>
        <value>Daten, die vom Manager für diese Quelle gespeichert werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können Daten- und Typ, in diesem Indexer zu speichern. Dies wird in der Regel implementiert, als eine <xref:System.Windows.WeakEventManager.ListenerList>, eine Liste der schwachen Verweise auf den Listener. Sie müssen nur zum Ändern dieses Typs, wenn die <xref:System.Windows.WeakEventManager.ListenerList> Typ kann nicht die erforderliche Informationen enthalten. Wenn also Sie außer Kraft setzen müssen der <xref:System.Windows.WeakEventManager.Purge%2A> Methode, damit alle Bereinigung des zugrunde liegenden Typs ordnungsgemäß ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein neues Objekt zurück, mit dem Listener zu einem Ereignis hinzugefügt werden.</summary>
        <returns>Ein neues Objekt, mit dem Listener zu einem Ereignis hinzugefügt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Das Quellobjekt, das der Handlerdelegat abonniert.</param>
        <param name="handler">Der Delegat, der das Ereignis behandelt, das von <paramref name="source" /> ausgelöst wird.</param>
        <summary>Fügt den angegebenen Delegaten als Ereignishandler der angegebenen Quelle hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, an die Listener angefügt werden.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Fügt den bereitgestellten Listener der bereitgestellten Quelle für das verwaltete Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode in Ihrer Managerklasse `AddListener` Methoden <xref:System.Windows.WeakEventManager> Implementierungen. `AddListener` ist der vorgeschlagene Name für die statische Methode, die Sie für die Managerklasse, um andere Klassen zum Hinzufügen eines Listeners für Ihre Muster für schwache Ereignisse ermöglichen definieren. `AddListener` dauert zwei Parameter: den `source` , der Listener angefügt ist, und die `listener` Instanz. Für Ihre `AddListener` -Implementierung, rufen die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Methode auf dem aktuellen-Manager und übergeben Sie dieselben beiden Parameter.  
  
 Wenn die Liste der Listener zuvor leer war, war <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Aufrufe der <xref:System.Windows.WeakEventManager.StartListening%2A> Methode intern, die Ihre spezifischen angerufen <xref:System.Windows.WeakEventManager.StartListening%2A> außer Kraft setzen, über die Polymorphie.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Fügt der Listener zu einer einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> pro `source`. Wenn die Manager-Implementierung mehr als eine Liste der Listener für jede Ereignisquelle Kombination aus verwaltet werden, verwenden Sie keine <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Ihre Implementierung sollten erstellen Sie stattdessen eine eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen `AddListener` sollten Listener die entsprechende Liste hinzufügen und durch Aufrufen von Ereignissen in die Liste der geeigneten Listener gesendet werden soll. die <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> Ereignisses statt auf die <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Handler, der aus der Quelle entfernt werden soll.</param>
        <param name="handler">Der zu vom <paramref name="source" />, zu entfernende Delegat.</param>
        <summary>Entfernt den zuvor hinzugefügten Handler aus der angegebenen Quelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, aus der Listener entfernt werden sollen.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Entfernt einen zuvor hinzugefügten Listener aus der bereitgestellten Quelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode in Ihrer Managerklasse `RemoveListener` Methoden <xref:System.Windows.WeakEventManager> Implementierungen. `RemoveListener` ist der vorgeschlagene Name für die statische Methode, die Sie für die Managerklasse, um andere Klassen Entfernen eines Listeners für das Muster für schwache Ereignisse ermöglichen definieren. `RemoveListener` dauert zwei Parameter: den `source` , der Listener entfernt wird, und die `listener` Klasse. Für Ihre `RemoveListener` -Implementierung, rufen die <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Methode auf dem aktuellen-Manager und übergeben Sie dieselben beiden Parameter.  
  
 Wenn ein Aufruf von <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> den letzten Listener in der Liste entfernt <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Aufrufe der <xref:System.Windows.WeakEventManager.StopListening%2A> Methode intern, die Ihre spezifischen angerufen <xref:System.Windows.WeakEventManager.StopListening%2A> außer Kraft setzen, über die Polymorphie.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> entfernt Sie aus einer einzelnen internen Listener <xref:System.Windows.WeakEventManager.ListenerList> pro `source`. Wenn die Manager-Implementierung mehr als eine Liste der Listener für jede Ereignisquelle Kombination aus verwaltet werden, verwenden Sie keine <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Stattdessen Ihre Implementierung Erstellen eigener <xref:System.Windows.WeakEventManager.ListenerList> Instanzen `RemoveListener` sollten Listener aus der entsprechenden Liste entfernen und durch Aufrufen von Ereignissen in die Liste der geeigneten Listener gesendet werden soll. die <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> -Methode anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle für Ereignisse, auf die gelauscht wird.</param>
        <param name="data">Die zu prüfenden Daten. Bei diesem Objekt wird erwartet, dass es sich um eine <see cref="T:System.Windows.WeakEventManager.ListenerList" />-Implementierung handelt.</param>
        <param name="purgeAll"><see langword="true" />, um das Lauschen auf <paramref name="source" /> zu beenden und alle Einträge aus <paramref name="data" /> zu entfernen.</param>
        <summary>Entfernt inaktive Listenereinträge aus der Datenliste für die bereitgestellte Quelle. Gibt <see langword="true" /> zurück, wenn tatsächlich Einträge aus der Liste entfernt wurden.</summary>
        <returns><see langword="true" />, wenn tatsächlich Einträge entfernt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.WeakEventManager.Purge%2A> Methode verfügt über eine Standardimplementierung, die alle Einträge entfernt werden, wenn Daten einem <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn die zugrunde liegende Typ der <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> ist etwas anders als <see cref="T:System.Windows.WeakEventManager.ListenerList" />, oder Daten über eine <see cref="T:System.Windows.WeakEventManager.ListenerList" />, müssen Sie überschreiben die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> Methode. Die Außerkraftsetzung sollten löschen Verhalten für die Liste der alternativen Typ Elemente angeben. Im Allgemeinen sollte die Außerkraftsetzung Verhalten bereitzustellen, ohne die basisimplementierung aufrufen. Wenn eine bestimmte <see cref="T:System.Windows.WeakEventManager.ListenerList" /> noch gelöscht werden soll, Aufruf <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Lesesperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In abgeleiteten Klassen, Abfragen, die in enthaltenen Tabelle <xref:System.Windows.WeakEventManager.Item%2A> müssen immer ausgeführt, in einem `using (ReadLock) { ... }` -Klausel, mit Ausnahme von Abfragen, die bereits in eine Schreibsperre sind. Diese Abfragen möglicherweise erforderlich, wenn Ihre Klasse eine komplexere unterstützt `AddListener` -Implementierung, die mehr Daten über benötigt die `source` und `listener`, und verwendet die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung zum Speichern der zusätzlichen Informationen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, für die Listenerinformationen entfernt werden sollen.</param>
        <summary>Entfernt alle Listener für die angegebene Quelle.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert an, dass das Löschen nicht verwendeter Einträge aus der zugrunde liegenden Liste der Listener in einem Thread mit niedrigerer Priorität ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> Methode ist vergleichbar mit einem Aufruf der <xref:System.Windows.WeakEventManager.Purge%2A> Methode für die aktuelle Liste des Managers, niedrigeren Threadpriorität, mit der `purgeAll` Parametersatz zu `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, auf den der neue Ereignis-Manager festgelegt werden soll.</param>
        <param name="manager">Der neue Ereignis-Manager.</param>
        <summary>Legt den aktuellen Manager für den angegebenen Managertyp fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> Methode, um einen Manager zu initialisieren, wenn das ist erforderlich, durch einen Aufruf Ihrer `CurrentManager` Eigenschaft auf eine <xref:System.Windows.WeakEventManager> Implementierung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, die überwacht werden soll.</param>
        <summary>Startet beim Überschreiben in einer abgeleiteten Klasse die Überwachung des verwalteten Ereignisses. Nach dem ersten Aufruf der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode muss der Manager bereit sein für einen Aufruf von <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> oder <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />, sobald das relevante Ereignis aus der bereitgestellten Quelle behandelt werden muss.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> überschreibungen sollten einen Ereignishandler hinzufügen, auf die bereitgestellte <paramref name="source" />. Der Handler wird durch den Manager selbst deklariert. Der Klassenhandler für die nicht öffentlich sein muss, und es sollte nur als Reaktion auf das verwaltete Ereignis aufgerufen werden. Der Klassenhandler aufrufen sollten die <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> Methode oder der <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> Methode entsprechend.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, deren Überwachung beendet werden soll.</param>
        <summary>Stoppt beim Überschreiben in einer abgeleiteten Klasse die Überwachung der bereitgestellten Quelle für das verwaltete Ereignis.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> Implementierungen sollten die Klassenhandler entfernen, indem hinzugefügt der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> Methode. Entfernen einen Listener sollten die Liste der Listener nicht gelöscht werden. Stattdessen sollten sie nur die Klassenhandler (z. B. vorübergehend) trennen. Andere Methoden zur Verfügung, für das Löschen der gesamten Liste, z. B. die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> -Methode mit dem <paramref name="purgeAll" /> Parametersatz zu <see langword="true" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Schreibsperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Änderungen an der zugrunde liegenden Datentabelle sollten treten in abgeleiteten Klassen innerhalb einer `using (WriteLock) { ... }` Klausel. Diese Änderungen möglicherweise erforderlich, wenn Ihre Klasse eine komplexere unterstützt `AddListener` -Implementierung, die mehr Daten über benötigt die `source` und `listener`, und verwendet die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung zum Speichern der zusätzlichen Informationen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>