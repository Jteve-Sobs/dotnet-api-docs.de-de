<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a1fbc670a1b9aa9ee4ad658c1bc1ecbd1fdfa279" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75051084" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ec59d-101">Stellt eine Basisklasse für den Ereignis-Manager bereit, der im *Muster für schwache Ereignisse* verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-101">Provides a base class for the event manager that is used in the *weak event pattern*.</span></span> <span data-ttu-id="ec59d-102">Der Manager fügt Listener hinzu oder entfernt diese für Ereignisse (oder Rückrufe), die ebenfalls dieses Muster verwenden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-102">The manager adds and removes listeners for events (or callbacks) that also use the pattern.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-103">Normalerweise verwenden Sie das schwache Ereignis Muster, wenn die Ereignis Quelle eine Objekt Lebensdauer hat, die unabhängig von den Ereignislistenern ist.</span><span class="sxs-lookup"><span data-stu-id="ec59d-103">You typically use the weak event pattern when the event source has an object lifetime that is independent of the event listeners.</span></span> <span data-ttu-id="ec59d-104">Durch die Verwendung der Funktion für die zentrale Ereignis Verteilung einer <xref:System.Windows.WeakEventManager> können die Handler des Listener auch dann in die Garbage Collection aufgenommen werden, wenn das Quell Objekt weiterhin besteht.</span><span class="sxs-lookup"><span data-stu-id="ec59d-104">Using the central event dispatching capability of a <xref:System.Windows.WeakEventManager> allows the listener's handlers to be garbage collected even if the source object persists.</span></span> <span data-ttu-id="ec59d-105">Im Gegensatz dazu bewirkt ein reguläres Ereignis mit dem `+=`-Operator, dass die möglicherweise getrennte Quelle einen Verweis auf die Listener enthält.</span><span class="sxs-lookup"><span data-stu-id="ec59d-105">By contrast, a regular event hookup using the `+=` operator causes the potentially disconnected source to hold a reference to the listeners.</span></span> <span data-ttu-id="ec59d-106">Dadurch wird verhindert, dass der Empfänger rechtzeitig eine Garbage Collection durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-106">This prevents the receiver from being garbage collected in a timely fashion.</span></span>  
  
 <span data-ttu-id="ec59d-107">Eine häufige Situation, in der die Lebensdauer Beziehungen zwischen Quellen und Listenern das schwache Ereignis Muster verwenden sollten, ist die Behandlung von Update Ereignissen aus Daten Bindungen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-107">One common situation where the lifetime relationships between sources and listeners should use of the weak event pattern is the handling of update events coming from data bindings.</span></span>  
  
 <span data-ttu-id="ec59d-108">Das schwache Ereignis Muster kann auch für Rückrufe und reguläre Ereignisse verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-108">The weak event pattern can also be used for callbacks and regular events.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="ec59d-109">Ein Beispiel für eine benutzerdefinierte <see cref="T:System.Windows.WeakEventManager" />finden Sie unter [schwache Ereignis Muster](~/docs/framework/wpf/advanced/weak-event-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="ec59d-109">For an example of a custom <see cref="T:System.Windows.WeakEventManager" />, see [Weak Event Patterns](~/docs/framework/wpf/advanced/weak-event-patterns.md).</span></span></para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ec59d-110">Initialisiert als Initialisierer innerhalb des Konstruktors einer abgeleiteten Klasse die Basisklassenwerte.</span><span class="sxs-lookup"><span data-stu-id="ec59d-110">Initializes base class values when it is used as the initializer by the constructor of a derived class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="ec59d-111">Das Objekt, für das das Ereignis behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-111">The object on which the event is being handled.</span></span></param>
        <param name="args"><span data-ttu-id="ec59d-112">Ein <see cref="T:System.EventArgs" />, das die vom Ereignis zu liefernden Ereignisdaten enthält.</span><span class="sxs-lookup"><span data-stu-id="ec59d-112">An <see cref="T:System.EventArgs" /> that contains the event data for the event to deliver.</span></span></param>
        <summary><span data-ttu-id="ec59d-113">Übermittelt das verwaltete Ereignis an alle Listener.</span><span class="sxs-lookup"><span data-stu-id="ec59d-113">Delivers the event being managed to each listener.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-114">Ruft die <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode aus den Ereignis Handlern auf, die durch die <xref:System.Windows.WeakEventManager.StartListening%2A>-und <xref:System.Windows.WeakEventManager.StopListening%2A>-Implementierungen von Unterklassen hinzugefügt oder daraus entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-114">Call the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method from within the event handlers that are added or removed by the <xref:System.Windows.WeakEventManager.StartListening%2A> and <xref:System.Windows.WeakEventManager.StopListening%2A> implementations of subclasses.</span></span>  
  
 <span data-ttu-id="ec59d-115">Wenn Sie die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>-Methode in ihrer `AddListener`-Implementierung der Klasse aufzurufen, wird die Liste der Listener, die das Ereignis empfangen, in einer zugrunde liegenden Auflistung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="ec59d-115">If you call the <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> method in your `AddListener` implementation of your class, the list of listeners receiving the event is kept in an underlying collection.</span></span> <span data-ttu-id="ec59d-116">(`AddListener` ist nicht Teil einer Schnittstelle oder eines Klassen Vertrags.</span><span class="sxs-lookup"><span data-stu-id="ec59d-116">(`AddListener` is not part of an interface or class contract.</span></span> <span data-ttu-id="ec59d-117">`AddListener` ist der vorgeschlagene Name für die-Methode Ihrer Manager-Klasse, die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> aufruft und schwache ereignismusterlistener für das-Ereignis hinzufügt.)</span><span class="sxs-lookup"><span data-stu-id="ec59d-117">`AddListener` is the suggested name for the method of your manager class that calls <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> and adds weak event pattern listeners for the event.)</span></span>  
  
 <span data-ttu-id="ec59d-118"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> fügt einer einzelnen Liste Listener hinzu.</span><span class="sxs-lookup"><span data-stu-id="ec59d-118"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> adds listeners to a single list.</span></span> <span data-ttu-id="ec59d-119">Wenn die Manager-Implementierung mehr als eine Liste von Listenern pro Ereignis beibehält, verwenden Sie nicht <xref:System.Windows.WeakEventManager.DeliverEvent%2A> oder <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span><span class="sxs-lookup"><span data-stu-id="ec59d-119">If your manager implementation maintains more than one list of listeners per event, do not use <xref:System.Windows.WeakEventManager.DeliverEvent%2A> or <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span></span> <span data-ttu-id="ec59d-120">Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `AddListener` der entsprechenden Liste Listener hinzufügen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-120">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` should add listeners to the appropriate list, and events should be delivered to the appropriate listener list by calling <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="ec59d-121">Das Objekt, für das das Ereignis behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-121">The object on which the event is being handled.</span></span></param>
        <param name="args"><span data-ttu-id="ec59d-122">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</span><span class="sxs-lookup"><span data-stu-id="ec59d-122">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <param name="list"><span data-ttu-id="ec59d-123">Die bereitgestellte <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</span><span class="sxs-lookup"><span data-stu-id="ec59d-123">The provided <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</span></span></param>
        <summary><span data-ttu-id="ec59d-124">Übermittelt das verwaltete Ereignis an jeden Listener in der bereitgestellten Liste.</span><span class="sxs-lookup"><span data-stu-id="ec59d-124">Delivers the event being managed to each listener in the provided list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-125">Diese Methode ist erforderlich, wenn die Manager-Implementierung separate Listener-Listen auf der Grundlage von Informationen verwaltet, die in den Ereignisdaten aufgezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-125">This method is necessary if your manager implementation maintains separate listeners lists based on information that is captured in the event data.</span></span> <span data-ttu-id="ec59d-126">Wenn Sie diese erweiterte Technik verwenden, müssen Sie die separaten Listen als Teil ihrer Manager-Implementierung erstellen und verwalten, und Sie müssen eine Möglichkeit zum Hinzufügen von Listenern zu einer bestimmten Liste bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-126">If you use this advanced technique, you must create and maintain the separate lists as part of your manager implementation, and you must provide a way to add listeners to a specific list.</span></span> <span data-ttu-id="ec59d-127">Die Handlerimplementierung, die auf das unformatierte Ereignis lauscht, muss auf die Bedingung reagieren, die Sie verwenden, um die Listen zu unterscheiden, und das Ereignis nur an die entsprechende Liste oder Listen übermitteln.</span><span class="sxs-lookup"><span data-stu-id="ec59d-127">Your handler implementation that listens to the raw event must act upon the condition that you use to differentiate the lists, and deliver the event only to the appropriate list or lists.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType"><span data-ttu-id="ec59d-128">Der Typ, für den der <see cref="T:System.Windows.WeakEventManager" /> abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-128">The type to obtain the <see cref="T:System.Windows.WeakEventManager" /> for.</span></span></param>
        <summary><span data-ttu-id="ec59d-129">Gibt die <see cref="T:System.Windows.WeakEventManager" />-Implementierung zurück, die für den bereitgestellten Typ verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-129">Returns the <see cref="T:System.Windows.WeakEventManager" /> implementation that is used for the provided type.</span></span></summary>
        <returns><span data-ttu-id="ec59d-130">Die übereinstimmende <see cref="T:System.Windows.WeakEventManager" />-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="ec59d-130">The matching <see cref="T:System.Windows.WeakEventManager" /> implementation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-131"><xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> Implementierungen verwenden diese Methode mithilfe Ihres bestandenen `managerType`.</span><span class="sxs-lookup"><span data-stu-id="ec59d-131"><xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementations call this method using their passed `managerType`.</span></span> <span data-ttu-id="ec59d-132">Der zurückgegebene <xref:System.Windows.WeakEventManager> wird dann als Differenzierer verwendet, der bestimmt, welches Ereignis empfangen wurde und welcher private Klassen Handler aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="ec59d-132">The returned <xref:System.Windows.WeakEventManager> is then used as the differentiator that determines which event was received, and which private class handler to invoke.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-133">Der nullbasierte Index der angeforderten Quelle.</span><span class="sxs-lookup"><span data-stu-id="ec59d-133">The zero-based index of the requested source.</span></span></param>
        <summary><span data-ttu-id="ec59d-134">Ruft die Daten ab, die für die angegebene Quelle gespeichert werden, oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="ec59d-134">Gets or sets the data being stored for the specified source.</span></span></summary>
        <value><span data-ttu-id="ec59d-135">Daten, die vom Manager für diese Quelle gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-135">Data being stored by the manager for this source.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-136">Abgeleitete Klassen können auswählen, welche Daten und Typen in diesem Indexer gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-136">Derived classes can choose what data and type to store in this indexer.</span></span> <span data-ttu-id="ec59d-137">In der Regel wird dies als <xref:System.Windows.WeakEventManager.ListenerList>implementiert, bei dem es sich um eine Liste schwacher Verweise auf Listener handelt.</span><span class="sxs-lookup"><span data-stu-id="ec59d-137">Typically this is implemented as a <xref:System.Windows.WeakEventManager.ListenerList>, which is a list of weak references to listeners.</span></span> <span data-ttu-id="ec59d-138">Sie müssen diesen Typ nur ändern, wenn der <xref:System.Windows.WeakEventManager.ListenerList> Typ nicht die erforderlichen Informationen enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="ec59d-138">You would only have to change this type if the <xref:System.Windows.WeakEventManager.ListenerList> type cannot contain your required information.</span></span> <span data-ttu-id="ec59d-139">Wenn dies der Fall ist, müssen Sie die <xref:System.Windows.WeakEventManager.Purge%2A>-Methode überschreiben, damit alle Bereinigungs Vorgänge des zugrunde liegenden Typs ordnungsgemäß durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-139">If so, you will have to override the <xref:System.Windows.WeakEventManager.Purge%2A> method so that all cleanup of the underlying type is performed correctly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ec59d-140">Gibt ein neues Objekt zurück, mit dem Listener zu einem Ereignis hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-140">Returns a new object to contain listeners to an event.</span></span></summary>
        <returns><span data-ttu-id="ec59d-141">Ein neues Objekt, mit dem Listener zu einem Ereignis hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-141">A new object to contain listeners to an event.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-142">Das Quellobjekt, das der Handlerdelegat abonniert.</span><span class="sxs-lookup"><span data-stu-id="ec59d-142">The source object that the handler delegate subscribes to.</span></span></param>
        <param name="handler"><span data-ttu-id="ec59d-143">Der Delegat, der das Ereignis behandelt, das von <paramref name="source" /> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-143">The delegate that handles the event that is raised by <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="ec59d-144">Fügt den angegebenen Delegaten als Ereignishandler der angegebenen Quelle hinzu.</span><span class="sxs-lookup"><span data-stu-id="ec59d-144">Adds the specified delegate as an event handler of the specified source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-145">Die Quelle, an die Listener angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-145">The source to attach listeners to.</span></span></param>
        <param name="listener"><span data-ttu-id="ec59d-146">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</span><span class="sxs-lookup"><span data-stu-id="ec59d-146">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</span></span></param>
        <summary><span data-ttu-id="ec59d-147">Fügt den bereitgestellten Listener der bereitgestellten Quelle für das verwaltete Ereignis hinzu.</span><span class="sxs-lookup"><span data-stu-id="ec59d-147">Adds the provided listener to the provided source for the event being managed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-148">Nennen Sie diese Methode in der Manager-Klasse `AddListener` Methoden für <xref:System.Windows.WeakEventManager> Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-148">Call this method within your manager class `AddListener` methods on <xref:System.Windows.WeakEventManager> implementations.</span></span> <span data-ttu-id="ec59d-149">`AddListener` ist der vorgeschlagene Name für die statische Methode, die Sie in der Manager-Klasse definieren, damit andere Klassen einen Listener für das schwache Ereignis Muster hinzufügen können.</span><span class="sxs-lookup"><span data-stu-id="ec59d-149">`AddListener` is the suggested name for the static method you define on your manager class to enable other classes to add a listener for your weak event pattern.</span></span> <span data-ttu-id="ec59d-150">`AddListener` sollten zwei Parameter annehmen: die `source`, an die der Listener angefügt ist, und die `listener` Instanz.</span><span class="sxs-lookup"><span data-stu-id="ec59d-150">`AddListener` should take two parameters: the `source` where the listener is attached, and the `listener` instance.</span></span> <span data-ttu-id="ec59d-151">Für Ihre `AddListener`-Implementierung wird die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>-Methode für den aktuellen Manager aufgerufen und die gleichen zwei Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="ec59d-151">For your `AddListener` implementation, call the <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> method on the current manager and pass the same two parameters.</span></span>  
  
 <span data-ttu-id="ec59d-152">Wenn die Liste der Listener zuvor leer war, ruft <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> intern die <xref:System.Windows.WeakEventManager.StartListening%2A>-Methode auf, die ihre spezifische <xref:System.Windows.WeakEventManager.StartListening%2A> Überschreibung über Polymorphie aufruft.</span><span class="sxs-lookup"><span data-stu-id="ec59d-152">If the list of listeners was previously empty, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> calls the <xref:System.Windows.WeakEventManager.StartListening%2A> method internally, which will call your specific <xref:System.Windows.WeakEventManager.StartListening%2A> override through polymorphism.</span></span>  
  
 <span data-ttu-id="ec59d-153"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> fügt einem einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> Listener pro `source`hinzu.</span><span class="sxs-lookup"><span data-stu-id="ec59d-153"><xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> adds listeners to a single internal <xref:System.Windows.WeakEventManager.ListenerList> per `source`.</span></span> <span data-ttu-id="ec59d-154">Wenn die Manager-Implementierung mehr als eine Liste von Listenern für jede Kombination aus Ereignis Quelle verwaltet, verwenden Sie <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>nicht.</span><span class="sxs-lookup"><span data-stu-id="ec59d-154">If your manager implementation maintains more than one list of listeners for each event-source combination, do not use <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>.</span></span> <span data-ttu-id="ec59d-155">Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `AddListener` der entsprechenden Liste Listener hinzufügen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem das <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> Ereignis anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-155">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` should add listeners to the appropriate list, and events should be delivered to the appropriate listener list by calling the <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> event instead of the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-156">Der Handler, der aus der Quelle entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ec59d-156">The source to remove the handler from.</span></span></param>
        <param name="handler"><span data-ttu-id="ec59d-157">Der zu vom <paramref name="source" />, zu entfernende Delegat.</span><span class="sxs-lookup"><span data-stu-id="ec59d-157">The delegate to remove from <paramref name="source" />.</span></span></param>
        <summary><span data-ttu-id="ec59d-158">Entfernt den zuvor hinzugefügten Handler aus der angegebenen Quelle.</span><span class="sxs-lookup"><span data-stu-id="ec59d-158">Removes the previously added handler from the specified source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-159">Die Quelle, aus der Listener entfernt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-159">The source to remove listeners from.</span></span></param>
        <param name="listener"><span data-ttu-id="ec59d-160">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</span><span class="sxs-lookup"><span data-stu-id="ec59d-160">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</span></span></param>
        <summary><span data-ttu-id="ec59d-161">Entfernt einen zuvor hinzugefügten Listener aus der bereitgestellten Quelle.</span><span class="sxs-lookup"><span data-stu-id="ec59d-161">Removes a previously added listener from the provided source.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-162">Nennen Sie diese Methode in der Manager-Klasse `RemoveListener` Methoden für <xref:System.Windows.WeakEventManager> Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-162">Call this method within your manager class `RemoveListener` methods on <xref:System.Windows.WeakEventManager> implementations.</span></span> <span data-ttu-id="ec59d-163">`RemoveListener` ist der vorgeschlagene Name für die statische Methode, die Sie in der Manager-Klasse definieren, damit andere Klassen einen Listener für das schwache Ereignis Muster entfernen können.</span><span class="sxs-lookup"><span data-stu-id="ec59d-163">`RemoveListener` is the suggested name for the static method you define on your manager class to enable other classes to remove a listener for your weak event pattern.</span></span> <span data-ttu-id="ec59d-164">`RemoveListener` sollten zwei Parameter annehmen: die `source`, in der der Listener entfernt wird, und die `listener`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ec59d-164">`RemoveListener` should take two parameters: the `source` where the listener is removed, and the `listener` class.</span></span> <span data-ttu-id="ec59d-165">Für Ihre `RemoveListener`-Implementierung wird die <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>-Methode für den aktuellen Manager aufgerufen und die gleichen zwei Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="ec59d-165">For your `RemoveListener` implementation, call the <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> method on the current manager and pass the same two parameters.</span></span>  
  
 <span data-ttu-id="ec59d-166">Wenn ein Aufruf von <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> den letzten Listener in der Liste entfernt, ruft <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> intern die <xref:System.Windows.WeakEventManager.StopListening%2A>-Methode auf, die eine bestimmte <xref:System.Windows.WeakEventManager.StopListening%2A> Überschreibung durch Polymorphie aufruft.</span><span class="sxs-lookup"><span data-stu-id="ec59d-166">If a call to <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> removes the last listener in the list, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> calls the <xref:System.Windows.WeakEventManager.StopListening%2A> method internally, which will call your specific <xref:System.Windows.WeakEventManager.StopListening%2A> override through polymorphism.</span></span>  
  
 <span data-ttu-id="ec59d-167"><xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> entfernt Listener aus einer einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> pro `source`.</span><span class="sxs-lookup"><span data-stu-id="ec59d-167"><xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> removes listeners from a single internal <xref:System.Windows.WeakEventManager.ListenerList> per `source`.</span></span> <span data-ttu-id="ec59d-168">Wenn die Manager-Implementierung mehr als eine Liste von Listenern für jede Kombination aus Ereignis Quelle verwaltet, verwenden Sie <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>nicht.</span><span class="sxs-lookup"><span data-stu-id="ec59d-168">If your manager implementation maintains more than one list of listeners for each event-source combination, do not use <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>.</span></span> <span data-ttu-id="ec59d-169">Stattdessen sollte Ihre Implementierung eigene <xref:System.Windows.WeakEventManager.ListenerList> Instanzen erstellen, `RemoveListener` Listener aus der entsprechenden Liste entfernen und Ereignisse an die entsprechende Listenerliste übermittelt werden, indem anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A>-Methode die <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-169">Instead, your implementation should create its own <xref:System.Windows.WeakEventManager.ListenerList> instances, `RemoveListener` should remove listeners from the appropriate list, and events should be delivered to the appropriate listener list by calling the <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> method instead of the <xref:System.Windows.WeakEventManager.DeliverEvent%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-170">Die Quelle für Ereignisse, auf die gelauscht wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-170">The source for events being listened to.</span></span></param>
        <param name="data"><span data-ttu-id="ec59d-171">Die zu prüfenden Daten.</span><span class="sxs-lookup"><span data-stu-id="ec59d-171">The data to check.</span></span> <span data-ttu-id="ec59d-172">Bei diesem Objekt wird erwartet, dass es sich um eine <see cref="T:System.Windows.WeakEventManager.ListenerList" />-Implementierung handelt.</span><span class="sxs-lookup"><span data-stu-id="ec59d-172">This object is expected to be a <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementation.</span></span></param>
        <param name="purgeAll"><span data-ttu-id="ec59d-173"><see langword="true" />, um das Lauschen auf <paramref name="source" /> zu beenden und alle Einträge aus <paramref name="data" /> zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-173"><see langword="true" /> to stop listening to <paramref name="source" />, and completely remove all entries from <paramref name="data" />.</span></span></param>
        <summary><span data-ttu-id="ec59d-174">Entfernt inaktive Listenereinträge aus der Datenliste für die bereitgestellte Quelle.</span><span class="sxs-lookup"><span data-stu-id="ec59d-174">Removes inactive listener entries from the data list for the provided source.</span></span> <span data-ttu-id="ec59d-175">Gibt <see langword="true" /> zurück, wenn tatsächlich Einträge aus der Liste entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-175">Returns <see langword="true" /> if some entries were actually removed from the list.</span></span></summary>
        <returns><span data-ttu-id="ec59d-176"><see langword="true" />, wenn tatsächlich Einträge entfernt wurden, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ec59d-176"><see langword="true" /> if some entries were actually removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-177">Die <xref:System.Windows.WeakEventManager.Purge%2A>-Methode verfügt über eine Standard Implementierung, bei der alle Einträge entfernt werden, wenn es sich um Daten <xref:System.Windows.WeakEventManager.ListenerList>handelt.</span><span class="sxs-lookup"><span data-stu-id="ec59d-177">The <xref:System.Windows.WeakEventManager.Purge%2A> method has a default implementation that will remove all entries when data is a <xref:System.Windows.WeakEventManager.ListenerList>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ec59d-178">Wenn der zugrunde liegende Typ für die <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> etwas anderes als <see cref="T:System.Windows.WeakEventManager.ListenerList" />ist oder Daten enthält, die über einen <see cref="T:System.Windows.WeakEventManager.ListenerList" />hinausgehen, müssen Sie die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />-Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="ec59d-178">If the underlying type for the <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> is something other than <see cref="T:System.Windows.WeakEventManager.ListenerList" />, or contains data beyond a <see cref="T:System.Windows.WeakEventManager.ListenerList" />, you must override the <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> method.</span></span> <span data-ttu-id="ec59d-179">Die außer Kraft Setzung sollte das Lösch Verhalten für die Alternative typelementliste bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-179">The override should provide purge behavior for the alternate type items list.</span></span> <span data-ttu-id="ec59d-180">Im Allgemeinen sollte die Überschreibung Verhalten bereitstellen, ohne die Basis Implementierung aufrufen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-180">Generally, the override should provide behavior without calling the base implementation.</span></span> <span data-ttu-id="ec59d-181">Wenn eine bestimmte <see cref="T:System.Windows.WeakEventManager.ListenerList" /> weiterhin gelöscht werden muss, wenden Sie <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />an.</span><span class="sxs-lookup"><span data-stu-id="ec59d-181">If a specific <see cref="T:System.Windows.WeakEventManager.ListenerList" /> still needs clearing, call <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</span></span></para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ec59d-182">Richtet auf der zugrunde liegenden Datentabelle eine Lesesperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ec59d-182">Establishes a read-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</span></span></summary>
        <value><span data-ttu-id="ec59d-183">Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-183">An object that can be used to establish a lock on the data table members and then be appropriately disposed with a <see langword="using" /> construct.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-184">In abgeleiteten Klassen sollten Abfragen an die in <xref:System.Windows.WeakEventManager.Item%2A> enthaltene Tabelle immer innerhalb einer `using (ReadLock) { ... }`-Klausel erfolgen, mit Ausnahme von Abfragen, die sich bereits in einer Schreibsperre befinden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-184">In derived classes, queries to the table contained in <xref:System.Windows.WeakEventManager.Item%2A> should always occur within a `using (ReadLock) { ... }` clause, except for queries that are already within a write lock.</span></span> <span data-ttu-id="ec59d-185">Diese Abfragen sind möglicherweise erforderlich, wenn Ihre Klasse eine ausgereiftere `AddListener` Implementierung unterstützt, die über die `source` und `listener`hinaus mehr Daten erfordert und die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung verwendet, um die zusätzlichen Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ec59d-185">These queries may be necessary if your class supports a more sophisticated `AddListener` implementation that requires more data beyond the `source` and the `listener`, and uses the <xref:System.Windows.WeakEventManager.Item%2A> collection to store the extra information.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-186">Die Quelle, für die Listenerinformationen entfernt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-186">The source to remove listener information for.</span></span></param>
        <summary><span data-ttu-id="ec59d-187">Entfernt alle Listener für die angegebene Quelle.</span><span class="sxs-lookup"><span data-stu-id="ec59d-187">Removes all listeners for the specified source.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ec59d-188">Fordert an, dass das Löschen nicht verwendeter Einträge aus der zugrunde liegenden Liste der Listener in einem Thread mit niedrigerer Priorität ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-188">Requests that a purge of unused entries in the underlying listener list be performed on a lower priority thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-189">Das Aufrufen der <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A>-Methode ähnelt dem Aufrufen der <xref:System.Windows.WeakEventManager.Purge%2A>-Methode in der Liste des aktuellen Managers mit niedrigerer Thread Priorität, wobei der `purgeAll`-Parameter auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ec59d-189">Calling the <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> method is similar to calling the <xref:System.Windows.WeakEventManager.Purge%2A> method on the current manager's list, at lower thread priority, with the `purgeAll` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType"><span data-ttu-id="ec59d-190">Der Typ, auf den der neue Ereignis-Manager festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ec59d-190">The type to set the new event manager.</span></span></param>
        <param name="manager"><span data-ttu-id="ec59d-191">Der neue Ereignis-Manager.</span><span class="sxs-lookup"><span data-stu-id="ec59d-191">The new event manager.</span></span></param>
        <summary><span data-ttu-id="ec59d-192">Legt den aktuellen Manager für den angegebenen Managertyp fest.</span><span class="sxs-lookup"><span data-stu-id="ec59d-192">Sets the current manager for the specified manager type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-193">Ruft die <xref:System.Windows.WeakEventManager.SetCurrentManager%2A>-Methode auf, um einen Vorgesetzten zu initialisieren, wenn dies für einen aufzurufenden `CurrentManager`-Eigenschaft in einer <xref:System.Windows.WeakEventManager>-Implementierung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="ec59d-193">Call the <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> method to initialize a manager, if that is required by a call to your `CurrentManager` property on a <xref:System.Windows.WeakEventManager> implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-194">Die Quelle, die überwacht werden soll.</span><span class="sxs-lookup"><span data-stu-id="ec59d-194">The source to begin listening on.</span></span></param>
        <summary><span data-ttu-id="ec59d-195">Startet beim Überschreiben in einer abgeleiteten Klasse die Überwachung des verwalteten Ereignisses.</span><span class="sxs-lookup"><span data-stu-id="ec59d-195">When overridden in a derived class, starts listening for the event being managed.</span></span> <span data-ttu-id="ec59d-196">Nach dem ersten Aufruf der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode muss der Manager bereit sein für einen Aufruf von <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> oder <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />, sobald das relevante Ereignis aus der bereitgestellten Quelle behandelt werden muss.</span><span class="sxs-lookup"><span data-stu-id="ec59d-196">After the <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> method is first called, the manager should be in the state of calling <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> or <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> whenever the relevant event from the provided source is handled.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ec59d-197">
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> über schreibungen sollten dem bereitgestellten <paramref name="source" />einen Handler hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-197">
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> overrides should add a handler to the provided <paramref name="source" />.</span></span> <span data-ttu-id="ec59d-198">Der Handler wird vom Vorgesetzten selbst deklariert.</span><span class="sxs-lookup"><span data-stu-id="ec59d-198">The handler is declared by the manager itself.</span></span> <span data-ttu-id="ec59d-199">Der Klassen Handler sollte nicht öffentlich sein und sollte nur als Reaktion auf das verwaltete Ereignis aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-199">The class handler should not be public, and it should only be called in response to the event being managed.</span></span> <span data-ttu-id="ec59d-200">Der Klassen Handler sollte die <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />-Methode oder die <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />-Methode entsprechend aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-200">The class handler should call the <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> method or the <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> method appropriately.</span></span></para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ec59d-201">Die Quelle, deren Überwachung beendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="ec59d-201">The source to stop listening on.</span></span></param>
        <summary><span data-ttu-id="ec59d-202">Stoppt beim Überschreiben in einer abgeleiteten Klasse die Überwachung der bereitgestellten Quelle für das verwaltete Ereignis.</span><span class="sxs-lookup"><span data-stu-id="ec59d-202">When overridden in a derived class, stops listening on the provided source for the event being managed.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ec59d-203">
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> Implementierungen sollten den Klassen Handler entfernen, wie er von der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="ec59d-203">
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementations should remove the class handler as added by the <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> method.</span></span> <span data-ttu-id="ec59d-204">Beim Entfernen eines Listener sollte die Listenerliste nicht gelöscht werden.</span><span class="sxs-lookup"><span data-stu-id="ec59d-204">Removing a listener should not clear the listener list.</span></span> <span data-ttu-id="ec59d-205">Stattdessen sollte Sie nur den Klassen Handler trennen (möglicherweise vorübergehend).</span><span class="sxs-lookup"><span data-stu-id="ec59d-205">Instead, it should only disconnect the class handler (perhaps temporarily).</span></span> <span data-ttu-id="ec59d-206">Zum Löschen der gesamten Liste stehen andere Methoden zur Verfügung, z. b. die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />-Methode, wobei der Parameter <paramref name="purgeAll" /> auf <see langword="true" />festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ec59d-206">Other methods are available for clearing the entire list, such as the <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> method with the <paramref name="purgeAll" /> parameter set to <see langword="true" />.</span></span></para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ec59d-207">Richtet auf der zugrunde liegenden Datentabelle eine Schreibsperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="ec59d-207">Establishes a write-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</span></span></summary>
        <value><span data-ttu-id="ec59d-208">Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ec59d-208">An object that can be used to establish a lock on the data table members and then be appropriately disposed with a <see langword="using" /> construct.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ec59d-209">In abgeleiteten Klassen sollten alle Änderungen an der zugrunde liegenden Datentabelle innerhalb einer `using (WriteLock) { ... }`-Klausel erfolgen.</span><span class="sxs-lookup"><span data-stu-id="ec59d-209">In derived classes, all modifications to the underlying data table should occur within a `using (WriteLock) { ... }` clause.</span></span> <span data-ttu-id="ec59d-210">Diese Änderungen sind möglicherweise erforderlich, wenn Ihre Klasse eine ausgereiftere `AddListener` Implementierung unterstützt, die über die `source` und `listener`hinaus mehr Daten erfordert und die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung verwendet, um die zusätzlichen Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ec59d-210">These modifications may be necessary if your class supports a more sophisticated `AddListener` implementation that requires more data beyond the `source` and the `listener`, and uses the <xref:System.Windows.WeakEventManager.Item%2A> collection to store the extra information.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
