<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac94cdae430bda3a59a21292d13f613f0012919d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680104" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Basisklasse für den Ereignis-Manager bereit, der im *Muster für schwache Ereignisse* verwendet wird. Der Manager fügt Listener hinzu oder entfernt diese für Ereignisse (oder Rückrufe), die ebenfalls dieses Muster verwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden das schwacher Ereignismuster in der Regel auf, wenn die Ereignisquelle eine Objektlebensdauer besitzt, die unabhängig von der Ereignislistener ist. Mit dem zentralen Ereignis verteilen die Möglichkeit, eine <xref:System.Windows.WeakEventManager> können Sie den Listener-Handler werden vom Garbage Collector gesammelt, selbst wenn das Quellobjekt weiterhin besteht. Im Gegensatz dazu, eine reguläre Ereignis ereigniseinbindung mithilfe der `+=` Operator bewirkt, dass die Quelle des potenziell nicht verbundene einen Verweis auf die Listener enthalten. Dadurch wird verhindert, dass den Empfänger Garbage collection rechtzeitig verarbeitet werden.  
  
 Eine allgemeine Situation, in denen die Lebensdauer Beziehungen zwischen Datenquellen und die Listener verwenden soll, das schwacher Ereignismuster ist die Behandlung von Update-Ereignisse, die aus datenbindungen stammen.  
  
 Das schwacher Ereignismuster kann auch für Rückrufe und regelmäßigem Ereignis verwendet werden.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Ein Beispiel eines benutzerdefinierten <see cref="T:System.Windows.WeakEventManager" />, finden Sie unter [schwacher Ereignismuster](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert als Initialisierer innerhalb des Konstruktors einer abgeleiteten Klasse die Basisklassenwerte.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die vom Ereignis zu liefernden Ereignisdaten enthält.</param>
        <summary>Übermittelt das verwaltete Ereignis an alle Listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode innerhalb der Ereignishandler, die hinzugefügt oder entfernt werden, indem Sie die <xref:System.Windows.WeakEventManager.StartListening%2A> und <xref:System.Windows.WeakEventManager.StopListening%2A> Implementierungen von Unterklassen.  
  
 Beim Aufrufen der <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Methode in Ihrer `AddListener` Implementierung einer Klasse, die Liste der Listener, die das Ereignis empfangen wird in einer zugrunde liegenden Auflistung beibehalten. (`AddListener` ist nicht Teil einer Schnittstelle oder Klasse Vertrag. `AddListener` vorgeschlagene Name für die Methode von der Managerklasse, die aufgerufen wird <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> und schwacher Ereignismuster-Listener für das Ereignis hinzugefügt.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> eine einzelne Liste hinzugefügt Listener. Wenn die Manager-Implementierung mehr als eine Liste von Listenern pro Ereignis verwaltet, verwenden Sie nicht <xref:System.Windows.WeakEventManager.DeliverEvent%2A> oder <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Ihre Implementierung sollte erstellen Sie stattdessen einen eigenen <xref:System.Windows.WeakEventManager.ListenerList> Instanzen `AddListener` sollte die entsprechende Liste Listener hinzu, und Ereignisse sollten durch Aufrufen der entsprechenden Listener Liste übermittelt werden <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, für das das Ereignis behandelt wird.</param>
        <param name="args">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <param name="list">Die bereitgestellte <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Übermittelt das verwaltete Ereignis an jeden Listener in der bereitgestellten Liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist erforderlich, wenn die Manager-Implementierung verwaltet separate Listener Listen auf Grundlage der Informationen, die Daten für das Ereignis aufgezeichnet wird. Wenn Sie dieses erweiterte Verfahren verwenden, müssen Sie erstellen und verwalten Sie separaten Listen als Teil der Manager-Implementierung, und müssen Sie eine Möglichkeit zum Hinzufügen von Listenern an eine bestimmte Liste angeben. Ihre Handlerimplementierung, das den raw-Ereignis überwacht, muss die Bedingung reagieren, die Sie verwenden, um die Listen zu unterscheiden, und übermitteln das Ereignis nur für die entsprechende Liste oder Listen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, für den der <see cref="T:System.Windows.WeakEventManager" /> abgerufen werden sollen.</param>
        <summary>Gibt die <see cref="T:System.Windows.WeakEventManager" />-Implementierung zurück, die für den bereitgestellten Typ verwendet wird.</summary>
        <returns>Die übereinstimmende <see cref="T:System.Windows.WeakEventManager" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> Implementierungen rufen Sie diese Methode, die mit ihren übergebene `managerType`. Das zurückgegebene <xref:System.Windows.WeakEventManager> wird dann als das Unterscheidungsmerkmal, der bestimmt, welches Ereignis empfangen wurde, und welche privaten Klassenhandler aufzurufenden verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Der nullbasierte Index der angeforderten Quelle.</param>
        <summary>Ruft die Daten ab, die für die angegebene Quelle gespeichert werden, oder legt diese fest.</summary>
        <value>Daten, die vom Manager für diese Quelle gespeichert werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können Daten- und zum Speichern in dieser Indexer auswählen. Dies ist in der Regel implementiert, als ein <xref:System.Windows.WeakEventManager.ListenerList>, dies ist eine Liste der schwachen Verweise auf den Listener. Sie müssen nur zum Ändern dieses Typs, wenn die <xref:System.Windows.WeakEventManager.ListenerList> darf nicht die erforderliche Informationen enthalten. Wenn also Sie überschreiben müssen die <xref:System.Windows.WeakEventManager.Purge%2A> Methode, damit alle Cleanup des zugrunde liegenden Typs ordnungsgemäß ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein neues Objekt zurück, mit dem Listener zu einem Ereignis hinzugefügt werden.</summary>
        <returns>Ein neues Objekt, mit dem Listener zu einem Ereignis hinzugefügt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Das Quellobjekt, das der Handlerdelegat abonniert.</param>
        <param name="handler">Der Delegat, der das Ereignis behandelt, das von <c>source</c> ausgelöst wird.</param>
        <summary>Fügt den angegebenen Delegaten als Ereignishandler der angegebenen Quelle hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, an die Listener angefügt werden.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Fügt den bereitgestellten Listener der bereitgestellten Quelle für das verwaltete Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode in dieser Managerklasse `AddListener` Methoden auf <xref:System.Windows.WeakEventManager> Implementierungen. `AddListener` der empfohlene Name ist für die statische Methode, die Sie für die Managerklasse, um andere Klassen zum Hinzufügen eines Listeners für das schwacher Ereignismuster ermöglichen definieren. `AddListener` sollten zwei Parameter annehmen: die `source` , der Listener angefügt wird, und die `listener` Instanz. Für Ihre `AddListener` -Implementierung, rufen die <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> -Methode für den aktuellen-Manager und übergeben Sie dieselben beiden Parameter.  
  
 Wenn die Liste der Listener zuvor leer war, wurde <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Aufrufe der <xref:System.Windows.WeakEventManager.StartListening%2A> Methode intern, die Ihre spezifischen angerufen <xref:System.Windows.WeakEventManager.StartListening%2A> über Polymorphismus überschreiben.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> fügt Listener zu einer einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> pro `source`. Wenn die Manager-Implementierung mehr als eine Liste der Listener für jede Kombination der Ereignisquelle beibehält, verwenden Sie nicht <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Ihre Implementierung sollte erstellen Sie stattdessen einen eigenen <xref:System.Windows.WeakEventManager.ListenerList> Instanzen, `AddListener` sollte die entsprechende Liste Listener hinzu, und Ereignisse sollten die Liste der entsprechenden Listener übermittelt werden, durch den Aufruf der <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> Ereignisses statt auf die <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Handler, der aus der Quelle entfernt werden soll.</param>
        <param name="handler">Der vo <c>source</c> zu entfernende Delegat.</param>
        <summary>Entfernt den zuvor hinzugefügten Handler aus der angegebenen Quelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, aus der Listener entfernt werden sollen.</param>
        <param name="listener">Die Überwachungsklasse (diese muss <see cref="T:System.Windows.IWeakEventListener" /> implementieren).</param>
        <summary>Entfernt einen zuvor hinzugefügten Listener aus der bereitgestellten Quelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode in dieser Managerklasse `RemoveListener` Methoden auf <xref:System.Windows.WeakEventManager> Implementierungen. `RemoveListener` der empfohlene Name ist für die statische Methode, die Sie für die Managerklasse, um andere Klassen Entfernen eines Listeners für das schwacher Ereignismuster ermöglichen definieren. `RemoveListener` sollten zwei Parameter annehmen: die `source` , der Listener entfernt wird, und die `listener` Klasse. Für Ihre `RemoveListener` -Implementierung, rufen die <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> -Methode für den aktuellen-Manager und übergeben Sie dieselben beiden Parameter.  
  
 Wenn ein Aufruf von <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> den letzten Listener in der Liste entfernt <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Aufrufe der <xref:System.Windows.WeakEventManager.StopListening%2A> Methode intern, die Ihre spezifischen angerufen <xref:System.Windows.WeakEventManager.StopListening%2A> über Polymorphismus überschreiben.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> entfernt Listener aus einer einzelnen internen <xref:System.Windows.WeakEventManager.ListenerList> pro `source`. Wenn die Manager-Implementierung mehr als eine Liste der Listener für jede Kombination der Ereignisquelle beibehält, verwenden Sie nicht <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Die Implementierung sollten erstellen Sie stattdessen einen eigenen <xref:System.Windows.WeakEventManager.ListenerList> Instanzen, `RemoveListener` sollten Listener aus der entsprechenden Liste entfernen, und Ereignisse sollten die Liste der entsprechenden Listener übermittelt werden, durch den Aufruf der <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> -Methode anstelle der <xref:System.Windows.WeakEventManager.DeliverEvent%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle für Ereignisse, auf die gelauscht wird.</param>
        <param name="data">Die zu prüfenden Daten. Bei diesem Objekt wird erwartet, dass es sich um eine <see cref="T:System.Windows.WeakEventManager.ListenerList" />-Implementierung handelt.</param>
        <param name="purgeAll">
          <see langword="true" />, um das Lauschen auf <c>source</c> zu beenden und alle Einträge aus <c>data</c> zu entfernen.</param>
        <summary>Entfernt inaktive Listenereinträge aus der Datenliste für die bereitgestellte Quelle. Gibt <see langword="true" /> zurück, wenn tatsächlich Einträge aus der Liste entfernt wurden.</summary>
        <returns>
          <see langword="true" />, wenn tatsächlich Einträge entfernt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.WeakEventManager.Purge%2A> Methode verfügt über eine Standardimplementierung, die alle Einträge entfernt werden, wenn Daten einer <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn die zugrunde liegende Typ der <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> ist etwas anders als <see cref="T:System.Windows.WeakEventManager.ListenerList" />, oder enthält Daten, die außerhalb einer <see cref="T:System.Windows.WeakEventManager.ListenerList" />, müssen Sie überschreiben die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> Methode. Die Außerkraftsetzung sollten Aufräum-Verhalten für die Liste der alternativen Elemente angeben. Im Allgemeinen sollte die Außerkraftsetzung Verhalten bereitzustellen, ohne die basisimplementierung aufrufen. Wenn eine bestimmte <see cref="T:System.Windows.WeakEventManager.ListenerList" /> weiterhin benötigt Clearing Aufruf <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Lesesperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In abgeleiteten Klassen Abfragen, die in enthaltenen Tabelle <xref:System.Windows.WeakEventManager.Item%2A> sollten treten immer innerhalb einer `using (ReadLock) { ... }` -Klausel, mit Ausnahme von Abfragen, die bereits in eine Schreibsperre sind. Diese Abfragen möglicherweise erforderlich, wenn Ihre Klasse eine komplexere unterstützt `AddListener` Implementierung, die weitere Daten über hinaus erfordert die `source` und die `listener`, und verwendet die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung zum Speichern der zusätzlichen Informationen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, für die Listenerinformationen entfernt werden sollen.</param>
        <summary>Entfernt alle Listener für die angegebene Quelle.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert an, dass das Löschen nicht verwendeter Einträge aus der zugrunde liegenden Liste der Listener in einem Thread mit niedrigerer Priorität ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> Methode ist vergleichbar mit einem Aufruf der <xref:System.Windows.WeakEventManager.Purge%2A> -Methode für den aktuellen-Manager-Liste niedrigeren Threadpriorität mit der `purgeAll` Parametersatz auf `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Der Typ, auf den der neue Ereignis-Manager festgelegt werden soll.</param>
        <param name="manager">Der neue Ereignis-Manager.</param>
        <summary>Legt den aktuellen Manager für den angegebenen Managertyp fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> einen Manager initialisiert werden, wenn diese Methode ist erforderlich, durch den Aufruf von Ihrer `CurrentManager` Eigenschaft auf einen <xref:System.Windows.WeakEventManager> Implementierung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, die überwacht werden soll.</param>
        <summary>Startet beim Überschreiben in einer abgeleiteten Klasse die Überwachung des verwalteten Ereignisses. Nach dem ersten Aufruf der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />-Methode muss der Manager bereit sein für einen Aufruf von <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> oder <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />, sobald das relevante Ereignis aus der bereitgestellten Quelle behandelt werden muss.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> Außerkraftsetzungen sollte einen Handler hinzuzufügen, auf das bereitgestellte <paramref name="source" />. Der Handler wird vom Manager selbst deklariert. Der Klassenhandler nicht öffentlich sein muss, und sollte nur als Reaktion auf das verwaltete Ereignis aufgerufen werden. Der Klassenhandler aufrufen sollten die <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> Methode oder die <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> Methode entsprechend.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Die Quelle, deren Überwachung beendet werden soll.</param>
        <summary>Stoppt beim Überschreiben in einer abgeleiteten Klasse die Überwachung der bereitgestellten Quelle für das verwaltete Ereignis.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> Implementierungen sollten den Klassenhandler entfernen, durch Hinzufügen der <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> Methode. Entfernen einen Listener sollten die Liste der Listener nicht deaktivieren. Stattdessen sollten sie nur die Klassenhandler (vielleicht vorübergehend) trennen. Andere Methoden zur Verfügung, für das Löschen der gesamten Liste, z. B. die <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> Methode mit der <paramref name="purgeAll" /> Parametersatz auf <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Richtet auf der zugrunde liegenden Datentabelle eine Schreibsperre ein und gibt ein <see cref="T:System.IDisposable" /> zurück.</summary>
        <value>Ein Objekt, das zum Einrichten einer Sperre für die Datentabellenmember verwendet werden kann und anschließend ordnungsgemäß mit einem <see langword="using" />-Konstrukt freigegeben wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In abgeleiteten Klassen sollten alle Änderungen an der zugrunde liegenden Datentabelle treten innerhalb einer `using (WriteLock) { ... }` Klausel. Diese Änderungen ist möglicherweise erforderlich, wenn Ihre Klasse eine komplexere unterstützt `AddListener` Implementierung, die über mehr Daten benötigt die `source` und `listener`, und verwendet die <xref:System.Windows.WeakEventManager.Item%2A> Auflistung zum Speichern der zusätzlichen Informationen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>