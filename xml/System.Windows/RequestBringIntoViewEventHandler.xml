<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RequestBringIntoViewEventHandler.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cda95cbf8cf82761ed796773cf82db1b1779f599.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cda95cbf8cf82761ed796773cf82db1b1779f599</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The object where the event handler is attached.</source>
          <target state="translated">Das Objekt, an das der Ereignishandler angefügt ist.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The event data.</source>
          <target state="translated">Die Ereignisdaten.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Represents the method that will handle the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> routed event.</source>
          <target state="translated">Stellt die Methode für die Behandlung des <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph>-Routingereignisses dar.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">Behandlung dieses Ereignisses ist in der Regel nur in den Elementen, die einen bildlauffähigen Bereich unterstützen, oder andernfalls legen ihre Renderinggröße kleiner als die kombinierten gewünschte Größe des ihre untergeordneten Elementinhalts und erfolgt nur durch die absichtlich Behandlung der das Ereignis, sobald es in der Elementstruktur nach oben weitergeleitet wurde und die erste übergeordneten Element, das Durchführen eines Bildlaufs Region-Unterstützung bietet erreicht hat.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</source>
          <target state="translated">Wird eine vorhandene Implementierung, die bildlauffähige Bereiche in einer Weise behandelt, die in der Regel für Benutzersteuerelemente wünschenswert ist <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>If you derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can register a class handler for <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> and supplement the base class handling of the event.</source>
          <target state="translated">Ableiten von <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, Sie können einen Klassenhandler für registrieren <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> und die Basisklasse Behandlung des Ereignisses ergänzen.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>You should also consider using or class-handling the class-defined <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> event instead of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie sollten auch berücksichtigen, verwenden oder die klassenbasierte Klassenbehandlung <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> Ereignis anstelle von <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Alternatively, if you create an entirely custom class that does not derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can still add class handling by calling <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> in your class instantiation.</source>
          <target state="translated">Auch wenn eine vollständig benutzerdefinierte Klasse zu erstellen, die nicht von abgeleitet ist <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, können Sie immer noch eine Klassenbehandlung durch Aufrufen von hinzufügen <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> in Ihrer Klasseninstanziierung.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zu Klassenbehandlung, finden Sie unter <bpt id="p1">[</bpt>Routingereignisse als bearbeitete sowie die Behandlung von Klasse markieren<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Content elements can cause the event to be raised by their content hosts (through calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> and raising <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> from the content host).</source>
          <target state="translated">Inhaltselemente können dazu führen, dass das Ereignis von deren Inhalt Hosts ausgelöst wird (durch Aufrufen von <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> und Auslösen von <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> vom Inhaltshost).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Auf ähnliche Weise können Sie anfordern, Elemente der logischen Struktur in die Ansicht mit der Hilfsmethode eingebunden werden <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implements a related but different method <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implementiert eine ähnliche, aber andere Methode <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>