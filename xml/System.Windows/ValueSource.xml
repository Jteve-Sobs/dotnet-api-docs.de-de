<Type Name="ValueSource" FullName="System.Windows.ValueSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e23b9ba27eef0ccdb922c9eddd868091fc8b0409" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83952517" /></Metadata><TypeSignature Language="C#" Value="public struct ValueSource" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueSource extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ValueSource" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueSource" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueSource" />
  <TypeSignature Language="F#" Value="type ValueSource = struct" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Meldet die Informationen, die von <see cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" /> zurückgegeben werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten Informationen, die <xref:System.Windows.ValueSource> überträgt, sind in der <xref:System.Windows.ValueSource.BaseValueSource%2A>-Eigenschaft enthalten. Diese Eigenschaft enthält einen Enumerationswert, der genau einen Aspekt des Gesamt [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften Systems angibt, das für den effektiven Wert einer Abhängigkeits Eigenschaft verantwortlich ist.  
  
 Neben dem Basiswert sind die anderen Informationen, die für den Wert einer Abhängigkeits Eigenschaft interessant sein können, ob der Wert animiert wird und ob der Wert einen Ausdruck (z. b. eine Bindung oder einen dynamischen Ressourcen Verweis) einschließt. Diese Informationen wird von gemeldet <xref:System.Windows.ValueSource.IsAnimated%2A> und <xref:System.Windows.ValueSource.IsExpression%2A> bzw. Wenn die Umwandlung für einen Eigenschafts Wert agiert, behält die Eigenschaft einen gewünschten Wert bei, und der Eigenschafts Wert versucht, den gewünschten Wert zu erreichen, wenn die Einschränkungen der spezifischen Umwandlung geändert oder aufgehoben werden. Eine erzwungene Eigenschaft, die nicht den gewünschten Wert hat, meldet, dass <xref:System.Windows.ValueSource.IsCoerced%2A> `true`ist.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
    <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
  </Docs>
  <Members>
    <Member MemberName="BaseValueSource">
      <MemberSignature Language="C#" Value="public System.Windows.BaseValueSource BaseValueSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.BaseValueSource BaseValueSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.BaseValueSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseValueSource As BaseValueSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::BaseValueSource BaseValueSource { System::Windows::BaseValueSource get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseValueSource : System.Windows.BaseValueSource" Usage="System.Windows.ValueSource.BaseValueSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.BaseValueSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert der <see cref="T:System.Windows.BaseValueSource" />-Enumeration ab, die die Quelle meldet, die einen Wert für das Abhängigkeitseigenschaftensystem bereitgestellt hat.</summary>
        <value>Ein Wert aus der Enumeration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basiswert ist nicht der effektive Wert, wenn für die Eigenschaft eine Umwandlung oder Animation fungiert. Überprüfen Sie <xref:System.Windows.ValueSource.IsAnimated%2A> und <xref:System.Windows.ValueSource.IsCoerced%2A>, wenn Sie bestimmen möchten, ob der Basiswert der effektive Wert ist.  
  
 Möglicherweise möchten Sie auch <xref:System.Windows.ValueSource.IsExpression%2A> überprüfen, um festzustellen, ob der Basiswert aus einem Ausdruck ausgewertet wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueSource.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit diesem <see cref="T:System.Windows.ValueSource" /> verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese <see cref="T:System.Windows.ValueSource" /> gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Objekt gleich der aktuellen <see cref="T:System.Windows.ValueSource" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung unterstützt Werte Gleichheit basierend auf den einzelnen Eigenschafts Werten der einzelnen <xref:System.Windows.ValueSource> Struktur.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueSource.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diesen <see cref="T:System.Windows.ValueSource" /> zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Hashcode basiert auf dem <xref:System.Windows.ValueSource.BaseValueSource%2A> Wert.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="IsAnimated">
      <MemberSignature Language="C#" Value="public bool IsAnimated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnimated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsAnimated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnimated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnimated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnimated : bool" Usage="System.Windows.ValueSource.IsAnimated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der deklariert, ob die Eigenschaft animiert wird.</summary>
        <value><see langword="true" />, wenn die Eigenschaft animiert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für alle Eigenschaften, die derzeit animiert werden, ist die von <xref:System.Windows.ValueSource.BaseValueSource%2A> gemeldete Quelle nicht sofort relevant, da die Animation eine höhere Rangfolge der Abhängigkeits Eigenschaften als der Basiswert hat. Weitere Informationen zur Rangfolge und zu Animationen finden Sie unter [Rangfolge von Abhängigkeits Eigenschafts Werten](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCoerced">
      <MemberSignature Language="C#" Value="public bool IsCoerced { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoerced" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCoerced" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoerced As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoerced { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoerced : bool" Usage="System.Windows.ValueSource.IsCoerced" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser Wert aus einer <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung resultiert, die auf eine Abhängigkeitseigenschaft angewendet wurde.</summary>
        <value><see langword="true" />, wenn der Wert aus einer <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung resultiert, die auf eine Abhängigkeitseigenschaft angewendet wurde andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Umwandlung für einen Eigenschafts Wert agiert, behält die Eigenschaft einen gewünschten Wert bei, und der Eigenschafts Wert versucht, den gewünschten Wert zu erreichen, wenn die Einschränkungen der spezifischen Umwandlung geändert oder aufgehoben werden. Eine erzwungene Eigenschaft, die nicht den gewünschten Wert hat, meldet, dass <xref:System.Windows.ValueSource.IsCoerced%2A> `true`ist.  
  
 Die Koersion verhält sich mit höherer Rangfolge als der Basiswert, und es wird nicht streng gesagt, wie der Basiswert festgelegt wird. Daher wird der Zustand der Umwandlung von dieser Eigenschaft gemeldet, nicht durch einen Wert der <xref:System.Windows.BaseValueSource> Enumeration. Weitere Informationen zu Umwandlung, Basiswerten und Rangfolge finden Sie unter [Rangfolge von Abhängigkeits Eigenschafts Werten](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrent">
      <MemberSignature Language="C#" Value="public bool IsCurrent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCurrent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCurrent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCurrent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrent : bool" Usage="System.Windows.ValueSource.IsCurrent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der Wert von der <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />-Methode festgelegt wurde.</summary>
        <value><see langword="true" />, wenn der Wert von der <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />-Methode festgelegt wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExpression">
      <MemberSignature Language="C#" Value="public bool IsExpression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExpression" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsExpression" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExpression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExpression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExpression : bool" Usage="System.Windows.ValueSource.IsExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der deklariert, ob dieser Wert das Ergebnis eines ausgewerteten Ausdrucks ist. Dabei kann es sich um einen <see cref="T:System.Windows.Data.BindingExpression" />, der eine Bindung unterstützt, oder um einen internen Ausdruck handeln, beispielsweise einen Ausdruck, der die Markuperweiterung [DynamicResource](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) unterstützt.</summary>
        <value><see langword="true" />, wenn der Wert aus einem ausgewerteten Ausdruck stammt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein ausgewerteter Ausdruck meldet auch die spezifische Bedingung für den Basiswert der Einstellung, bei der der Ausdruck angewendet wurde, als Wert in <xref:System.Windows.ValueSource.BaseValueSource%2A>. Der <xref:System.Windows.ValueSource.BaseValueSource%2A> ist für alle Eigenschaften, bei denen <xref:System.Windows.ValueSource.IsExpression%2A> `true`ist, immer noch sehr relevant. Das wissen, ob ein Wert durch einen Ausdruck kam, kann besonders nützlich sein, wenn der Wert indirekt festgelegt wurde, z. b. durch eine Vorlage oder einen geerbten Eigenschafts Wert.  
  
 Wenn ein Ausdruck nicht ausgewertet werden kann (bei der Bindung ist ein Fehler aufgetreten, es wurde keine Ressource mit diesem Namen gefunden), wird der Wert von einem anderen Teilnehmer im Eigenschaften System, höchstwahrscheinlich dem Standardwert, stammen. Diese Quelle wird dann in <xref:System.Windows.ValueSource.BaseValueSource%2A>gemeldet. Bei der Auswertung von Ausdrucks Fehlern werden `false` für <xref:System.Windows.ValueSource.IsExpression%2A>zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Equality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="vs1 = vs2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Der erste zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <param name="vs2">Der zweite zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Windows.ValueSource" />-Instanzen denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn die beiden <see cref="T:System.Windows.ValueSource" />-Instanzen äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ruft <xref:System.Windows.ValueSource.Equals%2A>auf und unterstützt auf der Grundlage aller Eigenschaften von <xref:System.Windows.ValueSource>Wert Gleichheit.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Inequality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="System.Windows.ValueSource.op_Inequality (vs1, vs2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Der erste zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <param name="vs2">Der zweite zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Windows.ValueSource" />-Instanzen verschiedene Werte haben.</summary>
        <returns><see langword="true" />, wenn die beiden <see cref="T:System.Windows.ValueSource" />-Instanzen nicht äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ruft <xref:System.Windows.ValueSource.Equals%2A>auf, gibt die Negation zurück und unterstützt die Wert Gleichheit basierend auf allen Eigenschaften <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
  </Members>
</Type>
