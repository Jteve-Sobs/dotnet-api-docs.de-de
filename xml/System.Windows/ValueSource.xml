<Type Name="ValueSource" FullName="System.Windows.ValueSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5805f4ddbc46f2fe95a7cd95d5adac5ac93260ed" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39968541" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct ValueSource" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueSource extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ValueSource" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueSource" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueSource" />
  <TypeSignature Language="F#" Value="type ValueSource = struct" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Meldet die von <see cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" /> zurückgegebenen Informationen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten Informationen, die <xref:System.Windows.ValueSource> überträgt ist Bestandteil der <xref:System.Windows.ValueSource.BaseValueSource%2A> Eigenschaft. Diese Eigenschaft enthält einen Enumerationswert, der angibt, genau einen Aspekt des gesamten [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem, das für den effektiven Wert einer Abhängigkeitseigenschaft zuständig ist.  
  
 Neben dem Basiswert ist die weiteren Informationen, die relevanten Informationen über den Wert einer Abhängigkeitseigenschaft möglicherweise an, ob der Wert animiert wird, und gibt an, ob der Wert für einen Ausdruck (z. B. eine Bindung, oder einen dynamischen Ressourcenverweis) beinhaltet. Diese Informationen wird von gemeldet <xref:System.Windows.ValueSource.IsAnimated%2A> und <xref:System.Windows.ValueSource.IsExpression%2A> bzw. Auch wenn Koersion auf einem Eigenschaftswert fungiert, die Eigenschaft behält einen gewünschten Wert und den Wert der Eigenschaft versucht, den gewünschten Wert zu erreichen, wenn die Einschränkungen für die spezifische Konvertierung geändert oder aufgehoben werden. Eine umgewandelte-Eigenschaft, die nicht den gewünschten Wert ist, meldet, dass <xref:System.Windows.ValueSource.IsCoerced%2A> ist `true`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
    <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
  </Docs>
  <Members>
    <Member MemberName="BaseValueSource">
      <MemberSignature Language="C#" Value="public System.Windows.BaseValueSource BaseValueSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.BaseValueSource BaseValueSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.BaseValueSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseValueSource As BaseValueSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::BaseValueSource BaseValueSource { System::Windows::BaseValueSource get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseValueSource : System.Windows.BaseValueSource" Usage="System.Windows.ValueSource.BaseValueSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.BaseValueSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert der <see cref="T:System.Windows.BaseValueSource" />-Enumeration ab, die die Quelle meldet, die einen Wert für das Abhängigkeitseigenschaftensystem bereitgestellt hat.</summary>
        <value>Ein Wert aus der Enumeration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basiswert ist nicht der tatsächliche Wert, wenn es sich bei entweder eine Umwandlung oder Animationen für die Eigenschaft fungiert. Überprüfen Sie <xref:System.Windows.ValueSource.IsAnimated%2A> und <xref:System.Windows.ValueSource.IsCoerced%2A> sollten Sie bestimmen, ob der Basiswert der effektive Wert ist.  
  
 Sie sollten auch überprüfen <xref:System.Windows.ValueSource.IsExpression%2A> um festzustellen, ob der Basiswert aus einem Ausdruck ausgewertet wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueSource.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit diesem <see cref="T:System.Windows.ValueSource" /> verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese <see cref="T:System.Windows.ValueSource" /> gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn das angegebene Objekt gleich der aktuellen <see cref="T:System.Windows.ValueSource" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung unterstützt Wertgleichheit, die auf Basis der einzelnen Eigenschaftswerte der einzelnen <xref:System.Windows.ValueSource> Struktur.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueSource.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diesen <see cref="T:System.Windows.ValueSource" /> zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Hash wird basierend auf den <xref:System.Windows.ValueSource.BaseValueSource%2A> Wert.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="IsAnimated">
      <MemberSignature Language="C#" Value="public bool IsAnimated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnimated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsAnimated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnimated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnimated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnimated : bool" Usage="System.Windows.ValueSource.IsAnimated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der deklariert, ob die Eigenschaft animiert wird.</summary>
        <value>
          <see langword="true" />, wenn die Eigenschaft animiert wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei jeder Eigenschaft, die derzeit animiert wird, wird die Quelle von gemeldeten <xref:System.Windows.ValueSource.BaseValueSource%2A> ist nicht direkt relevant, da die Animation auf Abhängigkeit-Eigenschaft Vorrang vor der Basiswert. Weitere Informationen über Rangfolge und Animationen finden Sie unter [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCoerced">
      <MemberSignature Language="C#" Value="public bool IsCoerced { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoerced" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCoerced" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoerced As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoerced { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoerced : bool" Usage="System.Windows.ValueSource.IsCoerced" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser Wert aus einer <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung resultiert, die auf eine Abhängigkeitseigenschaft angewendet wurde.</summary>
        <value>
          <see langword="true" />, wenn der Wert das Ergebnis einer <see cref="T:System.Windows.CoerceValueCallback" />-Implementierung ist, die auf eine Abhängigkeitseigenschaft angewendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Koersion auf einem Eigenschaftswert fungiert, die Eigenschaft behält einen gewünschten Wert aus, und den Wert der Eigenschaft versucht, den gewünschten Wert zu erreichen, wenn die Einschränkungen für die spezifische Konvertierung geändert oder aufgehoben werden. Eine umgewandelte-Eigenschaft, die nicht den gewünschten Wert ist, meldet, dass <xref:System.Windows.ValueSource.IsCoerced%2A> ist `true`.  
  
 Umwandlung auf höhere Priorität als Basiswert dient, und ist streng genommen keine Teilnehmer wie der Basiswert festgelegt wird. Daher wird der Zustand der Umwandlung gemeldet, von dieser Eigenschaft und nicht durch den Wert der <xref:System.Windows.BaseValueSource> Enumeration. Weitere Informationen zur Koersion, Basiswerte und Rangfolge finden Sie unter [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrent">
      <MemberSignature Language="C#" Value="public bool IsCurrent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCurrent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCurrent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCurrent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrent : bool" Usage="System.Windows.ValueSource.IsCurrent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der Wert von der <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />-Methode festgelegt wurde.</summary>
        <value>
          <see langword="true" />, wenn der Wert von der <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />-Methode festgelegt wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExpression">
      <MemberSignature Language="C#" Value="public bool IsExpression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExpression" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsExpression" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExpression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExpression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExpression : bool" Usage="System.Windows.ValueSource.IsExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der deklariert, ob dieser Wert das Ergebnis eines ausgewerteten Ausdrucks ist. Dabei kann es sich um einen <see cref="T:System.Windows.Data.BindingExpression" />, der eine Bindung unterstützt, oder um einen internen Ausdruck handeln, beispielsweise einen Ausdruck, der die Markuperweiterung [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) unterstützt.</summary>
        <value>
          <see langword="true" />, wenn der Wert aus einem ausgewerteten Ausdruck stammt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein ausgewerteter Ausdruck meldet sich auch auf die Bedingung zum Festlegen, in dem der Ausdruck angewendet wurde, als Wert in bestimmten Basiswert <xref:System.Windows.ValueSource.BaseValueSource%2A>. Die <xref:System.Windows.ValueSource.BaseValueSource%2A> ist immer noch relevant für jede Eigenschaft, in denen <xref:System.Windows.ValueSource.IsExpression%2A> ist `true`. Zu wissen, ob ein Wert durch einen Ausdruck stammt werden besonders nützlich, wenn der Wert z. B. indirekt, wie Sie sich über eine Vorlage oder eine geerbte Eigenschaft-Wert festgelegt wurde.  
  
 Wenn ein Ausdruck kann nicht ausgewertet (Fehler bei der Bindung, es wurde keine Ressource mit diesem Namen gefunden), und klicken Sie dann der Wert aus einem anderen Teilnehmer im Eigenschaftensystem, wahrscheinlich den Standardwert stammen. Diese Quelle wird dann gemeldet, <xref:System.Windows.ValueSource.BaseValueSource%2A>. Fehlerhaften auswertungen zurück `false` für <xref:System.Windows.ValueSource.IsExpression%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Equality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="vs1 = vs2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Der erste zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <param name="vs2">Der zweite zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Windows.ValueSource" />-Instanzen denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn die beiden <see cref="T:System.Windows.ValueSource" />-Instanzen äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ruft <xref:System.Windows.ValueSource.Equals%2A>, und unterstützt basierend auf alle Eigenschaften der Wertgleichheit <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Inequality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="System.Windows.ValueSource.op_Inequality (vs1, vs2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Der erste zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <param name="vs2">Der zweite zu vergleichende <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Windows.ValueSource" />-Instanzen verschiedene Werte haben.</summary>
        <returns>
          <see langword="true" />, wenn die beiden <see cref="T:System.Windows.ValueSource" />-Instanzen nicht äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ruft <xref:System.Windows.ValueSource.Equals%2A>, Zurückgeben der Negation und unterstützt die Wertgleichheit, die basierend auf alle Eigenschaften des <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
  </Members>
</Type>