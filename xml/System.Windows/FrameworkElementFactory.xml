<Type Name="FrameworkElementFactory" FullName="System.Windows.FrameworkElementFactory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee95aa6796088d0bf2bb8e03253da7b054afb263" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48664384" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElementFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkElementFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElementFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElementFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElementFactory" />
  <TypeSignature Language="F#" Value="type FrameworkElementFactory = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unterstützt die Erstellung von Vorlagen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse ist eine veraltete Möglichkeit zum programmgesteuerten Erstellen von Vorlagen, die ist eine Unterklasse der <xref:System.Windows.FrameworkTemplate> wie z. B. <xref:System.Windows.Controls.ControlTemplate> oder <xref:System.Windows.DataTemplate>; nicht alle von der Vorlage Funktionalität ist verfügbar, wenn Sie eine Vorlage, die mit dieser Klasse erstellen. Die empfohlene Methode zum programmgesteuerten Erstellen einer Vorlage besteht im Laden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] aus einer Zeichenfolge oder einen Speicher-Stream mit der <xref:System.Windows.Markup.XamlReader.Load%2A> Methode der <xref:System.Windows.Markup.XamlReader> Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElementFactory" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElementFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElementFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElementFactory" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElementFactory (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElementFactory(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkElementFactory : string -&gt; System.Windows.FrameworkElementFactory" Usage="new System.Windows.FrameworkElementFactory text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die zu erstellende Textzeichenfolge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElementFactory" />-Klasse mit dem angegebenen zu erstellenden Text.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElementFactory (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElementFactory(Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkElementFactory : Type -&gt; System.Windows.FrameworkElementFactory" Usage="new System.Windows.FrameworkElementFactory type" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu erstellenden Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElementFactory" />-Klasse mit der angegebenen <see cref="T:System.Type" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElementFactory (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElementFactory(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkElementFactory : Type * string -&gt; System.Windows.FrameworkElementFactory" Usage="new System.Windows.FrameworkElementFactory (type, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu erstellenden Instanz.</param>
        <param name="name">Der Formatbezeichner.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.FrameworkElementFactory" />-Klasse mit dem angegebenen <see cref="T:System.Type" /> und dem angegebenen Namen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Ereignishandler für das angegebene Routingereignis zu den von dieser Factory erstellten Instanzen hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="frameworkElementFactory.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Bezeichnerobjekt für das behandelte geroutete Ereignis .</param>
        <param name="handler">Ein Verweis auf die Handlerimplementierung.</param>
        <summary>Fügt einen Ereignishandler für das angegebene Routingereignis zu den von dieser Factory erstellten Instanzen hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="frameworkElementFactory.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Bezeichnerobjekt für das behandelte geroutete Ereignis .</param>
        <param name="handler">Ein Verweis auf die Handlerimplementierung.</param>
        <param name="handledEventsToo">Gibt an, ob der Händler auch für Routingereignisse aufgerufen werden soll, die im zugehörigen Argumentobjekt bereits als behandelt markiert wurden. <see langword="true" />, wenn der Handler auch dann aufgerufen werden soll, wenn das Routingereignis als behandelt markiert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />. Anforderungen der Behandlung von bereits behandelten Routingereignissen sind nicht üblich.</param>
        <summary>Fügt den von dieser Factory erstellten Instanzen für das angegebene Routingereignis einen Ereignishandler hinzu, wobei die Möglichkeit besteht, dass der bereitgestellte Handler auch für Routingereignisse aufgerufen werden kann, die von einem anderen Element entlang der Route als behandelt markiert wurden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public void AppendChild (System.Windows.FrameworkElementFactory child);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendChild(class System.Windows.FrameworkElementFactory child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.AppendChild(System.Windows.FrameworkElementFactory)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendChild (child As FrameworkElementFactory)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendChild(System::Windows::FrameworkElementFactory ^ child);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.FrameworkElementFactory -&gt; unit" Usage="frameworkElementFactory.AppendChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.FrameworkElementFactory" />
      </Parameters>
      <Docs>
        <param name="child">Das <see cref="T:System.Windows.FrameworkElementFactory" />-Objekt, das als untergeordnetes Element hinzugefügt werden soll.</param>
        <summary>Fügt dieser Factory eine untergeordnete Factory hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.FrameworkElementFactory FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.FrameworkElementFactory FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As FrameworkElementFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FrameworkElementFactory ^ FirstChild { System::Windows::FrameworkElementFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.FrameworkElementFactory" Usage="System.Windows.FrameworkElementFactory.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FrameworkElementFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die erste untergeordnete Factory ab.</summary>
        <value>Eine <see cref="T:System.Windows.FrameworkElementFactory" />, die die erste untergeordnete Factory darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.FrameworkElementFactory.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen unveränderlichen Zustand aufweist.</summary>
        <value><see langword="true" /> Wenn dieses Objekt einen unveränderlichen Zustand ist; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElementFactory.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Vorlagenelements ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge, die den Vorlagenbezeichner darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.FrameworkElementFactory NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.FrameworkElementFactory NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As FrameworkElementFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FrameworkElementFactory ^ NextSibling { System::Windows::FrameworkElementFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.FrameworkElementFactory" Usage="System.Windows.FrameworkElementFactory.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FrameworkElementFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die nächste nebengeordnete Factory ab.</summary>
        <value>Eine <see cref="T:System.Windows.FrameworkElementFactory" />, die die nächste nebengeordnete Factory darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.FrameworkElementFactory Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.FrameworkElementFactory Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As FrameworkElementFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FrameworkElementFactory ^ Parent { System::Windows::FrameworkElementFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.FrameworkElementFactory" Usage="System.Windows.FrameworkElementFactory.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FrameworkElementFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete <see cref="T:System.Windows.FrameworkElementFactory" /> ab.</summary>
        <value>Eine <see cref="T:System.Windows.FrameworkElementFactory" />, die die übergeordnete Factory darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="frameworkElementFactory.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Bezeichnerobjekt für das Routingereignis.</param>
        <param name="handler">Der zu entfernende Handler.</param>
        <summary>Entfernt einen Ereignishandler aus dem gegebenen Routingereignis. Dies gilt für die von dieser Factory erstellten Instanzen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public void SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBinding (dp As DependencyProperty, binding As BindingBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; unit" Usage="frameworkElementFactory.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Gibt die Eigenschaft an, für die die Bindung eingerichtet werden soll.</param>
        <param name="binding">Die Beschreibung der Bindung.</param>
        <summary>Richtet die Datenbindung für eine Eigenschaft ein.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElementFactory.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Die Eigenschaft, an die die Ressource gebunden ist.</param>
        <param name="name">Der Name der Ressource.</param>
        <summary>Richten Sie einen dynamischen Ressourcenverweis auf eine untergeordnete Eigenschaft ein.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElementFactory.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElementFactory.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner der Abhängigkeitseigenschaft für die festzulegende Eigenschaft.</param>
        <param name="value">Der neue Wert.</param>
        <summary>Legt den Wert einer Abhängigkeitseigenschaft fest.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.FrameworkElementFactory.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zu erstellende Textzeichenfolge ab oder legt diese fest.</summary>
        <value>Die zu erstellende Textzeichenfolge.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElementFactory.Type" />
      <MemberSignature Language="VB.NET" Value="Public Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ Type { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type with get, set" Usage="System.Windows.FrameworkElementFactory.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab den Typ der Objekte ab, der von dieser Factory erstellt wird, oder legt diesen fest.</summary>
        <value>Der Typ der Objekte, der von dieser Factory erstellt wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>