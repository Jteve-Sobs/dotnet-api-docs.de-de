<Type Name="Style" FullName="System.Windows.Style">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6eb533f7ae505f7ec3b4a36d8cb5fc407111f309" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679844" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.ISealable, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.ISealable, class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Style" />
  <TypeSignature Language="VB.NET" Value="Public Class Style&#xA;Inherits DispatcherObject&#xA;Implements IAddChild, INameScope, IQueryAmbient, ISealable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Style : System::Windows::Threading::DispatcherObject, System::Windows::ISealable, System::Windows::Markup::IAddChild, System::Windows::Markup::INameScope, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.ISealable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Setters")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("TargetType")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die gemeinsame Nutzung von Eigenschaften, Ressourcen und Ereignishandlern zwischen Instanzen eines Typs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können festlegen, eine <xref:System.Windows.Style> auf ein beliebiges Element, das von abgeleitet ist <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Deklariert ein Stil am häufigsten als Ressource in die <xref:System.Windows.Application.Resources%2A> Abschnitt. Da Stile Ressourcen sind, folgen sie denselben Bereichsregeln, die für alle Ressourcen gelten daher, wenn Sie eine Formatvorlage wirkt sich auf deklariert, in dem sie angewendet werden kann. Wenn z. B. das Format in das Stammelement der Anwendungsdefinition deklarieren [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Datei das Format kann an einer beliebigen Stelle in der Anwendung verwendet werden. Wenn Sie eine navigationsanwendung erstellen, und deklarieren das Format in einem von der Anwendungsverzeichnis [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Dateien, den Stil können verwendet werden, nur in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Datei. Weitere Informationen zu Bereichsregeln für Ressourcen finden Sie unter [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Die Style-Deklaration besteht aus einer <xref:System.Windows.Style> -Objekt, das eine Auflistung einer oder mehrerer enthält <xref:System.Windows.Setter> Objekte. Jede <xref:System.Windows.Setter> besteht aus einem <xref:System.Windows.Setter.Property%2A> und ein <xref:System.Windows.Setter.Value%2A>. Die Eigenschaft ist, dass der Name der Eigenschaft des Elements den Stil zuweisen. Nachdem Sie das Format als Ressource deklariert wird, kann es genau wie jede andere Ressource verwiesen werden.  
  
> [!NOTE]
>  Wenn mehr als eine Setter-Methode in der Auflistung der Setter mit dem gleichen vorhanden ist <xref:System.Windows.Setter.Property%2A> Eigenschaftswert Setter-Methode, die deklariert wird zuletzt verwendet wird. Wenn Sie einen Wert für die gleiche Eigenschaft in einem Format und für ein Element direkt festlegen, hat der Wert, der direkt auf das Element festgelegt auf ähnliche Weise Vorrang vor.  
  
 Die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Erstellen von Formaten und Vorlagen-Modell ermöglicht die Wartung und Freigabe von einer Darstellung sowie die Trennung von Darstellung und Logik. Das Erstellen von Formaten und Vorlagen-Modell enthält eine Sammlung von Funktionen, die Sie anpassen können Ihre [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Umfasst die Suite von Features der <xref:System.Windows.Style> -Klasse sowie die folgenden:  
  
-   <xref:System.Windows.Trigger>  
  
-   <xref:System.Windows.EventTrigger> und <xref:System.Windows.Media.Animation.Storyboard>  
  
-   <xref:System.Windows.Controls.ControlTemplate>  
  
-   <xref:System.Windows.DataTemplate>  
  
 Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Formatvorlage-Deklaration, die gelten die <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft eine <xref:System.Windows.Controls.Control>.  
  
 [!code-xaml[StyleOvw01#StyleSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimple)]   
  
 Führen Sie folgende Schritte aus, um den oben beschriebenen Stil zu übernehmen:  
  
 [!code-xaml[StyleOvw01#StyleSimpleApplied](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimpleapplied)]
  
 Sie können auch Stile für alle Elemente eines angegebenen Typs gelten, mithilfe der <xref:System.Windows.Style.TargetType%2A> Eigenschaft. Hinzufügen des Zieltyps den Stil bedeutet, dass Sie nicht mehr auf die Eigenschaft vollständig zu qualifizieren, legen Sie mit, der `ClassName.PropertyName` Syntax. Das folgende Beispiel definiert einen Stil, die allen angewendet werden <xref:System.Windows.Controls.TextBlock> Element.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
> [!NOTE]
>  Viele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelementen bestehen aus einer Kombination von anderen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelemente, also erstellen eine Formatvorlage, die für alle Steuerelemente eines Typs wendet reichende Auswirkungen haben können. Z. B. Wenn Sie einen Stil erstellen, die <xref:System.Windows.Controls.TextBlock> steuert in eine <xref:System.Windows.Controls.Canvas>, das Format gilt für alle <xref:System.Windows.Controls.TextBlock> Steuerelemente im Zeichenbereich, selbst wenn die <xref:System.Windows.Controls.TextBlock> ist Teil eines anderen Steuerelements, wie eine <xref:System.Windows.Controls.ListBox>.  
  
 Informationen zum Erweitern oder erben von einem definierten Stil finden Sie unter der <xref:System.Windows.Style.BasedOn%2A> Seite.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktoraufruf ist eine verzögerte Überprüfung erforderlich <xref:System.Windows.Style.TargetType%2A> und <xref:System.Windows.Style.BasedOn%2A> Typ zu formatieren. Wenn diese außerhalb des Kontexts des Parsers verwendet wird, ist das Verhalten nicht definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="targetType">Der Typ, auf den der Stil angewendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse zur Verwendung für den angegebenen <see cref="T:System.Type" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType, System.Windows.Style basedOn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType, class System.Windows.Style basedOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type, basedOn As Style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType, System::Windows::Style ^ basedOn);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="basedOn" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="targetType">Der Typ, auf den der Stil angewendet wird.</param>
        <param name="basedOn">Der Stil, der als Grundlage für diesen Stil verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse zur Verwendung für den angegebenen <see cref="T:System.Type" /> und auf Grundlage des angegebenen <see cref="T:System.Windows.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BasedOn">
      <MemberSignature Language="C#" Value="public System.Windows.Style BasedOn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style BasedOn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.BasedOn" />
      <MemberSignature Language="VB.NET" Value="Public Property BasedOn As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ BasedOn { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen definierten Stil ab, der die Grundlage für den aktuellen Stil ist, oder legt diesen fest.</summary>
        <value>Ein definierter Stil, der die Grundlage für den aktuellen Stil darstellt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Produktart unterstützt nur ein <xref:System.Windows.Style.BasedOn%2A> Wert.  
  
<a name="xamlAttributeUsage_BasedOn"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object BasedOn="myStyle" .../>  
```  
  
<a name="xamlValues_BasedOn"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *myStyle*  
 Ein vorhandener Stil. Normalerweise verwenden Sie die [Markuperweiterungen und WPF-XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md) zum Verweisen auf einen vorhandenen Stil.  
  
   
  
## Examples  
 Es gibt mehrere Möglichkeiten, das im Stile [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert oder geerbt werden kann. Stile können auf anderen Formaten über diese Eigenschaft basieren. Wenn Sie diese Eigenschaft verwenden, erbt die neue Formatvorlage die Werte des ursprünglichen Formats in die neue Formatvorlage nicht explizit neu definiert werden. Im folgenden Beispiel `Style2` erbt die <xref:System.Windows.Controls.Control.Background%2A?displayProperty=nameWithType> Wert `Yellow`, und fügt eine <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=nameWithType> Wert `Blue`.  
  
 [!code-xaml[StyleOvw01#ExtendingStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyle)]   
  
 Auf ähnliche Weise können Formatvorlagen auf den Stil eines vorhandenen basieren [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Element, wie im folgenden Beispiel, in dem die neue Formatvorlage die Art des basiert, ein <xref:System.Windows.Controls.TextBlock> Element.  
  
 [!code-xaml[PhotoStoreDemoStyled#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#2)]   
  
> [!NOTE]
>  Bei der Erstellung eines Stils mit einem <xref:System.Windows.Style.TargetType%2A> -Eigenschaft und die Basis, die auf einem anderen Stil, die definiert, die auch eine <xref:System.Windows.Style.TargetType%2A> -Eigenschaft der Zieltyp des abgeleiteten Stils müssen identisch sein oder vom Typ des Basis-Formatvorlage abgeleitet werden.  
  
 Für bestimmte Typen definierte Formatvorlagen können auch auf anderen Formate, wie im folgenden Beispiel basieren.  
  
 [!code-xaml[StyleOvw01#ExtendingStyleTargetType](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyletargettype)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diesen <see cref="T:System.Windows.Style" /> zurück.</summary>
        <returns>Der Hashcode für diese <see cref="T:System.Windows.Style" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Stil schreibgeschützt ist und nicht geändert werden kann.</summary>
        <value>
          <see langword="true" />, wenn der Stil versiegelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Stil ist versiegelt, wenn Sie einen anderen Stil darauf basiert, oder wenn sie zum ersten Mal angewendet wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Style.BasedOn" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der zu registrierende Name.</param>
        <param name="scopedElement">Das Objekt, das dem angegebenen <c>name</c> zugeordnet werden soll.</param>
        <summary>Registriert ein neues Name/Objekt-Paar im aktuellen Namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Ressourcen ab, die innerhalb des Bereichs dieses Stils verwendet werden können, oder legt sie fest.</summary>
        <value>Die Ressourcen, die im Bereich dieses Stils verwendet werden können.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
- or -   
<object>  
  <object.Resources>  
    <ResourceDictionary Source="externalDictionarySource"/>  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreResourceElements*  
 Eine oder mehrere Ressourcenelemente. Weiter unten in Verweise auf [StaticResource Markuperweiterung](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) oder [DynamicResource Markuperweiterung](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) Syntax in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], ein Ressourcenelement benötigen eine `x:Key` Attribut.  
  
 \<ResourceDictionary Source=" *externalDictionarySource*"/>  
 Eine externe Wörterbuchquelle. Weitere Informationen finden Sie unter [Ressourcenverzeichnis zusammengeführt](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.Seal" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seal ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seal();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sperrt diesen Stil und alle Factorys und Trigger, damit sie nicht geändert werden können.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Setters">
      <MemberSignature Language="C#" Value="public System.Windows.SetterBaseCollection Setters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.SetterBaseCollection Setters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Setters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Setters As SetterBaseCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SetterBaseCollection ^ Setters { System::Windows::SetterBaseCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.SetterBaseCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.Setter" />-Objekten und <see cref="T:System.Windows.EventSetter" />-Objekten ab.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.Setter" />-Objekten und <see cref="T:System.Windows.EventSetter" />-Objekten. Der Standard ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Style.Setters%2A> Eigenschaft eine <xref:System.Windows.Style> Objekt kann nur von Objekten zugewiesen werden bestehen <xref:System.Windows.SetterBase>. Hinzufügen einer <xref:System.Windows.SetterBase> untergeordnetes Element einer <xref:System.Windows.Style> Objekt implizit hinzugefügt der <xref:System.Windows.SetterBaseCollection> für die <xref:System.Windows.Style> Objekt.  
  
 Eine explizite Eigenschaftenelementen für <xref:System.Windows.Style.Setters%2A> ist außerdem relativ häufig. Dies ist ein Markup Stil Entscheidung, die in einigen Fällen unterschieden helfen können <xref:System.Windows.Style.Setters%2A> aus <xref:System.Windows.Style.Resources%2A> und <xref:System.Windows.Style.Triggers%2A> Elemente in einem komplexen Format. Zum Beispiel:  
  
```  
<Style>  
  <Style.Setters>  
    <!--one or more SetterBase derived object elements here-->  
  </Style.Setters>  
</Style>  
```  
  
<a name="xamlPropertyElementUsage_Setters"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  oneOrMoreSetters  
</object>  
```  
  
<a name="xamlValues_Setters"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreSetters*  
 Eine oder mehrere <xref:System.Windows.Setter> oder <xref:System.Windows.EventSetter> Objekte.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie diese Eigenschaft verwendet wird.  
  
 [!code-csharp[listboxitemstyle#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItemStyle/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[listboxitemstyle#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItemStyle/VisualBasic/Pane1.xaml.vb#1)]  
  
 Hinzufügen einer <xref:System.Windows.SetterBase> untergeordnetes Element einer <xref:System.Windows.Style> Objekt implizit hinzugefügt der <xref:System.Windows.SetterBaseCollection> für die <xref:System.Windows.Style> Objekt. Die folgenden <xref:System.Windows.EventSetter> implizit hinzugefügt wurden, um die <xref:System.Windows.SetterBaseCollection> des Formats:  
  
 [!code-xaml[eventovwsupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Setter" />
        <altmember cref="T:System.Windows.EventSetter" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.CanSeal">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.CanSeal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.CanSeal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#CanSeal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanSeal As Boolean Implements ISealable.CanSeal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Windows.ISealable.CanSeal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.IsSealed">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#IsSealed" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSealed As Boolean Implements ISealable.IsSealed" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Windows.ISealable.IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.Seal">
      <MemberSignature Language="C#" Value="void ISealable.Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.ISealable.Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#ISealable#Seal" />
      <MemberSignature Language="VB.NET" Value="Sub Seal () Implements ISealable.Seal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.ISealable.Seal() = System::Windows::ISealable::Seal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das hinzuzufügende untergeordnete Objekt.</param>
        <summary>Fügt ein untergeordnetes Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der dem Objekt hinzuzufügende Text.</param>
        <summary>Fügt dem Objekt den Textinhalt eines Knotens hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.INameScope.FindName">
      <MemberSignature Language="C#" Value="object INameScope.FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Markup.INameScope.FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindName (name As String) As Object Implements INameScope.FindName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Markup.INameScope.FindName(System::String ^ name) = System::Windows::Markup::INameScope::FindName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Namensbezeichner für das angeforderte Objekt.</param>
        <summary>Gibt ein Objekt zurück, das über den bereitgestellten kennzeichnenden Namen verfügt.</summary>
        <returns>Das Objekt, falls gefunden. Gibt <see langword="null" /> zurück, wenn kein Objekt dieses Namens gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.INameScope>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Fragt ab, ob eine angegebene Ambient-Eigenschaft im aktuellen Bereich verfügbar ist.</summary>
        <returns>
          <see langword="true" />, wenn die angeforderte Ambient-Eigenschaft verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public Type TargetType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ TargetType { Type ^ get(); void set(Type ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, für den dieser Stil vorgesehen ist, oder legt ihn fest.</summary>
        <value>Der Zieltyp für diesen Stil.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Formatvorlage auf ein beliebiges Element, das von abgeleitet ist festlegen <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Aus diesem Grund kann Ihre Zieltyp keines dieser Elemente sein. Allerdings bei der Erstellung eines Stils mit einer <xref:System.Windows.Style.TargetType%2A> -Eigenschaft und die Basis, die auf einem anderen Stil, die definiert, die auch eine <xref:System.Windows.Style.TargetType%2A> -Eigenschaft der Zieltyp des abgeleiteten Stils müssen identisch sein oder aus der Zieltyp des Basis-Formatvorlage abgeleitet werden.  
  
 Wenn Sie nicht angeben einer <xref:System.Windows.Style.TargetType%2A>, dann Sie angeben müssen, ein `x:Key` für Ihre <xref:System.Windows.Style> und außerdem die Eigenschaften im Stil durch einen Klassennamen qualifizieren.  
  
<a name="xamlAttributeUsage_TargetType"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object  TargetType="{x:Type typeName}"/>  
-or-  
<object  TargetType="typeName"/>  
```  
  
<a name="xamlValues_TargetType"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `{x:Type ...}`  
 Ein [X: Type-Markuperweiterung](~/docs/framework/xaml-services/x-type-markup-extension.md) Markuperweiterungsverwendung.  
  
 *typeName*  
 Der Typname der Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen Stil, die auf alle Instanzen von angewendet werden, die <xref:System.Windows.Controls.TextBlock> Element.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
 Festlegen der <xref:System.Windows.Style.TargetType%2A> Eigenschaft, um die <xref:System.Windows.Controls.TextBlock> Typ festlegen, ohne eine `x:Key` legt implizit die `x:Key` auf `{x:Type TextBlock}`. Dies bedeutet auch, dass, wenn die oben genannten verfügt <xref:System.Windows.Style> ein `x:Key` Wert von anderem außer `{x:Type TextBlock}`, die <xref:System.Windows.Style> würde nicht angewendet werden, um alle <xref:System.Windows.Controls.TextBlock> Elemente automatisch. Stattdessen müssen Sie den Stil darauf anzuwenden der <xref:System.Windows.Controls.TextBlock> Elemente explizit.  
  
 Viele [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelementen bestehen aus einer Kombination von anderen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Steuerelemente, also erstellen eine Formatvorlage, die für alle Steuerelemente eines Typs wendet reichende Auswirkungen haben können. Z. B. Wenn Sie einen Stil erstellen, die <xref:System.Windows.Controls.TextBox> steuert in eine <xref:System.Windows.Controls.Canvas>, das Format gilt für alle <xref:System.Windows.Controls.TextBox> Steuerelemente im Zeichenbereich, selbst wenn die <xref:System.Windows.Controls.TextBox> ist Teil eines anderen Steuerelements, wie eine <xref:System.Windows.Controls.ComboBox>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.TriggerBase" />-Objekten ab, die Eigenschaftswerte auf Grundlage bestimmter Bedingungen anwenden.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.TriggerBase" />-Objekten. Der Standard ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Erstellen von Formaten und Vorlagen-Modell ermöglicht Ihnen die Angabe von Triggern innerhalb Ihrer <xref:System.Windows.Style>. Im Wesentlichen Trigger sind Objekte, die Ihnen ermöglichen, Anwenden von Änderungen aus, wenn bestimmte Bedingungen (z. B. wenn ein bestimmter Eigenschaftswert wird `true`, oder wenn ein Ereignis auftritt) erfüllt sind.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreTriggers*  
 NULL oder mehr Objektelemente, die Klassen abgeleitet sind <xref:System.Windows.TriggerBase>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine benannte <xref:System.Windows.Style> zur <xref:System.Windows.Controls.Button> Steuerelemente. Die <xref:System.Windows.Style> definiert eine <xref:System.Windows.Trigger> Element, das ändert die <xref:System.Windows.Controls.Control.Foreground%2A> Eigenschaft einer Schaltfläche bei der <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> Eigenschaft ist `true`.  
  
 [!code-xaml[BtnStyles#2](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnStyles/CS/app.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu entfernenden Zuordnung.</param>
        <summary>Entfernt eine Name/Objekt-Zuordnung aus dem Namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>