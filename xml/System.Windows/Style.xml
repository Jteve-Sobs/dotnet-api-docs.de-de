<Type Name="Style" FullName="System.Windows.Style">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c5c6e0e35f0a2174c5431bd602871bd1c84a59ac" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88264889" /></Metadata><TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Style" />
  <TypeSignature Language="VB.NET" Value="Public Class Style&#xA;Inherits DispatcherObject&#xA;Implements IAddChild, INameScope, IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class Style : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IAddChild, System::Windows::Markup::INameScope, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Style = class&#xA;    inherit DispatcherObject&#xA;    interface IAddChild&#xA;    interface INameScope&#xA;    interface IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class Style&#xA;Inherits DispatcherObject&#xA;Implements IAddChild, INameScope" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class Style : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IAddChild, System::Windows::Markup::INameScope" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type Style = class&#xA;    inherit DispatcherObject&#xA;    interface INameScope&#xA;    interface IAddChild" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Style = class&#xA;    inherit DispatcherObject&#xA;    interface INameScope&#xA;    interface IAddChild&#xA;    interface IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.ContentProperty("Setters")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.ContentProperty("Setters")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Markup.DictionaryKeyProperty("TargetType")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.DictionaryKeyProperty("TargetType")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die gemeinsame Nutzung von Eigenschaften, Ressourcen und Ereignishandlern zwischen Instanzen eines Typs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Windows.Style> für alle Elemente festlegen, die von oder abgeleitet werden <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> . Ein Stil wird am häufigsten als Ressource innerhalb des Abschnitts deklariert <xref:System.Windows.Application.Resources%2A> . Da es sich bei Stilen um Ressourcen handelt, werden dieselben Bereichs Regeln befolgt, die für alle Ressourcen gelten. Wenn Sie also einen Stil deklarieren, wirkt er sich darauf aus, wo er angewendet werden kann. Wenn Sie beispielsweise den Stil im Stamm Element ihrer Anwendungs Definitionsdatei deklarieren [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , kann der Stil an beliebiger Stelle in der Anwendung verwendet werden. Wenn Sie eine Navigations Anwendung erstellen und den Stil in einer der Anwendungs Dateien deklarieren [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , kann der Stil nur in dieser Datei verwendet werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] . Weitere Informationen zu Bereichs Regeln für Ressourcen finden Sie unter [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources).  
  
 Die Format Deklaration besteht aus einem- <xref:System.Windows.Style> Objekt, das eine Auflistung von einem oder mehreren- <xref:System.Windows.Setter> Objekten enthält. Jede <xref:System.Windows.Setter> besteht aus einem <xref:System.Windows.Setter.Property%2A> und einem <xref:System.Windows.Setter.Value%2A> . Die-Eigenschaft ist der Name der-Eigenschaft des Elements, auf das der Stil angewendet werden soll. Nachdem der Stil als Ressource deklariert wurde, kann auf ihn genauso wie auf jede andere Ressource verwiesen werden.  
  
> [!NOTE]
>  Wenn mehr als ein Setter in der Setter-Auflistung mit dem gleichen- <xref:System.Windows.Setter.Property%2A> Eigenschafts Wert vorhanden ist, wird der als letzter deklarierte Setter verwendet. Wenn Sie einen Wert für dieselbe Eigenschaft in einem Stil und direkt auf einem Element festlegen, hat der Wert, der für das Element direkt festgelegt wurde, Vorrang.  
  
 Das Formatvorlagen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] -und Vorlagen Modell ermöglicht die Wartung und Freigabe eines Sehens sowie die Trennung von Präsentation und Logik. Das Formatierungs-und Vorlagen Modell umfasst eine Reihe von Features, mit denen Sie Ihre anpassen können [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] . Diese featuresuite beinhaltet die- <xref:System.Windows.Style> Klasse und die folgenden:  
  
-   <xref:System.Windows.Trigger>  
  
-   <xref:System.Windows.EventTrigger> und <xref:System.Windows.Media.Animation.Storyboard>  
  
-   <xref:System.Windows.Controls.ControlTemplate>  
  
-   <xref:System.Windows.DataTemplate>  
  
 Weitere Informationen finden Sie unter [Erstellen von Formaten und Vorlagen](/dotnet/framework/wpf/controls/styling-and-templating).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Format Deklaration, die sich <xref:System.Windows.Controls.Control.Background%2A> auf die-Eigenschaft eines-Objekts auswirkt <xref:System.Windows.Controls.Control> .  
  
 [!code-xaml[StyleOvw01#StyleSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimple)]   
  
 Gehen Sie folgendermaßen vor, um den obigen Stil anzuwenden:  
  
 [!code-xaml[StyleOvw01#StyleSimpleApplied](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimpleapplied)]
  
 Mithilfe der-Eigenschaft können Sie auch Stile auf alle Elemente eines bestimmten Typs anwenden <xref:System.Windows.Style.TargetType%2A> . Das Hinzufügen des Zieltyps zum Stil bedeutet, dass Sie die Eigenschaft, die Sie mit der Syntax festlegen, nicht mehr vollständig qualifizieren müssen `ClassName.PropertyName` . Im folgenden Beispiel wird ein Stil definiert, der auf jedes Element angewendet wird <xref:System.Windows.Controls.TextBlock> .  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
> [!NOTE]
>  Viele Steuer [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Elemente bestehen aus einer Kombination aus anderen Steuer [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Elementen, sodass das Erstellen eines Stils, der für alle Steuerelemente eines Typs gilt, weitreichende Auswirkungen haben kann. Wenn Sie z. b. einen Stil erstellen, der auf die Steuer <xref:System.Windows.Controls.TextBlock> Elemente in einem abzielt <xref:System.Windows.Controls.Canvas> , wird der Stil auf alle- <xref:System.Windows.Controls.TextBlock> Steuerelemente im Zeichenbereich angewendet, auch wenn der <xref:System.Windows.Controls.TextBlock> Teil eines anderen Steuer Elements ist, z <xref:System.Windows.Controls.ListBox> . b..  
  
 Informationen zum Erweitern oder Erben eines definierten Stils finden Sie auf der <xref:System.Windows.Style.BasedOn%2A> Seite.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/desktop-wpf/xaml-services/xkey-directive">x:Schlüssel-Attribut</related>
    <related type="Article" href="/dotnet/desktop-wpf/xaml-services/xtype-markup-extension">x:Type-Markuperweiterung</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Einführung in das Beispiel für formatieren und Vorlagen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser konstruktorbefehl erfordert eine verzögerte Validierung von <xref:System.Windows.Style.TargetType%2A> und <xref:System.Windows.Style.BasedOn%2A> Stiltyp. Wenn diese außerhalb des Kontexts des Parsers verwendet wird, ist das Verhalten nicht definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type -&gt; System.Windows.Style" Usage="new System.Windows.Style targetType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="targetType">Der Typ, auf den der Stil angewendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse zur Verwendung für den angegebenen <see cref="T:System.Type" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType, System.Windows.Style basedOn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType, class System.Windows.Style basedOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type, basedOn As Style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType, System::Windows::Style ^ basedOn);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type * System.Windows.Style -&gt; System.Windows.Style" Usage="new System.Windows.Style (targetType, basedOn)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="basedOn" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="targetType">Der Typ, auf den der Stil angewendet wird.</param>
        <param name="basedOn">Der Stil, der als Grundlage für diesen Stil verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Style" />-Klasse zur Verwendung für den angegebenen <see cref="T:System.Type" /> und auf Grundlage des angegebenen <see cref="T:System.Windows.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BasedOn">
      <MemberSignature Language="C#" Value="public System.Windows.Style BasedOn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style BasedOn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.BasedOn" />
      <MemberSignature Language="VB.NET" Value="Public Property BasedOn As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ BasedOn { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BasedOn : System.Windows.Style with get, set" Usage="System.Windows.Style.BasedOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen definierten Stil ab, der die Grundlage für den aktuellen Stil ist, oder legt diesen fest.</summary>
        <value>Ein definierter Stil, der die Grundlage für den aktuellen Stil darstellt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Stil unterstützt nur einen <xref:System.Windows.Style.BasedOn%2A> Wert.  
  
<a name="xamlAttributeUsage_BasedOn"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object BasedOn="myStyle" .../>  
```  
  
<a name="xamlValues_BasedOn"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *Meinstil*  
 Ein vorhandener Stil. In der Regel verwenden Sie die [Markup Erweiterungen und WPF-XAML](/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml) , um auf einen vorhandenen Stil zu verweisen.  
  
   
  
## Examples  
 Es gibt mehrere Möglichkeiten, wie Stile in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert oder geerbt werden können. Stile können über diese Eigenschaft auf anderen Stilen basieren. Wenn Sie diese Eigenschaft verwenden, erbt der neue Stil die Werte des ursprünglichen Stils, die nicht explizit im neuen Stil neu definiert werden. Im folgenden Beispiel `Style2` erbt den <xref:System.Windows.Controls.Control.Background%2A?displayProperty=nameWithType> Wert von `Yellow` und fügt den <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=nameWithType> Wert hinzu `Blue` .  
  
 [!code-xaml[StyleOvw01#ExtendingStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyle)]   
  
 Entsprechend können Stile auf dem Stil eines vorhandenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Elements basieren, wie im folgenden Beispiel, in dem die neue Formatvorlage auf dem Stil eines- <xref:System.Windows.Controls.TextBlock> Elements basiert.  
  
 [!code-xaml[PhotoStoreDemoStyled#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#2)]   
  
> [!NOTE]
>  Wenn Sie einen Stil mit einer <xref:System.Windows.Style.TargetType%2A> Eigenschaft erstellen und auf einem anderen Stil basieren, der auch eine <xref:System.Windows.Style.TargetType%2A> Eigenschaft definiert, muss der Zieltyp des abgeleiteten Stils mit dem Typ des Basistyps identisch sein oder davon abgeleitet sein.  
  
 Für bestimmte Typen definierte Stile können auch auf anderen Stilen basieren, wie im folgenden Beispiel gezeigt.  
  
 [!code-xaml[StyleOvw01#ExtendingStyleTargetType](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyletargettype)]   
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Einführung in das Beispiel für formatieren und Vorlagen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="style.GetHashCode " FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="style.GetHashCode " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diesen <see cref="T:System.Windows.Style" /> zurück.</summary>
        <returns>Der Hashcode für diese <see cref="T:System.Windows.Style" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.Style.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Stil schreibgeschützt ist und nicht geändert werden kann.</summary>
        <value><see langword="true" />, wenn der Stil versiegelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Stil ist versiegelt, wenn ein anderer Stil darauf basiert oder wenn er zum ersten Mal angewendet wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Style.BasedOn" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="style.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der zu registrierende Name.</param>
        <param name="scopedElement">Das Objekt, das dem angegebenen <paramref name="name" /> zugeordnet werden soll.</param>
        <summary>Registriert ein neues Name/Objekt-Paar im aktuellen Namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Style.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Ressourcen ab, die innerhalb des Bereichs dieses Stils verwendet werden können, oder legt sie fest.</summary>
        <value>Die Ressourcen, die im Bereich dieses Stils verwendet werden können.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```xaml
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>
```

- oder -

```xaml
<object>  
  <object.Resources>  
    <ResourceDictionary Source="externalDictionarySource"/>  
  </object.Resources>  
</object>  
```

<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoreresourceelements*  
 Mindestens ein Ressourcen Element. Um später in der [statikresource-Markup Erweiterung](/dotnet/framework/wpf/advanced/staticresource-markup-extension) oder der [dynamikresource-Markup Erweiterungs](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension) Syntax in referenziert zu werden [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , muss ein Ressourcen Element über ein- `x:Key` Attribut verfügen.  
  
 \<ResourceDictionary Source=" *externalDictionarySource*"/>  
 Eine externe Wörterbuch Quelle. Weitere Informationen finden Sie unter [zusammengeführte Ressourcen Wörterbücher](/dotnet/framework/wpf/advanced/merged-resource-dictionaries).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.Seal" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seal ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seal();" />
      <MemberSignature Language="F#" Value="member this.Seal : unit -&gt; unit" Usage="style.Seal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sperrt diesen Stil und alle Factorys und Trigger, damit sie nicht geändert werden können.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Setters">
      <MemberSignature Language="C#" Value="public System.Windows.SetterBaseCollection Setters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.SetterBaseCollection Setters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Setters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Setters As SetterBaseCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SetterBaseCollection ^ Setters { System::Windows::SetterBaseCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Setters : System.Windows.SetterBaseCollection" Usage="System.Windows.Style.Setters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.SetterBaseCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.Setter" />-Objekten und <see cref="T:System.Windows.EventSetter" />-Objekten ab.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.Setter" />-Objekten und <see cref="T:System.Windows.EventSetter" />-Objekten. Der Standard ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Windows.Style.Setters%2A> Eigenschaft eines- <xref:System.Windows.Style> Objekts kann nur aus Objekten bestehen, die zugewiesen werden können <xref:System.Windows.SetterBase> . Wenn Sie einem-Objekt ein untergeordnetes Element hinzufügen, wird dieses <xref:System.Windows.SetterBase> <xref:System.Windows.Style> implizit dem <xref:System.Windows.SetterBaseCollection> für das- <xref:System.Windows.Style> Objekt hinzugefügt  
  
 Eine explizite Verwendung eines Eigenschafts Elements für <xref:System.Windows.Style.Setters%2A> ist ebenfalls relativ häufig. Dabei handelt es sich um eine Entscheidung über den Markup Stil, die manchmal zur Unterscheidung <xref:System.Windows.Style.Setters%2A> von <xref:System.Windows.Style.Resources%2A> -Elementen und- <xref:System.Windows.Style.Triggers%2A> Elementen in einem komplexen Stil Beispiel:  
  
```  
<Style>  
  <Style.Setters>  
    <!--one or more SetterBase derived object elements here-->  
  </Style.Setters>  
</Style>  
```  
  
<a name="xamlPropertyElementUsage_Setters"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  oneOrMoreSetters  
</object>  
```  
  
<a name="xamlValues_Setters"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoresetters*  
 Mindestens ein- <xref:System.Windows.Setter> oder- <xref:System.Windows.EventSetter> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie diese Eigenschaft verwendet wird.  
  
 [!code-csharp[listboxitemstyle#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItemStyle/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[listboxitemstyle#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItemStyle/VisualBasic/Pane1.xaml.vb#1)]  
  
 Wenn Sie einem-Objekt ein untergeordnetes Element hinzufügen, wird dieses <xref:System.Windows.SetterBase> <xref:System.Windows.Style> implizit dem <xref:System.Windows.SetterBaseCollection> für das- <xref:System.Windows.Style> Objekt hinzugefügt Folgendes <xref:System.Windows.EventSetter> wird implizit dem des-Stils hinzugefügt <xref:System.Windows.SetterBaseCollection> :  
  
 [!code-xaml[eventovwsupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Setter" />
        <altmember cref="T:System.Windows.EventSetter" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Einführung in das Beispiel für formatieren und Vorlagen</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IAddChild.AddChild : obj -&gt; unit&#xA;override this.System.Windows.Markup.IAddChild.AddChild : obj -&gt; unit" Usage="style.System.Windows.Markup.IAddChild.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das hinzuzufügende untergeordnete Objekt.</param>
        <summary>Fügt ein untergeordnetes Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IAddChild.AddText : string -&gt; unit&#xA;override this.System.Windows.Markup.IAddChild.AddText : string -&gt; unit" Usage="style.System.Windows.Markup.IAddChild.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der dem Objekt hinzuzufügende Text.</param>
        <summary>Fügt dem Objekt den Textinhalt eines Knotens hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.IAddChild>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.INameScope.FindName">
      <MemberSignature Language="C#" Value="object INameScope.FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Markup.INameScope.FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindName (name As String) As Object Implements INameScope.FindName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Markup.INameScope.FindName(System::String ^ name) = System::Windows::Markup::INameScope::FindName;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.INameScope.FindName : string -&gt; obj&#xA;override this.System.Windows.Markup.INameScope.FindName : string -&gt; obj" Usage="style.System.Windows.Markup.INameScope.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Namensbezeichner für das angeforderte Objekt.</param>
        <summary>Gibt ein Objekt zurück, das über den bereitgestellten kennzeichnenden Namen verfügt.</summary>
        <returns>Das Objekt, falls gefunden. Gibt <see langword="null" /> zurück, wenn kein Objekt mit diesem Namen gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.Style>-Instanz in eine <xref:System.Windows.Markup.INameScope>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="style.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Der Name der angeforderten Ambient-Eigenschaft.</param>
        <summary>Fragt ab, ob eine angegebene Ambient-Eigenschaft im aktuellen Bereich verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die angeforderte Ambient-Eigenschaft verfügbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public Type TargetType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ TargetType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : Type with get, set" Usage="System.Windows.Style.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, für den dieser Stil vorgesehen ist, oder legt ihn fest.</summary>
        <value>Der Zieltyp für diesen Stil.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können für jedes Element, das von oder abgeleitet wird, einen Stil festlegen <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> . Daher kann der Zieltyp ein beliebiges Element sein. Wenn Sie jedoch einen Stil mit einer Eigenschaft erstellen <xref:System.Windows.Style.TargetType%2A> und auf einem anderen Stil basieren, der auch eine <xref:System.Windows.Style.TargetType%2A> Eigenschaft definiert, muss der Zieltyp des abgeleiteten Stils mit dem Zieltyp des Basistyps identisch sein oder davon abgeleitet sein.  
  
 Wenn Sie keinen angeben <xref:System.Windows.Style.TargetType%2A> , müssen Sie ein für den angeben `x:Key` <xref:System.Windows.Style> und die Eigenschaften im Stil mit einem Klassennamen qualifizieren.  
  
<a name="xamlAttributeUsage_TargetType"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object  TargetType="{x:Type typeName}"/>  
-or-  
<object  TargetType="typeName"/>  
```  
  
<a name="xamlValues_TargetType"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `{x:Type ...}`  
 Die Markup Erweiterungs Verwendung einer [x:typmarkup Erweiterung](/dotnet/framework/xaml-services/x-type-markup-extension) .  
  
 *typeName*  
 Der Typname der Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Stil definiert, der auf alle Instanzen des-Elements angewendet wird <xref:System.Windows.Controls.TextBlock> .  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
 Wenn die-Eigenschaft auf den-Typ festgelegt wird, <xref:System.Windows.Style.TargetType%2A> <xref:System.Windows.Controls.TextBlock> ohne dass ein festgelegt wird `x:Key` `x:Key` , `{x:Type TextBlock}` wird Dies bedeutet auch, dass, wenn Sie dem <xref:System.Windows.Style> obigen `x:Key` Wert einen anderen Wert als geben `{x:Type TextBlock}` , der <xref:System.Windows.Style> nicht automatisch auf alle Elemente angewendet wird <xref:System.Windows.Controls.TextBlock> . Stattdessen müssen Sie den Stil explizit auf die Elemente anwenden <xref:System.Windows.Controls.TextBlock> .  
  
 Viele Steuer [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Elemente bestehen aus einer Kombination aus anderen Steuer [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Elementen, sodass das Erstellen eines Stils, der für alle Steuerelemente eines Typs gilt, weitreichende Auswirkungen haben kann. Wenn Sie z. b. einen Stil erstellen, der auf die Steuer <xref:System.Windows.Controls.TextBox> Elemente in einem abzielt <xref:System.Windows.Controls.Canvas> , wird der Stil auf alle- <xref:System.Windows.Controls.TextBox> Steuerelemente im Zeichenbereich angewendet, auch wenn der <xref:System.Windows.Controls.TextBox> Teil eines anderen Steuer Elements ist, z <xref:System.Windows.Controls.ComboBox> . b..  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Einführung in das Beispiel für formatieren und Vorlagen</related>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.Style.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.TriggerBase" />-Objekten ab, die Eigenschaftswerte auf Grundlage bestimmter Bedingungen anwenden.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.TriggerBase" />-Objekten. Der Standard ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Formatvorlagen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] -und Vorlagen Modell ermöglicht Ihnen das Angeben von Triggern in Ihrem <xref:System.Windows.Style> . Trigger sind im wesentlichen Objekte, die es Ihnen ermöglichen, Änderungen anzuwenden, wenn bestimmte Bedingungen erfüllt sind (z. b. Wenn ein bestimmter Eigenschafts Wert wird `true` oder wenn ein Ereignis auftritt).  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneormoretriggers*  
 0 (null) oder mehr Objekt Elemente, die von abgeleitete Klassen sind <xref:System.Windows.TriggerBase> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein mit dem Namen <xref:System.Windows.Style> verfügbar für-Steuer <xref:System.Windows.Controls.Button> Elemente angezeigt. <xref:System.Windows.Style>Definiert ein- <xref:System.Windows.Trigger> Element, das die- <xref:System.Windows.Controls.Control.Foreground%2A> Eigenschaft einer Schaltfläche ändert, wenn die- <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> Eigenschaft ist `true` .  
  
 [!code-xaml[BtnStyles#2](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnStyles/CS/app.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.EventTrigger" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Einführung in das Beispiel für formatieren und Vorlagen</related>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="style.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu entfernenden Zuordnung.</param>
        <summary>Entfernt eine Name/Objekt-Zuordnung aus dem Namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
