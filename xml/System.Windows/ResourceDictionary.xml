<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3dee98cd5dc847f758d1452b0d58283dbea70592" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52251700" /></Metadata><TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type ResourceDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ISupportInitialize&#xA;    interface IUriContext&#xA;    interface INameScope" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Hashtabelle/Wörterbuchimplementierung bereit, die von Komponenten und anderen Elementen einer WPF-Anwendung verwendete WPF-Ressourcen enthält.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente in einem <xref:System.Windows.ResourceDictionary> werden nicht sofort verarbeitet, wenn der Anwendungscode geladen wird, indem eine [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Ladeprogramm. Stattdessen die <xref:System.Windows.ResourceDictionary> weiterhin besteht, wie ein Objekt, und die einzelnen Werte werden nur verarbeitet, wenn sie ausdrücklich angefordert werden.  
  
 Die <xref:System.Windows.ResourceDictionary> abgeleitete Klasse wird nicht von <xref:System.Collections.DictionaryBase>. Stattdessen die <xref:System.Windows.ResourceDictionary> -Klasse implementiert <xref:System.Collections.IDictionary> basiert jedoch auf eine <xref:System.Collections.Hashtable> intern.  
  
 In [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], <xref:System.Windows.ResourceDictionary> Klasse ist in der Regel ein implizites Auflistungselement, die der Objekt-Elementwert von mehreren `Resources` Eigenschaften, wenn im Eigenschaftenelement-Syntax angegeben. Ausführliche Informationen zum impliziten Auflistungen in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], finden Sie unter [XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Eine Ausnahme ist, wenn Sie ein zusammengeführtes Wörterbuch angeben möchten. Weitere Informationen finden Sie unter [zusammengeführte Ressourcenverzeichnisse](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Ein weiterer möglicher [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Verwendung ist, deklarieren Sie ein Ressourcenverzeichnis als separate [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] -Datei, und entweder zur Laufzeit mit laden <xref:System.Windows.Markup.XamlReader.Load%2A> oder als lose Datei oder Ressource in einem Projekt (mit voller Vertrauenswürdigkeit) eingeschlossen werden. In diesem Fall <xref:System.Windows.ResourceDictionary> können deklariert werden, als Objektelement, als das Stammelement der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sie müssen die entsprechenden Werte der XML-Namespace zuordnen (Standard für die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Namespace und in der Regel `x:` für die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Namespace) auf die <xref:System.Windows.ResourceDictionary> Element, wenn Sie diese als Stammelement verwenden möchten. Und Sie untergeordnete Elemente hinzufügen können, die definieren, die Ressourcen, jeweils mit einem [X: Key](~/docs/framework/xaml-services/x-key-directive.md) Wert.  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Verwendung der impliziten XAML-Auflistung  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *resourcesProperty*  
 Eine Eigenschaft, die angibt, in dem der Werttyp der Eigenschaft ist ein Eigenschaftenelement <xref:System.Windows.ResourceDictionary>. Dies ist normalerweise die `Resources` Eigenschaft <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>, oder der <xref:System.Windows.Application> in Anwendungsressourcen.  
  
 *oneOrMoreResources*  
 Eine oder mehrere Ressourcen, die als Objektelemente angegeben werden. Jede Ressource, die Sie angeben, müssen eine [X: Key Directive](~/docs/framework/xaml-services/x-key-directive.md) zugewiesen.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.ResourceDictionary" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="resourceDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Name des hinzuzufügenden Schlüssels.</param>
        <param name="value">Der Wert der hinzuzufügenden Ressource.</param>
        <summary>Fügt diesem <see cref="T:System.Windows.ResourceDictionary" /> eine Ressource nach Schlüssel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird versucht, einen doppelten Schlüssel hinzuzufügen, wird eine Ausnahme auslöst.  
  
 Schlüssel werden immer dem Basiswörterbuch hinzugefügt. Schlüssel im <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> in der aktuellen <xref:System.Windows.ResourceDictionary> werden nicht überprüft, für die Duplizierung nur das Basiswörterbuch auf Duplikate überprüft wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.ResourceDictionary" /> ist gesperrt oder schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Hashtable" /> ist bereits ein Element mit demselben Schlüssel enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="resourceDictionary.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung für dieses <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode ist ein Hinweis auf, den Inhalt der <xref:System.Windows.ResourceDictionary> geladen werden sollen. Der nächste Schritt im Prozess wird zum Aufrufen <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 Rufen Sie keine <xref:System.Windows.ResourceDictionary.BeginInit%2A> mehr als einmal vor dem Aufruf von <xref:System.Windows.ResourceDictionary.EndInit%2A>. Auf diese Weise wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.ResourceDictionary.BeginInit" /> wurde mehrmals aufgerufen, bevor <see cref="M:System.Windows.ResourceDictionary.EndInit" /> aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="resourceDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Schlüssel (und Werte) im Basis-<see cref="T:System.Windows.ResourceDictionary" />. Zusammengeführte Wörterbuchelemente werden dabei nicht gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die zusammengeführte Wörterbuchelemente löschen möchten, rufen Sie das bestimmte Wörterbuch aus <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> Sammlung, und rufen <xref:System.Windows.ResourceDictionary.Clear%2A> , <xref:System.Windows.ResourceDictionary>, obwohl die Wörterbücher in der Regel remote werden und möglicherweise keinen Zugriff. Entfernen Sie alternativ den gesamten <xref:System.Windows.ResourceDictionary> aus <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> durch Aufrufen von entfernen für die generische Auflistung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="resourceDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Windows.ResourceDictionary" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Windows.ResourceDictionary" /> ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Windows.ResourceDictionary" /> ein Schlüssel-Wert-Paar mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist der angeforderte Schlüssel nicht in diesem Ressourcenverzeichnis, überprüft die Suchlogik der Ressource auch die zusammengeführten Wörterbüchern.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="resourceDictionary.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, in das die <see cref="T:System.Collections.DictionaryEntry" />-Objekte aus der <see cref="T:System.Windows.ResourceDictionary" />-Instanz kopiert werden. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index von <paramref name="array" />, an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die <see cref="T:System.Windows.ResourceDictionary" />-Elemente am angegebenen Index in ein eindimensionales <see cref="T:System.Collections.DictionaryEntry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dadurch werden nur das Basiswörterbuch kopiert. Das resultierende Array haben keinen <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> , wenn sie bei der Wiederherstellung um eine <xref:System.Windows.ResourceDictionary> erneut aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.ResourceDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Einträge im Basis-<see cref="T:System.Windows.ResourceDictionary" /> ab.</summary>
        <value>Die aktuelle Anzahl von Einträgen im Basiswörterbuch.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeferrableContent : System.Windows.DeferrableContent with get, set" Usage="System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den verzögerbaren Inhalt für dieses Ressourcenwörterbuch ab oder legt ihn fest.</summary>
        <value>Gibt immer <see langword="null" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="resourceDictionary.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung und macht die vorherige Struktur ungültig, sodass alle Änderungen, die während der Initialisierung an den Schlüsseln vorgenommen wurden, erfasst werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A> und <xref:System.Windows.ResourceDictionary.EndInit%2A> führen Sie ein Transaktionsmodell. <xref:System.Windows.ResourceDictionary.BeginInit%2A> markiert das Wörterbuch nicht initialisiert und <xref:System.Windows.ResourceDictionary.EndInit%2A> Initialisierung markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj&#xA;override this.FindName : string -&gt; obj" Usage="resourceDictionary.FindName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Namensbezeichner für das angeforderte Objekt.</param>
        <summary>Wird von dieser Wörterbuchimplementierung nicht unterstützt.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.ResourceDictionary> -Klasse unterstützt nicht die Registrierung nach Name. Stattdessen verwendet es Schlüssel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IDictionaryEnumerator" /> zurück, der zum Durchlaufen des <see cref="T:System.Windows.ResourceDictionary" /> verwendet werden kann.</summary>
        <returns>Ein spezialisierter Enumerator für das <see cref="T:System.Windows.ResourceDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Iterator ist für die nur dem Basiswörterbuch.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InvalidatesImplicitDataTemplateResources : bool with get, set" Usage="System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der angibt, ob vom <see cref="T:System.Windows.ResourceDictionary" />-Objekt ausgelöste Invalidierungen dazu führen, dass <see cref="T:System.Windows.Controls.ContentPresenter" />-Objekte ihre Vorlagenwahl neu bewerten. Invalidierungen treten auf, wenn sich eine implizite Datenvorlagenressource ändert.</summary>
        <value><see langword="true" />, wenn die Invalidierungen dazu führen, dass <see cref="T:System.Windows.Controls.ContentPresenter" />-Objekte ihre Vorlagenwahl neu bewerten; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob dieses <see cref="T:System.Windows.ResourceDictionary" /> eine feste Größe hat.</summary>
        <value><see langword="true" />, wenn die Hashtabelle eine feste Größe hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt das <xref:System.Collections.Hashtable> als Standardwert `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob dieses <see cref="T:System.Windows.ResourceDictionary" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn die Hashtabelle schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt die <xref:System.Collections.Hashtable> als Standardwert `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.ResourceDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der gewünschte Schlüssel, der abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Schlüssel zugeordnet ist, oder legt diesen fest.</summary>
        <value>Der Wert des Schlüssels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angeforderte Schlüssel nicht in diesem Ressourcenverzeichnis ist, überprüft das System der Framework-Ressource auch die zusammengeführten Wörterbüchern.  
  
 Überprüfen einer <xref:System.Windows.ResourceDictionary> nach Element oder Index ist nicht in der Regel die bevorzugte Methode zum Abrufen von Ressourcen. Sie sollten stattdessen Methoden aufrufen, sind der Suchprozess vollständige Ressourcen teilnehmen kann und die Ressourcen anhand ihrer Schlüssel nachschlagen und, die die Ressourcen in Anwendungen oder Designs finden. <xref:System.Windows.FrameworkElement.FindResource%2A> eine solche Methode ist, und befindet sich auf einem <xref:System.Windows.FrameworkElement>. Andernfalls entspricht Sie versucht haben, suchen die Ressource nicht das eigentliche Verhalten der Laufzeit.  
  
 Abrufen von Ressourcen direkt aus einem einzelnen Wörterbuch möglicherweise jedoch sinnvoll, wenn das Abrufen von Ressourcen zu einem bekannten <xref:System.Windows.ResourceDictionary> Speicherort und sind dabei, um mögliche Leistung und Bereich Auswirkungen auf die Laufzeit-Schlüsselsuche zu vermeiden.  
  
 Sie verwenden nicht Indexer zum Definieren der Sammelelemente im [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Stattdessen erstellen Sie untergeordnete Elemente im Markup. Die untergeordneten Elemente sind entweder untergeordnete Elemente von <xref:System.Windows.ResourceDictionary>, oder ein Property-Element, in denen der Eigenschaftstyp ist `ResourceDictionary`. Weitere Informationen finden Sie unter den [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Nutzung Abschnitte <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung aller in diesem <see cref="T:System.Windows.ResourceDictionary" /> enthaltenen Schlüssel ab.</summary>
        <value>Die Auflistung aller Schlüssel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft vorhanden ist, da dies erforderlich ist <xref:System.Collections.IDictionary>, aber <xref:System.Windows.ResourceDictionary.Keys%2A> ist in der Regel nicht nützlich für die meisten <xref:System.Windows.ResourceDictionary> Szenarien.  
  
 Die zurückgegebenen Schlüssel enthalten keine Schlüssel in der <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Auflistung der Schlüssel ist auch eine Momentaufnahme der Schlüssel im Basiswörterbuch. Wenn Sie dies später ändern, <xref:System.Windows.ResourceDictionary>, ein gespeichertes <xref:System.Windows.ResourceDictionary.Keys%2A> spiegeln nicht die Änderungen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergedDictionaries : System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;" Usage="System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der <see cref="T:System.Windows.ResourceDictionary" />-Wörterbücher ab, aus denen sich die verschiedenen Ressourcenwörterbücher in den zusammengeführten Wörterbüchern zusammensetzen.</summary>
        <value>Die Auflistung zusammengeführter Wörterbücher.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wörterbücher werden zusammengeführt, durch das Hinzufügen einer <xref:System.Windows.ResourceDictionary> der generischen Sammlung verweist <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Ein zusammengeführtes <xref:System.Windows.ResourceDictionary> verfügt nicht über die Resource-Elemente definiert sind, im Markup. Stattdessen zusammengeführte Wörterbuch ist ein <xref:System.Windows.ResourceDictionary> keine untergeordnete Markupelemente definiert (oder ohne Elemente, die über Code hinzugefügt wurden), jedoch mit einer [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] für <xref:System.Windows.ResourceDictionary.Source%2A>. Die <xref:System.Windows.ResourceDictionary.Source%2A> Angabe ermöglicht das zusammengeführte Wörterbuch, das von einer externen Quelle, z. B. einer separaten Assembly stammen, die mit der Anwendung ausgeliefert wird "lose [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]", oder einer bestimmten Lokalisierung oder die Assembly für globale Ressourcen.  
  
 Angeben von Ressourcenelementen innerhalb einer <xref:System.Windows.ResourceDictionary> , bei dem <xref:System.Windows.ResourceDictionary.Source%2A> angegebene wird nicht unterstützt.  
  
 Suchverhalten innerhalb der <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> Auflistung durchsucht die zuletzt hinzugefügte <xref:System.Windows.ResourceDictionary> zuerst und anschließend die Suche wird angehalten, sobald ein angeforderten Schlüssel gefunden wird. Doppelte Schlüssel in die Auflistung zusammengeführter Wörterbücher sind zulässig. Weitere Informationen zum Verhalten von zusammengeführten Wörterbüchern, finden Sie unter [zusammengeführte Ressourcenverzeichnisse](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreResourceDictionaries*  
 Eine oder mehrere <xref:System.Windows.ResourceDictionary> Objektelemente. Ein <xref:System.Windows.ResourceDictionary> zum <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> keinen Auflistungsinhalt und gibt eine <xref:System.Windows.ResourceDictionary.Source%2A> Attribut, das die vollständige verweist <xref:System.Windows.ResourceDictionary> Remote.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zwei <xref:System.Windows.ResourceDictionary> Elemente, die mit dem primären zusammengeführt werden <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberSignature Language="F#" Value="abstract member OnGettingValue : obj *  *  -&gt; unit&#xA;override this.OnGettingValue : obj *  *  -&gt; unit" Usage="resourceDictionary.OnGettingValue (key, value, canCache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" RefType="ref" />
        <Parameter Name="canCache" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel der abzurufenden Ressource.</param>
        <param name="value">Der Wert der angeforderten Ressource.</param>
        <param name="canCache"><see langword="true" />, wenn die Ressource gespeichert und später verwendet werden kann; andernfalls <see langword="false" />.</param>
        <summary>Tritt auf, wenn das <see cref="T:System.Windows.ResourceDictionary" /> eine Ressourcenanforderung empfängt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="resourceDictionary.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Wird nicht unterstützt.</param>
        <param name="scopedElement">Wird nicht unterstützt.</param>
        <summary>Wird von dieser Wörterbuchimplementierung nicht unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.ResourceDictionary> -Klasse unterstützt nicht die Registrierung nach Name. Stattdessen verwendet es Schlüssel. Die XAML-Namescope-Methoden werden als nicht verwendbare Versionen implementiert <xref:System.Windows.ResourceDictionary> zur, XAML Erklärung Namen gelten nicht für Ressourcen.  
  
 Aufrufen dieser Methode bewirkt, dass eine <xref:System.NotSupportedException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bei jedem Aufruf dieser Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="resourceDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Eintrags.</param>
        <summary>Entfernt den Eintrag mit dem angegebenen Schlüssel aus dem Basiswörterbuch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.ResourceDictionary> enthält kein Element mit dem angegebenen Schlüssel, der <xref:System.Windows.ResourceDictionary> bleibt unverändert. Es wird keine Ausnahme ausgelöst.  
  
 Diese Methode entfernt keine Schlüssel aus der <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Benötigen Sie die spezifischen <xref:System.Windows.ResourceDictionary> aus der Auflistung entfernt, die die Schlüssel, aber, die möglicherweise nicht möglich sein, da Sie dieses Wörterbuch in der Regel Remote zugreifen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.ResourceDictionary" /> ist gesperrt oder schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.ResourceDictionary.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] ab oder legt ihn fest, von dem Ressourcen geladen werden sollen.</summary>
        <value>Der Quellspeicherort eines externes Ressourcenwörterbuchs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Windows.ResourceDictionary.Source%2A> angegeben ist, als ein Paket-URI, der den Speicherort eines Ressourcenverzeichnisses verweist, die von Ihrem Anwendungsprojekt für das Erstellen von als eine Berechtigungsmenge Buildaktion Ressource oder den Inhalt enthalten ist. Ausführliche Informationen zu den Paket-URI-Format, finden Sie unter [Paket-URIs in WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 Im Allgemeinen die <xref:System.Windows.ResourceDictionary.Source%2A> Eigenschaftensatz wird nur für eine <xref:System.Windows.ResourceDictionary> , angegeben wurde für die <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> Eigenschaft (entweder als ein Eigenschaftenelement in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], oder als eine <xref:System.Windows.ResourceDictionary> Element der Auflistung im Code). In diesem Kontext festlegen des Werts für <xref:System.Windows.ResourceDictionary.Source%2A> wird das Wörterbuchinhalt finden Sie unter dem angegebenen merge [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] in das aktuelle <xref:System.Windows.ResourceDictionary>. Jeder Fehler beim Laden von löst eine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zwei <xref:System.Windows.ResourceDictionary> Elemente, die mit dem primären zusammengeführt werden <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Ein nullbasiertes <see cref="T:System.Array" />, das die kopierten Elemente aus der <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" /> empfängt.</param>
        <param name="arrayIndex">Die Anfangsposition im angegebenen <see cref="T:System.Array" />, an die der Inhalt kopiert wird.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.ResourceDictionary>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
        <value><see langword="true" />, wenn der Zugriff auf <see cref="T:System.Windows.ResourceDictionary" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.ResourceDictionary>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf das <see cref="T:System.Windows.ResourceDictionary" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.ResourceDictionary>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.ResourceDictionary>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System::Windows::Markup::IUriContext::BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>Der Basis-[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] des aktuellen Kontexts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Windows.ResourceDictionary>-Instanz in eine <xref:System.Windows.Markup.IUriContext>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="resourceDictionary.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Wird nicht unterstützt.</param>
        <summary>Wird von dieser Wörterbuchimplementierung nicht unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.ResourceDictionary> -Klasse unterstützt nicht die Registrierung nach Name. Stattdessen verwendet es Schlüssel. Das Aufrufen dieser Methode hat keine Auswirkungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.ResourceDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung aller Werte ab, die Schlüsseln zugeordnet sind, die in diesem <see cref="T:System.Windows.ResourceDictionary" /> enthalten sind.</summary>
        <value>Die Auflistung aller Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft vorhanden ist, da dies erforderlich ist <xref:System.Collections.IDictionary>, eignet sich jedoch im Allgemeinen nicht für die meisten <xref:System.Windows.ResourceDictionary> Szenarien.  
  
 Die zurückgegebenen Werte schließen sich nicht auf die Werte innerhalb der <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Außerdem ist die Auflistung eine Momentaufnahme der Werte im Basiswörterbuch. Wenn Sie dies später ändern, <xref:System.Windows.ResourceDictionary>, ein gespeichertes <xref:System.Windows.ResourceDictionary.Values%2A> spiegeln nicht die Änderungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>