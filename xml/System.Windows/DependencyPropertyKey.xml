<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyPropertyKey.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a12e407bc5345e416145c390f8fcd6f8262c445.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a12e407bc5345e416145c390f8fcd6f8262c445</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyPropertyKey">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">Stellt einen Bezeichner für eine Abhängigkeitseigenschaft für den beschränkten Schreibzugriff auf eine schreibgeschützte Abhängigkeitseigenschaft bereit.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instances are obtained as the return value of a dependency property registration call using the methods <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> -Instanzen werden als Rückgabewert einer Abhängigkeit Eigenschaft Registrierung Aufrufs mit den Methoden abgerufen <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The types that register a dependency property can use the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> that adjust the property's value as part of class logic.</source>
          <target state="translated">Die Typen, die eine Abhängigkeitseigenschaft registrieren können die <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> Aufrufe <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> passen Sie den Wert der Eigenschaft, die als Teil der Klassenlogik.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">Wenn die Zugriffsebene des Schlüssels erlaubt, können verwandte Klassen den Schlüssel und die Abhängigkeitseigenschaft auch.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">Beispielsweise können Sie den Schlüssel als interne deklarieren, und andere Typen innerhalb derselben Assembly können auch festlegen, der Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> zurückgegeben von schreibgeschützten Abhängigkeitseigenschaft eigenschaftsregistrierung sollten nicht öffentlich gemacht werden, da durch den Schlüssel die Eigenschaft festgelegt werden, also dem Zeitpunkt der Registrierung als eine schreibgeschützte Abhängigkeitseigenschaft angeben kann.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">Darüber hinaus den Schlüssel bewirkt, dass ein Konflikt zwischen den verfügbaren Abhängigkeit Eigenschaft Verhalten und die zugehörige <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> Eigenschaft Wrapperimplementierungen, die fehlerhafte-Klassenentwurf ist.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Instead of exposing the key itself, you should instead expose the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value of the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> as a <ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> on your class.</source>
          <target state="translated">Anstatt den Schlüssel selbst verfügbar gemacht werden, Sie sollten stattdessen verfügbar machen die <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> Wert, der die <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> als eine <ph id="ph3">`public static readonly`</ph> <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> für Ihre Klasse.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">Dadurch wird die Eigenschaft Bezeichner für eine gültige Abhängigkeitseigenschaft für bestimmte Eigenschaft Systemvorgänge z. B. das Durchzählen lokal festgelegten Werte zurückgeben.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>However, the identifier thus obtained does not have the full capabilities of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> for many property system operations.</source>
          <target state="translated">Der Bezeichner, die erhaltenen müssen jedoch nicht alle Funktionen von einer <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> für viele Eigenschaft Systemvorgänge.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</source>
          <target state="translated">Das folgende Beispiel registriert eine schreibgeschützte Abhängigkeitseigenschaft und verwendet auch den Schlüssel für zwei Zwecke in anderen Klassenmembern: Implementieren des Get "Wrappers" und als Bezeichner für einen geschützten Bestimmung-Vorgang, der den Wert fest, anhand von Berechnungen der anderen Eigenschaftswerte.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">Ruft den Bezeichner einer Abhängigkeitseigenschaft ab, der diesem Bezeichner einer spezialisierten schreibgeschützten Abhängigkeitseigenschaft zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">Der relevante Bezeichner einer Abhängigkeitseigenschaft.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> -Wert ermöglicht eine schreibgeschützte Eigenschaft Bezeichner gemeinsame Eigenschaft Systemvorgänge unter Verwendung der gleichen Schnittstellen auch verwendet für Lese-/ Schreibzugriff Abhängigkeitseigenschaften teilnehmen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class.</source>
          <target state="translated">Um den Get-Accessor für eine schreibgeschützte Abhängigkeitseigenschaft zu implementieren, sollten Sie erstellen und verfügbar machen eine <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner für Ihre Klasse.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>This serves two purposes:</source>
          <target state="translated">Bei diesem Verfahren werden zwei Ziele verfolgt:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Your own class needs the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">Die eigene Klasse erfordert die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner, um die Get-Zugriffsmethode für den Eigenschaftenwrapper zu implementieren.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>You use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as a parameter for the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> call that implements the get accessor.</source>
          <target state="translated">Verwenden Sie die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> als Parameter für die <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> -Aufruf, der "Get"-Zugriffsmethode implementiert.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner die Abhängigkeitseigenschaft im Eigenschaftensystem verfügbar machen, sodass andere Methoden, die abhängig von Metadaten in ein Standardformat darauf zugreifen können.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>For instance, if you called <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> on some <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value rather than the key.</source>
          <target state="translated">Für die Instanz, wenn Sie aufgerufen <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> auf einigen <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> und erhalten Sie einer Enumeration der lokal festgelegten Eigenschaften (Werte und Bezeichner) den Bezeichner für eine schreibgeschützte Abhängigkeitseigenschaft wäre zurückgegebene Ihrer <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> anstelle der Schlüssel-Wert.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Not exposing a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">Nicht verfügbar machen eine <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner nicht erhöht die Sicherheit der schreibgeschützten Abhängigkeitseigenschaft, vereinfacht nur Vorgänge, die die Eigenschaft umständlicher für nachfolgende abgeleitete Klassen und Klasseninstanzen betreffen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>To expose the  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class, you call <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directly on your key.</source>
          <target state="translated">Verfügbarmachen der <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> -Bezeichner für die Klasse, rufen Sie <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> direkt für den Schlüssel.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on the class, which parallels the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</source>
          <target state="translated">Verwenden Sie diesen Wert zum Erstellen einer <ph id="ph1">`public static readonly`</ph> <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner auf die Klasse, die entspricht der <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> to expose the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier (<ph id="ph3">`AquariumGraphicProperty`</ph>) for the <ph id="ph4">`AquariumGraphic`</ph> read-only dependency property on a class.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> verfügbar machen die <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> Bezeichner (<ph id="ph3">`AquariumGraphicProperty`</ph>) für die <ph id="ph4">`AquariumGraphic`</ph> schreibgeschützte Abhängigkeitseigenschaft für eine Klasse.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The example also shows the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> creation (as an internal member) and the get accessor for <ph id="ph2">`AquariumGraphic`</ph>.</source>
          <target state="translated">Das Beispiel zeigt auch die <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> (als interner Member) und die Get-Zugriffsmethode für <ph id="ph2">`AquariumGraphic`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">Der Typ, für den diese Abhängigkeitseigenschaft vorhanden ist, sowie die Metadaten müssen überschrieben werden.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata supplied for this type.</source>
          <target state="translated">Für diesen Typ angegebene Metadaten.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">Überschreibt die Metadaten einer schreibgeschützten Abhängigkeitseigenschaft, die durch diesen Bezeichner einer Abhängigkeitseigenschaft dargestellt wird.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">Überschreiben die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft erfolgt aus ähnlichen Gründen wie beim Überschreiben von Metadaten für eine Abhängigkeitseigenschaft mit Lese-/ Schreibzugriff und sind für den Zugriff auf die wichtigsten Ebene eingeschränkt, da in den Metadaten angegebene Verhaltensweisen das Set-Verhalten (die ändern können DEFAULT-Wert, z. B.).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">Wie mit Lese-/ Schreibzugriff Abhängigkeitseigenschaften, überschreiben die Metadaten für eine schreibgeschützte Abhängigkeitseigenschaft nur vor der Eigenschaft verwendet platziert wird, von dem Eigenschaftensystem erfolgen soll (Dies entspricht dem Zeitpunkt, bestimmte Instanzen von Objekten, das Registrieren der Eigenschaft instanziiert werden).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">Aufrufe von <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> sollte nur ausgeführt werden, in den statischen Konstruktoren des Typs, der sich selbst als der <ph id="ph2">`forType`</ph> Parameter dieser Methode oder eine gleichwertige Initialisierung für diese Klasse.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This method effectively forwards to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method, passing the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance as the key parameter.</source>
          <target state="translated">Diese Methode leitet effektiv an die <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> -Methode auf und übergibt die <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> Instanz entsprechend den Key-Parameter.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The following example overrides metadata for an existing read-only dependency property that a class inherits.</source>
          <target state="translated">Im folgende Beispiel werden die Metadaten für eine vorhandene schreibgeschützte Abhängigkeitseigenschaft, die eine Klasse erbt überschrieben.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</source>
          <target state="translated">In diesem Fall wurde das Szenario-Ziel einen Rückruf zum Wert hinzufügen, den die Basiseigenschaft Metadaten nicht vorhanden wäre.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values, etc.)</source>
          <target state="translated">Sie können auch Metadaten überschreiben, für keines der anderen Gründe, aus denen das Überschreiben von Metadaten in der Regel ist die entsprechende (Standardwert ändern hinzufügen <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> Werte usw..)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">Versuchte Überschreibung von Metadaten für eine Abhängigkeitseigenschaft mit Schreib- und Leseberechtigungen (kann nicht mit dieser Signatur ausgeführt werden).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">Metadaten wurden für die Eigenschaft bereits festgelegt, da sie im bereitgestellten Typ bereits vorhanden sind.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>